<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gwq5210&#39;s Blog</title>
  
  <subtitle>凡是过往，皆为序章！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://blog.gwq5210.com/"/>
  <updated>2021-09-13T08:00:57.712Z</updated>
  <id>https://blog.gwq5210.com/</id>
  
  <author>
    <name>gwq5210</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://blog.gwq5210.com/2019/03/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)/"/>
    <id>https://blog.gwq5210.com/2019/03/28/Lambda表达式(匿名函数)/</id>
    <published>2019-03-28T11:35:53.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，C++，Python中的Lambda表达式</p><h1 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h1><p>在编程中，Lambda表达式就是指匿名函数（anonymous function），它是一类无需定义标识符（函数名）的函数<br>匿名函数通常作为参数传递给高阶函数或者作为高阶函数的返回值<br>如果函数只使用一次或者有限的次数，则使用匿名函数会比较方便<br>现在越来越多的编程语言支持匿名函数</p><p>闭包常常被用作匿名函数的同义词，严格来说，匿名函数仅仅是没有名字的函数，闭包是任何能够访问自由变量（free variable or non-local variable，不在局部和参数列表里定义的变量）的函数实例</p><h1 id="Java中的Lambda表达式"><a href="#Java中的Lambda表达式" class="headerlink" title="Java中的Lambda表达式"></a>Java中的Lambda表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Java 中的 Lambda 表达式通常使用 (argument) -&gt; (body) 语法书写，例如：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(arg1, arg2...)</span> -&gt;</span> &#123; body &#125;</span><br><span class="line"><span class="function"><span class="params">(type1 arg1, type2 arg2...)</span> -&gt;</span> &#123; body &#125;</span><br></pre></td></tr></table></figure></p><p>在Lambda表达式中引用的自由变量，必须是final或者是实际上不会修改的变量</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li><li>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ol><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要参数，返回值为int的42</span></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，返回值为float的3.1415</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受两个int参数，返回值为它们的和</span></span><br><span class="line">(int a, int b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，没有返回值，输出一个字符串</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个String参数，没有返回值，打印该字符串</span></span><br><span class="line">(<span class="built_in">String</span> s) -&gt; &#123; System.out.println(s); &#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Java中只有一个方法声明的接口叫做函数式接口，例如java.lang.Runnable接口只声明了一个void run()方法<br>不指明函数式接口时，编译器可以进行自动转化<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable <span class="function"><span class="title">r</span> = <span class="params">()</span> -&gt;</span> System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br><span class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Hello Java!"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p><h1 id="C-中的Lambda表达式"><a href="#C-中的Lambda表达式" class="headerlink" title="C++中的Lambda表达式"></a>C++中的Lambda表达式</h1><p>在C++ 11中支持Lambda表达式</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>Lambda表达式的语法如下</p><ol><li>[]中可以以值或引用捕获变量，来实现闭包</li><li>捕获变量时需要注意，如果调用闭包时，引用了生存周期结束的变量，则发生未定义行为，C++的闭包不会延长被捕获引用的生存周期</li><li>Lambda表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型</li><li>this是一个特殊的捕获，必须定义在类的非静态成员函数中，该Lambda具有访问该类的保护和私有成员的权限，在Lambda中访问该类的成员，不需要显式使用this-&gt;，即this-&gt;a和a等价</li><li>不捕获变量的Lambda可以将函数赋值给对应的函数指针</li><li>Lambda表达式可以赋值给std::function</li></ol><p>Boost库提供了自己的Lambda表达式语法，参见<a href="https://www.boost.org/doc/libs/1_62_0/doc/html/lambda.html" target="_blank" rel="noopener">Boost.Lambda</a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) -&gt; return_type &#123; body &#125;</span><br><span class="line"><span class="comment">// 忽略返回值，返回值的类型使用自动推断</span></span><br><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) &#123; body &#125;</span><br><span class="line"><span class="comment">// 不接受任何参数</span></span><br><span class="line">[<span class="meta"> captures </span>] &#123; body &#125;</span><br></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受x，y参数，返回它们的和</span></span><br><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是捕获的例子</span></span><br><span class="line">[]        <span class="comment">//no variables defined. Attempting to use any external variables in the lambda is an error.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&amp;]       <span class="comment">//any external variable is implicitly captured by reference if used</span></span><br><span class="line">[=]       <span class="comment">//any external variable is implicitly captured by value if used</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Variables captured by value are constant by default. Adding mutable after the parameter list makes them non-constant.</span></span><br><span class="line"><span class="comment">// 按值捕获到的变量不能被改变，需要改变的话要在参数列表后加上mutalbe，按值捕获不会改变原值</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=] () <span class="keyword">mutable</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用捕获可以修改原值，a值会被改变成3</span></span><br><span class="line"><span class="keyword">auto</span> r = [&amp;] &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">r();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosureTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClosureTest() &#123; r = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获this</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClosureTest::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">this</span>-&gt;r, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给函数指针，不能捕获变量</span></span><br><span class="line"><span class="keyword">void</span> (*p)() = []&#123;<span class="built_in">printf</span>(<span class="string">"test\n"</span>);&#125;;</span><br><span class="line">p();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给std::function对象，可以进行捕获，void不能省略</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; <span class="built_in">print</span> = [](<span class="keyword">int</span> a)&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; <span class="built_in">print</span> = [&amp;]()&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h1 id="Python中的Lambda表达式"><a href="#Python中的Lambda表达式" class="headerlink" title="Python中的Lambda表达式"></a>Python中的Lambda表达式</h1><p>Python中可以使用lambda关键字定义匿名函数，它能用在任何需要函数的地方，在语法上它被限制只能有单个语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> parameter_list: expression</span><br><span class="line"></span><br><span class="line">// 例如参数x，返回x*x</span><br><span class="line"><span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line">// 以上等价于</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">// 参数x，y，返回它们的和</span><br><span class="line"><span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">// 可以使用自由变量</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> g  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assigning specific closures to variables.</span></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = h(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the closures stored in variables.</span></span><br><span class="line"><span class="keyword">assert</span> a(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> b(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using closures without binding them to variables first.</span></span><br><span class="line"><span class="keyword">assert</span> f(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># f(1) is the closure.</span></span><br><span class="line"><span class="keyword">assert</span> h(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># h(1) is the closure.</span></span><br><span class="line"></span><br><span class="line">// x是全局的</span><br><span class="line">// 修改x后，会修改函数f的结果</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">// [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">// [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br></pre></td></tr></table></figure></p><h1 id="Go的匿名函数"><a href="#Go的匿名函数" class="headerlink" title="Go的匿名函数"></a>Go的匿名函数</h1><p>Go的匿名函数是闭包，他们可以引用自由变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别打出11，102，111</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> num + x</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">num = <span class="number">101</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(test(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h1><p>闭包通常用一个包含函数代码的指针和创建闭包时函数词法环境（一系列可用的变量）的数据结构来实现<br>也就是说闭包引用的自由变量，需要在闭包调用的时候仍然能够访问</p><p>只在栈上分配变量的语言很难容易的实现完全的闭包，这些语言中，自动变量会在函数返回后自动的销毁<br>这也可以解释为什么通常支持闭包的语言也使用垃圾回收机制<br>替代方案是非局部变量的手动内存管理，不过这种方式可能会产生野指针的问题，C++ 11中的Lambda表达式和<a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html" target="_blank" rel="noopener">GNU C中的嵌套函数</a>都可能会产生这个问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">Anonymous_function</a><br>2) <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">Closure_(computer_programming)</a><br>3) <a href="https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/" target="_blank" rel="noopener">Java中的闭包之争</a><br>4) <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank" rel="noopener">Free_variables_and_bound_variables</a><br>5) <a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="noopener">深入浅出 Java 8 Lambda 表达式</a><br>6) <a href="https://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">Lambda expressions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，
      
    
    </summary>
    
    
      <category term="Java" scheme="https://blog.gwq5210.com/tags/Java/"/>
    
      <category term="C++" scheme="https://blog.gwq5210.com/tags/C/"/>
    
      <category term="Python" scheme="https://blog.gwq5210.com/tags/Python/"/>
    
      <category term="Lambda表达式" scheme="https://blog.gwq5210.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="匿名函数" scheme="https://blog.gwq5210.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git简介及常用命令</title>
    <link href="https://blog.gwq5210.com/2019/03/25/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://blog.gwq5210.com/2019/03/25/Git简介及常用命令/</id>
    <published>2019-03-25T20:31:11.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想深入了解一下Git，阅读了一下<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a>的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅</p><h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。<br><a id="more"></a><br>本地版本控制系统无法实现协同工作，集中化的版本控制系统解决了协同工作的问题，但中央服务器的单点故障会影响所有人的工作，分布式版本控制系统采用快照的方式，每个开发者电脑上都有一份代码的完整拷贝，故障恢复起来就比较容易。</p><p>Git是Linux开源社区的杰作，他们开发Git之初就对其有以下目标：</p><ol><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全的分布式</li><li>有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）</li></ol><p>Git和其他版本控制系统（如Subversion）的主要差别在于对待数据的方法。不像其他版本控制系统保存基本文件和基于基本文件的差异，Git直接保存每个文件的快照。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/存储每个文件和基础版本的差异.png" alt="存储每个文件和基础版本的差异" title>                </div>                <div class="image-caption">存储每个文件和基础版本的差异</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/存储项目随时间变化的快照.png" alt="存储项目随时间变化的快照" title>                </div>                <div class="image-caption">存储项目随时间变化的快照</div>            </figure><p>正因为如此，Git中的大多数操作只需要访问本地资源，而不需要与服务器进行通信，保证了操作的速度。</p><h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h2><p>在Git中，你的文件处于以下三种状态之一：</p><ol><li>已提交（committed），表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified），表示已经修改了文件，但还没保存在数据库中。</li><li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>由此引入Git项目的三个工作区的概念：Git仓库，工作目录以及暂存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/工作目录，暂存区域以及Git仓库.png" alt="Git仓库，工作目录以及暂存区域" title>                </div>                <div class="image-caption">Git仓库，工作目录以及暂存区域</div>            </figure><p>基本的 Git 工作流程如下： </p><ol><li>在工作目录中修改文件。 </li><li>暂存文件，将文件的快照放入暂存区域。 </li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 </li></ol><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>有三种方式获取Git的帮助：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">help</span> <span class="symbol">&lt;verb&gt;</span></span><br><span class="line">git <span class="symbol">&lt;verb&gt;</span> --<span class="keyword">help</span></span><br><span class="line">man git-<span class="symbol">&lt;verb&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>Git的配置信息存放在三个不同的位置</p><ol><li>/etc/gitconfig文件，系统上每一个用户及他们仓库的配置，使用—system选项会读写此配置文件</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。使用—global选项会读写此配置文件</li><li>当前仓库中使用的配置（.git/config），需要在当前仓库进行修改，不需要加选项。</li></ol><p>每一个级别的配置会覆盖上一个级别的配置。</p><p>以下是常用的配置<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看用户配置</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局的用户名和邮箱</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"gwq5210"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"gwq5210@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用的编辑器</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> core<span class="variable">.editor</span> <span class="string">"vim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置常用的别名，以下命令会在稍候介绍</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.co</span> checkout</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.br</span> branch</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.st</span> status</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.unstage</span> reset HEAD --</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.last</span> log -l HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Git设置代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.http</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为不同的网址设置不同的代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> https<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免每次都输入账号密码，将账号密码保存在内存中几分钟</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> credential<span class="variable">.helper</span> cache</span><br></pre></td></tr></table></figure></p><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种方式获取Git仓库：从现有目录初始化仓库和从服务器克隆一个现有的Git仓库。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从现有目录初始化仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器克隆一个现有的仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">clone</span> <span class="selector-attr">[url]</span> <span class="selector-attr">[name]</span></span><br></pre></td></tr></table></figure></p><p>Git仓库里存在着.git目录，保存着Git仓库的必要信息。</p><h2 id="查看当前文件状态、跟踪新文件和暂存已修改的文件"><a href="#查看当前文件状态、跟踪新文件和暂存已修改的文件" class="headerlink" title="查看当前文件状态、跟踪新文件和暂存已修改的文件"></a>查看当前文件状态、跟踪新文件和暂存已修改的文件</h2><p>工作目录的文件状态不外乎：已跟踪和未跟踪。已跟踪是已纳入版本控制的文件，在上一次快照中有他们的记录，工作过一段时候后，他们的状态可能是未修改，已修改，已暂存状态。除此之外其他文件都属于未跟踪文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/文件状态变化生命周期.png" alt="文件状态变化生命周期" title>                </div>                <div class="image-caption">文件状态变化生命周期</div>            </figure></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 查看当前文件状态</span></span><br><span class="line"><span class="regexp">git status</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 之前设置的status别名为st</span></span><br><span class="line"><span class="regexp">git st</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 显式简介的状态</span></span><br><span class="line"><span class="regexp">git status -s</span></span><br><span class="line"><span class="regexp">git status --short</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第一列表示在暂存区域的状态，第二列表示在工作区域的状态</span></span><br><span class="line"><span class="regexp">-------------------</span></span><br><span class="line"><span class="regexp"> M README</span></span><br><span class="line"><span class="regexp">MM Rakefile</span></span><br><span class="line"><span class="regexp">A lib/git</span>.rb</span><br><span class="line">M <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">?? LICENSE.txt </span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 跟踪新文件或暂存已修改的文件</span></span><br><span class="line"><span class="regexp">git add [path]</span></span><br></pre></td></tr></table></figure><p>我们可以使用.gitignore文件来忽略我们不想跟踪的文件，这里有.gitignore文件的列表，可供查阅<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 查看未暂存的修改，即工作区域和已暂存区域的修改</span><br><span class="line">git diff</span><br><span class="line"><span class="string">//</span> 查看已提交和已暂存的修改</span><br><span class="line">git diff <span class="params">--cached</span></span><br><span class="line"><span class="string">//</span> Git 1.6.1及更高版本</span><br><span class="line">git diff <span class="params">--staged</span></span><br></pre></td></tr></table></figure><h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>使用如下命令将暂存区域的内容提交<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">// 命令行指定提交消息</span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line">// 跳过暂存，进行提交</span><br><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"commit message"</span></span><br><span class="line">// commit的别名</span><br><span class="line">git ci</span><br></pre></td></tr></table></figure></p><h2 id="移除或修改文件"><a href="#移除或修改文件" class="headerlink" title="移除或修改文件"></a>移除或修改文件</h2><p>要移除文件，需要从已跟踪清单中（确切的说是从暂存区域）移除，然后提交。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git rm [path]</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git rm类似如下命令</span></span><br><span class="line">rm [path]</span><br><span class="line">git add [path]</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从暂存区域移除，仍然保留在工作区域</span></span><br><span class="line">git rm --cached [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经修改了文件或者已经暂存了该文件，则需要使用-f进行删除，防止误操作删除了不可恢复的文件</span></span><br><span class="line">git rm -f [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名文件</span></span><br><span class="line">git mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git mv相当于下边的操作</span></span><br><span class="line">mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">git rm file<span class="emphasis">_from</span></span><br><span class="line"><span class="emphasis">git add file_</span>to</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>提交若干更新或者克隆一个仓库之后，我们可以查看提交历史<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 默认会列出所有的提交历史，最近的更新会排在最上边</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">// 显示最新的n条记录</span><br><span class="line">git <span class="built_in">log</span> -n</span><br><span class="line"></span><br><span class="line">// 显示每次提交的内容差异</span><br><span class="line">git <span class="built_in">log</span> -p</span><br><span class="line"></span><br><span class="line">// 查看每次提交的简略统计信息</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--stat</span></span><br><span class="line"></span><br><span class="line">// 单行显示提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--oneline</span></span><br><span class="line"></span><br><span class="line">// 使用图形提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure></p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 修改最后一次提交，使用这个选项会覆盖上一次的提交</span><br><span class="line">git ci <span class="params">--amend</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 取消暂存文件</span><br><span class="line">git reset HEAD &lt;file&gt;<span class="string">...</span></span><br><span class="line"><span class="string">//</span> 别名</span><br><span class="line">git unstage &lt;file&gt;<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 撤销对文件的修改，此操作会丢失对文件的修改，很危险</span><br><span class="line">git checkout -- &lt;file&gt;<span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="使用远程仓库"><a href="#使用远程仓库" class="headerlink" title="使用远程仓库"></a>使用远程仓库</h2><p>克隆一个仓库，会自动给远程仓库添加origin的名称<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote show <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加远程仓库</span></span><br><span class="line">git remote add <span class="params">&lt;shortname&gt;</span> <span class="params">&lt;url&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取远程仓库的信息，不会自动合并或修改你当前的工作</span></span><br><span class="line"><span class="comment">// 分支设置了跟踪一个远程分支的话git pull会自动抓取然后合并</span></span><br><span class="line">git fetch <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送到远程仓库</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;branch-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程仓库重命名和移除</span></span><br><span class="line">git remote rename <span class="params">&lt;old-name&gt;</span> <span class="params">&lt;new-name&gt;</span></span><br><span class="line">git remote rm <span class="params">&lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>Git可以给历史中的某一个提交打上标签，表示重要<br>Git标签有两种标签，轻量标签和附注标签<br>轻量标签很像一个不会改变的分支，它只是一个特定提交的引用<br>附注标签是存储在Git数据库中的完整对象，可以包含打标签者的名字，邮件，日期等信息<br>通常建议创建附注标签<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出标签</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l <span class="string">"v1.8*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建附注标签，指定存储在标签中的信息</span></span><br><span class="line">git tag -a v1<span class="number">.0</span> -m <span class="string">"create tag v1.0"</span></span><br><span class="line"><span class="comment">// 查看标签的信息和对应的提交信息，轻量标签只会显示提交信息</span></span><br><span class="line">git show v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轻量标签，只需要提供标签名字</span></span><br><span class="line">git tag v1<span class="number">.0</span>-lw</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对过去的提交打标签</span></span><br><span class="line">git tag -a v0<span class="number">.9</span> <span class="number">9f</span>ceb02</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享标签，将标签推送到远程仓库，类似共享远程分支</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有不在远程服务器的标签都推送过去</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --tags</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除标签，此命令不会删除远程服务器的标签</span></span><br><span class="line">git tag -d v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程服务器的标签</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> :refs<span class="meta-keyword">/tags/</span><span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --delete <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检出标签，此命令会使你的仓库处于分离头指针（detached HEAD）状态</span></span><br><span class="line"><span class="comment">// 在分离头指针状态你进行某些更改然后提交他们，标签不会发生变化，你的提交不属于任何分支，只能使用确切的哈希来访问</span></span><br><span class="line">git checkout <span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git co <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，需要修复旧版本的错误，通常需要创建一个新的分支，在新分支上进行修改，并提交，该分支就和此标签不同了</span></span><br><span class="line">git co -b <span class="params">&lt;branch-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>几乎所有的版本控制系统都支持分支，你可以把工作从开发主线上分离出来，以免影响开发主线<br>Git处理分支的方式十分轻量，创建和切换分支操作都十分便捷，因此Git鼓励使用分支</p><p>进行提交操作时，Git会保存一个提交对象，该提交对象包含一个指向暂存内容快照的指针，还包括作者的姓名，邮箱等信息，以及它的父对象信息（一个或多个）</p><p>Git的默认分支是master分支，master分支不是一个特殊的分支，与其他分支没有差别，git init命令会默认创建它</p><p>这些分支操作全部都保存在本地，没有与服务器发生交互<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支，会在当前所的提交对象上创建一个指针，Git有一个HEAD的特殊指针，指向当前分支，可以理解为当前分支的别名</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>切换分支，分支切换会改变工作目录的内容，如果Git不能干净利落的完成这个任务，它将禁止切换分支</span><br><span class="line"><span class="symbol">git</span> checkout &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>新建分支并切换</span><br><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>合并分支，将&lt;<span class="keyword">branch-name&gt;分支合并到当前分支</span></span><br><span class="line"><span class="keyword">// </span>合并两个分支时，如果顺着一个分支能够到达另外一个分支，那么就进行快进（fast-forward）</span><br><span class="line">// 有分叉的合并会产生一个合并提交，该提交使用三方（两个分支末端的快照和它们的公共祖先）合并的结果</span><br><span class="line">// 如果合并时遇到对同一个文件同一处的修改，则会发生冲突，等你解决冲突后，使用git <span class="keyword">add命令将冲突的文件标记为已解决冲突</span></span><br><span class="line"><span class="keyword">git </span>merge &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>删除分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支，*号代表当前所在分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支最后一个提交</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-v</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>-v</span><br><span class="line"></span><br><span class="line">// 显示列表中已经合并或尚未合并到当前分支的分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--merged</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>--no-merged</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/一个和并提交.png" alt="一个和并提交" title>                </div>                <div class="image-caption">一个和并提交</div>            </figure><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用，包括分支标签等。<br>我们经常利用远程跟踪分支，它是远程分支状态的引用，它们是你不能移动的本地引用，当你进行任何网络操作时，它们会自动移动<br>远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签，以<remote>/<branch>命名，如origin/master</branch></remote></p><p>origin和master没有特殊含义，origin是git clone创建的远程仓库的默认名字，master是git init时默认的起始分支的名字<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看完整远程引用列表</span></span><br><span class="line">git ls-remote</span><br><span class="line">git remote <span class="keyword">show</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/本地与远程的工作可以分叉.png" alt="本地与远程的工作可以分叉" title>                </div>                <div class="image-caption">本地与远程的工作可以分叉</div>            </figure><h3 id="推送到远程分支"><a href="#推送到远程分支" class="headerlink" title="推送到远程分支"></a>推送到远程分支</h3><p>你想分享一个分支，必须要将其推送到有写入权限的远程仓库，本地的分支不会自动与远程仓库同步，必须显式的推送<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分支推送到远程仓库</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地分支与远程分支采用不同的名字</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;:&lt;remote-branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他人可以获取到远程分支</span></span><br><span class="line">git fetch &lt;remote-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 合并远程分支到当前分支</span></span><br><span class="line">git merge &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git co -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程仓库检出一个本地分支会自动创建一个做跟踪分支（上游分支），跟踪分支是与远程分支有直接关系的本地分支<br>如果在跟踪分支上输入git pull，则Git能自动识别去哪个服务器抓取、合并到哪个分支<br>克隆仓库时，会自动创建一个跟踪origin/master的master分支<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git checkout -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git checkout --track &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 当前分支设置跟踪的远程分支</span></span><br><span class="line">git branch -u &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置好跟踪分支后，可以通过@&#123;u&#125;或@&#123;upstream&#125;快捷方式来引用它</span></span><br><span class="line">git merge origin/master</span><br><span class="line">git merge @<span class="comment">&#123;u&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看分支跟踪的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取远程分支，并不会修改本地工作目录中的内容，需要自己合并</span></span><br><span class="line">git fetch origin master</span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment">// git pull会查找当前分支的跟踪分支，从服务器抓取数据然后尝试合并入那个远程分支</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; --delete &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>Git中整合来自不同分支的修改主要有两种方法：merge和rebase<br>合并进行一次三方合并，产生一个新的快照并提交<br>变基首先找到两个分支的共同祖先，对比当前分支的历次提交，提取相应的修改，然后在新的分支上进行重新播放，最后进行一次快速合并<br>一般进行变基的目的是确保向远程分支推送时，保持提交历史的整洁<br>这两种方式整合的最终快照是一样的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将当前分支变基到<span class="literal">master</span>分支</span><br><span class="line">git rebase <span class="literal">master</span></span><br><span class="line">// 将在client分支里但不在server分支里的修改，在<span class="literal">master</span>分支里重放</span><br><span class="line">git rebase --onto <span class="keyword">master</span> <span class="title">server</span> client</span><br><span class="line">// 无需切换分支进行变基</span><br><span class="line">git rebase <span class="keyword">master</span> <span class="title">server</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/变基然后进行快进合并.png" alt="变基然后进行快进合并" title>                </div>                <div class="image-caption">变基然后进行快进合并</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/通过合并操作来整合分叉的历史.png" alt="通过合并操作来整合分叉的历史" title>                </div>                <div class="image-caption">通过合并操作来整合分叉的历史</div>            </figure><p>变基存在风险，使用变基的准则是不要对在你的仓库外有副本的分支执行变基<br>变基的操作实际上是丢弃一些现有的提交，然后相应的新建一些内容一样的但是实际上不同的提交<br>如果别人在该分支上进行了工作，你对此分支进行了变基，那么就会出现问题<br>出现类似的情况可以使用变基来解决变基<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上的命令和知识可以应付大部分Git的使用场景了<br>如果遇到其他的困难问题，可以后续再补充</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想深入了解一下Git，阅读了一下&lt;a href=&quot;https://git-scm.com/book/en/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pro Git&lt;/a&gt;的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅&lt;/p&gt;
&lt;h1 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h1&gt;&lt;p&gt;Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;p&gt;版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://blog.gwq5210.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Cpp-Primer-Plus读书笔记（四）</title>
    <link href="https://blog.gwq5210.com/2018/04/12/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://blog.gwq5210.com/2018/04/12/Cpp-Primer-Plus读书笔记（四）/</id>
    <published>2018-04-12T22:26:26.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-中的代码重用"><a href="#C-中的代码重用" class="headerlink" title="C++中的代码重用"></a>C++中的代码重用</h1><p>C++的一个主要目标是促进代码重用。</p><h2 id="包含对象成员的类"><a href="#包含对象成员的类" class="headerlink" title="包含对象成员的类"></a>包含对象成员的类</h2><p>valarray是由头文件valarray定义，其用于处理数值<br>通常用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类<br>使用组合可以获得实现，但不获得接口，共有继承可以获得接口，可能还有实现</p><p>对于模板类我们可以使用typedef简化其描述</p><p>使用成员初始化列表来初始化包含的类对象。</p><a id="more"></a><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。这种关系是has-a关系。</p><p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象(subobject)来表示通过继承或包含添加的对象。</p><p>使用包含时使用对象名来调用方法，而使用私有继承时，将使用类名和作用域解析运算符来调用方法</p><p>私有继承如果希望访问基类对象，可以使用强制类型转换。同样，可以通过强制类型转换来使用基类的友元函数。</p><p>在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针。在多重继承情况下，不进行强制类型转换也无法确定应转换成哪个类。然而即使公有继承也必须进行强制类型抓换。</p><h3 id="使用包含还是私有继承"><a href="#使用包含还是私有继承" class="headerlink" title="使用包含还是私有继承"></a>使用包含还是私有继承</h3><p>使用包含更容易理解，继承会引起多个问题，尤其是使用多重继承的情况下，另外还可能需要包含类的多个子对象</p><p>通常应使用包含来实现has-a，如果新类要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承</p><h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护继承是私有继承的变体，其使用关键字protected<br>在使用保护继承时，基类的共有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的，当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别就呈现出来了，使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中将变成私有方法，使用保护继承时，基类的共有方法在第二代类中将变成受保护的，因此第三代类可以使用它们。隐式向上转换(implicit upcasting)意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。如下表<br>| 特征  | 共有继承 | 保护继承 | 私有继承 |<br>| —— | —— | —— | —— |<br>| 公有成员变成 | 派生类的公有成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 保护成员变成 | 派生类的保护成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 私有成员变成 | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |<br>| 能否隐式向上转换 | 是 | 是(但只能在派生类中) | 否 |</p><h4 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h4><p>使用保护派生或私有派生时，假设要使基类的方法在派生类外可用，方法之一是定义一个使用该基类方法的派生类方法，如<br><figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> Student::sum() <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> std::valarray&lt;<span class="keyword">double</span>&gt;::sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用基类特定的基类成员，即使采用的是私有派生，注意，using声明只使用成员名，没有圆括号，函数特征标和返回值，这使得所有成员名的方法都可用，其只适用于继承，不适用于包含。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="built_in">min</span>;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::<span class="built_in">max</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;C-中的代码重用&quot;&gt;&lt;a href=&quot;#C-中的代码重用&quot; class=&quot;headerlink&quot; title=&quot;C++中的代码重用&quot;&gt;&lt;/a&gt;C++中的代码重用&lt;/h1&gt;&lt;p&gt;C++的一个主要目标是促进代码重用。&lt;/p&gt;
&lt;h2 id=&quot;包含对象成员的类&quot;&gt;&lt;a href=&quot;#包含对象成员的类&quot; class=&quot;headerlink&quot; title=&quot;包含对象成员的类&quot;&gt;&lt;/a&gt;包含对象成员的类&lt;/h2&gt;&lt;p&gt;valarray是由头文件valarray定义，其用于处理数值&lt;br&gt;通常用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类&lt;br&gt;使用组合可以获得实现，但不获得接口，共有继承可以获得接口，可能还有实现&lt;/p&gt;
&lt;p&gt;对于模板类我们可以使用typedef简化其描述&lt;/p&gt;
&lt;p&gt;使用成员初始化列表来初始化包含的类对象。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://blog.gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>mathjax简单教程（翻译）</title>
    <link href="https://blog.gwq5210.com/2018/02/04/mathjax%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/"/>
    <id>https://blog.gwq5210.com/2018/02/04/mathjax简单教程（翻译）/</id>
    <published>2018-02-04T00:36:22.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathjax简单教程（翻译）"><a href="#mathjax简单教程（翻译）" class="headerlink" title="mathjax简单教程（翻译）"></a>mathjax简单教程（翻译）</h1><p>原文地址：<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">mathjax basic tutorial and quick reference</a></p><ol><li>在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。</li><li>使用$…$来产生行内公式，使用$$…$$来产生多行公式。公式$\sum<em>{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\sum</em>{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\tag{displayed}$是不一样的。</li><li>使用\alpha,\beta,…,\omega来产生希腊字母：$\alpha$,$\beta$,$\omega$。使用\Gamma,\Delta,…,\Omega来产生大写的：$\Gamma$,$\Delta$,…,$\Omega$。</li><li>使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。</li></ol><a id="more"></a><ol><li>组。下标，上标和其他运算符只能应用到下一个”组”。单个符号或者被大括号{…}包含起来的公式被视为一个组。如10^10产生$10^10$，而不是$10^{10}$，这样写可以得到预期的结果：10^{10}。使用大括号可以界定公式中那些是上标或者下标：x^5^6是错误的，{x^y}^z是${x^y}^z$，x^{y^z}是$x^{y^z}$。显然x<em>i^2：$x_i^2$和x</em>{i^2}：$x_{i^2}$是不同的。</li><li>符号()[]产生对应的符号，如(3+4)[4+4]产生：$(3+4)[4+4]$。但使用{和}来产生大括号：${}$。<br>但上边的不会自动适应公式的大小，所以如果你写下(\frac12)，那么括号会很小：$(\frac12)$，使用\left(…\right)来使括号自动适应公式的大小：\left(\frac12\right)产生$\left(\frac12\right)$。<br>\left和\right可以作用于下边种类的括号：(和)：$\left(x\right)$，[和]：$\left[x\right]$，{和} ：$\left{x\right}$，|：$\left|x\right|$，\langle和\ rangle：$\left\langle{x}\right\rangle$，\lceil和\rceil：$\left\lceil{x}\right\rceil$，\lfloor和\rfloor：$\left\lfloor{x}\right\rfloor$。还有一种不可见的括号，用.来指代：\left.\frac12\right}表示$\left.\frac12\right}$。</li><li>使用\sum和\int来代表求和，积分。下标表示下限，上标表示上限，所以\sum<em>1^n表示$\sum_1^n$。上限和下限超过一个符号不要忘记加上{…}。如\sum</em>{i=0}^\infty i^2表示$\sum_{i=0}^\infty{i^2}$。类似的还有：\prod$表示\prod$，\int表示$\int$，\bigcup表示$\bigcup$，\bigcap表示$\bigcap$，\iint表示$\iint$。</li><li>分数有两种产生方式。\frac作用于下边紧邻的两个组；如\frac ab产生$\frac ab$。可以使用{…}来产生更复杂的表达式；如\frac{a+1}{b+1}产生$\frac{a+1}{b+1}$。如果分子和分母很复杂，你可能更喜欢\over，它分割一个组内的两部分产生分数；如{a+1 \over b+1}产生${a+1 \over b+1}$。</li><li>字体。<ul><li>使用\mathbb或\Bbb产生”blackboard bold”：$\mathbb{CHNQRZ}$</li><li>使用\mathface产生blodface：$\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathbf{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathtt产生”typewriter”字体：$\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathtt{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mattrm产生roman字体：$\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathrm{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathcal产生”calligraphic”字母：<br>$\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathcal{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathsrc产生script字母：<br>$\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathscr{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathfrak产生”Fraktur”(老式德国风格)字母：<br>$\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathfrak{abcdefghijklmnopqrstuvwxyz}$</li></ul></li><li>使用\sqrt产生根号，它会自动适应公式的大小。如\sqrt{x^3}产生$\sqrt{x^3}$；\sqrt[3]{\frac xy}产生$\sqrt[3]{\frac xy}$。对于复杂的表达式可以使用{…}^{1/2}。</li><li>一些如lim，sin，max，ln的特殊函数可以使用\lim，\sin等产生。如\sin x产生$\sin x$，而不是sin x产生$sin x$。\lim使用下标产生趋近符号：\lim<em>{x\to 0}产生$\lim</em>{x\to 0}$。</li><li>有大量的特殊符号和记号，可以参考<a href="http://pic.plover.com/MISC/symbols.pdf" target="_blank" rel="noopener">this shorter listing</a>或<a href="http://mirror.math.ku.edu/tex-archive/info/symbols/comprehensive/symbols-a4.pdf" target="_blank" rel="noopener">this exhaustive listing</a>。一些常用的列在下边：<ul><li>\lt,\gt,\le,\ge,\neq分别表示$\lt$,$\gt$,$\le$,$\ge$,$\neq$。你可以使用\not来在大多数符号上画上斜线，但通常看起来很差劲，如\not\lt表示$\not\lt$。</li><li>\times,\div,\pm,\mp分别表示$\times$,$\div$,$\pm$,$\mp$。\cdot表示一个居中的点：$x\cdot y$。</li><li>\cup,\cap,\setminus,\subset,\subseteq,\subsetneq,\supset,\in,\notin,\emptyset,\varnothing分别表示$\cup\, \cap\, \setminus\, \subset\, \subseteq \,\subsetneq \,\supset\, \in\, \notin\, \emptyset\, \varnothing$。</li><li>{n+1 \choose 2k}或者\binom{n+1}{2k}表示${n+1 \choose 2k}$。</li><li>\to,\rightarrow,\leftarrow,\Rightarrow,\Leftarrow,\mapsto分别表示$\to\, \rightarrow\, \leftarrow\, \Rightarrow\, \Leftarrow\, \mapsto$。</li><li>\land,\lor,\lnot,\forall,\exists,\top,\bot,\vdash,\vDash分别表示$\land\, \lor\, \lnot\, \forall\, \exists\, \top\, \bot\, \vdash\, \vDash$。</li><li>\star\, \ast\, \oplus\, \circ\, \bullet分别表示$\star\, \ast\, \oplus\, \circ\, \bullet$。</li><li>\approx\, \sim \, \simeq\, \cong\, \equiv\, \prec分别表示$\approx\, \sim \, \simeq\, \cong\, \equiv\, \prec$。</li><li>\infty\, \aleph_0, \nabla\, \partial, \Im\, \Re分别表示$\infty\, \aleph_0, \nabla\, \partial, \Im\, \Re$。</li><li>可以使用\pmod来产生同余式，如a\equiv b\pmod n产生$a\equiv b\pmod n$。</li><li>\ldots可以产生这里的点：$a_1, a_2, \ldots ,a_n$；\cdots产生这里的点：$a_1+a_2+\cdots+a_n$。</li><li>一些希腊字母具有不同的形式：\epsilon\, \varepsilon分别表示$\epsilon\, \varepsilon$，\phi\, \varphi分别表示$\phi\, \varphi$，\ell表示$\ell$等。</li></ul></li><li>在mathjax的公式中加入空格，不会改变公式中空格的数量。如a␣b和a␣␣␣␣b都产生$a b$。可以使用\,加入一个空格$a\,b$，使用\;加入一个宽空格$a\;b$，使用\quad和\qquad产生大量的空格$a\quad b,a\qquad b$。<br>可以使用\text{…}在公式中加入普通文本：${x\in s\mid x\text{ is extra large}}$。还可以在\text{…}中嵌套$…$。</li><li>强调和区别标志。\hat用于单个符号：$\hat x$,\widehat用于一个公式：$\widehat{xy}$。如果将它弄的特别宽，看起来就十分丑。类似的，\bar产生$\bar x$，\overline产生$\overline{xyz}$，\vec产生$\vec x$，\overrightarrow产生$\overrightarrow{xy}$。可以使用\dot和\ddot产生点和双点，如\frac d{dx}x\dot x =  \dot x^2 +  x\ddot x产生$\frac d{dx}x\dot x =  \dot x^2 +  x\ddot x$。</li><li>使用\来转义mathjax中使用的特殊字符，如$表示$$$，{表示${$，_表示$_$等等。<br>教程到此结束。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mathjax简单教程（翻译）&quot;&gt;&lt;a href=&quot;#mathjax简单教程（翻译）&quot; class=&quot;headerlink&quot; title=&quot;mathjax简单教程（翻译）&quot;&gt;&lt;/a&gt;mathjax简单教程（翻译）&lt;/h1&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathjax basic tutorial and quick reference&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &amp;gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。&lt;/li&gt;
&lt;li&gt;使用$…$来产生行内公式，使用$$…$$来产生多行公式。公式$\sum&lt;em&gt;{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\sum&lt;/em&gt;{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\tag{displayed}$是不一样的。&lt;/li&gt;
&lt;li&gt;使用\alpha,\beta,…,\omega来产生希腊字母：$\alpha$,$\beta$,$\omega$。使用\Gamma,\Delta,…,\Omega来产生大写的：$\Gamma$,$\Delta$,…,$\Omega$。&lt;/li&gt;
&lt;li&gt;使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mathjax教程" scheme="https://blog.gwq5210.com/tags/mathjax%E6%95%99%E7%A8%8B/"/>
    
      <category term="LaTeX" scheme="https://blog.gwq5210.com/tags/LaTeX/"/>
    
  </entry>
  
  <entry>
    <title>Redis中的geo功能</title>
    <link href="https://blog.gwq5210.com/2018/02/03/Redis%E4%B8%AD%E7%9A%84geo%E5%8A%9F%E8%83%BD/"/>
    <id>https://blog.gwq5210.com/2018/02/03/Redis中的geo功能/</id>
    <published>2018-02-03T17:37:12.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><p>Redis是一个开源的（BSD协议），基于内存的kv存储数据库。它支持很多数据结构。目前Redis还支持部署集群。</p><p>从Redis 3.2开始，Redis提供了geo的功能，也就是地理位置相关的命令，今天我们主要来了解这个功能。</p><a id="more"></a><h1 id="geo相关命令简介"><a href="#geo相关命令简介" class="headerlink" title="geo相关命令简介"></a>geo相关命令简介</h1><p>跟geo相关的命令有六个：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">GEOADD key longitude latitude member [longitude latitude member <span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">GEODIST key member1 member2 [unit]</span><br><span class="line"></span><br><span class="line">GEOHASH key member [member <span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">GEOPOS key member [member <span class="built_in">..</span>.]</span><br><span class="line"></span><br><span class="line">GEORADIUS key longitude latitude<span class="built_in"> radius </span>m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line"></span><br><span class="line">GEORADIUSBYMEMBER key member<span class="built_in"> radius </span>m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure></p><p>通过名字我们大概可以知道命令的功能。</p><ul><li>geoadd添加地理位置</li><li>geodist计算地理位置之间的距离</li><li>geohash计算地理位置的geohash(有关geohash的内容可以参考<a href="/2018/02/03/geohash简介/">geohash简介</a>)</li><li>geopos获取地理位置</li><li>georadius和georadiusbymember获取某个地理位置附近的所有位置点</li></ul><p>下面我们分别对其进行介绍。</p><h1 id="添加和获取地理位置"><a href="#添加和获取地理位置" class="headerlink" title="添加和获取地理位置"></a>添加和获取地理位置</h1><h2 id="添加地理位置"><a href="#添加地理位置" class="headerlink" title="添加地理位置"></a>添加地理位置</h2><p>我们通过GEOADD来添加位置。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOADD <span class="built_in">key</span> longitude latitude <span class="built_in">member</span> [longitude latitude <span class="built_in">member</span> ...]</span><br></pre></td></tr></table></figure></p><p>可以看到GEOADD每次可以添加多个位置。key是地理位置的集合。</p><p>下面是例子，首先添加一个地点清远，后边一次添加多个地点。<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 添加一个地点</span><br><span class="line">GEOADD Guangdong-cities <span class="number">113.2099647</span> <span class="number">23.593675</span> Qingyuan</span><br><span class="line"></span><br><span class="line">// 添加多个地点</span><br><span class="line">GEOADD Guangdong-cities <span class="number">113.2278442</span> <span class="number">23.1255978</span> Guangzhou <span class="number">113.106308 23</span>.<span class="number">0088312</span> Foshan <span class="number">113.7943267</span> <span class="number">22.9761989</span> Dongguan <span class="number">114.0538788</span> <span class="number">22.5551603</span> Shenzhen</span><br></pre></td></tr></table></figure></p><h2 id="获取地理位置"><a href="#获取地理位置" class="headerlink" title="获取地理位置"></a>获取地理位置</h2><p>我们通过GEOPOS来获取对应的地理位置信息。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOPOS <span class="built_in">key</span> <span class="built_in">member</span> [<span class="built_in">member</span> ...]</span><br></pre></td></tr></table></figure></p><p>例如我们通过如下命令来获取刚刚添加进去的地理位置<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GEOPOS Guangdong-cities Qingyuan Guangzhou Foshan</span></span><br></pre></td></tr></table></figure></p><p>其返回是一个数组，每个数组包含两个元素：经度和维度<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">"113.20996731519699"</span>    -- 清远的经度</span><br><span class="line">   <span class="number">2</span>) <span class="string">"23.593675019671288"</span>    -- 清远的纬度</span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"113.22784155607224"</span>    -- 广州的经度</span><br><span class="line">   <span class="number">2</span>) <span class="string">"23.125598202060807"</span>    -- 广州的纬度</span><br><span class="line"><span class="number">3</span>) <span class="number">1</span>) <span class="string">"113.10631066560745"</span>    -- 佛山的经度</span><br><span class="line">   <span class="number">2</span>) <span class="string">"23.008831202413539"</span>    -- 佛山的纬度</span><br></pre></td></tr></table></figure></p><h1 id="计算距离和geohash"><a href="#计算距离和geohash" class="headerlink" title="计算距离和geohash"></a>计算距离和geohash</h1><p>针对地理位置的操作，Redis提供了计算两点间距离和获取该地理位置geohash的方法</p><h2 id="计算距离"><a href="#计算距离" class="headerlink" title="计算距离"></a>计算距离</h2><p>我们使用GEODIST获取两个位置之间的距离<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">GEODIST</span> key member1 member2<span class="meta"> [unit]</span></span><br></pre></td></tr></table></figure></p><p>我们需要制定一个地点集合中的两个地理位置<br>unit指定返回的距离单位（默认为m），可用值如下</p><ul><li>m 表示单位为米。</li><li>km 表示单位为千米。</li><li>mi 表示单位为英里。</li><li>ft 表示单位为英尺。</li></ul><p>例如，计算清远和广州之间的距离<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GEODIST Guangdong-cities Qingyuan Guangzhou km</span><br><span class="line"><span class="string">"52.094433840356309"</span>    <span class="comment">-- 两地相距 52 公里</span></span><br></pre></td></tr></table></figure></p><h2 id="计算geohash"><a href="#计算geohash" class="headerlink" title="计算geohash"></a>计算geohash</h2><p>相关geohash的资料可以参考<a href="/2018/02/03/geohash简介/">这里</a></p><p>在Redis中我们使用GEOHASH获取一个地点的geohash值<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GEOHASH <span class="built_in">key</span> <span class="built_in">member</span> [<span class="built_in">member</span> ...]</span><br></pre></td></tr></table></figure></p><p>geohash返回一个数组，数组中每个元素都是一个geohash字符串，Redis返回的字符串为11个字符。</p><p>例子<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">"Palermo"</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">"Catania"</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">redis&gt; GEOHASH Sicily Palermo Catania</span><br><span class="line"><span class="number">1</span>) <span class="string">"sqc8b49rny0"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"sqdtr74hyu0"</span></span><br><span class="line">redis&gt;</span><br></pre></td></tr></table></figure></p><h1 id="获取附近的点"><a href="#获取附近的点" class="headerlink" title="获取附近的点"></a>获取附近的点</h1><p>在我们使用的许多应用中，都有获取附近美食等的能力，Redis也提供了类似的功能，获取附近范围内的地理位置。<br>有两个命令GEORADIUS和GEORADIUSBYMEMBER，前者用经纬度指定中心点，后者使用存储在Redis中的某个点作为中心点<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GEORADIUS key longitude latitude<span class="built_in"> radius </span>m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br><span class="line"></span><br><span class="line">GEORADIUSBYMEMBER key member<span class="built_in"> radius </span>m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]</span><br></pre></td></tr></table></figure></p><p>其中</p><ul><li>m|km|ft|mi 指定的是计算范围时的单位；</li><li>如果给定了可选的 WITHCOORD ， 那么命令在返回匹配的位置时会将位置的经纬度一并返回；</li><li>如果给定了可选的 WITHDIST ， 那么命令在返回匹配的位置时会将位置与中心点之间的距离一并返回；</li><li>在默认情况下， GEORADIUS 和 GEORADIUSBYMEMBER 的结果是未排序的， ASC 可以让查找结果根据距离从近到远排序， 而 DESC 则可以让查找结果根据从远到近排序；</li><li>COUNT 参数指定要返回的结果数量。</li></ul><p>例子<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">redis&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">"Palermo"</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">"Catania"</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">redis&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km WITHDIST</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">"Palermo"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"190.4424"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"Catania"</span></span><br><span class="line">   <span class="number">2</span>) <span class="string">"56.4413"</span></span><br><span class="line">redis&gt; GEORADIUS Sicily <span class="number">15</span> <span class="number">37</span> <span class="number">200</span> km WITHCOORD</span><br><span class="line"><span class="number">1</span>) <span class="number">1</span>) <span class="string">"Palermo"</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="string">"13.36138933897018433"</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">"38.11555639549629859"</span></span><br><span class="line"><span class="number">2</span>) <span class="number">1</span>) <span class="string">"Catania"</span></span><br><span class="line">   <span class="number">2</span>) <span class="number">1</span>) <span class="string">"15.08726745843887329"</span></span><br><span class="line">      <span class="number">2</span>) <span class="string">"37.50266842333162032"</span></span><br><span class="line"></span><br><span class="line">redis&gt; GEOADD Sicily <span class="number">13.583333</span> <span class="number">37.316667</span> <span class="string">"Agrigento"</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">1</span></span><br><span class="line">redis&gt; GEOADD Sicily <span class="number">13.361389</span> <span class="number">38.115556</span> <span class="string">"Palermo"</span> <span class="number">15.087269</span> <span class="number">37.502669</span> <span class="string">"Catania"</span></span><br><span class="line">(<span class="type">integer</span>) <span class="number">2</span></span><br><span class="line">redis&gt; GEORADIUSBYMEMBER Sicily Agrigento <span class="number">100</span> km</span><br><span class="line"><span class="number">1</span>) <span class="string">"Agrigento"</span></span><br><span class="line"><span class="number">2</span>) <span class="string">"Palermo"</span></span><br></pre></td></tr></table></figure></p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>Redis提供了地理位置相关的命令，我们可以使用这些特性方便的时间地理位置查找等相关的功能。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis 命令参考</a><br>2) <a href="http://blog.huangz.me/diary/2015/redis-geo.html" target="_blank" rel="noopener">Redis GEO 特性简介</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Redis简介&quot;&gt;&lt;a href=&quot;#Redis简介&quot; class=&quot;headerlink&quot; title=&quot;Redis简介&quot;&gt;&lt;/a&gt;Redis简介&lt;/h1&gt;&lt;p&gt;Redis是一个开源的（BSD协议），基于内存的kv存储数据库。它支持很多数据结构。目前Redis还支持部署集群。&lt;/p&gt;
&lt;p&gt;从Redis 3.2开始，Redis提供了geo的功能，也就是地理位置相关的命令，今天我们主要来了解这个功能。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.gwq5210.com/tags/Redis/"/>
    
      <category term="geohash" scheme="https://blog.gwq5210.com/tags/geohash/"/>
    
      <category term="Redis地理位置功能" scheme="https://blog.gwq5210.com/tags/Redis%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AE%E5%8A%9F%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>geohash简介</title>
    <link href="https://blog.gwq5210.com/2018/02/03/geohash%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.gwq5210.com/2018/02/03/geohash简介/</id>
    <published>2018-02-03T17:35:38.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近项目需要使用到通过用户的经纬度查询附近的地理位置，了解到geohash可以快速的查找附近的地点，就找时间了解下是geohash的实现方式。</p><h1 id="geohash介绍"><a href="#geohash介绍" class="headerlink" title="geohash介绍"></a>geohash介绍</h1><p>geohash能将地理位置编码成字母和数字组成字符串。每个字符串表示一个地图上的矩形区域，举行区域的大小取决于字符串的长度，长度越长，矩形区域越小。每个矩形区域中的位置都共享相同的geohash字符串。正因为如此，我们可以将geohash的字符串当做key，来存储所有的地理位置坐标。</p><p>上边提到字符串越长，表示的区域越小，也就是位置越精确。我们可以从geohash字符串的后边移除字符串来增大矩形区域的位置，当然也降低了经度。</p><p>geohash字符串相近的地点其距离也越近，相似前缀越长，两个地点越近。但也有特殊情况，地理位置近但其geohash字符串差别很大，这种情况在下边介绍。</p><a id="more"></a><h1 id="主要用途"><a href="#主要用途" class="headerlink" title="主要用途"></a>主要用途</h1><p>geohash主要用在如下两个场景：</p><ol><li>将geohash字符串当做一个唯一的标识</li><li>用来表示地点数据，将其存储到数据库中</li></ol><p>geohash也经常用于地理标记。</p><p>使用geohash有两个优点：一是用geohash索引的数据表示的是一个矩形区域中所有的点，在数据库中单个索引的效率也比多个索引高；二是我们可以使用geohash来进行快速但不精确的查询：geohash相近的字符串也有相近的距离。</p><h1 id="算法和例子"><a href="#算法和例子" class="headerlink" title="算法和例子"></a>算法和例子</h1><p>geohash的字符串其实是<a href="https://en.wikipedia.org/wiki/Base32" target="_blank" rel="noopener">base32</a>的结果。<br>我们用ws104来作为例子说明如何从geohash解析成经纬度。</p><p>先使用base32对字符串ws104进行解码。<br>下面是base32的字符表：</p><div class="table-container"><table><thead><tr><th>十进制</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th></tr></thead><tbody><tr><td>base32</td><td>0</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr><tr><td>十进制</td><td>8</td><td>9</td><td>10</td><td>11</td><td>12</td><td>13</td><td>14</td><td>15</td></tr><tr><td>base32</td><td>8</td><td>9</td><td>b</td><td>c</td><td>d</td><td>e</td><td>f</td><td>g</td></tr><tr><td>十进制</td><td>16</td><td>17</td><td>18</td><td>19</td><td>20</td><td>21</td><td>22</td><td>23</td></tr><tr><td>base32</td><td>h</td><td>j</td><td>k</td><td>m</td><td>n</td><td>p</td><td>q</td><td>r</td></tr><tr><td>十进制</td><td>24</td><td>25</td><td>26</td><td>27</td><td>28</td><td>29</td><td>30</td><td>31</td></tr><tr><td>base32</td><td>s</td><td>t</td><td>u</td><td>v</td><td>w</td><td>x</td><td>y</td><td>z</td></tr></tbody></table></div><p>由此可以得到ws104对应的二进制串是：11100 11000 00001 00000 00100</p><p>从左边开始数从0开始，偶数位是经度(1101 0001 0001 0)，奇数位是维度(1010 0000 0000)</p><p>这些二进制数从左到右对经纬度进行一系列分解，对于维度其范围在-90到90度，对于经度其范围在-180到180度。0表示较小的部分，1表示较大的部分。经度第一位是1，因此经度的范围在0到180度的范围内。我们依次进行此操作，对于维度的操作一样。</p><p>这样我们也可以理解为什么geohash字符串长度越长，表示的数据越准确。</p><p>下面是对维度进行分解的数据：</p><div class="table-container"><table><thead><tr><th>位置</th><th>二进制值</th><th>最小值</th><th>中间值</th><th>最大值</th><th>平均值</th><th>最大误差</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>-90.000</td><td>0</td><td>90.000</td><td>45.000</td><td>45.000</td></tr><tr><td>1</td><td>0</td><td>0</td><td>45.000</td><td>90.000</td><td>22.500</td><td>22.500</td></tr><tr><td>2</td><td>1</td><td>0</td><td>22.500</td><td>45.000</td><td>33.750</td><td>11.250</td></tr><tr><td>3</td><td>0</td><td>22.500</td><td>33.750</td><td>45.000</td><td>28.125</td><td>5.625</td></tr><tr><td>4</td><td>0</td><td>22.500</td><td>28.125</td><td>33.750</td><td>25.3125</td><td>2.8125</td></tr><tr><td>5</td><td>0</td><td>22.500</td><td>25.3125</td><td>28.125</td><td>23.90625</td><td>1.40625</td></tr><tr><td>6</td><td>0</td><td>22.500</td><td>23.90625</td><td>25.3125</td><td>23.203125</td><td>0.703125</td></tr><tr><td>7</td><td>0</td><td>22.500</td><td>23.203125</td><td>23.90625</td><td>22.8515625</td><td>0.3515625</td></tr><tr><td>8</td><td>0</td><td>22.500</td><td>22.8515625</td><td>23.203125</td><td>22.67578125</td><td>0.17578125</td></tr><tr><td>9</td><td>0</td><td>22.500</td><td>22.67578125</td><td>22.8515625</td><td>22.587890625</td><td>0.087890625</td></tr><tr><td>10</td><td>0</td><td>22.500</td><td>22.587890625</td><td>22.67578125</td><td>22.5439453125</td><td>0.0439453125</td></tr><tr><td>11</td><td>0</td><td>22.500</td><td>22.5439453125</td><td>22.587890625</td><td>22.52197265625</td><td>0.02197265625</td></tr></tbody></table></div><p>因此这个位置的维度在范围22.500到22.5439453125之间，误差为0.02197265625。</p><p>同理可以算出经度范围在113.994140625到114.0380859375之间，误差为0.02197265625。</p><div class="table-container"><table><thead><tr><th>位置</th><th>二进制值</th><th>最小值</th><th>中间值</th><th>最大值</th><th>平均值</th><th>最大误差</th></tr></thead><tbody><tr><td>0</td><td>1</td><td>-180.000</td><td>0</td><td>180.000</td><td>90.000</td><td>90.000</td></tr><tr><td>1</td><td>1</td><td>0</td><td>90.000</td><td>180.000</td><td>135.000</td><td>45.000</td></tr><tr><td>2</td><td>0</td><td>90.000</td><td>135.000</td><td>180.000</td><td>112.500</td><td>22.500</td></tr><tr><td>3</td><td>1</td><td>90.000</td><td>112.500</td><td>135.000</td><td>123.750</td><td>11.250</td></tr><tr><td>4</td><td>0</td><td>112.500</td><td>123.750</td><td>135.000</td><td>118.125</td><td>5.625</td></tr><tr><td>5</td><td>0</td><td>112.500</td><td>118.125</td><td>123.750</td><td>115.3125</td><td>2.8125</td></tr><tr><td>6</td><td>0</td><td>112.500</td><td>115.3125</td><td>118.125</td><td>113.90625</td><td>1.40625</td></tr><tr><td>7</td><td>1</td><td>112.500</td><td>113.90625</td><td>115.3125</td><td>114.609375</td><td>0.703125</td></tr><tr><td>8</td><td>0</td><td>113.90625</td><td>114.609375</td><td>115.3125</td><td>114.2578125</td><td>0.3515625</td></tr><tr><td>9</td><td>0</td><td>113.90625</td><td>114.2578125</td><td>114.609375</td><td>114.08203125</td><td>0.17578125</td></tr><tr><td>10</td><td>0</td><td>113.90625</td><td>114.08203125</td><td>114.2578125</td><td>113.994140625</td><td>0.087890625</td></tr><tr><td>11</td><td>1</td><td>113.90625</td><td>113.994140625</td><td>114.08203125</td><td>114.0380859375</td><td>0.0439453125</td></tr><tr><td>12</td><td>0</td><td>113.994140625</td><td>114.0380859375</td><td>114.08203125</td><td>114.01611328125</td><td>0.02197265625</td></tr></tbody></table></div><p>下面我们给出geohash字符串长度跟精度的关系</p><div class="table-container"><table><thead><tr><th>geohash长度</th><th>维度位数</th><th>经度位数</th><th>维度误差</th><th>经度误差</th><th>距离误差（km）</th></tr></thead><tbody><tr><td>1</td><td>2</td><td>3</td><td>$\pm$23</td><td>$\pm$23</td><td>$\pm$2500</td></tr><tr><td>2</td><td>5</td><td>5</td><td>$\pm$2.8</td><td>$\pm$5.6</td><td>$\pm$630</td></tr><tr><td>3</td><td>7</td><td>8</td><td>$\pm$0.70</td><td>$\pm$0.70</td><td>$\pm$78</td></tr><tr><td>4</td><td>10</td><td>10</td><td>$\pm$0.087</td><td>$\pm$0.18</td><td>$\pm$20</td></tr><tr><td>5</td><td>12</td><td>13</td><td>$\pm$0.022</td><td>$\pm$0.022</td><td>$\pm$2.4</td></tr><tr><td>6</td><td>15</td><td>15</td><td>$\pm$0.0027</td><td>$\pm$0.0055</td><td>$\pm$0.61</td></tr><tr><td>7</td><td>17</td><td>18</td><td>$\pm$0.00068</td><td>$\pm$0.00068</td><td>$\pm$0.076</td></tr><tr><td>8</td><td>20</td><td>20</td><td>$\pm$0.000085</td><td>$\pm$0.00017</td><td>$\pm$0.019</td></tr></tbody></table></div><h1 id="使用上的限制"><a href="#使用上的限制" class="headerlink" title="使用上的限制"></a>使用上的限制</h1><h2 id="边界情况"><a href="#边界情况" class="headerlink" title="边界情况"></a>边界情况</h2><p>前面提到我们可以通过前缀匹配来大致的寻找附近的点。但是，这不是总能够成立的。</p><p>南极和北极的地点相近但是它们的经度差别很大，没有相同的前缀；在180度子午线(经线)两侧的地点，距离很近，但是在不同的区域内，也不会有相同的前缀。同样的，划分的区域边界，也存在类似的情况。</p><h2 id="非线性的距离"><a href="#非线性的距离" class="headerlink" title="非线性的距离"></a>非线性的距离</h2><p>由于geohash是基于经纬度坐标的距离进行计算，两个geohash点映射出来的距离并不是真实的距离。这是因为我们很难将球体上的坐标映射到一个均匀的二维空间。</p><p>尽管存在许多问题，但仍有可能的解决办法，这些算法已经成功的在Elasticsearch，MongoDB，HBase中实现用于近似查找。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="http://www.cnblogs.com/LBSer/p/3310455.html" target="_blank" rel="noopener">GeoHash核心原理解析</a><br>2) <a href="https://en.wikipedia.org/wiki/Geohash" target="_blank" rel="noopener">Geohash-Wikipedia</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近项目需要使用到通过用户的经纬度查询附近的地理位置，了解到geohash可以快速的查找附近的地点，就找时间了解下是geohash的实现方式。&lt;/p&gt;
&lt;h1 id=&quot;geohash介绍&quot;&gt;&lt;a href=&quot;#geohash介绍&quot; class=&quot;headerlink&quot; title=&quot;geohash介绍&quot;&gt;&lt;/a&gt;geohash介绍&lt;/h1&gt;&lt;p&gt;geohash能将地理位置编码成字母和数字组成字符串。每个字符串表示一个地图上的矩形区域，举行区域的大小取决于字符串的长度，长度越长，矩形区域越小。每个矩形区域中的位置都共享相同的geohash字符串。正因为如此，我们可以将geohash的字符串当做key，来存储所有的地理位置坐标。&lt;/p&gt;
&lt;p&gt;上边提到字符串越长，表示的区域越小，也就是位置越精确。我们可以从geohash字符串的后边移除字符串来增大矩形区域的位置，当然也降低了经度。&lt;/p&gt;
&lt;p&gt;geohash字符串相近的地点其距离也越近，相似前缀越长，两个地点越近。但也有特殊情况，地理位置近但其geohash字符串差别很大，这种情况在下边介绍。&lt;/p&gt;
    
    </summary>
    
    
      <category term="geohash" scheme="https://blog.gwq5210.com/tags/geohash/"/>
    
      <category term=" 地理位置hash" scheme="https://blog.gwq5210.com/tags/%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AEhash/"/>
    
  </entry>
  
  <entry>
    <title>hiredis的使用</title>
    <link href="https://blog.gwq5210.com/2018/01/27/hiredis%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.gwq5210.com/2018/01/27/hiredis的使用/</id>
    <published>2018-01-27T16:39:49.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近期开发的项目使用到了Redis，本文主要记录下使用Redis API遇到的一些问题。<br>如果想了解Redis相关的细节，可以看<a href="http://redisbook.com/" target="_blank" rel="noopener">《Redis设计与实现》</a>。<br>想了解Redis相关的命令，可以参考<a href="http://redisdoc.com/" target="_blank" rel="noopener">Redis命令参考</a></p><h1 id="hiredis简介"><a href="#hiredis简介" class="headerlink" title="hiredis简介"></a>hiredis简介</h1><p>hiredis是<a href="https://redis.io/" target="_blank" rel="noopener">Redis</a>的一个极简c客户端库。<br>它实现了Redis协议的最小集，但同时也提供类printf的API，使用既方便有简介。<br>hiredis提供了多种API，它同时支持同步，异步和回复解析API。在此基础上，能够实现Redis的流水线操作。</p><a id="more"></a><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><p>首先来看数据结构，主要分为两部分。保存Redis连接上下文的redisContext和保存Redis命令回复的RedisReply。<br>下边分别介绍：</p><h2 id="连接上下文redisContext"><a href="#连接上下文redisContext" class="headerlink" title="连接上下文redisContext"></a>连接上下文redisContext</h2><p>首先看结构定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Context for a connection to Redis */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> err; <span class="comment">/* Error flags, 0 when there is no error */</span></span><br><span class="line">    <span class="keyword">char</span> errstr[<span class="number">128</span>]; <span class="comment">/* String representation of error when applicable */</span></span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">int</span> flags;</span><br><span class="line">    <span class="keyword">char</span> *obuf; <span class="comment">/* Write buffer */</span></span><br><span class="line">    redisReader *reader; <span class="comment">/* Protocol reader */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> redisConnectionType connection_type;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> *<span class="title">timeout</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *host;</span><br><span class="line">        <span class="keyword">char</span> *source_addr;</span><br><span class="line">        <span class="keyword">int</span> port;</span><br><span class="line">    &#125; tcp;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">char</span> *path;</span><br><span class="line">    &#125; unix_sock;</span><br><span class="line"></span><br><span class="line">&#125; redisContext;</span><br></pre></td></tr></table></figure></p><p>可以看到结构体中包含了一些必要的字段。<br>obuf保存的是格式化后的Redis协议字符串，我们可以把这个字段打出来，可以理解Redis协议。<br>后边介绍到具体接口再来看这个结构体。</p><h2 id="回复结构体redisReply"><a href="#回复结构体redisReply" class="headerlink" title="回复结构体redisReply"></a>回复结构体redisReply</h2><p>结构定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* This is the reply object returned by redisCommand() */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> type; <span class="comment">/* REDIS_REPLY_* */</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> integer; <span class="comment">/* The integer when type is REDIS_REPLY_INTEGER */</span></span><br><span class="line">    <span class="keyword">size_t</span> len; <span class="comment">/* Length of string */</span></span><br><span class="line">    <span class="keyword">char</span> *str; <span class="comment">/* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */</span></span><br><span class="line">    <span class="keyword">size_t</span> elements; <span class="comment">/* number of elements, for REDIS_REPLY_ARRAY */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">redisReply</span> **<span class="title">element</span>;</span> <span class="comment">/* elements vector for REDIS_REPLY_ARRAY */</span></span><br><span class="line">&#125; redisReply;</span><br></pre></td></tr></table></figure></p><p>从结构体定义可以看出，它可以表示不同类型的消息。<br>最常用的包括：字符串，数组，整数。具体的在后边介绍。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上两个结构体可以帮助我们理解hiredis库的内部实现，我们总会遇到库的一些坑。只有理解库的实现，才能够避免踩到这些坑。</p><h1 id="同步接口"><a href="#同步接口" class="headerlink" title="同步接口"></a>同步接口</h1><p>hiredis提供了如下三个同步API：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">redisContext *<span class="title">redisConnect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">redisCommand</span><span class="params">(redisContext *c, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeReplyObject</span><span class="params">(<span class="keyword">void</span> *reply)</span></span>;</span><br></pre></td></tr></table></figure></p><p>可以看出使用同步接口分为三个步骤，创建连接，发送Redis命令，得到结果后释放回复类。</p><h2 id="连接Redis"><a href="#连接Redis" class="headerlink" title="连接Redis"></a>连接Redis</h2><p>redisConnect函数使用之前提到的redisContext来保存连接的状态。<br>结构体redisContext的成员err非零表示连接出错，errstr保存具体的错误信息。<br>调用redisConnect函数后，应该检查err来确认连接是否真的建立。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">redisContext *<span class="built_in">c</span> = redisConnect(<span class="string">"127.0.0.1"</span>, <span class="number">6379</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">c</span> == <span class="type">NULL</span> || <span class="built_in">c</span>-&gt;err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">c</span>) &#123;</span><br><span class="line">        printf(<span class="string">"Error: %s\n"</span>, <span class="built_in">c</span>-&gt;errstr);</span><br><span class="line">        <span class="comment">// handle error</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        printf(<span class="string">"Can't allocate redis context\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>值得注意的是redisContext不是线程安全的。</p><h2 id="向Redis发送命令"><a href="#向Redis发送命令" class="headerlink" title="向Redis发送命令"></a>向Redis发送命令</h2><p>redisCommand是类printf的，可以向已经建立连接的Redis发送命令。</p><p>这个函数使用空格来区分Redis的参数。%s指明一个参数，该参数是一个\0结尾的字符串。如果想使用二进制安全的版本，则可以使用%b，其需要两个参数，一个字符指针，一个表明这个字符串长度的size_t参数。</p><p>值得注意的是%s表明一个Redis命令的参数，即使这个字符串中包含空格，回车等字符。仔细阅读hiredis的代码你就会发现这一点。</p><p>下面是一些例子：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">reply = redisCommand(<span class="keyword">context</span>, <span class="string">"SET foo bar"</span>);</span><br><span class="line">reply = redisCommand(<span class="keyword">context</span>, <span class="string">"SET foo %s"</span>, <span class="keyword">value</span>);</span><br><span class="line">reply = redisCommand(<span class="keyword">context</span>, <span class="string">"SET foo %b"</span>, <span class="keyword">value</span>, (size_t) valuelen);</span><br><span class="line">reply = redisCommand(<span class="keyword">context</span>, <span class="string">"SET key:%s %s"</span>, myid, <span class="keyword">value</span>);</span><br><span class="line"></span><br><span class="line">// 这个将会出错，因为<span class="meta">%s</span>被解释为一个参数，所以Redis收到的就是一个参数的命令‘SET foo bar’，这当然会出错</span><br><span class="line">reply = redisCommand(<span class="keyword">context</span>, <span class="string">"%s"</span>, <span class="string">"SET foo bar"</span>);</span><br></pre></td></tr></table></figure></p><h2 id="获得命令的回复"><a href="#获得命令的回复" class="headerlink" title="获得命令的回复"></a>获得命令的回复</h2><p>redisCommand返回值是一个redisReply的结构体，保存了命令的回复。<br>如果出错，则返回值为NULL并且redisContext的err字段设置为非0。<br>Once an error is returned the context cannot be reused and you should set up a new connection.</p><p>redisReply结构体中的type字段表明了返回的数据类型。<br>有如下几种枚举<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表明回复是一个状态，状态的具体信息在str和len中</span></span><br><span class="line">REDIS_REPLY_STATUS</span><br><span class="line"><span class="comment">// 表明回复是一个错误，错误信息在str和len中</span></span><br><span class="line"><span class="symbol">REDIS_REPLY_ERROR:</span></span><br><span class="line"><span class="comment">// 表明回复是一个整数，整数保存在interger中，其实long long类型</span></span><br><span class="line"><span class="symbol">REDIS_REPLY_INTEGER:</span></span><br><span class="line"><span class="comment">// 返回一个nil对象，表明没有数据</span></span><br><span class="line"><span class="symbol">REDIS_REPLY_NIL:</span></span><br><span class="line"><span class="comment">// 回复一个字符串，字符串在str和len中</span></span><br><span class="line"><span class="symbol">REDIS_REPLY_STRING:</span></span><br><span class="line"><span class="comment">// 表明回复是一个数组，保存在elements，element表明了数组的大小。可能回复是嵌套数组</span></span><br><span class="line"><span class="symbol">REDIS_REPLY_ARRAY:</span></span><br></pre></td></tr></table></figure></p><p>redisCommand获得的reply应该使用freeReplyObject函数释放内存。</p><p>Important: the current version of hiredis (0.10.0) frees replies when the asynchronous API is used. This means you should not call freeReplyObject when you use this API. The reply is cleaned up by hiredis after the callback returns. This behavior will probably change in future releases, so make sure to keep an eye on the changelog when upgrading (see issue #39).</p><h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p>使用完Redis后，使用redisFree来断开网络连接和释放对应的内存<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">redisFree</span><span class="params">(redisContext *c)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="变种的redisCommand"><a href="#变种的redisCommand" class="headerlink" title="变种的redisCommand"></a>变种的redisCommand</h2><p>由于redisCommand使用了可变参数技术，其就会有对应的va_list版本。<br>下边是这一系列参数的原型<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Write a command to the output buffer. Use these functions in blocking mode</span></span><br><span class="line"><span class="comment"> * to get a pipeline of commands. */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redisvAppendCommand</span><span class="params">(redisContext *c, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redisAppendCommand</span><span class="params">(redisContext *c, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">redisAppendCommandArgv</span><span class="params">(redisContext *c, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">size_t</span> *argvlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Issue a command to Redis. In a blocking context, it is identical to calling</span></span><br><span class="line"><span class="comment"> * redisAppendCommand, followed by redisGetReply. The function will return</span></span><br><span class="line"><span class="comment"> * NULL if there was an error in performing the request, otherwise it will</span></span><br><span class="line"><span class="comment"> * return the reply. In a non-blocking context, it is identical to calling</span></span><br><span class="line"><span class="comment"> * only redisAppendCommand and will always return NULL. */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">redisvCommand</span><span class="params">(redisContext *c, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">redisCommand</span><span class="params">(redisContext *c, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">redisCommandArgv</span><span class="params">(redisContext *c, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">size_t</span> *argvlen)</span></span>;</span><br></pre></td></tr></table></figure></p><p>我们暂时忽略redisAppendCommand这一系列函数，我们在讲到流水线操作时会讲解它们。</p><p>可以看到这些函数与我们使用的其他可变参数函数没有什么区别。</p><p>另外一个需要介绍的函数是redisCommandArgv。<br>它不再使用类printf的方法来指定参数，而使用argc和argv来指明参数。另外argvlen参数还给该函数提供了使用二进制字符串的方法。如果argvlen是NULL，那么该函数将使用strlen来确定每个参数的长度。再该函数中Redis命令总是第一个参数。</p><h2 id="流水线操作"><a href="#流水线操作" class="headerlink" title="流水线操作"></a>流水线操作</h2><p>我们下边解释hiredis的内部执行流程来理解为什么可以在同步的API中实现流水线操作。</p><p>当我们调用redisCommand等函数时，hiredis首先讲这些命令转化成Redis的协议。然后将转化后的命令写入输出缓冲区中，写入完成后，调用redisGetReply来获取命令的结果。该函数的流程如下：</p><ol><li>输入缓冲区非空，尝试解析单个回复并返回。如果不能解析则进行2</li><li>输入缓冲区是空，将输出缓冲区的所有内容发送到Redis，然后从socket读取单个回复并返回</li></ol><p>为了实现流水线操作，第一步就是使用redisAppendCommand或redisAppendCommandArgv填充输出缓冲区，函数原型参见上小结。</p><p>第二步我们需要调用redisGetReply，当然我们可以调用redisGetReply多次来获取多个命令的回复。我们需要判断redisGetReply的返回值来确定是否调用成功。成功返回REDIS_OK，失败返回REDIS_ERR。</p><p>下面是一个简单的例子：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">redisReply *reply<span class="comment">;</span></span><br><span class="line">redisAppendCommand(<span class="name">context</span>,<span class="string">"SET foo bar"</span>)<span class="comment">;</span></span><br><span class="line">redisAppendCommand(<span class="name">context</span>,<span class="string">"GET foo"</span>)<span class="comment">;</span></span><br><span class="line">redisGetReply(<span class="name">context</span>,<span class="symbol">&amp;reply</span>)<span class="comment">; // reply for SET</span></span><br><span class="line">freeReplyObject(<span class="name">reply</span>)<span class="comment">;</span></span><br><span class="line">redisGetReply(<span class="name">context</span>,<span class="symbol">&amp;reply</span>)<span class="comment">; // reply for GET</span></span><br><span class="line">freeReplyObject(<span class="name">reply</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h2 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h2><p>当函数返回NULL或REDIS_ERR的时候，redisContext的err字段将会设置成如下枚举：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">REDIS_ERR_IO: There was an I/O <span class="builtin-name">error</span> <span class="keyword">while</span> creating the connection, trying <span class="keyword">to</span> write <span class="keyword">to</span> the socket <span class="keyword">or</span> read <span class="keyword">from</span> the socket. <span class="keyword">If</span> you included errno.h <span class="keyword">in</span> your application, you can use the global errno variable <span class="keyword">to</span> <span class="builtin-name">find</span> out what is wrong.</span><br><span class="line"></span><br><span class="line">REDIS_ERR_EOF: The<span class="built_in"> server </span>closed the<span class="built_in"> connection </span>which resulted <span class="keyword">in</span> an empty read.</span><br><span class="line"></span><br><span class="line">REDIS_ERR_PROTOCOL: There was an <span class="builtin-name">error</span> <span class="keyword">while</span> parsing the protocol.</span><br><span class="line"></span><br><span class="line">REDIS_ERR_OTHER: Any other error. Currently, it is only used when a specified hostname <span class="keyword">to</span> connect <span class="keyword">to</span> cannot be resolved.</span><br></pre></td></tr></table></figure></p><p>redisContext的errstr字段将会指明具体的错误信息。</p><h1 id="异步API"><a href="#异步API" class="headerlink" title="异步API"></a>异步API</h1><p>TODO</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;近期开发的项目使用到了Redis，本文主要记录下使用Redis API遇到的一些问题。&lt;br&gt;如果想了解Redis相关的细节，可以看&lt;a href=&quot;http://redisbook.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《Redis设计与实现》&lt;/a&gt;。&lt;br&gt;想了解Redis相关的命令，可以参考&lt;a href=&quot;http://redisdoc.com/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis命令参考&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;hiredis简介&quot;&gt;&lt;a href=&quot;#hiredis简介&quot; class=&quot;headerlink&quot; title=&quot;hiredis简介&quot;&gt;&lt;/a&gt;hiredis简介&lt;/h1&gt;&lt;p&gt;hiredis是&lt;a href=&quot;https://redis.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Redis&lt;/a&gt;的一个极简c客户端库。&lt;br&gt;它实现了Redis协议的最小集，但同时也提供类printf的API，使用既方便有简介。&lt;br&gt;hiredis提供了多种API，它同时支持同步，异步和回复解析API。在此基础上，能够实现Redis的流水线操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Redis" scheme="https://blog.gwq5210.com/tags/Redis/"/>
    
      <category term="hiredis" scheme="https://blog.gwq5210.com/tags/hiredis/"/>
    
      <category term="Redis API" scheme="https://blog.gwq5210.com/tags/Redis-API/"/>
    
  </entry>
  
  <entry>
    <title>Cpp-Primer-Plus读书笔记（三）</title>
    <link href="https://blog.gwq5210.com/2017/08/02/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>https://blog.gwq5210.com/2017/08/02/Cpp-Primer-Plus读书笔记（三）/</id>
    <published>2017-08-02T22:25:37.000Z</published>
    <updated>2021-09-13T08:00:57.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="对象和类"><a href="#对象和类" class="headerlink" title="对象和类"></a>对象和类</h1><p>面向对象编程是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，下边是最重要的OOP特性：</p><ul><li>抽象</li><li>封装和数据隐藏</li><li>多态</li><li>继承</li><li>代码的可重用性</li></ul><p>采用OOP方法时，首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。</p><a id="more"></a><h2 id="抽象和类"><a href="#抽象和类" class="headerlink" title="抽象和类"></a>抽象和类</h2><p>对于基本类型，编译器需要维护如下内容：</p><ul><li>决定数据对象需要的内存数量</li><li>决定如何解释内存中的位</li><li>决定可使用数据对象执行的操作或方法</li></ul><p>对于C++中自定义的类，我们需要自己提供这些信息。</p><p>类中可以声明public和private及protected的成员。类设计尽可能的将公有接口与实现细节分开。公有接口表示设计的抽象组件，将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现的细节隐藏在私有部分中，也是封装，封装的另一个例子是将类定义和类声明放在不同的文件中。</p><p>数据隐藏可以防止直接访问数据，还让开发者无需了解数据是如何被表示的。这样，只要接口不变，我们就可以对程序的细节进行修改。</p><p>数据项一般来说是私有对象，接口成员一般放在公共部分。对于实现的细节相关的函数，我们可以作为私有成员函数。对于类来说，成员默认是私有的。一般我们显式的指出private。</p><p>C++对于C的结构进行了扩充，与类的功能类似，唯一的区别是结构的默认访问方式是公有的。</p><p>对于类成员函数的定义，与普通函数有两点不同：</p><ul><li>定义成员函数时，使用作用域解析运算符来标识函数所属的类</li><li>类方法可以访问类的private组件</li></ul><p>对于类中的函数或成员，我们说这些标识符具有类作用域。</p><p>定义位于类声明中的函数都将自动成为内联函数。除此之外还可以在类函数声明中使用inline。</p><p>内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用。最简便的方法是：将内联定义放在定义类的头文件中。顺便说一句，根据改写规则，在类声明中定义方法，等同于用原型替换方法定义，然后在类声明的后边将定义改写为内联函数。</p><p>调用成员函数时，它将使用被用来调用它的对象的数据成员。</p><p>所创建的每个新对象都有自己的存储空间，用于存储其他内部变量和类成员。但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。</p><p>指定类设计的第一步是提供类声明。类声明类似结构声明，可以包含数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问，通常数据成员函数被放在私有部分中。</p><p>第二步是实现类成员函数。</p><h2 id="类的构造函数和析构函数"><a href="#类的构造函数和析构函数" class="headerlink" title="类的构造函数和析构函数"></a>类的构造函数和析构函数</h2><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>构造函数没有声明类型，其名字和类的名字一样。<br>有两种方式使用构造函数，显式和隐式的调用，如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Student s = Student(<span class="string">"name"</span>)<span class="comment">;</span></span><br><span class="line">Student <span class="literal">t</span>(<span class="string">"name"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>每次创建类对象，C++都使用构造函数。构造函数的使用不同于其他方法。</p><p>默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，C++将提供默认构造函数，它是默认构造函数的显式版本，不做任何工作。我们可以通过显式的方式重载一个构造函数。</p><h3 id="析构函数"><a href="#析构函数" class="headerlink" title="析构函数"></a>析构函数</h3><p>对象过期时，程序将自动调用一个特殊的成员函数——析构函数。析构函数完成清理工作。析构函数的名字是在类名前面加上~。析构函数没有参数。如果没有提供析构函数，编译器将隐式的声明一个默认析构函数。</p><p>C++11的列表初始化可以用来初始化类。</p><p>有一种成员函数叫做const成员函数，这种函数不会修改调用对象，我们将const关键字放在函数括号的后边来实现这种函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只要类方法不修改调用对象，就应将其声明为const</p><p>初始化对象有三种方式<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Student a</span> = Student(<span class="string">"name"</span>);</span><br><span class="line"><span class="attribute">Student b</span> = Student(<span class="string">"name"</span>);</span><br><span class="line"><span class="attribute">Student c</span> = <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure></p><p>接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值。这种特性可能会导致问题，我们可以关闭这种特性。</p><h2 id="this指针"><a href="#this指针" class="headerlink" title="this指针"></a>this指针</h2><p>每个成员函数都包含一个this指针。this指针指向用来调用成员函数的对象，其作为隐藏参数传递给方法。const成员方法中的this不能用来修改调用对象的值。</p><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><p>我们可以声明一个对象数组。并对其进行初始化，如果不进行初始化，则使用默认构造函数进行初始化。还可以使用初始化列表对对象数组进行初始化。</p><p>初始化对象数组的方案是首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中，这就说明要想创建对象数组，这个对象必须有默认构造函数。</p><h2 id="类作用域"><a href="#类作用域" class="headerlink" title="类作用域"></a>类作用域</h2><p>类作用域是c++特有的。其不同于全局作用域和局部作用域。在类中定义的名称的作用域都为类，作用域为整个类的名称只在类中是已知的，在类外不可知。不能从外部直接访问类的成员(必须通过类对象)。</p><p>使用类成员名时，必须根据上下文使用直接成员运算符(.)，间接成员运算符(-&gt;)或作用域解析运算符。</p><h3 id="作用域为类的常量"><a href="#作用域为类的常量" class="headerlink" title="作用域为类的常量"></a>作用域为类的常量</h3><p>有两种方式，一种是在类内声明一个枚举。在类声明中声明的枚举的作用域为整个类，可以用枚举为整型常量提供作用域为整个类的符号名称。这种方式声明枚举并不会创建类数据成员。这种方式不比创建枚举类型的变量，因此不需要提供枚举名。</p><p>另一种方式是使用static关键字。这创建一个常量，其与其他静态变量存储在一起，而不是存储在对象中。如果不是const的方式，需要在类外进行初始化。在C++ 98中只能使用这种技术声明值为整数或枚举的静态常量，而不能存储double常量，C++ 11取消了这种限制。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> num = <span class="number">12</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="作用域内枚举-C-11"><a href="#作用域内枚举-C-11" class="headerlink" title="作用域内枚举(C++ 11)"></a>作用域内枚举(C++ 11)</h3><p>传统枚举可能会存在名称冲突，C++提供的新枚举，其枚举量的作用域为类。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">egg</span> &#123;<span class="title">Small</span>, <span class="title">Large</span>&#125;;</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span> <span class="title">t_shirt</span> &#123;<span class="title">Small</span>, <span class="title">Large</span>&#125;;</span></span><br></pre></td></tr></table></figure></p><p>其中class可以替换为struct。使用时需要使用枚举名限定枚举量。如egg::Small。</p><p>C++ 11还提高了作用域内枚举的类型安全。在有些情况下常规枚举自动转换为整型，如将其赋值给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型。但可以进行显式转换。</p><p>枚举用某种底层整型类型表示，在C++ 98中如何选择取决于实现，其长度可能因系统而异。对于作用域内枚举，C++ 11消除了这种依赖性，默认情况下，C++ 11作用域内枚举的底层类型为int，另外，还提供了一种语法，可用于做出不同选择：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">class</span>: <span class="title">short</span> <span class="title">pizza</span> &#123;<span class="title">Small</span>, <span class="title">Large</span>&#125;;</span></span><br></pre></td></tr></table></figure></p><p>其底层类型为short。底层类型必须为整形。在C++ 11中也可以使用这种语法来指定常规枚举的底层类型，如果没有指定，编译器选择的底层类型将随实现而异。</p><h2 id="抽象数据类型"><a href="#抽象数据类型" class="headerlink" title="抽象数据类型"></a>抽象数据类型</h2><p>ADT(abstract data type)以通用的方式描述数据类型，而没有引入语言或实现细节。类的概念非常适用于ADT方法。私有部分隐藏实现的细节，共有的方法提供相应的接口。</p><h1 id="使用类"><a href="#使用类" class="headerlink" title="使用类"></a>使用类</h1><p>学习C++的难点之一是需要记住大量的东西，但在拥有丰富的时间经验之前，根本不可能全部记住这些东西。“轻松的使用这种语言，不要觉得必须使用所用特性，不要在第一次学习时就试图使用所有特性”。</p><h2 id="运算符重载"><a href="#运算符重载" class="headerlink" title="运算符重载"></a>运算符重载</h2><p>运算符重载是一种形式的C++多态。函数重载是使用同名的函数来完成相同的基本操作。同样C++允许运算符有用多种不同的含义。C++(C)很多运算符已经被重载。</p><p>重载运算符op的格式如下<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">operatorop</span><span class="params">(argument-list)</span></span></span><br></pre></td></tr></table></figure></p><p>op必须是有效的C++运算符。编译器使用重载的运算符op时使用这种格式obj1.operatorop(obj2)</p><p>不要返回局部变量或临时变量的引用，函数执行完毕后，局部变量或临时引用将会消失</p><p>我们可以首先定义一个sum函数，然后将sum换成operator+就可以重载+运算符，其他运算符同理<br>有两种形式可以使用重载运算符<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sum</span> = a.operator+(b)<span class="comment">;</span></span><br><span class="line"><span class="attr">sum</span> = a + b</span><br></pre></td></tr></table></figure></p><p>可以使用重载运算符对多个操作数进行相加</p><h3 id="重载限制"><a href="#重载限制" class="headerlink" title="重载限制"></a>重载限制</h3><ol><li>重载后的运算符必须至少有一个是用户定义的类型，这防止用户为标准类型重载运算符</li><li>使用运算符时不能违反运算符原来的句法规则，不能修改运算符的优先级</li><li>不能创建新的运算符</li><li>不能重载一些运算符，sizeof，.成员运算符，.*成员指针运算符，::作用域解析运算符，typeid一个RTTI运算符，const_cast，dynamic_cast，reinterpret_cast，static_cast强制类型转换运算符</li><li>大多数运算符都可以通过成员或非成员函数进行重载，下边的运算符只能通过成员函数进行重载，=赋值运算符，()函数调用运算符，[]下标运算符，-&gt;通过指针访问类成员运算符</li></ol><h2 id="友元"><a href="#友元" class="headerlink" title="友元"></a>友元</h2><p>C++提供了另外一种形式的访问权限友元。分为三种友元函数，友元类，友元成员函数，通过让函数称为类的友元，可以赋予该函数与类成员函数相同的权限。</p><p>在重载二元运算符时，常常需要友元。对于重载了+的类来说，a+1和1+a是一样的。但我们无法将1+a转换为1.operator+(a)的形式。<br>这时候我们需要使用非成员函数来重载运算符，这种运算符的参数都是显式参数。这样就可以把1+a转换为operator+(1, a)。非成员函数不能访问a对象的私有成员，这时候就需要使用友元函数了。</p><p>创建友元的第一步是将函数原型放在类声明中，并在函数原型声明前加上关键字friend。<br>它说明虽然其实在函数中声明的，但它不是成员函数，因此不能使用成员运算符来调用<br>虽然它不是成员函数，但是它与成员函数的访问权限相同<br>不要在函数定义中使用关键字friend</p><p>友元和类方法都是表达类接口的两种不同机制。友元必须在类声明中出现，所以类声明仍然控制着哪些函数可以访问私有数据。</p><p>如果要为类重载运算符，并将非类的项作为第一个操作数，则可以用友元函数来反转操作数的顺序。</p><p>常用的友元是重载&lt;&lt;运算符，重载后可以将其与cout结合输出对象的内容。通用格式<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> c_name &amp;obj)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; ...;</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>只有在类声明中的原型中才能使用friend关键字，除非函数定义也是原型，否则不能在函数定义中使用该关键字</p><h2 id="重载运算符：作为成员函数还是非成员函数"><a href="#重载运算符：作为成员函数还是非成员函数" class="headerlink" title="重载运算符：作为成员函数还是非成员函数"></a>重载运算符：作为成员函数还是非成员函数</h2><p>非成员函数版本的重载运算符函数所需要的形参数目与运算符使用的操作数数目相同，成员函数版本的参数少一个，因为其中一个操作数是被隐式的传递的调用对象。</p><p>定义运算符时，必须选择其中的一种格式，不能同时选用这两种格式。某些情况下成员函数是唯一的选择，其他情况下，这两种方式没有太大区别。有时使用友元的版本更好一点。</p><p>运算符重载是通过函数实现的，所以只要运算符函数的特征标不同，使用的运算符数量与相应的内置C++运算符相同，就可以多次重载同一个运算符</p><h2 id="类的自动转换和强制类型转换"><a href="#类的自动转换和强制类型转换" class="headerlink" title="类的自动转换和强制类型转换"></a>类的自动转换和强制类型转换</h2><p>将一个标准的类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。但不进行转换不兼容的类型</p><p>可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的。这种情况下，程序员可以指示C++如何自动进行转换，或通过强制类型转换来完成。</p><p>在C++中接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。这种转换是自动进行的，而不需要显式强制类型转换。只有接受一个参数的构造函数才能作为转换函数（其他参数可以是默认值）。<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Student c</span> = <span class="string">"name"</span>;</span><br></pre></td></tr></table></figure></p><p>我们也提供了explicit关键字用于关闭这种自动特性。但仍然允许显式转换。<br>隐式转换在下列情况下出现</p><ul><li>将对象初始化为构造函数参数类型时</li><li>将构造函数参数类型赋值给对象时</li><li>将构造函数类型传递给接受对象参数的函数时</li><li>返回值被声明为对象的函数试图返回构造函数参数类型时</li><li>在上述任意情况下，使用可自动转换为double类型的内置类型时</li></ul><p>最后一点当且仅当不存在二义性时，才会进行这种转换</p><p>转换函数可以将用户定义的类型转换成某种类型，这是用户定义的强制类型转换，可以像使用强制类型转换一样使用它们。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">typeName</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></p><p>转换函数必须是类方法<br>转换函数不能指定返回类型<br>转换函数不能有参数</p><p>如果存在二义性转换，编译器不会进行自动转换。但我们可以通过强制类型转换来指出需要使用哪个转换函数<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> gone = (<span class="keyword">double</span>)a;</span><br><span class="line"><span class="keyword">long</span> gone = <span class="keyword">double</span>(a);</span><br></pre></td></tr></table></figure></p><p>在C++98中，explicit关键字不能用于转换函数，C++11消除了这种限制，在C++11中可以将转换函数声明为显式的<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></p><p>这样就必须使用强制类型转换来使用。另一种方式是定义一个功能相同的非转换函数替代，其必须被显式的调用。</p><p>C++提供了如下类型转换</p><ul><li>只有一个参数的构造函数用于将类型与该参数相同的值转换为类类型，使用explicit可以防止隐式转换，只能使用显式转换</li><li>被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。</li></ul><p>实现加法的选择，可以使用友元+一个参数的构造函数，或者将加法运算符进行重载，它们各有优点，前者程序简短，但依赖隐式转换，出错少，但调用时间和效率不高，后者正好相反。具体要看使用场景</p><p>经验表明，最好不要依赖这种隐式转换函数。</p><h1 id="类和动态内存分配"><a href="#类和动态内存分配" class="headerlink" title="类和动态内存分配"></a>类和动态内存分配</h1><p>C++使用new和delete运算符来动态控制内存，但在类中使用这些运算符将导致许多新的编程问题，这种情况下，析构函数将是必不可少的，有时候还必须重载赋值运算符，保证程序的正确性。</p><p>静态类成员只创建一个静态类变量副本。不能在类声明中初始化静态成员变量，静态类成员可以在类声明外用单独的语句进行初始化，初始化语句中指出了类型，并使用了作用域运算符，但没有使用关键字static。初始化不能放在头文件中。静态数据成员为整型或枚举型const可以在类声明中初始化。</p><p>在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存，如果使用new[]来分配内存，则应使用delete[]来释放内存。</p><p>具体来说，C++自动提供了下面这些成员函数</p><ul><li>默认构造函数，如果没有定义构造函数</li><li>默认析构函数，如果没有定义</li><li>复制构造函数，如果没有定义</li><li>赋值运算符，如果没有定义</li><li>地址运算符，如果没有定义，返回this的值</li></ul><p>C++11还提供了另外两个特殊成员函数：移动构造函数(move constructor)和移动赋值运算符(move assignment operator)</p><p>带有参数的构造函数也可以是默认构造函数，只要所有参数都有默认值</p><h2 id="复制构造函数"><a href="#复制构造函数" class="headerlink" title="复制构造函数"></a>复制构造函数</h2><p>复制构造函数用于将一个对象复制到新创建的对象中，它用于初始化过程中，包括按值传递参数，而不是常规的赋值过程，其原型如下<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_name(<span class="name">const</span> class_name <span class="symbol">&amp;c</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>需要知道何时调用和有何功能</p><h3 id="何时调用复制构造函数"><a href="#何时调用复制构造函数" class="headerlink" title="何时调用复制构造函数"></a>何时调用复制构造函数</h3><p>新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> a;</span><br><span class="line"><span class="keyword">string</span> <span class="built_in">s</span>(a);</span><br><span class="line"><span class="keyword">string</span> s = a;</span><br><span class="line"><span class="keyword">string</span> s = <span class="keyword">string</span>(a);</span><br><span class="line"><span class="keyword">string</span> s = <span class="keyword">new</span> <span class="keyword">string</span>(a);</span><br></pre></td></tr></table></figure></p><p>中间的两种声明可能会使用复制构造函数直接创建对象，也可能使用复制构造函数生成一个临时对象，然后将临时对象内容赋给变量，这取决于具体实现。</p><p>每当程序生成了对象副本时，编译器都将使用复制构造函数。例如函数按值传递对象，函数返回对象，生成临时对象（如将对象相加）时。</p><p>按引用传递可以节约时间和存储空间。</p><h3 id="默认的复制构造函数的功能"><a href="#默认的复制构造函数的功能" class="headerlink" title="默认的复制构造函数的功能"></a>默认的复制构造函数的功能</h3><p>默认的复制构造函数逐个复制非静态成员(成员复制也叫浅复制)，复制的是成员的值。如果成员本身就是类对象，则使用这个类的复制复制函数来复制成员对象。静态函数不受影响，因为它们属于整个类，而不是各个对象。</p><p>如果类中包含这样的静态数据成员，即其值将在新对象创建时发生变化，则应该提供一个显式复制构造函数来处理计数问题。</p><p>处理类遇到常用的问题就是进行深度复制(deep copy)。应该复制内容（new初始化的，指向数据的指针）而不是地址。</p><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><p>赋值运算符的原型如下<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class_name &amp;class_name::<span class="keyword">operator</span>=(<span class="keyword">const</span> class_name &amp;c);</span><br></pre></td></tr></table></figure></p><p>它接受并返回一个指向类对象的引用。</p><h3 id="赋值运算符的功能以及何时使用它"><a href="#赋值运算符的功能以及何时使用它" class="headerlink" title="赋值运算符的功能以及何时使用它"></a>赋值运算符的功能以及何时使用它</h3><p>将已有的对象赋值给另一个对象时，将使用赋值运算符，初始化对象时不一定会使用赋值运算符。<br>与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。</p><h3 id="解决赋值运算符的问题"><a href="#解决赋值运算符的问题" class="headerlink" title="解决赋值运算符的问题"></a>解决赋值运算符的问题</h3><p>仍然是提供赋值运算符的定义，进行深度复制，需要注意的是</p><ul><li>由于目标对象可能引用了以前分配的数据，所以可能需要释放之前的内存</li><li>函数应该避免将对象赋给自身，需要进行特别判定</li><li>函数返回一个指向调用对象的引用</li></ul><p>C++空指针，在C++98中，字面值0有两个含义：可以表示数字值零，也可以表示空指针。C语言用NULL表示空指针，C++11提供了关键字nullptr，表示空指针。但仍保留了使用0的方式</p><p>对于操作符[]，有两个操作数。重载[]时，C++将区分常量和非常量函数的特征标。后者就可以读const对象了<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> &amp;opeartor[](<span class="keyword">int</span> idx);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> &amp;<span class="keyword">operator</span>[](<span class="keyword">int</span> idx) <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure></p><h2 id="静态类成员函数"><a href="#静态类成员函数" class="headerlink" title="静态类成员函数"></a>静态类成员函数</h2><p>不能通过对象调用静态成员函数；静态成员函数不能使用this指针，可以通过类名和作用域解析运算符来调用它。<br>静态类成员函数只能使用静态数据成员。</p><h2 id="在构造函数中使用new时应注意的事项"><a href="#在构造函数中使用new时应注意的事项" class="headerlink" title="在构造函数中使用new时应注意的事项"></a>在构造函数中使用new时应注意的事项</h2><ul><li>如果在构造函数中使用new([])来初始化指针成员，则应该在析构函数中使用delete([])</li><li>应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象</li><li>应定义一个赋值运算符，通过深度复制想一个对象复制给另一个对象</li></ul><h2 id="返回对象的说明"><a href="#返回对象的说明" class="headerlink" title="返回对象的说明"></a>返回对象的说明</h2><ul><li>返回指向const对象的引用</li><li>返回指向非const对象的引用</li><li>返回对象</li><li>返回const对象，使用+运算符的时，否则可能出现a+b=c情况</li></ul><h2 id="使用指向对象的指针"><a href="#使用指向对象的指针" class="headerlink" title="使用指向对象的指针"></a>使用指向对象的指针</h2><p>析构函数的调用</p><ul><li>如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数</li><li>如果对象是静态变量(外部，静态，静态外部或来自名称空间)，则在该程序结束时将调用该对象的析构函数</li><li>如果对象是new创建的，则仅当您显式的使用delete删除对象时，其析构函数才会被调用</li></ul><h3 id="定位new运算符"><a href="#定位new运算符" class="headerlink" title="定位new运算符"></a>定位new运算符</h3><p>delete不能与定位new运算符配合使用，因此在使用定位new运算符时，不能使用delete来删除对象，进而调用析构函数。解决方案是显式的为定位new运算符创建的对象调用析构函数。需要注意的一点是正确的删除顺序，对于使用定位new运算符创建的对象，应以创建顺序相反的顺序进行删除，原因在于晚创建的对象可能依赖于早创建的对象，另外，仅当所有对象被销魂后，才能释放用于存储这些对象的缓冲区。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>我们可以在类中嵌套结构或类声明。其作用域为整个类。公共的定义还可以通过类名和作用域解析运算符来使用。</p><p>在类中初始化非静态const或引用对象时，我们需要使用成员初始化列表(member initializer list)，只有构造函数可以使用这种方式。对于本身就是类对象的成员来说，使用初始化列表效率更高。初始化的顺序与他们在类声明中出现的顺序相同，与初始化列表中的排列顺序无关。</p><p>C++11可以使用类内初始化初始化非静态const成员，在类中可以使用这样的语句int a = 10;在构造函数中的成员初始化列表会覆盖其值。</p><h1 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h1><p>C++提供了类继承，能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。<br>通过继承可以在已有类的基础上添加功能。可以给类添加数据。可以修改类方法的行为。</p><p>派生类对象将包含基类对象，使用共有派生，基类的共有成员将成为派生类的共有成员，基类的私有部分也将成为派生类的一部分，但只能通过基类的共有或保护方法访问。<br>派生类需要自己的构造函数，派生类可以根据需要添加额外的数据成员和成员函数。</p><p>派生类构造函数必须使用基类构造函数，创建派生类对象时，程序首先创建基类对象。基类对象应该在程序进入派生类构造函数之前被创建，在C++中成员初始化列表语法来完成这种工作。如果不调用基类构造函数将调用默认的基类构造函数，派生类构造函数应该初始化派生类新增的数据成员。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。</p><p>派生类对象可以使用基类的方法，条件是方法不是私有的。<br>基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是基类指针或引用只能调用基类方法。</p><p>有三种继承方式：共有继承，保护继承，私有继承。共有继承是一种is-a关系，派生类对象也是一个基类对象。其他需要区分的是has-a，is-like-a，is-implemented-as-a，uses-a关系。</p><h2 id="多态共有继承"><a href="#多态共有继承" class="headerlink" title="多态共有继承"></a>多态共有继承</h2><p>如果希望同一个方法在派生类和基类中的行为是不同的，方法的行为取决于调用该方法的对象，这种较复杂的行为称为多态——具有多种形态，即同一个方法的行为随上下文而异。可以通过两种重要的机制用于实现多态共有继承。在派生类中重新定义基类的方法或使用虚方法。</p><p>如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，这样程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。</p><p>为何需要虚析构函数。如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。因此使用虚析构函数可以保证正确的析构函数序列被调用。</p><h2 id="静态联编和动态联编"><a href="#静态联编和动态联编" class="headerlink" title="静态联编和动态联编"></a>静态联编和动态联编</h2><p>将源代码中的函数调用解释为执行特定函数代码块被称为函数名联编(binding)。C或C++编译器可以在编译过程完成这种联编。在编译过程中进行联编称为静态联编(static binding)。然而虚函数必须使用动态联编(dynamic binding)，必须生成能够在程序运行过程中选择正确虚函数方法的代码。</p><p>将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，这使得共有继承不需要进行显式类型转换。相反的过程，将基类指针或引用转换为派生类指针或引用称为向下强制转换(downcasting)。</p><h3 id="为什么有两种类型的联编以及为什么默认为静态联编"><a href="#为什么有两种类型的联编以及为什么默认为静态联编" class="headerlink" title="为什么有两种类型的联编以及为什么默认为静态联编"></a>为什么有两种类型的联编以及为什么默认为静态联编</h3><p>我们需要考虑效率和概念模型。<br>为了能使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的开销。如果不需要重新定义方法，则使用静态联编更合理。因为其效率更高，因此被设置为C++的默认选择。一个原则是不要为不使用的特性付出代价(内存或处理时间)。仅当程序设计确实需要使用虚函数时，才使用他们。</p><p>另外在类设计时，可能包含一些不在派生类中重新定义的成员函数，不设置该函数为虚函数效率更高，另外也指出不要重新定义该函数。这表明仅将那些预期将被重新定义的方法声明为虚的。</p><h3 id="虚函数的工作原理"><a href="#虚函数的工作原理" class="headerlink" title="虚函数的工作原理"></a>虚函数的工作原理</h3><p>通常编译器处理虚函数的方法是给每个对象添加一个隐藏成员。隐藏成员保存了一个指向函数地址数组的指针，这种数组被称为(虚函数表，virtual function table，vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数地址也将被添加到vtbl中。<br>其成本包括</p><ul><li>每个对象都将增大，增大为存储地址的空间</li><li>对于每个类，编译器都创建一个虚函数地址表(数组)</li><li>对于每个函数调用，都要执行一项额外的操作，即到表中查找地址</li></ul><h3 id="虚函数的要点"><a href="#虚函数的要点" class="headerlink" title="虚函数的要点"></a>虚函数的要点</h3><ul><li>在基方法的生命中使用关键字virtual可使该方法在基类以及在所有的派生类(包括从派生类派生出来的类)中是虚的</li><li>如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象</li><li>如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的</li></ul><p>构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后派生类的构造函数将使用基类的一个构造函数，这不同于继承。</p><p>析构函数应当是虚函数，除非类不用作基类。</p><p>友元不能是虚函数，因为友元不是成员函数</p><p>如果派生类没有重新定义函数，则将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。</p><p>重新定义将隐藏方法<br>重新定义继承的方法并不是重载，如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。</p><p>如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用指针，则可以修改为指向派生类的引用或指针，这种特性被称为返回类型协变(covariance of return type)，因为允许返回类型随类类型的变化而变化。这种例外只适用于返回值，而不适用于参数。</p><p>如果基类声明重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则其他的版本将被隐藏。如果不需要修改，则新定义可只调用基类版本。</p><h2 id="访问控制：protected"><a href="#访问控制：protected" class="headerlink" title="访问控制：protected"></a>访问控制：protected</h2><p>关键字protected与private相似，在类外只能用共有类成员来访问protected部分中的类成员，private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员。因此，对于外部世界来说保护成员的行为与私有成员类似，但对于派生类来说，保护成员的行为与共有成员相似。</p><p>最好对类数据成员采用私有访问控制，不要使用保护访问控制，同时通过基类方法使派生类能够访问基类数据。对于成员函数来说，保护访问控制很有用，他让派生类能够访问公众不能使用的内部函数。</p><h2 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h2><p>抽象基类比较复杂(abstract base class)。C++通过使用纯虚函数(pure virtual function)提供未实现的函数。纯虚函数声明的结尾处为=0</p><p>当类声明中包含纯虚函数的时候，则不能创建类对象。这里的理念是，包含纯虚函数的类只用作基类。在原型中使用=0指出类是一个抽象基类，再类中可以不定义该函数。但也可以定义不过好像没什么作用。</p><p>可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则。</p><h2 id="继承和动态内存分配"><a href="#继承和动态内存分配" class="headerlink" title="继承和动态内存分配"></a>继承和动态内存分配</h2><p>在继承中使用动态内存分配需要注意一些情况。</p><h3 id="第一种情况：派生类不使用new"><a href="#第一种情况：派生类不使用new" class="headerlink" title="第一种情况：派生类不使用new"></a>第一种情况：派生类不使用new</h3><p>假设基类使用了动态内存分配，并且正确实现了析构函数，复制构造函数和重载赋值运算符。如果其派生类不使用动态内存分配，其是否需要显式的定义析构函数，复制构造函数，赋值运算符。答案是不用。</p><p>派生类的析构函数总要执行自身的代码后调用基类析构函数，因为派生类的析构函数不需要进行任何操作，所以不用显式提供析构函数。</p><p>默认复制构造函数执行成员复制，对于派生类来说没有问题。我们要考虑从基类继承过来的组件，复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以默认构造函数对于派生了也是合适的。赋值运算符也类似。</p><h3 id="第二种情况：派生类使用了new"><a href="#第二种情况：派生类使用了new" class="headerlink" title="第二种情况：派生类使用了new"></a>第二种情况：派生类使用了new</h3><p>派生类使用了动态内存分配，则必须为派生类定义显式析构函数，复制构造函数，赋值运算符。</p><p>派生类析构函数自动调用基类的析构函数，故其职责是对派生类构造函数执行工作的进行清理，因此派生类的析构函数需要释放派生类分配的内存。复制构造函数需要深度复制派生类的动态内存分配部分，同时也要调用基类的复制构造函数，方法是使用成员初始化列表调用基类的复制构造函数。基类引用可以指向派生类对象。</p><p>赋值运算符需要处理派生类的动态内存分配，同时也需要调用基类的赋值运算符，我们必须显式调用基类的赋值运算符，BaseClass::operator=(c)。必须使用这种函数表示法，否则可能会造成递归调用。</p><p>友元函数并非类成员，因此不能继承，然而，您可能希望派生类的友元函数能够使用基类的友元函数，为此，可以通过强制类型转换，派生类引用或指针转换为基类的引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;对象和类&quot;&gt;&lt;a href=&quot;#对象和类&quot; class=&quot;headerlink&quot; title=&quot;对象和类&quot;&gt;&lt;/a&gt;对象和类&lt;/h1&gt;&lt;p&gt;面向对象编程是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，下边是最重要的OOP特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;抽象&lt;/li&gt;
&lt;li&gt;封装和数据隐藏&lt;/li&gt;
&lt;li&gt;多态&lt;/li&gt;
&lt;li&gt;继承&lt;/li&gt;
&lt;li&gt;代码的可重用性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;采用OOP方法时，首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://blog.gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记(一)</title>
    <link href="https://blog.gwq5210.com/2017/07/12/APUE%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <id>https://blog.gwq5210.com/2017/07/12/APUE笔记-一/</id>
    <published>2017-07-12T01:22:08.000Z</published>
    <updated>2021-09-13T08:00:57.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="UNIX基础知识"><a href="#UNIX基础知识" class="headerlink" title="UNIX基础知识"></a>UNIX基础知识</h1><p>所有的操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读文件、分配存储区以及获得当前时间等。</p><p>从严格意义上说，可以将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。从广义上说，操作系统包含了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。</p><p>我们通常将这种软件成为内核（kernel），因为它相对较小，而且位于环境的核心。</p><p>内核的接口称之为系统调用（system call）。公共函数库构建在系统调用接口之上，应用程序既可使用公共函数库，也可以使用系统调用。shell是一个特殊的应用程序， 为运行其他应用程序提供了一个接口。</p><p>系统的口令文件由7个以冒号分割的字段组成，依次是：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录以及shell程序。目前所有已知的系统已将加密口令移到另一个文件中。</p><p>shell是一个命令解释器，它读取用户输入，然后执行命令。</p><a id="more"></a><p>UNIX文件系统是目录和文件的一种层次结构，所有的目录或文件以根（root，/）为起点。</p><p>目录是一个包含目录项的文件。每个目录项都包含文件名和文件属性。目录中的各个名字称为文件名。斜线（分割路径）和空字符（标记路径名结尾）不能出现在文件名中。创建新目录会自动创建点和点点目录，分别表示当前目录和上一级目录。根目录中，点点和点相同。</p><p>以斜线开头的路径名成为绝对路径，否则称为相对路径。</p><p>每个进程都有工作目录（working directory），有时称其为当前工作目录（current working directory）。所有相对路径都从工作目录开始解释。登录时，工作目录设置为起始目录（home direcotry）。</p><p>文件描述符（file descriptor）通常是一个小的非负整数，内核用于标识一个特定进程正在访问的文件。</p><p>当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入，标准输出，标准错误。</p><p>函数open，write，read，lseek和close提供了不带缓冲的IO。标准IO函数为那些不带缓冲的函数提供了一个带缓冲的接口，我们无需担心如何选取最佳的缓冲区大小。</p><p>程序（program）是一个存储在磁盘上某个目录中的可执行文件。程序的执行实例被称为进程（process）。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，它是一个非负整数。</p><p>通常一个进程只有一个线程（thread）。但进程中可以有多个线程。一个进程内的所有线程共享同一地址空间，文件描述符，栈及进程相关属性。线程也使用线程ID标识。</p><p>UNIX系统函数出错时，函数通常返回一个负值， 而且整型变量errno通常被设置为具有特定信息的值。在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno。</p><p>使用errno需要注意，如果没有出错，其值不会被任何例程清除。因此仅当函数的返回值指明出错时，才检验其值。任何函数都不会将errno值设置为0。</p><p>errno定义的错误可以分为两类，致命的和非致命的。对于致命的错误无法进行恢复动作。对于非致命的错误，有时可以进行妥善的处理。与资源相关的非致命错误包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK，有时ENOMEM也是非致命错误。当EBUSY指明共享资源正在使用时，也可将它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性错误处理。</p><p>口令文件登录项中的用户ID是一个数值，用来标识各个不同的用户。用户ID为0的用户为根用户或超级用户。我们称超级用户的特权为超级用户特权。</p><p>组被用于将若干用户集合到一起，便于共享资源。我们用组ID来标识用户组。组文件为/etc/group，它将组ID映射为组名。</p><p>使用数值的用户ID和组ID是历史原因，它们更节省磁盘空间，在权限校验时，更加节省资源。</p><p>多数UNIX系统还允许用户属于另外一个组，我们称之为附属组（supplementary group）。</p><p>信号（signal）用来通知进程发生了某种情况。<br>对于信号，进程有三种方式处理：</p><ul><li>忽略信号</li><li>按照系统默认方式处理</li><li>提供一个函数，信号发生时调用该函数，这被称为捕捉该信号</li></ul><p>在进程中，我们可以调用kill函数向另一个进程发送信号，前提是我们必须是这个进程的所有者或者超级用户。</p><p>UNIX使用两种不同的时间值。一是日历时间，该值是自协调世界时（Coordinated Universal Time，UTC）1970年1月1日00:00:00这个特定时间以来所经历的秒数累计值。系统基本数据类型使用time_t保存这个时间。二是进程时间。也被称为CPU时间，用于度量进程使用的中央处理器资源。进程时间以时钟时间为单位。系统基本数据类型clock_t保存这种时间值。我们可以通过sysconf函数得到每秒的时钟滴答数。<br>UNIX为一个进程维护了三个进程时间：</p><ul><li>时钟时间，是进程运行的时间总量，其值与系统同时运行的进程数有关。</li><li>用户CPU时间，是执行用户指令所用的时间量。</li><li>系统CPU时间，是为该进程执行内核程序所经历的时间。</li></ul><p>我们可以简单的使用命令time获取程序的执行时间。</p><p>所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。系统还定义了通用库函数，这些函数可能会使用一个或多个系统调用，但是它们并不是内核的入口点。</p><p>从实现者的角度，系统调用和库函数之间有根本的区别，但从用户角度看，其区别并不重要。我们应该理解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。</p><p>应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。</p><h1 id="UNIX标准及实现"><a href="#UNIX标准及实现" class="headerlink" title="UNIX标准及实现"></a>UNIX标准及实现</h1><p>人们在UNIX环境编程和C程序设计语言的标准化方面做已经做了很多工作。</p><p>UNIX系统实现定了了很多幻数和常量。其中很多已经被硬编码到程序中，或用特定的技术确定。<br>以下两种类型的限制是必须的：</p><ul><li>编译时限制，可以在头文件中定义，程序在编译时可以包含这些头文件</li><li>运行时限制，要求程序调用一个函数获得限制值</li></ul><p>某些限制在给定的实现中是确定的，但在另一个实现中可能是变动的。为了解决这类问题，提供了如下三种限制：</p><ul><li>编译时限制(头文件)</li><li>与文件或目录无关的运行时限制(sysconf函数)</li><li>与文件或目录有关的运行时限制(pathconf或fpathconf函数)</li></ul><p>ISO C定义的所有编译时限制都在头文件<limits.h>中。这些限制在一个给定的系统中并不会改变。我们将会遇到的一个问题是系统是否提供带符号或无符号的字符值，可以通过其中定义的值确定。另一个ISO C的常量是FOPEN_MAX，这是具体实现保证可同时打开的标准IO流的最小个数，其在头文件<stdio.h>中定义，最小值是8。POSIX.1中的STREAM_MAX则应与其相同。头文件stdio.h中还定义了TMP_MAX，这是由tmpnam函数产生的唯一文件名的最大个数。在ISO C中虽然定义了常量FILENAME_MAX，但我们应该避免使用。POSIX.1提供了更好的代替常量NAME_MAX和PATH_MAX。</stdio.h></limits.h></p><p>POSIX可以分为7类：</p><ul><li>数值限制：LONG_BIT，SSIZE_MAX，WORD_BIT </li><li>最小值</li><li>最大值，_POSIX_CLOCKRES_MIN</li><li>运行时可以增加的值：CHARCLASS_NAME_MAX，COLL_WEIGHTS_MAX，LINE_MAX，NGROUPS_MAX，RE_DUP_MAX</li><li>运行时不变值</li><li>其他不变值</li><li>路径名可变值：FILESIZEBITS，LINK_MAX，MAX_CANON，MAX_INPUT,MAX_INPUT，NAME_MAX，PATH_MAX，PIPE_BUF，SYMLINK_MAX</li></ul><p>最小值是不变的，它们不随系统改变。它们指定了这些特征最具约束性的值。一个符合POSIX.1的实现应当至少提供这样的值。为了保证移植性，严格符合标准的应用程序不应要求更大的值</p><p>不过某些最小值在实际中太小了。</p><p>运行时限制可以通过下面3个函数获得：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br></pre></td></tr></table></figure></p><p>我们讨论这三个函数不同的返回值：</p><ul><li>如果name参数并不是一个合适的常量，这三个函数都返回-1，并把errno设置为EINVAL</li><li>有些name返回一个变量值(大于等于0)，或者提示该值是不确定的，不确定的值通过返回-1来体现，但不改变errno的值</li><li>_SC_CLK_TCK返回值是每秒的时钟滴答数，用于times函数的返回值</li></ul><p>对于后两个函数的第一个参数有很多限制。可以通过手册查询。</p><p>不确定的运行时限制：</p><ul><li>路径名，可以通过PATH_MAX来获得，但是结果可能是不确定的</li><li>最大打开文件数，守护进程中一个常见的代码就是关闭所有打开的文件<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/param.h&gt;</span></span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NOFILE; ++i)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">close</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>但这种方式是不可移植的，所以可以通过sysconf来获取，尽可能提高移植性</p><p>如果我们需要编写可以移植的程序，这些程序可能依赖一些可选的支持的功能，我们需要一个可移植的方法来确定实现是否支持一个给定的选项</p><p>有三种处理选项的方法：</p><ul><li>编译时选项定义在unistd.h中</li><li>与文件或目录无关的选项使用sysconf确定</li><li>与文件或目录有关的选项使用pathconf或fpathconf确定</li></ul><p>对于每一个选项，有三种可能的平台支持状态。</p><ul><li>如果符号常量没有定义或者定义值为-1，那么该平台在编译时不支持相应选项。但是有一种可能，在已支持该选项的新系统上运行老应用时，即使该选项在应用编译时未被支持，但如今新系统运行时检查会显示该选项已经支持</li><li>如果符号常量的定义值大于0，那么支持该选项</li><li>如果符号常量的值为0，则必须调用三个函数来确定是否支持相应的选项</li></ul><p>如果在编译程序时，希望它只与POSIX的定义有关，而不与任何实现定义的常量冲突，那么需要定义常量_POSIX_C_SOURCE，一旦定义了该常量，所有POSIX.1的头文件都是用此常量来排除任何实现专有的定义。可以在编译时指定该常量</p><p>头文件sys/types.h中定义了某些与实现有关的数据类型，它们被称为基本系统数据类型(primitive system data type)，它们使用C语言的typedef定义，大多使用_t结尾，用这种方式定义了这些数据类型时，就不需要考虑因系统不同而变化的程序实现细节。</p><div class="table-container"><table><thead><tr><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>clock_t</td><td>时钟滴答计数器</td></tr><tr><td>comp_t</td><td>压缩的时钟滴答</td></tr><tr><td>dev_t</td><td>设备号，主和次</td></tr><tr><td>fd_set</td><td>文件描述符集</td></tr><tr><td>fpos_t</td><td>文件位置</td></tr><tr><td>gid_t</td><td>数值组ID</td></tr><tr><td>ino_t</td><td>i节点编号</td></tr><tr><td>mode_t</td><td>文件类型，文件创建模式</td></tr><tr><td>nlink_t</td><td>目录项的链接计数</td></tr><tr><td>off_t</td><td>文件长度和偏移量，带符号的</td></tr><tr><td>pid_t</td><td>进程ID和进程组ID，带符号的</td></tr><tr><td>pthread_t</td><td>线程ID</td></tr><tr><td>ptrdiff_t</td><td>两个指针相减的结果</td></tr><tr><td>rlim_t</td><td>资源限制</td></tr><tr><td>sig_atomic_t</td><td>能原子性访问的数据类型</td></tr><tr><td>sigset_t</td><td>信号集</td></tr><tr><td>size_t</td><td>对象长度，如字符串，不带符号的</td></tr><tr><td>ssize_t</td><td>返回字节计数器的函数，带符号的</td></tr><tr><td>time_t</td><td>日历时间的秒计数器</td></tr><tr><td>uid_t</td><td>数值用户ID</td></tr><tr><td>wchar_t</td><td>能表示所有不同的字符码</td></tr></tbody></table></div><h1 id="文件IO"><a href="#文件IO" class="headerlink" title="文件IO"></a>文件IO</h1><p>UNIX系统大多数的文件IO只需要5个函数：open，read，write，lseek，close。对于read和write不同缓冲区对读取性能有一定影响。这些函数常被称为不带缓冲的IO。属于不带缓冲指的是每个read和write都调用内核中的一个系统调用。如果在多个进程之间共享资源，我们需要了解原子操作。</p><p>对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。</p><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p>调用open或openat可以打开或创建一个文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> oflag, ... <span class="comment">/* mode_t mode */</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>path参数时要打开或创建的文件的名字。oflag参数可用来说明此函数的多个选项。用下面一个或多个常量进行或来构成oflag参数。</p><ul><li>O_RDONLY，只读打开</li><li>O_WRONLY，只写打开</li><li>O_RDWR，读写打开</li><li>O_EXEC，只执行打开</li><li>O_SEARCH，只搜索打开(应用于目录)</li></ul><p>以上5个常量中必须指定一个且只能指定一个。下列常量是可选的：</p><ul><li>O_APPEND，每次写都追加到文件的结尾</li><li>O_CLOEXEC，把FD_CLOEXEC常量设置为文件描述符标志。</li><li>O_CREAT，若此文件不存在则创建它。使用此选项open或openat函数需同时说明mode参数，用mode指定该新文件的访问权限位。</li><li>O_DIRECTORY，如果path引用的不是目录，则出错。</li><li>O_EXCL，如果同时指定了O_CREAT，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在则创建文件，这使得测试和创建两者成为一个原子操作。</li><li>O_NOCTTY，如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。</li><li>O_NOFOLLOW，如果path引用的是一个符号链接，则出错。</li><li>O_NOBLOCK，如果path引用的是一个FIFO，一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的IO操作设置非阻塞方式。</li><li>O_SYNC，使每次write等待物理IO操作完成，包括由该write操作引起的文件属性更新所需的IO。</li><li>O_TRUNC，如果此文件存在，而且为只写或读写成功打开文件，则将其长度截断为0。</li><li>O_TTY_INIT，如果打开一个还未打开的终端设备，设置非标准的termios参数值，使其符合single UNIX Specification。</li><li>O_DSYNC，使每次write要等待物理IO操作完成，但是如果该写操作并不影响读取刚写的数据，则不需要等待文件属性被更新。文件属性包括文件大小等信息。</li><li>O_RSYNC，使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。</li></ul><p>对于每一个选项，具体可以阅读man手册。</p><p>由open或openat函数返回的文件描述符一定是最小的未被使用的描述符的值。</p><p>fd参数把open和openat参数区分开：</p><ul><li>path参数指定的是绝对路径名，在这种情况下，fd参数被忽略，openat函数相当于open函数。</li><li>path参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中的开始地址。fd参数时通过打开相对路径名所在的目录来获取。</li><li>path参数指定了相对路径名，fd参数具有特殊值AT_FDCWD。在这种情况下，路径名在当前工作目录获取，open函数在操作上与open函数类似。</li></ul><p>openat函数希望解决两个问题，一是让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。二是可以避免time-of-check-to-time-of-use(TOCTTOU)错误，其基本思想是，如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的，因为两个调用并不是原子操作，在两个函数调用之间的文件可能改变了，这样也就造成了第一个调用的结果不再有效，使得最终程序的结果是错误的。</p><p>使用open需要注意文件名截断。现在大多数系统支持的文件名长度可以为255。</p><h2 id="creat函数"><a href="#creat函数" class="headerlink" title="creat函数"></a>creat函数</h2><p>另外，creat函数也可以创建一个文件：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 等效于</span></span><br><span class="line"><span class="built_in">open</span>(path, O_WRONLY | O_CREAT | O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p><p>它只以写的方式打开所创建的文件</p><h2 id="close函数"><a href="#close函数" class="headerlink" title="close函数"></a>close函数</h2><p>函数close关闭一个打开的文件：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(fd)</span></span>;</span><br></pre></td></tr></table></figure></p><p>关闭一个文件时，还会释放该进程加在该文件上的所有记录锁。当一个进程终止，内核自动关闭它所有的打开文件。</p><h2 id="lseek函数"><a href="#lseek函数" class="headerlink" title="lseek函数"></a>lseek函数</h2><p>每个打开的文件都有一个与其相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用于度量从文件开始处计算的字节数。通常读写操作都从当前文件便宜量开始，并使偏移量增加所读写的字节数。按照系统默认情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。</p><p>lseek可以显式的设置偏移量：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">off_t</span> <span class="title">lseek</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br></pre></td></tr></table></figure></p><p>对offset参数的解释与whence的值有关：</p><ul><li>若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节</li><li>若whence是SEEK_CUR，则将该文件偏移量设置为其当前值加上offset，offset可正可负</li><li>若whence是SEEK_END，则该文件偏移量设置为文件长度加上offset，offset可正可负</li></ul><p>lseek成功执行返回新的文件偏移量：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">off_t curr_pos<span class="comment">;</span></span><br><span class="line">curr_pos = lseek(<span class="name">fd</span>, <span class="number">0</span>, SEEK_CUR)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>这种方法可以确定打开文件的当前偏移量，也可以来确定涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管道，FIFO，或网络套接字，则lseek返回-1，并将errno设置为ESPIPE。</p><p>通常文件的当前偏移量应该是一个非负整数，但是某些设备也可能允许负的偏移量，但对于普通文件，必须是非负值。在比较lseek返回值时应该注意，不要测试它是否小于0，而要测试它是否等于-1。</p><p>lseek仅将当前的文件偏移量记录在内核中，它并不引起任何IO操作，该偏移量用于下一次读或写。</p><p>文件的偏移量可以大于当前文件大小，这种情况下，将会引起文件空洞，没被写过的字节都被读为0，文件中的空洞并不要求在磁盘上占用存储区，具体与实现有关。</p><p>lseek使用的偏移量用off_t类型表示，允许具体实现根据各自的平台自行选择合适的数据类型。</p><h2 id="read函数"><a href="#read函数" class="headerlink" title="read函数"></a>read函数</h2><p>read函数从打开的文件中读取数据：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">read</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果read成功，返回读取到的字节数。如已到达文件末端，返回0。<br>多种情况使得实际读取到的字节数少于要求读取的字节数：</p><ul><li>读取普通文件时，在读到要求字节数之前已经达到了文件尾端。</li><li>当从终端设备读时，通常依次最多读取一行。</li><li>当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。</li><li>当从管道或FIFO读时，如果管道包含的字节少于所需的数量，那么read将返回实际可用的字节数。</li><li>当从某些面向记录的设备(如磁带)读时，一次最多返回一个记录</li><li>当一信号造成中断，而已经读了部分数量时。</li></ul><p>读操作从当前文件偏移量开始，在成功返回之前，该偏移量将增加实际读到的字节数。</p><h2 id="write函数"><a href="#write函数" class="headerlink" title="write函数"></a>write函数</h2><p>write函数向打开的文件写入数据。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes)</span></span>;</span><br></pre></td></tr></table></figure></p><p>返回值通常与nbytes相同，否则表示出错，write出错的一个常见错误是磁盘已经写满，或者超过了一个给定进程的文件长度限制。</p><p>对于普通文件，写操作从文件的当前偏移量处开始。如果在打开文件时指定了O_APPEND选项，则在每次写操作前，将文件的偏移量设置在文件的结尾处，因此这种方式不能写中间的某个部分。在一次写成功后，文件偏移量增加实际写入的字节数。</p><h2 id="IO的效率"><a href="#IO的效率" class="headerlink" title="IO的效率"></a>IO的效率</h2><p>read函数和write的函数选出合适的buf大小是很重要的。一般来说在4096字节(磁盘块长度)效率比较高。大多数文件系统为改善性能都采取某种预读技术。检测到正在顺序读取时，系统就试图读取比应用所要求更多的数据，并假想应用很快就会读这些数据。</p><h2 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h2><p>UNIX支持在不同进程间共享打开文件。</p><p>内核使用三种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p><ul><li>每个进程在进程表项中都有一个记录项，记录项包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与文件描述符相关联的是文件描述符标志(close_on_exec)和指向一个文件表项的指针。</li><li>内核为所有打开文件维持一张文件表。每个文件表项包含：文件状态标志(读，写，添写，同步和非阻塞等)、当前文件偏移量、指向该文件的v节点指针。</li><li>每个打开文件(或设备)都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v节点还包含了该文件的i节点(索引节点)。这些信息是在打开文件时从磁盘读入内存的。对于不同的实现可能不同，例如linux不包含v节点，而是使用了通用的i节点。</li></ul><p>不同实现可能有不同，但是是有必要保存这些信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/打开文件的内核数据结构.png" alt="打开文件的内核数据结构" title>                </div>                <div class="image-caption">打开文件的内核数据结构</div>            </figure></p><p>文件描述符标志和文件状态标志在作用范围方面有区别，前者只用于一个进程的某一个描述符，而后者则应用于指向该给定文件表项的任何进程中所有的描述符。</p><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>一般而言，原子操作(atomic operation)是由多步操作组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。</p><p>多个进程对同一个文件追加数据，可以在打开文件时指定O_APPEND标志。这使得每次写操作之前内核都将进程的当前文件偏移量设置到该文件的末尾。对于对于这种write操作在不同进程间是不是原子的，后续有文章来验证。</p><p>pread和pwrite允许原子性的定位并执行IO。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">pread</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">pwrite</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes, <span class="keyword">off_t</span> offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>调用pread相当于调用lseek后调用read，但是pread又与这种顺序调用有如下重要区别：</p><ul><li>调用pread时，无法中断其定位和读操作</li><li>不更新当前文件偏移量</li></ul><p>pwrite也有类似的问题</p><h2 id="函数dup和dup2"><a href="#函数dup和dup2" class="headerlink" title="函数dup和dup2"></a>函数dup和dup2</h2><p>这两个函数可用来复制一个现有的文件描述符：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure></p><p> 由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2，可以用fd2参数指定新描述符的值，如果fd2已经打开，则先将其关闭。如若fd等于fd2，则dup2返回fd2而不关闭它。否则，fd2的FD_CLOEXEC文件描述符就被清除，这样fd2在进程调用exec时是打开状态。</p><p> 这些函数返回的新描述符与参数fd共享同一个文件表项。<br> <figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/dup后的内核数据结构.png" alt="dup后的内核数据结构" title>                </div>                <div class="image-caption">dup后的内核数据结构</div>            </figure></p><p> 赋值描述符的另一个方法是使用fcntl函数<br> <figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> dup<span class="comment">(fd)</span>;<span class="comment">// fcntl(fd, F_DUPFD, 0);</span></span><br><span class="line"> dup<span class="number">2</span><span class="comment">(fd, fd2)</span>;<span class="comment">// close(fd2); fcntl(fd, F_DUPFD, fd2);</span></span><br></pre></td></tr></table></figure></p><p> 后一种情况，dup2并不完全等同于close加上fcntl</p><ul><li>dup2是一个原子操作</li><li>dup2和fcntl有一些不同的errno</li></ul><h2 id="函数sync，fsync和fdatasync"><a href="#函数sync，fsync和fdatasync" class="headerlink" title="函数sync，fsync和fdatasync"></a>函数sync，fsync和fdatasync</h2><p>传统的UNIX系统实现在内核中设有高速缓冲区高速缓存或页高速缓存，大多数磁盘IO都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲中，然后排入队列，晚些时候再写入磁盘。这种方式被称为延迟写</p><p>通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘实际文件与缓冲区中内容的一致性，UNIX提供了sync，fsync和fdatasync三个函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>sync只是将所有修改过的缓冲块排入写队列，然后就返回，它并不等待实际写磁盘结束。通常称为update的系统守护进程周期性的调用(一般30s)sync函数。这就保证了定期冲洗内核的块缓冲区。sync命令也调用sync函数</p><p>fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待磁盘操作结束才返回。fdatasync函数类似于fsync，但它只影响文件的数据部分。fsync还会同时更新文件属性的更新。</p><h2 id="函数fcntl"><a href="#函数fcntl" class="headerlink" title="函数fcntl"></a>函数fcntl</h2><p>fcntl可以改变已经打开文件的属性：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* int arg */</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>fcntl函数有如下5个功能：</p><ul><li>复制一个已有的文件描述符(F_DUPFD或F_DUPFD_CLOEXEC)</li><li>获取或设置文件描述符标志(F_GETFD或F_SETFD)</li><li>获取或设置文件状态标志(F_GETFL或F_SETFL)</li><li>获取或设置异步IO所有权(F_GETOWN或F_SETOWN)</li><li>获取或设置记录锁(F_GETLK，F_SETLK或F_SETLKW)</li></ul><p>F_DUPFD，复制文件描述符fd。新的描述符作为函数返回值返回。它是尚未打开的各描述符中大于或等于第三个参数值中各值得最小值。<br>F_DUPFD_CLOEXEC，复制文件描述符，设置文件描述符关联的FD_CLOEXEC文件描述符的值，返回新文件描述符。<br>F_GETFD，对应于fd的文件描述符标志作为函数值返回，当前只定义了一个文件描述符标志FD_CLOEXEC<br>F_SETFD，对于fd设置文件描述符标志<br>F_GETFL，对应于fd的文件状态标志作为函数值返回。5个访问方式标志(O_RDONLY，O_WRONLY，O_RDWR，O_EXEC以及O_SEARCH)并不各占一位，这5个值互斥。因此首先必须使用屏蔽字O_ACCMODE取得访问方式，然后再进行比较。<br>F_SETFL，将文件状态标志设置为第三个参数的值，可以更改的标志是：O_APPEND，O_NONBLOCK，O_SYNC，O_DSYNC，O_RSYNC，O_FSYNC和O_ASYNC。<br>F_GETOWN，获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。<br>F_SETOWN，设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID。</p><p>fcntl如果出错返回-1，如果成功返回相应的值。</p><p>我们必须小心的使用设置标志，我们需要先取出现有的，设置想要设置的标志，然后再进行设置。</p><h2 id="函数ioctl"><a href="#函数ioctl" class="headerlink" title="函数ioctl"></a>函数ioctl</h2><p>ioctl函数一直是IO操作的杂物箱。终端IO是使用ioctl最多的地方。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line">// <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> ioctl(<span class="built_in">int</span> fd, <span class="built_in">int</span> request, ...)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>不能用本章其他io函数表示的IO操作通常都能用ioctl表示。</p><h2 id="dev-fd"><a href="#dev-fd" class="headerlink" title="/dev/fd"></a>/dev/fd</h2><p>较新的系统都提供名为/dev/fd的目录，打开文件/dev/fd/n等效于复制描述符n。</p><p>在linux系统中，它把文件描述符映射成指向物理底层文件的符号链接。</p><h1 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h1><p>对于文件除了文件本身，还有和文件相关的其他属性。另外还有函数能够修改这些属性</p><h2 id="函数stat，fstat，fstatat和lstat"><a href="#函数stat，fstat，fstatat和lstat" class="headerlink" title="函数stat，fstat，fstatat和lstat"></a>函数stat，fstat，fstatat和lstat</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, staruct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, struct stat *<span class="keyword">restrict</span> buf, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure><p>stat将返回与文件pathname有关的信息结构。fstat函数获得已在描述符fd上打开文件的有关信息。lstat函数类似stat，但是当命名文件是一个符号链接时，lstat返回符号链接本身的有关信息，而不是由符号链接引用的文件的信息。fstatat函数为一个相对于当前打开目录（由fd参数指向）的路径名返回文件统计信息。flag参数控制着是否跟随着符号链接。当AT_SYMLINK_NOFOLLOW标志被设置时，fstatat函数不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所指向的文件的信息。如果fd参数的值是AT_FDCWD，并且pathname参数是一个相对路径名，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径名，fd参数就会被忽略。这两种情况下，根据flag的取值，fstatat函数的作用就跟stat或lstat函数一样。</p><p>第二个参数buf是一个指针，它指向一个我们必须提供的结构。函数来填充buf指向的结构。结构的实际定义可能随系统具体实现不同，但其基本形式是：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">mode_t</span>st_mode;<span class="comment">// file type &amp; mode (permissions)</span></span><br><span class="line">  <span class="keyword">ino_t</span>  st_ino;<span class="comment">// i-node number (serial number)</span></span><br><span class="line">  <span class="keyword">dev_t</span> st_dev;<span class="comment">// device number (file system)</span></span><br><span class="line">  <span class="keyword">dev_t</span> st_rdev;<span class="comment">// device number for special files</span></span><br><span class="line">  <span class="keyword">nlink_t</span>   st_nlink;<span class="comment">// number of links</span></span><br><span class="line">  <span class="keyword">uid_t</span>  st_uid;<span class="comment">// user ID of owner</span></span><br><span class="line">  <span class="keyword">gid_t</span> st_gid;<span class="comment">// group ID of owner</span></span><br><span class="line">  <span class="keyword">off_t</span>  st_size;<span class="comment">// size in bytes, for regular files</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_atime</span>;</span><span class="comment">// time of last access</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_mtime</span>;</span><span class="comment">// time of last modification</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timespec</span><span class="title">st_ctime</span>;</span><span class="comment">// time of last file status change</span></span><br><span class="line">  <span class="keyword">blksize_t</span>st_blksize;<span class="comment">// best IO block size</span></span><br><span class="line">  <span class="keyword">blkcnt_t</span>st_blocks;<span class="comment">// number of disk blocks allocated</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// timespec按照秒和纳秒定义了时间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>stat结构中的大部分成员都是基本系统数据类型。我们将说明此结构的每个成员以了解文件属性。ls命令使用stat函数。</p><h2 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h2><p>文件类型包括</p><ul><li>普通文件（regular file）。这是最常用的文件类型。UNIX系统并不区分文本文件和二进制文件。但是对于可执行文件，内核必须理解其格式，以便能够确定程序文本和数据的加载位置。</li><li>目录文件（direcory file）。这种文件包含了其他文件的名字与指向这些文件的有关信息。通常只有内核可以直接写目录文件。</li><li>块特殊文件（block special file）。这种类型的文件提供对设备的带缓冲的访问，每次访问以固定的长度为单位进行。</li><li>字符特殊文件（character special file）。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是字符特殊文件，要么是块特殊文件。</li><li>FIFO。可用于进程间通信，又被称作命名管道（named pipe）。</li><li>套接字（socket）。这种类型的文件用用于进程间的网络通信。也可以用于在一台宿主机上进程间的非网络通信。</li><li>符号链接（symbolic link）。这种类型的文件指向另一个文件。</li></ul><p>文件类型信息包含在stat结构的st_mode成员中。可以使用宏来确定文件类型。</p><div class="table-container"><table><thead><tr><th>宏</th><th>文件类型</th></tr></thead><tbody><tr><td>S_ISREG()</td><td>普通文件</td></tr><tr><td>S_ISDIR()</td><td>目录文件</td></tr><tr><td>S_ISCHR()</td><td>字符特殊文件</td></tr><tr><td>S_ISBLK()</td><td>块特殊文件</td></tr><tr><td>S_ISFIFO()</td><td>管道或FIFO</td></tr><tr><td>S_ISLNK()</td><td>符号链接</td></tr><tr><td>s_ISSOCK()</td><td>套接字</td></tr></tbody></table></div><p>POSIX.1允许将进程间通信的对象说明为文件。例如消息队列，信号量，共享内存对象。</p><p>对于宏的实现，一般是将st_mode与屏蔽字S_IFMT进行&amp;运算，然后与对应常量比较，判断是否为特定文件类型。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define S_ISDIR(<span class="name">mode</span>) (((<span class="name">mode</span>) &amp; SIFMT) == SIFDIR)</span><br></pre></td></tr></table></figure></p><h2 id="设置用户ID和设置组ID"><a href="#设置用户ID和设置组ID" class="headerlink" title="设置用户ID和设置组ID"></a>设置用户ID和设置组ID</h2><p>与一个进程相关的ID有6个或更多：</p><ul><li>实际用户ID、实际组ID——我们实际上是谁，在登录时取自口令文件。在一个登录会话期间并不会改变，但是超级用户进程可以改变它们。</li><li>有效用户ID、有效组ID、附属组ID——用于文件访问权限检查</li><li>保存的设置用户ID、保存的设置组ID——由exec函数保存</li></ul><p>每个文件有一个所有者和组所有者，分别由st_uid和st_gid指出。</p><p>执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常就是实际组ID。但是可以st_mode中设置一个特殊标志，含义为当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID。同样还有类似的设置组ID。分别被称为设置用户ID位和设置组ID位。</p><p>例如passwd修改登录口令，是一个设置用户ID程序。因为口令文件只有超级用户才有写入权限。这种程序会获得额外权限，需要谨慎处理。</p><p>设置用户ID和设置组ID可以使用S_ISUID和S_ISGID测试。</p><h2 id="文件访问权限"><a href="#文件访问权限" class="headerlink" title="文件访问权限"></a>文件访问权限</h2><p>st_mode也包含了对文件的文件权限位。这里的文件是前面提到的任何类型的文件。所有文件类型都有访问权限。</p><p>每个文件有9个访问权限位，可以分为三组</p><div class="table-container"><table><thead><tr><th>st_mode屏蔽</th><th>含义</th></tr></thead><tbody><tr><td>S_IRUSR</td><td>用户读</td></tr><tr><td>S_IWUSR</td><td>用户写</td></tr><tr><td>S_IXUSR</td><td>用户执行</td></tr><tr><td>S_IRGRP</td><td>组读</td></tr><tr><td>S_IWGRP</td><td>组写</td></tr><tr><td>S_IXGRP</td><td>组执行</td></tr><tr><td>S_IROTH</td><td>其他读</td></tr><tr><td>S_IWOTH</td><td>其他写</td></tr><tr><td>S_IXOTH</td><td>其他执行</td></tr></tbody></table></div><p>前三行用户指的是文件的所有者。我们可以使用chmod来修改文件的访问权限。</p><p>对于访问权限以各种方式由不同函数使用。</p><ul><li>第一个规则是我们用名字打开任一类型的文件时，对该名字包含中的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这也是为什么对于目录其执行权限位常被称为搜索位的原因。</li><li>对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作，对应了open函数的o_RDONLY和O_RDWR标志</li><li>对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作，对应了open函数的O_WRONLY和O_RDWR标志</li><li>为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限</li><li>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限</li><li>为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身则不需要有读写权限</li><li>如果7个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限，该文件必须是一个普通文件</li></ul><p>进程每次打开，创建或删除一个文件，内核就进行文件访问权限测试，这种测试可能涉及文件的所有者，进程的有效ID及进程的附属组ID。</p><ul><li>若进程的有效ID是0（超级用户），则允许访问。</li><li>若进程的有效用户ID等于文件的所有者ID，那么如果所有者适当的访问权限位被设置，则允许访问，否则拒绝访问。</li><li>若进程的有效组ID或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权限位被设置，则允许访问，否则拒绝访问。</li><li>若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。</li></ul><h2 id="新文件和目录的所有权"><a href="#新文件和目录的所有权" class="headerlink" title="新文件和目录的所有权"></a>新文件和目录的所有权</h2><p>进程创建的新文件的用户ID设置为进程的有效用户ID。对于组ID，POSIX.1允许实现选择以下之一作为新文件的组ID：</p><ul><li>新文件的组ID可以是进程的有效组ID</li><li>新文件的组ID可以是它所在目录的组ID</li></ul><p>有些实现默认使用第二种方式，例如Mac OS 10.6.8。linux 3.2.0默认情况下新文件的组ID取决于它所在目录的设置组ID位是否被设置，如果设置，则使用第二种方式，否则使用第一种方式。</p><h2 id="函数access和faccessat"><a href="#函数access和faccessat" class="headerlink" title="函数access和faccessat"></a>函数access和faccessat</h2><p>当打开一个文件时，内核使用进程的有效用户ID和有效组ID为基础执行权限访问测试。进程有时候也希望按照实际用户ID和实际组ID来测试其访问能力。access和faccessat函数按照实际用户ID和实际组ID进行访问权限测试。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccess</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果mode设置为F_OK，则测试文件是否存在。否则是三个常量的按位或：R_OK，W_OK、X_OK。</p><p>faccessat函数在下列情况的作用于access函数相同：一种是pathname参数为绝对路径，另一种是fd参数的取值为AT_FDCWD且参数pathname为相对路径。否则，faccessat计算相对于打开目录（fd指定）的pathname。</p><p>flag参数可以改变faccessat的行为，如果flag设置为AT_EACCESS，访问检查用的是调用进程的有效用户ID和有效组ID。</p><h2 id="函数umask"><a href="#函数umask" class="headerlink" title="函数umask"></a>函数umask</h2><p>每个进程都有一个相关联的文件模式创建屏蔽字，umask函数可以为进程设置文件模式创建屏蔽字，返回之前的值<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">mode_t</span> <span class="title">umaks</span><span class="params">(<span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p><p>进程创建一个文件或目录时就一定会使用文件模式创建屏蔽字，在其中为1的位，在文件mode中相应的位一定会被关闭。</p><p>在shell中，我们可以使用umask命令来修改这个值。以便修改创建文件的默认权限。</p><h2 id="函数chmod、fchmod和fchmodat"><a href="#函数chmod、fchmod和fchmodat" class="headerlink" title="函数chmod、fchmod和fchmodat"></a>函数chmod、fchmod和fchmodat</h2><p>这三个函数用来修改现有文件的访问权限<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>fchmodat函数在两种情况下与chmod函数一样：一种是pathname参数为绝对路径；另一种是fd参数取值为AT_FDCWD且pathname参数为相对路径。否则fchmodat相对于fd打开的目录来计算pathname。flag参数可以改变fchmodat的行为，当设置了AT_SYMLINK_NOFOLLOW时，fchmodat不跟随符号链接。</p><p>为了改变一个文件的权限位，进程的有效用户ID必须等于文件所有者ID，或者该进程具有超级用户权限</p><p>参数mode由以下值按位或</p><div class="table-container"><table><thead><tr><th>mode</th><th>说明</th></tr></thead><tbody><tr><td>S_ISUID</td><td>执行时设置用户ID</td></tr><tr><td>S_ISGID</td><td>执行时设置组ID</td></tr><tr><td>S_ISVTX</td><td>保存正文（粘着位）</td></tr><tr><td>S_IRWXU</td><td>用户读写执行</td></tr><tr><td>S_IRUSR</td><td>用户读</td></tr><tr><td>S_IWUSR</td><td>用户写</td></tr><tr><td>S_IXUSR</td><td>用户执行</td></tr><tr><td>S_IRWXG</td><td>组读写执行</td></tr><tr><td>S_IRGRP</td><td>组读</td></tr><tr><td>S_IWGRP</td><td>组写</td></tr><tr><td>S_IXGRP</td><td>组执行</td></tr><tr><td>S_IRWXO</td><td>其他读写执行</td></tr><tr><td>S_IROTH</td><td>其他读</td></tr><tr><td>S_IWOTH</td><td>其他写</td></tr><tr><td>S_IXOTH</td><td>其他执行</td></tr></tbody></table></div><p>chmod函数在下列条件下自动清除两个权限位：</p><ul><li>Solaris等系统对于普通文件的粘着位赋予了特殊含义在这些系统上，如果我们尝试设置普通文件的粘着位(S_ISVTX)，而且又没有超级用户权限，那么mode中的粘着位自动被关闭。这意味着只有超级用户才能设置普通文件的粘着位。这样做是防止恶意用户设置粘着位，影响系统性能。</li><li>新创建文件的组ID可能不是调用进程所属的组。新文件的组ID可能是父目录的组ID，特别的如果新文件的组ID不等于进程的有效组ID或附属组ID中的一个，而且进程没有超级用户权限，那么设置组ID位会被自动关闭。这就防止了用户创建了一个设置组ID文件，而该文件是并非该用户所属的组拥有的。</li></ul><p>有的系统，如Linux 3.2.0等增加了另一个安全性功能试图阻止误用某些保护位。如果没有超级用户权限的进程写一个文件，则设置用户ID位和设置组ID位会被自动清除。如果恶意用户找到一个它们可以写的设置用户ID位和设置组ID位文件，即使它们可以修改此文件，它们也失去了特殊的授权。</p><h2 id="粘着位"><a href="#粘着位" class="headerlink" title="粘着位"></a>粘着位</h2><p>粘着位（S_ISVTX，sticky bit）有着有趣的历史，在早期版本的UNIX中，如果一个可执行程序的这一位被设置了，那么当程序第一次执行，在其终止时，程序正文部分的一个副本仍然保存在交换区中，正文指指令部分。这样程序下次执行就能较快的载入内存。原因是：通常的UNIX文件系统中，文件的各数据块可能是随机存放的，相比较而言，交换区是被作为一个连续文件来存放的。后来的UNIX系统将其称为保存正文位(saved-text bit)。现在的系统大多数都配置了虚拟存储系统以及快速文件系统，所以不再需要此技术。</p><p>现在，我们扩展了粘着位的使用范围。如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件：</p><ul><li>拥有此文件</li><li>拥有此目录</li><li>是超级用户</li></ul><p>例如目录/tmp就是这种目录，这样，一个用户就无法删除或重命名其他用户的文件。</p><h2 id="chown、fchown、fchownat和lchown"><a href="#chown、fchown、fchownat和lchown" class="headerlink" title="chown、fchown、fchownat和lchown"></a>chown、fchown、fchownat和lchown</h2><p>下列函数用来修改文件的用户ID和组ID，如果参数中任意一个是-1，则对应ID不变：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flag)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></p><p>除了引用的文件时符号链接外，4个函数都类似。在符号链接的情况下，lchown和fchownat(设置了AT_SYMLINK_NOFOLLOW)更改符号链接本身的所有者，而不是符号链接指向的文件的所有者。</p><p>fchown用于改变fd参数指向的打开文件的所有者，它在一个已打开的文件上操作，因此它不能用于改变符号链接的所有者。</p><p>fchownat函数与chown或和lchown函数在下列情况下相同：一种是pathname是绝对路径，另一种是fd参数值取值为AT_FDCWD且pathname参数为相对路径。在这两种情况下，如果flag参数设置了AT_SYMLINK_NOFOLLOW，fchownat与lchown函数相同，否则与chown函数相同。其他情况下，fchownat函数计算相对于打开目录的pathname。</p><p>一般来说，只有超级用户或文件所有者才能更改一个文件的所有者。POSIX.1允许两种操作中选择一种。可以使用_POSIX_CHOWN_RESTRICTED常量来确定是否有限制，我们可以根据pathconf或fpathconf查询。此选项与文件有关，对于不同的文件可能值不一样。</p><p>如果其对指定的文件生效：</p><ul><li>只有超级用户才能更改此文件的用户ID</li><li>如果进程拥有此文件，参数owner等于-1或文件的用户ID，并且参数group等于进程的有效组ID或进程的附属组ID之一，那么一个非超级用户进程可以更改此文件的组ID。</li></ul><p>如果这些函数由非超级用户进程调用，那么在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。</p><h2 id="文件长度"><a href="#文件长度" class="headerlink" title="文件长度"></a>文件长度</h2><p>stat结构成员st_size表示以字节为单位的长度。此字段只对普通文件、目录文件和符号链接有意义。</p><p>对于普通文件，长度可以是0，在开始读这种文件时，将得到文件结束指示。对于目录，文件长度通常是一个数的整数倍。对于符号链接，文件长度是在文件名中的实际字节数。</p><p>现今大多数现在的UNIX系统提供字段st_blksize和st_blocks，其中，第一个是对文件IO比较适合的块长度，第二个是所分配的实际512字节(不同系统单位可能不同)的块数。标准IO库一次也尝试读写st_blksize个字节。</p><p>我们可以在文件中建立空洞，这些空洞并不占用磁盘空间，读取空洞导致读取到的内容为0。</p><h2 id="文件截断"><a href="#文件截断" class="headerlink" title="文件截断"></a>文件截断</h2><p>有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件长度截断为0是一个特例，在打开文件时使用O_TRUNC标志可以做到这一点。为了截断文件可以调用函数truncate和ftruncate函数。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这两个函数将一个现有文件截断到长度length。要么缩短文件，要么产生一个空洞。</p><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>UNIX文件系统有多种不同的实现。每一种文件系统都有它各自的特征。大部分UNIX文件系统支持大小写敏感的文件名。在Mac OS上，HFS是大小写保留的，但是大小写不敏感。</p><p>我们可以把磁盘分成一个或多个分区。每个分区可以包含一个文件系统。i节点是固定长度的记录项，它包含有关文件的大部分信息。<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/磁盘、分区和文件系统.jpg" alt="磁盘、分区和文件系统" title>                </div>                <div class="image-caption">磁盘、分区和文件系统</div>            </figure></p><p>下面是比较详细的i节点和数据块图<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/i节点和数据块详细图.jpg" alt="i节点和数据块详细图" title>                </div>                <div class="image-caption">i节点和数据块详细图</div>            </figure><br>在图中，我们注意到：</p><ul><li>有两个目录项指向同一个i节点，每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少到0时，才可删除该文件。这就是为什么解除一个文件的链接操作并不总是意味着释放该文件占用的磁盘块的原因。在stat结构中，链接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t。这种链接类型称为硬链接。LINK_MAX指定了一个文件链接数的最大值。</li><li>另外一种类型链接称为符号链接（symbolic link）。符号链接的实际内容包含了该符号链接所指向的文件的名字。</li><li>i节点包含了文件有关的所有信息：文件类型，文件访问权限位，文件长度和指向文件数据块的指针。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录中：文件名和i节点编号。还有其他记录项，我们并不关心，如文件名长度等</li><li>因为目录项中的i节点编号指向同一个文件系统中相应的i节点，一个目录项不能指向另一个文件系统的i节点。这就是为什么ln命令构造一个现有文件的新目录项不能跨越文件系统的原因。</li><li>当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需要构造一个指向现有i节点的目录项，并删除老的目录项。链接计数不会改变。这一般是mv命令的通常操作方式。</li></ul><p>任何一个不包含任何其他目录的目录的链接计数总是2。即.和..。</p><h2 id="函数link，linkat，unlink，unlinkat和remove"><a href="#函数link，linkat，unlink，unlinkat和remove" class="headerlink" title="函数link，linkat，unlink，unlinkat和remove"></a>函数link，linkat，unlink，unlinkat和remove</h2><p>创建一个指向现有文件的链接的方法是使用link或linkat函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> efd, <span class="keyword">const</span> <span class="keyword">char</span> *existingpath, <span class="keyword">int</span> nfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这两个函数创建一个新目录项newpath，它引用现有文件existingpath，如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应该已经存在。</p><p>对于linkat函数，现有文件是通过efd和existingpath参数指定的，新的路径名是通过nfd和newpath指定的。默认情况下，如果两个路径名中的任意一个是相对路径，那么他需要通过相对于对应的文件描述符进行计算，如果两个文件描述符中的任一个设置为AT_FDCWD，那么相应的路径名就通过相对于当前目录计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。</p><p>当现有文件名是符号链接时，由参数flag来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有符号链接指向的文件的链接。如果在flag中设置了AT_SYMLINK_FOLLOW标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。创建新目录项和增加链接计数应当是一个原子操作。</p><p>虽然POSIX.1允许实现支持跨越文件系统的链接，但是大多数现有系统要求现有的和新建的两个文件路径名在同一个文件系统中。只有超级用户才能够创建指向一个目录的硬链接。这样可能在系统中形成循环。</p><p>为了删除一个现有的目录项，可以调用unlink函数：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这两个函数删除目录项，并将由pathname所引用文件的链接计数减1，如果该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对文件进行任何修改。</p><p>当链接计数为0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了文件。关闭一个文件时，内核首先检查打开该文件的进程个数；如果这个计数达到0，内核再去检查其链接计数，如果计数也是0，那么就删除该文件的内容。</p><p>unlinkat使用fd作为相对路径起点。或者设置为AT_FDCWD，则相对于当前路径。</p><p>当flag为AT_REMOVEDIR时，unlinkat可以类似于rmdir一样删除目录，如果这个标志被清除，unlinkat与link执行相同的操作。</p><p>如果pathname是符号链接，那么unlink函数删除该符号链接，而不是删除由符号链接所引用的文件，给出符号链接名的情况下，没有一个函数能够删除由该符号链接引用的文件。</p><p>我们也可以使用remove函数接触一个函数或目录的链接。对于文件remove的功能与unlink相同，对于目录，remove的功能与rmdir相同：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure></p><h2 id="函数rename和renameat"><a href="#函数rename和renameat" class="headerlink" title="函数rename和renameat"></a>函数rename和renameat</h2><p>文件或目录可以使用rename或renameat函数进行重命名。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> oldfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldname, <span class="keyword">int</span> newfd, <span class="keyword">const</span> <span class="keyword">char</span> *newname)</span></span>;</span><br></pre></td></tr></table></figure></p><p>根据对oldname是指文件，目录还是符号链接或者newname已经存在我们需要说明：</p><ul><li>如果oldname指的是文件而不是目录，那么为该文件或符号链接重命名。在这种情况下，如果newname已经存在，则它不能引用一个目录。如果newname已经存在，而且不是一个目录，则先将该目录项删除然后将oldname重命名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录。</li><li>如果oldname是一个目录，那么为该目录重命名。如果newname已经存在，则它必须引用一个目录，而且该目录应当是空目录(只有.和..)。如果newname存在而且是一个空目录，则先将其删除，然后将oldname重命名为newname。newname不能包含oldname的前缀。</li><li>如果oldname或newname引用符号链接，则处理的是符号链接本身，而不是它引用的文件。</li><li>不能对.和..重命名。</li><li>作为一个特例，如果oldname和newname引用同一个文件，则函数不做任何修改而成功返回。</li></ul><p>除了当oldname或newname指向相对路径时，其他情况renameat和rename函数功能相同。</p><h2 id="符号链接"><a href="#符号链接" class="headerlink" title="符号链接"></a>符号链接</h2><p>符号链接是对一个文件的间接指针。引入符号链接是为了避开硬链接的一些限制。</p><ul><li>硬链接通常要求链接和文件在同一个文件系统上</li><li>只有超级用户才能创建指向目录的硬链接</li></ul><p>对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接。</p><p>当使用以名字引用文件的函数时，应当了解函数是否处理符号链接。也就是是否跟随符号链接到达它所链接的文件。</p><div class="table-container"><table><thead><tr><th>函数</th><th>是否跟随符号链接</th></tr></thead><tbody><tr><td>access</td><td>是</td></tr><tr><td>chdir</td><td>是</td></tr><tr><td>chmod</td><td>是</td></tr><tr><td>chown</td><td>是</td></tr><tr><td>creat</td><td>是</td></tr><tr><td>exec</td><td>是</td></tr><tr><td>lchown</td><td>否</td></tr><tr><td>link</td><td>是</td></tr><tr><td>lstat</td><td>否</td></tr><tr><td>open</td><td>是</td></tr><tr><td>opendir</td><td>是</td></tr><tr><td>pathconf</td><td>是</td></tr><tr><td>readlink</td><td>否</td></tr><tr><td>remove</td><td>否</td></tr><tr><td>rename</td><td>否</td></tr><tr><td>stat</td><td>是</td></tr><tr><td>truncate</td><td>是</td></tr><tr><td>unlink</td><td>否</td></tr></tbody></table></div><p>open的一个例外是，如果同时用O_CREAT和O_EXCL两个标志，如果路径引用符号链接，open函数将出错，errno设置为EEXIST，这种处理是意图堵塞一个安全漏洞，以防止具有特权的进程被诱骗编写错误的文件</p><h2 id="创建和读取符号链接"><a href="#创建和读取符号链接" class="headerlink" title="创建和读取符号链接"></a>创建和读取符号链接</h2><p>可以使用symlink或symlinkat函数创建一个符号链接<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *actualpath, <span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *sympath)</span></span>;</span><br></pre></td></tr></table></figure></p><p>函数创建了一个指向actualpath的新目录项sympath，在创建符号链接时，并不要求actualpath存在，也不需要在同一个文件系统中。</p><p>symlinkat函数类似，sympath根据fd作为相对路径进行计算。</p><p>open函数跟随符号链接，所以提供了readlink和readlinkat函数来读取符号链接本身<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="keyword">size_t</span> bufsize)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readlinkat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">restrict</span> pathname, <span class="keyword">char</span> *<span class="keyword">restrict</span> buf, <span class="built_in">size</span> bufsize)</span></span>;</span><br></pre></td></tr></table></figure></p><p>两个函数组合了open，read，close的所有操作。readlinkat以fd作为相对路径。</p><h2 id="文件的时间"><a href="#文件的时间" class="headerlink" title="文件的时间"></a>文件的时间</h2><p>对于每个文件维护三个时间</p><div class="table-container"><table><thead><tr><th>字段</th><th>说明</th><th>例子</th><th>ls选项</th></tr></thead><tbody><tr><td>st_atim</td><td>文件数据的最后访问时间</td><td>read</td><td>-u</td></tr><tr><td>st_mtim</td><td>文件数据的最后修改时间</td><td>write</td><td>默认</td></tr><tr><td>st_ctim</td><td>i节点状态的最后更改时间</td><td>chmod，chown</td><td>-c</td></tr></tbody></table></div><p>注意文件数据修改时间和i节点最后更改时间，i节点信息和文件数据是分开存放的</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/各种函数对三种时间的影响.png" alt="各种函数对三种时间的影响" title>                </div>                <div class="image-caption">各种函数对三种时间的影响</div>            </figure><h2 id="函数futimens，utimensat和utimes"><a href="#函数futimens，utimensat和utimes" class="headerlink" title="函数futimens，utimensat和utimes"></a>函数futimens，utimensat和utimes</h2><p>一个文件的访问和修改时间可以通过一下几个函数修改。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>times数组参数的第一个元素包含访问时间，第二个元素包含修改时间，这两个值是日历时间。</p><p>时间戳可以按下列4中方式之一指定</p><ul><li>如果times是空指针，则访问时间和修改时间两者都设置为当前时间</li><li>如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_NOW，则相应的时间戳就设置为当前时间，忽略相应的tv_sec字段</li><li>如果times参数指向两个timespec结构的数组，任意数组元素的tv_nsec字段的值为UTIME_OMIT，相应的时间戳保持不变，忽略相应的tv_sec字段</li><li>如果times参数执行两个timespec结构的数组，且tv_nsec字段的值不是上述两者，这种情况下，设置为对应的值</li></ul><p>执行函数的所需的权限取决于times的值，如果不修改时间戳，则不进行权限检查；如果修改，则除了对文件有写权限，进程的有效用户ID必须等于文件的所有者ID</p><p>utimesns提供了使用文件名来设置时间的功能，flag可以决定是否跟随符号链接(是否设置了AT_SYMLINK_NOFOLLOW标志)，默认行为是跟随符号链接。</p><p>前两个函数都包含在POSIX.1中，第3个函数包含在Single UNIX Specsification的XSI扩展选项中<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></p><p>utimes函数对路径名进行操作。结构timeval包含两个时间戳，用秒和微妙来表示<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">  <span class="keyword">long</span> tv_usec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们不能对状态更改时间指定一个值，这在调用utimes函数时自动被更新。</p><h2 id="函数mkdir，mkdirat和rmdir"><a href="#函数mkdir，mkdirat和rmdir" class="headerlink" title="函数mkdir，mkdirat和rmdir"></a>函数mkdir，mkdirat和rmdir</h2><p>我们用mkdir、mkdirat创建目录，用rmdir来删除目录<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这两个函数创建一个空目录。mode指定访问权限。通常我们需要目录的执行权限。</p><p>可以使用rmdir函数删除一个空目录<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果调用此函数使得目录的链接计数为0，并且也没有其他进程打开目录，则释放由此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则此函数返回前删除最后一个链接及.和..项。此目录中不能再创建任何文件，但是在最后一个进程关闭它之前并不释放此目录，即使另一些进程打开该目录，它在此目录下也不能执行其他操作。因为rmdir执行成功的前提是目录是空的。</p><h2 id="读目录"><a href="#读目录" class="headerlink" title="读目录"></a>读目录</h2><p>对某个目录具有读访问权限的任一用户都能读该目录，但是为了防止文件系统混乱，只有内核才能够写目录。</p><p>目录的实际格式依赖实现。我们使用下边的函数来屏蔽这种实现细节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirnet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure></p><p>dirent结构与实现有关，但是至少包含i节点编号和目录名字。</p><p>DIR是一个内部结构，用来维护正在读的目录的有关信息。</p><p>ftw和nftw实现了目录的遍历</p><h2 id="函数chdir，fchdir和getcwd"><a href="#函数chdir，fchdir和getcwd" class="headerlink" title="函数chdir，fchdir和getcwd"></a>函数chdir，fchdir和getcwd</h2><p>进程都有一个当前工作目录，调用chdir或fchdir可以更改当前工作目录<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当前工作目录与进程相关，在shell中，cd命令是内建的命令，因为需要shell本身来调用chdir。</p><p>我们可以通过chdir一直转到上级目录来获取当前工作路径，getcwd提供了类似的功能<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure></p><p>chdir跟随符号链接。</p><h2 id="设备特殊文件"><a href="#设备特殊文件" class="headerlink" title="设备特殊文件"></a>设备特殊文件</h2><p>st_dev和st_rdev经常混淆，有关规则很简单</p><ul><li>每个文件系统所在的存储设备都由其主次设备号表示。其系统基本数据类型是dev_t，主设备号标识设备驱动程序，有时编码为与其通信的外设板，次设备号标识特定的子设备。</li><li>我们使用major和minor来访问主、次设备号。大多数系统都定义了这两个宏。</li><li>系统中与每个文件名关联的st_dev是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点</li><li>只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号。</li></ul><h2 id="文件访问权限位小结"><a href="#文件访问权限位小结" class="headerlink" title="文件访问权限位小结"></a>文件访问权限位小结</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/img/文件访问权限位小结.png" alt="文件访问权限位小结" title>                </div>                <div class="image-caption">文件访问权限位小结</div>            </figure><h1 id="标准IO库"><a href="#标准IO库" class="headerlink" title="标准IO库"></a>标准IO库</h1>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;UNIX基础知识&quot;&gt;&lt;a href=&quot;#UNIX基础知识&quot; class=&quot;headerlink&quot; title=&quot;UNIX基础知识&quot;&gt;&lt;/a&gt;UNIX基础知识&lt;/h1&gt;&lt;p&gt;所有的操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读文件、分配存储区以及获得当前时间等。&lt;/p&gt;
&lt;p&gt;从严格意义上说，可以将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。从广义上说，操作系统包含了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。&lt;/p&gt;
&lt;p&gt;我们通常将这种软件成为内核（kernel），因为它相对较小，而且位于环境的核心。&lt;/p&gt;
&lt;p&gt;内核的接口称之为系统调用（system call）。公共函数库构建在系统调用接口之上，应用程序既可使用公共函数库，也可以使用系统调用。shell是一个特殊的应用程序， 为运行其他应用程序提供了一个接口。&lt;/p&gt;
&lt;p&gt;系统的口令文件由7个以冒号分割的字段组成，依次是：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录以及shell程序。目前所有已知的系统已将加密口令移到另一个文件中。&lt;/p&gt;
&lt;p&gt;shell是一个命令解释器，它读取用户输入，然后执行命令。&lt;/p&gt;
    
    </summary>
    
    
      <category term="unix" scheme="https://blog.gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://blog.gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://blog.gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://blog.gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>Cpp-Primer-Plus读书笔记（二）</title>
    <link href="https://blog.gwq5210.com/2017/07/09/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://blog.gwq5210.com/2017/07/09/Cpp-Primer-Plus读书笔记（二）/</id>
    <published>2017-07-09T14:47:52.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h1 id="循环和关系表达式"><a href="#循环和关系表达式" class="headerlink" title="循环和关系表达式"></a>循环和关系表达式</h1><p>for循环为执行重复的操作提供了循序渐进的步骤。for循环的组成部分完成下面这些步骤：</p><ul><li>设置初始值</li><li>执行测试，看看循环是否应该继续执行</li><li>执行循环操作</li><li>更新用于测试的值<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (initialization; test-<span class="keyword">expression</span>; update-<span class="keyword">expression</span>)</span><br><span class="line">body</span><br></pre></td></tr></table></figure></li></ul><p>C++ 语法将for看做一条语句，——虽然循环体可以包括一条或多条语句。循环只执行一次初始化，测试表达式决定循环体是否被执行，通常，这个表达式是关系表达式，即对两个值进行比较。这里可以使用任何表达式，C++将把结果强制转换为bool类型。</p><p>for循环是入口条件循环，这意味着在每轮循环之前，都将计算测试表达式得值，当测试表达式为false时，将不会执行循环体。</p><p>更新表达式在每轮循环结束时执行，此时循环体已经执行完毕。通常，它用来对跟踪循环次数的变量的值进行递增。</p><p>for循环的控制部分使用了3个表达式，任何值或任何有效的值和运算符的组合都是表达式。赋值也是一个表达式，C++将赋值表达式的值定义为左侧成员的值。</p><a id="more"></a><p>当判定表达式的值这种操作改变了内存中数据的值时，我们说表达式有副作用。判定赋值表达式的值会修改被赋值者的值。</p><p>从表达式到语句的转变很容易，只需要加分号即可。因此a=100是表达式，a=100;是语句。更准确的说，这是一条表达式语句。只要加上分号，所有的表达式都可以成为语句，但不一定有编程意义。如a+6;是合法的语句，但它没完成任何有用的工作，智能编译器甚至可能跳过这条语句</p><p>对任何表达式加上分号都可以成为语句，但是这句话反过来说就不对了。也就是说，从语句中删除分号并不一定能将它转换为表达式。对于返回语句，声明语句和for语句都不满足这种情况</p><p>C++在C的基础上添加了一项特性，要求对for循环语句做一些微妙的调整，原来的语法：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">expression</span>; <span class="keyword">expression</span>; <span class="keyword">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></p><p>但是C++的for循环允许这样做：<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (int <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; <span class="number">5</span>; <span class="built_in">i</span>++)</span><br><span class="line">printf(<span class="string">"%d\n"</span>, <span class="built_in">i</span>);</span><br></pre></td></tr></table></figure></p><p>这很方便，但是不符合原来的语法，因为声明不是表达式。现在则使用下边的语句：<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">for</span>-init-statement <span class="keyword">condition</span>; <span class="keyword">expression</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></p><p>在for-init-statement中声明变量其实还有有用的一面，这也是该知道的。这种变量只存在与for循环中，当程序离开循环，这种变量将消失</p><p>在循环中经常使用递增运算符（++）和递减运算符（—）。这两种运算符执行两种极其常用的循环操作：将循环计数器加1或减1。这两个运算符都有两种变体。前缀版本位于操作数前面，如++x；后缀版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。粗略的讲a++意味着使用a的当前值计算表达式，然后将a的值加1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。</p><p>递增运算符和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于规则使用后修改和修改后使用可能会变得模糊不清。也就是说，下面这条语句在不同的系统上将生成不同的结果：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">x</span> = <span class="number">2</span> * x++ * (<span class="number">3</span> - ++x)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>对于这种语句，C++没有定义正确的行为</p><p>副作用是指在计算表达式时对某些东西进行了修改；顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保所有的副作用都进行了评估。在C++中语句中的分号就是一个顺序点，这意味着程序在处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。本章后边将讨论的有些操作也有顺序点。另外任何完整的表达式末尾都是一个顺序点。完整表达式是这样一个表达式：不是另一个更大表达式的子表达式</p><p>前缀格式和后缀格式的执行速度可能存在细微的差别，对于内置类型和当代的编译器而言，这看似不是什么问题。然而C++允许你针对类定义这些运算符，这种情况下，前缀格式的效率更高</p><p>可以将递增或递减运算符用于指针和基本变量。也可以结合使用这些运算符和*运算符来修改指针指向的值。前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。*++p的含义如下：先将++应用于pt，然后将*应用于被递增后的pt，另一方面++*pt意味着先取得pt指向的值，然后将这个值加1。(*p)++，圆括号指出首先对指针解除引用，然后再进行递增。*pt++后缀运算符++的优先级更高，这意味着将运算符应用于pt而不是*pt。</p><p>可以使用组合赋值运算符来进行赋值：</p><div class="table-container"><table><thead><tr><th>操作符</th><th>操作数（L为左操作数，R为右操作数）</th></tr></thead><tbody><tr><td>+=</td><td>将L+R赋值给L</td></tr><tr><td>-=</td><td>将L-R赋值给L</td></tr><tr><td>*=</td><td>将L*R赋值给L</td></tr><tr><td>/=</td><td>将L/R赋值给L</td></tr><tr><td>%=</td><td>将L%R赋值给L</td></tr></tbody></table></div><p>C++使用花括号来构造一条复合语句（代码块）。代码块由一对花括号和它们包含的语句组成，被视为一条语句，从而满足句法的要求</p><p>复合语句还有一个有趣的特性，如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完毕该语句块后，变量将被释放。</p><p>在外部语句块中定义的变量在内部语句块中也是被定义了的。</p><p>如果在一个语句块中声明一个变量，而外部语句块中也有一个这种名称的变量，在声明位置到内部语句块结束的范围内，新的变量将隐藏旧变量，然后旧变量再次可见</p><p>逗号表达式允许将两个表达式放到C++句法只允许放一个表达式的地方。逗号并不总是逗号运算符，在声明中的逗号是分隔符</p><p>逗号表达式还有其他特性。首先，它确保先计算第一个表达式，然后计算第二个表达式，即逗号运算符是一个顺序点；其次，C++规定逗号表达式的值是第二部分的值</p><p>C++提供了6种关系运算符来对数字进行比较：</p><div class="table-container"><table><thead><tr><th>操作符</th><th>含义</th></tr></thead><tbody><tr><td>&lt;</td><td>小于</td></tr><tr><td>&lt;=</td><td>小于或等于</td></tr><tr><td>==</td><td>等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&gt;=</td><td>大于或等于</td></tr><tr><td>!=</td><td>不等于</td></tr></tbody></table></div><p>关系运算符的优先级比算符运算符低</p><p>不要混淆等于运算符（==）与赋值运算符（=）</p><p>C风格字符串比较，不能直接使用等于运算符进行比较，这样比较的是两个字符串的地址。对于string类字符串，可以直接使用等于运算符进行比较</p><p>while循环是没有初始化和更新部分的for循环：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (test-condition)</span><br><span class="line"><span class="keyword">body</span></span><br></pre></td></tr></table></figure></p><p>while也是一种入口条件循环，因此如果测试条件一开始就是false，则程序将不会执行循环体</p><p>while循环和for循环可以进行相互转换；省略for循环中的测试表达式时，测试结果将为true</p><p>在设计循环时，记住如下的原则：</p><ul><li>指定循环终止的条件</li><li>在首次测试之前初始化条件</li><li>在条件再次被测试之前更新条件</li></ul><p>在循环中，不要使用错误的分号，如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; cnt);   <span class="comment">// 多了一个分号</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>C++为类型建立别名的方式有两种，一种是使用预处理器：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BYTE char</span></span><br></pre></td></tr></table></figure></p><p>这样程序将使用char替换BYTE<br>第二种方式是使用C++的关键字typedef<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> <span class="keyword">byte</span>; <span class="comment">// typedef type_name alias_name;</span></span><br></pre></td></tr></table></figure></p><p>使用define和使用typedef的区别在于，在声明一系列变量时，define不在有效</p><p>do while循环不同于for循环和while循环，它是出口条件循环。这意味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否继续执行循环。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span></span><br><span class="line"><span class="keyword">body</span></span><br><span class="line"><span class="keyword">while</span> (<span class="keyword">test</span>-expression);</span><br></pre></td></tr></table></figure></p><p>三种循环各有应用场景，需要合适选择</p><p>C++新增了基于范围的for循环。这简化了一种常见的循环任务：对数组或容器的每个元素执行相同的操作，后者提供了修改元素的方法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> x: v)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> &amp;x: v)</span><br><span class="line">&#123;</span><br><span class="line">  x = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>cin对象支持三种不同模式的单字符输入：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;<span class="comment">// 忽略空白</span></span><br><span class="line">ch = <span class="built_in">cin</span>.<span class="built_in">get</span>(); <span class="comment">// return char</span></span><br><span class="line"><span class="built_in">cin</span>.<span class="built_in">get</span>(ch);<span class="comment">// return istream</span></span><br></pre></td></tr></table></figure></p><p>可以使用文件尾条件（EOF）来表示输入的结束。检测到EOF后，cin将两位（eofbit和failbit）都设置为1，可以通过成员函数eof()来查看eofbit，如果eofbit或failbit被设置，fail函数返回true。eof和fail方法报告最近读取的结果，也就是说它们在事后报告，而不是预先报告。因此应将这两个测试放在读取后</p><p>istream提供了一个可以将istream转换为bool的函数，当cin出现在bool需要的地方时，该转换函数将被调用。如果最后一次读取成功，则转换得到的bool值为true；否则为false。因此输入可以如下：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.<span class="built_in">get</span>(ch))</span><br><span class="line">&#123;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>二维数组更像是一个表格——既有数据行又有数据列。</p><h1 id="分支语句和逻辑运算符"><a href="#分支语句和逻辑运算符" class="headerlink" title="分支语句和逻辑运算符"></a>分支语句和逻辑运算符</h1><p>if语句让程序能够决定是否执行特定的语句块<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if (<span class="name">test-condition</span>)</span><br><span class="line">statement</span><br></pre></td></tr></table></figure></p><p>if else语句让程序决定执行两条语句中的哪一个<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(test-condition)</span></span><br><span class="line">stateme<span class="symbol">nt1</span></span><br><span class="line">else</span><br><span class="line">stateme<span class="symbol">nt2</span></span><br></pre></td></tr></table></figure></p><p>if else中的两个操作必须都是一条语句，如果需要多条语句，则需要使用大括号将它们括起来，组成一个语句块</p><p>if else语句可以互相嵌套，组成多种选择</p><p>可以将variable == value转换成value == variable，以此来捕获将相等运算符误写为赋值运算符的错误</p><p>逻辑运算符分为逻辑或，逻辑与，逻辑非</p><p>C++可以采用逻辑或运算符(||)，将两个表达式组合起来。如果原来表达式中的任何一个或全部都为true，则得到的表达式的值为true；否则，表达式的值为false</p><p>||运算符的优先级低于算术运算符</p><p>C++规定，||是一个顺序点，也就是说先修改左边的值，再对右侧的值进行判定。当能够确定整个表达式的值时，就不再往下运算了，也就是说||运算符有短路特性</p><p>对于逻辑与，仅当所有的表达式都为true时，得到的表达式才为true</p><p>&amp;&amp;运算符的优先级低于算术运算符</p><p>和||运算符一样，&amp;&amp;运算符也是顺序点，同样&amp;&amp;也有短路特性</p><p>对于取值范围，不要写成3&lt;a&lt;5，这样不能正确表示范围，编译器不会捕获这种错误，因为它仍然是合法的C++语句</p><p>逻辑非(!)对它后边的表达式取反</p><p>C++逻辑与和逻辑或运算符的优先级低于算术运算符，!运算符的优先级高于所有的关系运算符和算术运算符。因此如果对表达式取反，必须使用括号将其括起来</p><p>编写复杂的逻辑表达式，还是加上括号，降低出现错误的可能性</p><p>C++确保程序从左到右进行计算逻辑表达式，并在知道答案后立刻停止</p><p>并不是所有键盘都提供了用作逻辑运算符的符号，因此C++标准提供了另一种表示方式。标识符and，or，not都是C++保留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们都是已有语言特性的另一种表示方式。另外它们不是C的保留字。但C语言可以将它们用作运算符，只要包含了iso646.h头文件，C++并不要求头文件</p><p>C++从C语言继承了一个与字符相关的、非常方便的函数软件包，可以简化确定字母，数字等的工作。函数原型在cctype中。使用这些函数更加通用，例如在有的系统上，可能字母并不是连续编码的</p><div class="table-container"><table><thead><tr><th>函数名称</th><th>返回值</th></tr></thead><tbody><tr><td>isalum()</td><td>如果参数是字母或数字，返回true</td></tr><tr><td>isalpha()</td><td>如果参数是字母，返回true</td></tr><tr><td>iscntrl()</td><td>如果参数是控制字符，返回true</td></tr><tr><td>isdigit()</td><td>如果参数是数字，返回true</td></tr><tr><td>isgraph()</td><td>如果参数是除空格外的打印字符，该函数返回true</td></tr><tr><td>islower()</td><td>如果参数是小写字母，返回true</td></tr><tr><td>isprint()</td><td>如果参数是打印字符(包括空格)，该函数返回true</td></tr><tr><td>ispunct()</td><td>如果参数是标点符号，返回true</td></tr><tr><td>isspace()</td><td>如果参数是标准空白符，如空格，进纸，换行符，回车，水平制表符，或者垂直制表符，返回true</td></tr><tr><td>issupper()</td><td>如果参数是大写字母，返回true</td></tr><tr><td>isxdigit()</td><td>如果参数是16进制数字，0-9，a-f,A-F，返回true</td></tr><tr><td>tolower()</td><td>如果参数是大写字母，则返回小写，否则返回该参数</td></tr><tr><td>toupper()</td><td>如果参数是小写字母，则返回大写，否则返回该参数</td></tr></tbody></table></div><p>C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符(?:)，它是C++中唯一一个需要3个操作数的运算符<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expressio<span class="symbol">n1</span>?expressio<span class="symbol">n2</span>:expressio<span class="symbol">n3</span>;</span><br></pre></td></tr></table></figure></p><p>如果expression1为true，则整个表达式的值为expression2，否则，表达式的值为expression3</p><p>switch语句提供了分支选择的另一种方法<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(integer expression)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="string">label1:</span> statement(s)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">label1:</span> statement(s)</span><br><span class="line">  <span class="keyword">case</span> <span class="string">label1:</span> statement(s)</span><br><span class="line">  ...</span><br><span class="line"><span class="symbol">  defaule:</span> statement(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序将跳到integer expression的值标记的那一行。integer expression必须是结果值为整数的表达式，每个标签必须是整数常量表达式。如果不匹配任何标签，则程序跳转到default的那一行。default是可选的，如果被省略，有没有匹配的标签，则程序直接跳转到switch后边的语句执行</p><p>跳转到switch语句中的标签后，将会依次执行后边的代码，除非有明确的其他指示，如break指令</p><p>如果既可以使用switch和if else，选项不少于3项时，则可以考虑使用switch</p><p>break和continue语句都能使程序跳过部分代码。可以在switch语句中使用break，使程序跳转到switch后执行语句。continue和break都可以用到循环中。break使程序跳出循环，continue使程序跳过本次循环，开始一个新的循环，其不会跳过更新表达式</p><p>C++使得将读取屏幕输入输出的技巧应用于文件输入输出中。</p><p>可以使用ifstream和ofstream类创建对象，关联到相应的文件，对文件进行读取和写入。类似于使用cin和cout对象</p><h1 id="函数——C-的编程模块"><a href="#函数——C-的编程模块" class="headerlink" title="函数——C++的编程模块"></a>函数——C++的编程模块</h1><p>使用函数，必须完成如下工作：</p><ul><li>提供函数定义</li><li>提供函数原型</li><li>调用函数</li></ul><p>函数可以分为有返回值的函数和没有返回值的函数<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">void func_name(parameter_list)</span><br><span class="line">&#123;</span><br><span class="line">  statement(s);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">type_name func_name(parameter_list)</span><br><span class="line">&#123;</span><br><span class="line">  statement</span><br><span class="line">  <span class="keyword">return</span> value;// value <span class="keyword">is</span> <span class="keyword">type</span> <span class="type">cast </span>to <span class="keyword">type</span> <span class="type">type_name</span></span><br><span class="line"><span class="type">&#125;</span></span><br></pre></td></tr></table></figure></p><p>对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。结果的类型必须是type_name类型或者可以被转换成type_name类型。C++的函数返回值不能是数组。</p><p>通常函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。</p><p>函数原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。通常在函数原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。</p><p>在C++中，括号为空与在括号中使用关键字void是等效的，但是在C中，括号意味着不指出参数——这意味着将在后边定义参数列表。但在C++中不指定参数列表时应使用省略号。</p><p>原型有以下几点作用：</p><ul><li>编译器正确的处理函数返回值</li><li>编译器检查使用的参数数目是否正确</li><li>编译器检查使用的参数类型是否正确，如果不正确，则转换成正确的类型(如果可能的话)</li></ul><p>C++通常按值传递参数。在函数中声明的变量(包括参数)是该函数私有的。C++标准用参数(argument)表示实参，使用参量(parameter)来表示形参。</p><p>在C++中当且仅当用于函数头或函数原型中，int *arr和int arr[]的含义才是相同的。</p><p>可以用const来声明一个指针常量，让指针指向一个常量对象，这样可以防止使用指针来修改所指向的值。但是指针本身是可以修改的，即指向另外的常量对象。如果只涉及一级间接关系，则可以将非const指针赋值给const指针，但是进入两级间接关系时，这种方式是不允许的。<br>在指针参数中，尽可能使用const，可以避免无意对数据的修改，使得能够处理const和非const参数<br>另一种是声明一个常量指针，即指针本身的指向是不能修改的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> p = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> **pp;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line">pp = &amp;p; 不允许，假设允许</span><br><span class="line">*pp = &amp;a; 合法，都是<span class="keyword">const</span>，但是将p设置为a的地址</span><br><span class="line">*p = <span class="number">1</span>; 合法，但是修改了<span class="keyword">const</span> a</span><br></pre></td></tr></table></figure></p><p>对于在参数中的二维数组或多维数组，必须指出除第一维的数组长度。否则，函数将无法处理。因为整个数组的指针是需要指定数组长度的</p><p>可以通过三种方式将C-风格字符串传递给函数：</p><ul><li>char数组</li><li>用引号括起来的字符串常量</li><li>被设置为字符串地址的char指针</li></ul><p>对于string字符串和模板类array，可以像使用基本类型一样使用。</p><p>使用结构作为参数时，可以像处理基本类型一样处理结构。然而，这种默认的按值传递结构的方式有一个缺点，如果结构比较大，则复制结构将增加内存消耗，我们可以通过传递结构指针来减少消耗。</p><p>C++函数可以调用自己(然而，与C语言不同的是C++不允许main函数调用自己)，这种功能被称为递归。递归需要在合适的条件下终止，否则函数将一直递归下去，直到耗尽内存。</p><p>与数据项相似，函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址。</p><p>函数名就是函数的地址。</p><p>通常，如果要声明函数指针，可以首先编写这种函数的原型，然后使用(*pf)替换函数名，这样pf就是这类函数的指针。优先级要求使用括号，才能定义正确的函数指针。</p><p>如果pf是函数指针，可以有两种方式调用该函数(*pf)()和pf()，其实其中存在着逻辑冲突。但是C++允许这两种语法同时存在。</p><p>函数指针数组：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int f()<span class="comment">;</span></span><br><span class="line">int (<span class="name">*pf</span>)()<span class="comment">;</span></span><br><span class="line">int (<span class="name">*pf_arr</span>[<span class="number">10</span>])()<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>可以使用typedef简化函数指针的定义<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> *(*pf)();</span><br><span class="line"><span class="function"><span class="keyword">int</span> *<span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">pf func = f;</span><br></pre></td></tr></table></figure></p><h1 id="函数探幽"><a href="#函数探幽" class="headerlink" title="函数探幽"></a>函数探幽</h1><h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>常规函数和内联函数的区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。</p><p>使用函数需要一定的开销。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈中，跳到标记函数起点的内存单元，执行函数代码，也许还要将返回值放入寄存器中，然后跳跃到地址被保存的指令处。对于内联函数，编译器将使用相应的函数代码替换函数调用。这样程序无需来回跳跃，执行速度稍快，代价是需要占用更多的内存。应有选择性的使用内联函数。</p><p>为了定义内联函数，我们必须在函数声明前或者函数定义前加上关键字inline。但是编译器不一定会满足这种需求。</p><p>在C语言中使用宏也可以实现类似的功能，但是宏只是文本替换，可能造成问题。</p><h2 id="引用变量"><a href="#引用变量" class="headerlink" title="引用变量"></a>引用变量</h2><p>引用是已定义的变量的别名。</p><p>必须在声明引用变量时进行初始化。引用实际上更接近const指针。</p><p>引用经常被作为函数参数，这种传递参数的方法叫做按引用传递。</p><p>引用变量作用函数参数，如果不需要修改参数的值，可以将其声明为const引用。</p><p>如果引用参数是const，则编译器将在下面两种情况下生成临时变量：</p><ul><li>实参的类型正确，但不是左值</li><li>实参的类型不正确，但可以转换为正确的类型</li></ul><p>左值参数是可以被引用的数据对象。常规变量和const变量都可以视为左值，一个可以被修改，一个不能被修改。</p><p>对于常量引用，将不会生成临时变量。如果是const引用参数，如果实参不匹配，则其行为类似于按值传递。</p><p>我们应尽可能的使用const：</p><ul><li>可以避免无意修改数据</li><li>可以处理const和非const实参</li><li>能够正确的生成并使用临时变量</li></ul><p>函数可以返回引用，其实际上是被引用变量的别名。应避免返回函数终止时不再存在的内存单元的引用。</p><p>返回引用类型的函数是左值，我们可以对其进行赋值，如果不希望这样做，可以将返回类型声明为const引用。但常规返回类型是右值，这种返回值位于临时内存单元中，运行到下一条语句，它们可能已经不存在了<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> = <span class="number">1</span>; <span class="comment">// 合法</span></span><br></pre></td></tr></table></figure></p><p>C风格字符串可以传递给const string引用。</p><p>对于集成的对象，基类的引用可以指向派生类对象，无需进行强制转换。</p><p>使用引用参数的原因主要有两个：</p><ul><li>能够修改调用函数中的数据对象</li><li>通过传递引用而不是整个数据对象，可以提高程序的运行速度</li></ul><p>对于使用传递的值而不做修改的函数：</p><ul><li>如果数据对象很小，如内置数据类型，则按值传递</li><li>如果数据对象是数组，则使用指针，这是唯一的选择，并将指针声明为指向const的指针</li><li>如果数据对象是较大的结构，则使用const指针或const引用，可以提高程序效率。节省复制结构所需的时间和空间</li><li>如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递</li></ul><p>对于修改调用函数中数据的函数：</p><ul><li>如果数据对象是内置数据类型，则使用指针。当然也可以使用引用</li><li>如果数据对象是数组，则只能使用指针</li><li>如果数据对象是结构，则使用指针或引用</li><li>如果数据对象是类对象，则使用引用</li></ul><h2 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h2><p>默认参数指的是当函数调用中省略了实参时自动使用的一个值。</p><p>通过函数原型来设置默认参数。对于带参数列表的函数，必须从右往左添加默认值。如果不指定实参，则使用默认值，如果指定实参，则使用实参的值。</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>函数重载可以使用多个同名的函数。其关键是函数的参数列表，也称为函数的特征标。</p><p>如果两个函数的参数的个数和类型相同，同时参数的排列顺序也相同，则它们的特征标相同。函数重载的条件是函数的特征标不同。</p><p>我们可以对引用参数进行重载：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> x = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> y = <span class="number">2.0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stove</span><span class="params">(<span class="keyword">double</span> &amp;r)</span></span>;<span class="comment">// 匹配可修改的左值，x</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span> &amp;r)</span></span>;<span class="comment">// 匹配const左值，y</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">stove</span><span class="params">(<span class="keyword">double</span> &amp;&amp;r)</span></span>;<span class="comment">// 匹配右值，x+y，如果没有定义，将匹配上一个函数</span></span><br></pre></td></tr></table></figure></p><p>仅当函数基本执行相同任务，但使用不同形式的数据时，才应该采用函数重载。</p><p>编译器对每个重载函数进行名称修饰，以此来定位每个重载的函数。</p><h2 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h2><p>函数模板是通用的函数描述，它使用泛型来定义函数，其中的泛型可以用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。</p><p>模板的一个用法是希望将一个算法应用到不同的数据类型中。例如排序算法。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// template &lt;class T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br></pre></td></tr></table></figure></p><p>在最终生成的代码里不包含模板，只包含实际生成的函数。</p><p>可以对模板定义进行重载，前提也是特征标不同。</p><p>编写的模板函数可能无法处理所有的类型。例如，可能有的类没有+运算符，但是我们在模板定义中使用了。一种解决方案是重载+号运算符，另一种是为特定类型提供具体化的模板定义。</p><p>我们可以对模板函数提供一个函数具体化的定义——称为显式具体化，其中包含所需要的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。<br>具体方法为：</p><ul><li>对于给定的函数名，可以有非模板函数，模板函数和显式具体化模板函数以及它们的重载版本</li><li>显式具体化的原型和定义应该以template&lt;&gt;开头，并通过名称来指出类型</li><li>具体化优先于常规模板，而非模板函数优先于具体化和常规模板</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一下两种方式都可以</span></span><br><span class="line"><span class="keyword">template</span> &lt;&gt; swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b);</span><br><span class="line"><span class="keyword">template</span> &lt;&gt; swap(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b);</span><br></pre></td></tr></table></figure><p>另外还必须理解实例化和具体化。在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。这种方式被称为隐式实例化，编译器通过函数调用来知道如何进行实例化。</p><p>现在C++还允许显式实例化。这意味着可以直接命令编译器创建特定的实例。声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="keyword">void</span> swap&lt;<span class="keyword">int</span>&gt;(<span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b);</span><br></pre></td></tr></table></figure></p><p>要区别显式具体化和显式实例化，前者并不生成函数定义。试图在同一个文件或抓换单元中使用同一种类型的显式实例和显式具体化将出错。</p><p>可以在程序中使用函数来创建显式实例化：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> m = <span class="number">1</span>;</span><br><span class="line">swap&lt;<span class="keyword">int</span>&gt;(x, m);</span><br></pre></td></tr></table></figure></p><p>隐式实例化，显式实例化，显式具体化统称为具体化。它们表示的都是使用具体类型的函数定义，而不是通用描述。</p><p>对于函数重载，函数模板和函数模板重载，C++需要一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。这个过程称为重载解析。</p><ul><li>第一步，创建候选函数列表。其中包含与被调函数的名称相同的函数和模板函数</li><li>第二步，使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。</li><li>第三步，确定是否有最佳的可行函数，如果有则使用它，否则该函数调用出错。</li></ul><p>为了确定是否有最佳的可行函数，需要查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，最佳到最差的顺序如下：</p><ul><li>完全匹配，但常规函数优于模板</li><li>提升转换(char转换为int或float转换为double)</li><li>标准转换(int转换为char，long转换为double)</li><li>用户定义的转换，如类声明中定义的转换</li></ul><p>进行完全匹配时，C++允许某些无关紧要的转换。Type本身可以是char &amp;这样的类型。Type(argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的</p><div class="table-container"><table><thead><tr><th>从实参</th><th>到形参</th></tr></thead><tbody><tr><td>Type</td><td>Type &amp;</td></tr><tr><td>Type &amp;</td><td>Type</td></tr><tr><td>Type []</td><td>*Type</td></tr><tr><td>Type(argument-list)</td><td>Type(*)(argument-list)</td></tr><tr><td>Type</td><td>const Type</td></tr><tr><td>Type</td><td>volatile Type</td></tr><tr><td>Type *</td><td>const Type</td></tr><tr><td>Type *</td><td>volatile Type*</td></tr></tbody></table></div><p>例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">f(a);</span><br><span class="line"><span class="comment">// 下面都是完全匹配的</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> &amp;)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (<span class="keyword">const</span> <span class="keyword">int</span> &amp;);</span><br></pre></td></tr></table></figure></p><p>有的时候即使两个函数都完全匹配，仍可以完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。在上面示例中，如果只定义了函数3和4，则使用函数3。这种区别只适用于指针和引用指向的数据，如果只定义了函数1和2，将出现二义性错误。</p><p>另一种情况是其中一个是非模板函数，而另一个不是。这种情况下非模板函数优先于模板函数(包括显式具体化)。如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如：显式具体化将优于使用模板隐式生成的具体化。</p><p>术语最具体不一定意味着显式具体化。而是指编译器推断使用哪种类型时执行的转换最少。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T t)</span></span>;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T *t)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">f(&amp;a);</span><br></pre></td></tr></table></figure></p><p>模板1将T解释为int <em>，模板2将T解释为int，因此两个隐式实例f&lt;int </em>&gt;(int <em>)和f<int>(int </int></em>)，后者被认为是更具体的，模板2已经指出函数参数时指向T的指针。</p><p>用于找出最具体模板的规则被称为函数模板的部分排序规则。</p><p>简而言之，重载解析将寻找最匹配的函数。如果只存在这样一个函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数；如果存在多个合适的函数，且它们都为模板函数，但其中一个函数比其他函数更具体，则选择该函数。如果有多个同样合适的非模板或模板函数，但没有一个函数比其他函数更具体，则函数调用时不确定的，因此是错误的。当然，如果不存在匹配的函数，则也是错误的。</p><p>我们也可以显式的指出需要使用模板函数，即使已经有匹配的非模板函数了。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a = <span class="number">0</span><span class="comment">;</span></span><br><span class="line">f&lt;&gt;(<span class="name">a</span>)<span class="comment">;</span></span><br><span class="line">f&lt;int&gt;(<span class="name">a</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。编译器必须考虑所有参数的匹配情况。如果找到比其他可行函数都合适的函数，则选择该函数。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数的匹配程度比其他函数都高</p><p>编写模板时，并不一定能知道使用的类型<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">template &lt;typename <span class="built_in">T1</span>, typename <span class="built_in">T2</span></span><br><span class="line">void f(<span class="built_in">T1</span> a, <span class="built_in">T2</span> <span class="keyword">b)</span></span><br><span class="line"><span class="keyword">&#123;</span></span><br><span class="line"><span class="keyword"> </span> type? c = a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">&#125;</span></span><br></pre></td></tr></table></figure></p><p>C++11提供了关键字decltype，给其的参数可以是表达式<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decltype<span class="comment">(a + b)</span> c = a + b;</span><br></pre></td></tr></table></figure></p><p>编译器一般通过如下方式确定类型：</p><ul><li>如果expression是一个没有用括号括起来的标识符，则类型与该标识符类型相同，包括const等限定符</li><li>如果expression是一个函数调用，则类型与函数的返回类型相同，这种情况并不会实际调用函数</li><li>如果expression是一个左值，则类型为指向其类型的引用。一种情况是expression是用括号括起来的标识符。括号并不会改变表达式的值和左值性</li><li>如果前面条件都不满足，则类型与expression的类型相同</li></ul><p>可以结合typedef和decltype<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type decltype(a + b) type;</span><br><span class="line">type c;</span><br></pre></td></tr></table></figure></p><p>另一中函数声明语法<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2</span><br><span class="line">? f(T1 a, T2 b)</span><br><span class="line"><span class="comment">// auto f(T1 a, T2 b) -&gt; decltype(a + b)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这种情况，并不能使用decltype解决，x，y并不在作用域内。<br>新增的语法可以用作声明和定义：<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">auto</span> f(int a, <span class="built_in">double</span> b) - &gt; <span class="built_in">double</span>;</span><br><span class="line"><span class="built_in">auto</span> func(<span class="built_in">double</span> a) -&gt; <span class="built_in">double</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="内存模型和名称空间"><a href="#内存模型和名称空间" class="headerlink" title="内存模型和名称空间"></a>内存模型和名称空间</h1><p>C++为在内存中存储数据方面提供了多种选择</p><h2 id="单独编译"><a href="#单独编译" class="headerlink" title="单独编译"></a>单独编译</h2><p>和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。我们可以单独编译这些文件，然后将这些文件链接起来。</p><p>我们一般可以将程序分为三部分：</p><ul><li>头文件：包含结构声明和使用这些结构的函数的原型</li><li>源代码文件：包含与结构有关的函数的代码</li><li>源代码文件：包含调用与结构相关的函数的代码</li></ul><p>在头文件中，我们一般包含如下内容：</p><ul><li>函数原型</li><li>使用#define或const定义的符号常量</li><li>结构声明</li><li>类声明</li><li>模板声明</li><li>内联函数</li></ul><p>通常我们需要保证一个头文件只包含一次。</p><h2 id="存储持续性、作用域和链接性"><a href="#存储持续性、作用域和链接性" class="headerlink" title="存储持续性、作用域和链接性"></a>存储持续性、作用域和链接性</h2><p>C++使用3种(在C++11中是4种)不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间：</p><ul><li>自动存储持续性：在函数定义中声明的包括参数的存储持续性为自动的</li><li>静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。</li><li>线程存储持续性(C++11)：我们使用关键字thread_local声明这种变量，其生命周期与所属的线程一样长</li><li>动态存储持续性：用new来分配，和delete来释放。也被称为堆或自由存储</li></ul><p>作用域描述了名称在文件中的多大范围可见。链接性描述了名称如何在不同单元间共享。链接性为外部的名称可以在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。</p><p>C++变量的作用于有多种，作用域为局部的变量只在定义它的代码块中可用。作用域为全局的变量在定义位置到文件结束之间都可用。在函数原型作用域中使用的名称只在包含参数列表的括号中可用。在类中声明的成员的作用域为整个类。在名称空间中声明的变量的作用域为整个名称空间。全局作用域是名称空间作用域的特例。</p><p>C++函数的作用域可以是整个类或整个名称空间(包括全局的)，但不能是局部的。不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。</p><h3 id="自动存储持续性"><a href="#自动存储持续性" class="headerlink" title="自动存储持续性"></a>自动存储持续性</h3><p>默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。如果代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块中。如果存在同名变量，则较小作用域的变量会覆盖较大作用域的变量。</p><p>C++11中的auto关键字用于自动类型推断。和之前的含义截然不同。C++11中的register关键字替代了之前的auto关键字，来指出变量是自动的，不再建议编译器使用CPU寄存器来存储自动变量。</p><p>自动变量一般存储在栈中，栈是LIFO。这种设计简化了参数传递，参数一般从右往左进入栈中，这样也实现了可变参数。</p><h3 id="静态存储变量"><a href="#静态存储变量" class="headerlink" title="静态存储变量"></a>静态存储变量</h3><p>静态存储变量有三种链接性：</p><ul><li>外部链接性，可在其他文件中访问，在代码块的外边声明它</li><li>内部链接性，只能在当前文件中访问，在代码块的外边声明它，并使用static限定符</li><li>无链接性，只能在当前函数或代码块中访问，在代码块中声明它，并使用static限定符</li></ul><p>这三种链接性都在整个程序执行期间存在。编译器分配固定的内存块来存储所有的静态变量。如果静态变量没有显示的初始化，编译器将把它设置为0。</p><p>所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0，这种变量被称为零初始化的。</p><div class="table-container"><table><thead><tr><th>存储描述</th><th>持续性</th><th>作用域</th><th>链接性</th><th>如何声明</th></tr></thead><tbody><tr><td>自动</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中</td></tr><tr><td>寄存器</td><td>自动</td><td>代码块</td><td>无</td><td>在代码块中，使用关键字register</td></tr><tr><td>静态，无连接性</td><td>静态</td><td>代码块</td><td>无</td><td>在代码块中，使用关键字static</td></tr><tr><td>静态，外部链接性</td><td>静态</td><td>文件</td><td>外部</td><td>不在任何函数中</td></tr><tr><td>静态，内部链接性</td><td>静态</td><td>文件</td><td>内部</td><td>不再任何函数中，使用关键字static</td></tr></tbody></table></div><p>除了默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。零初始化和常量表达式初始化被统称为静态初始化。这意味着在编译器处理文件时初始化变量。动态初始化意味着变量在编译后初始化。</p><p>C++11新增了关键字constexpr，这增加了创建常量表达式的方式。</p><h3 id="静态持续性、外部链接性"><a href="#静态持续性、外部链接性" class="headerlink" title="静态持续性、外部链接性"></a>静态持续性、外部链接性</h3><p>链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外定义的，因此对所有函数而言都是外部的。</p><p>单定义规则指出变量只能定义一次，C++提供了两种变量声明。一种是定义声明，简称定义，它给变量分配存储空间，另一种是引用声明，简称声明，它不给变量分配存储空间，它引用已有的变量；引用声明使用关键字extern，且不进行初始化，否则为定义。</p><p>单定义规则并不意味这不能定义相同名字的变量。因为定义可以被覆盖。</p><h3 id="静态持续性、内部链接性"><a href="#静态持续性、内部链接性" class="headerlink" title="静态持续性、内部链接性"></a>静态持续性、内部链接性</h3><p>将static限定符用于作用域为整个文件的变量时，该变量的链接性定义为内部的。我们不能在两个文件中分别定义同名的变量，这违反了单定义规则；但是一个内部静态变量能够隐藏在另一个文件中定义的外部静态变量。</p><h2 id="静态存储持续性、无链接性"><a href="#静态存储持续性、无链接性" class="headerlink" title="静态存储持续性、无链接性"></a>静态存储持续性、无链接性</h2><p>静态局部变量的值在程序运行期间一直存在，初始化只初始化一次。</p><h3 id="说明符和限定符"><a href="#说明符和限定符" class="headerlink" title="说明符和限定符"></a>说明符和限定符</h3><p>有些称为存储说明符或cv限定符的关键字提供了其他有关存储的信息。下边是存储说明符：</p><ul><li>auto，C++11中不再是说明符</li><li>register</li><li>static</li><li>extern</li><li>thread_local</li><li>mutable</li></ul><p>关键字mutable的含义将根据const来解释。cv限定符包含const和volatile。const我们已经介绍过了。volatile表明即使一个程序代码没有对内存单元进行修改，其值也可能发生变化，例如访问某些硬件。这样编译器就不会对这个变量进行特殊优化。</p><p>mutable指出即使结构或类为const，某个成员也可以被修改。</p><p>在C++中，但不是在C语言中，const限定符对默认存储类型稍有影响。在默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的。对于const变量，我们需要使用extern指出其链接性为外部的。</p><h3 id="函数和链接性"><a href="#函数和链接性" class="headerlink" title="函数和链接性"></a>函数和链接性</h3><p>函数的链接性可选的范围比变量小。默认情况下，函数的链接性为外部的，可以在文件间共享。对于函数来说extern关键字是可选的。使用关键字static来指出函数链接性为内部的，只能在当前文件中使用，必须同时在原型和函数定义中使用该关键字。</p><p>单定义规则也适用于非内联函数。内联函数不受这个规则的约束，我们允许将内联函数定义在头文件中。要求所有内联函数的定义都必须相同。</p><h3 id="语言链接性"><a href="#语言链接性" class="headerlink" title="语言链接性"></a>语言链接性</h3><p>语言链接性对函数也有影响。链接程序要求每个不同的函数都有不同的符号名。C语言中，一个名称只对应一个函数，因此这很容易实现，编译器可能将func这样的函数翻译为_func。这被称为C语言链接性。但在C++中，函数重载导致一个名称对应多个函数，我们需要为这些函数生成不同的名称，例如加上参数列表的类型信息，这被称为C++语言链接性。这就导致了链接程序寻找函数时的方法不同。如果要在C++中使用C库中预编译的函数，我们可以使用函数原型来指出希望的约定：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// c</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>)</span></span>;<span class="comment">// c++</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C++"</span> func(<span class="keyword">int</span>);  <span class="comment">// c++</span></span><br></pre></td></tr></table></figure></p><h3 id="存储方案和动态分配"><a href="#存储方案和动态分配" class="headerlink" title="存储方案和动态分配"></a>存储方案和动态分配</h3><p>对于new或malloc分配的内存，我们有自己控制这些内存生存周期的能力。</p><p>new和delete将被转换为对应的函数，我们可以提供自己的函数来替换现有的new函数</p><p>new还提供一种变体，被称为定位new运算符。我们能够指定存放的位置。我们必须包含new头文件。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> <span class="built_in">buffer</span>[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="keyword">new</span> (<span class="built_in">buffer</span>)<span class="keyword">int</span>[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p><p>定位new运算符并不跟踪哪些内存已经被使用，两次使用将返回相同的地址，先前的数据将被覆盖。我们不能使用delete来释放这些内存。</p><p>对于定位new函数，我们不可以替换，但可以进行重载。</p><h2 id="名称空间"><a href="#名称空间" class="headerlink" title="名称空间"></a>名称空间</h2><p>C++提供的名称空间工具，可以更好的控制名称的作用域。</p><h3 id="传统的C-名称空间"><a href="#传统的C-名称空间" class="headerlink" title="传统的C++名称空间"></a>传统的C++名称空间</h3><p>声明区域是可以进行声明的区域。潜在作用域从声明点开始，到其声明区域的结尾。变量在潜在作用域内并不一定都是可见的。</p><p>C++可以通过定义一种新的声明区域来创建命名的名称空间，提供一个声明名称的区域。名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。在默认情况下，名称空间中声明的名称的链接性是外部的，除非它引用了常量。存在一个全局名称空间，它对应于文件声明区域，全局变量在这个名称空间中。</p><p>任何名称空间中的名称不会与其他名称空间中的名称发生冲突。我们使用作用域解析运算符::来使用名称空间中的名称。</p><p>同样我们也可以使用using声明或using编译指令来简化对名称空间的使用。前者是特定标识符可用，后者使整个名称空间可用。</p><p>using声明将特定的名称添加到它所属的声明区域中。</p><p>using声明和using编译指令是不一样的，使用using声明就好像是声明了相应的名称一样，如果一个名称已经在函数中声明了，则不能再使用using声明导入相同的名称。然而使用using编译指令将进行名称解析，局部变量将隐藏名称空间版本的同名变量。</p><p>名称空间可以进行嵌套，也可以在名称空间中使用using声明和using编译指令。using编译指令是可传递的。还可以对名称空间创建别名：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">test</span> = other_namespace;</span><br></pre></td></tr></table></figure></p><p>我们可以创建未命名的名称空间，其中的名称的潜在作用域为从声明点到该声明区域末尾。这提供了链接性为内部的静态变量的替代品。</p><h3 id="指导原则"><a href="#指导原则" class="headerlink" title="指导原则"></a>指导原则</h3><p>对于名称空间，下面是指导原则：</p><ul><li>使用在已命名的名称空间中声明的变量，而不是使用外部全局变量</li><li>使用在已命名的名称空间中声明的变量，而不是使用静态全局变量</li><li>如果开发了一个函数库，将其放在一个名称空间中</li><li>谨慎使用using编译指令</li><li>不要在头文件使用using编译指令</li><li>导入名称时，首先使用作用域解析运算符或using声明的方法</li><li>对于using声明，首选将其作用域设置为局部而不是全局</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;循环和关系表达式&quot;&gt;&lt;a href=&quot;#循环和关系表达式&quot; class=&quot;headerlink&quot; title=&quot;循环和关系表达式&quot;&gt;&lt;/a&gt;循环和关系表达式&lt;/h1&gt;&lt;p&gt;for循环为执行重复的操作提供了循序渐进的步骤。for循环的组成部分完成下面这些步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置初始值&lt;/li&gt;
&lt;li&gt;执行测试，看看循环是否应该继续执行&lt;/li&gt;
&lt;li&gt;执行循环操作&lt;/li&gt;
&lt;li&gt;更新用于测试的值&lt;figure class=&quot;highlight mel&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (initialization; test-&lt;span class=&quot;keyword&quot;&gt;expression&lt;/span&gt;; update-&lt;span class=&quot;keyword&quot;&gt;expression&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	body&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C++ 语法将for看做一条语句，——虽然循环体可以包括一条或多条语句。循环只执行一次初始化，测试表达式决定循环体是否被执行，通常，这个表达式是关系表达式，即对两个值进行比较。这里可以使用任何表达式，C++将把结果强制转换为bool类型。&lt;/p&gt;
&lt;p&gt;for循环是入口条件循环，这意味着在每轮循环之前，都将计算测试表达式得值，当测试表达式为false时，将不会执行循环体。&lt;/p&gt;
&lt;p&gt;更新表达式在每轮循环结束时执行，此时循环体已经执行完毕。通常，它用来对跟踪循环次数的变量的值进行递增。&lt;/p&gt;
&lt;p&gt;for循环的控制部分使用了3个表达式，任何值或任何有效的值和运算符的组合都是表达式。赋值也是一个表达式，C++将赋值表达式的值定义为左侧成员的值。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://blog.gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>Cpp Primer Plus读书笔记（一）</title>
    <link href="https://blog.gwq5210.com/2017/07/02/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://blog.gwq5210.com/2017/07/02/Cpp-Primer-Plus读书笔记（一）/</id>
    <published>2017-07-02T21:25:04.000Z</published>
    <updated>2021-09-13T08:00:57.708Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一章-预备知识"><a href="#第一章-预备知识" class="headerlink" title="第一章 预备知识"></a>第一章 预备知识</h1><h2 id="C-简介"><a href="#C-简介" class="headerlink" title="C++简介"></a>C++简介</h2><p>C++融合了三种不同的编程方式：</p><ul><li>C语言代表的过程性语言</li><li>以类为代表的面向对象于艳</li><li>模板支持的泛型编程</li></ul><h2 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h2><p>面向对象编程(OOP)强调的是数据。理念是设计与问题本质特性相对应的数据格式。</p><h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2><p>泛型编程强调编程要独立于特定数据类型，即创建独立于类型的代码。</p><h2 id="C与C"><a href="#C与C" class="headerlink" title="C与C++"></a>C与C++</h2><p>C++是C的超集，尽管有一些细微差别，但这种差别很小。</p><a id="more"></a><h1 id="第二章-开始学习C"><a href="#第二章-开始学习C" class="headerlink" title="第二章 开始学习C++"></a>第二章 开始学习C++</h1><h2 id="进入C"><a href="#进入C" class="headerlink" title="进入C++"></a>进入C++</h2><p>C++提供了不同于C的输入输出工具，内置的cin和cout对象，使用它们需要包含头文件iostream。</p><p>main函数通常被启动代码调用，启动代码是编译程序加入到程序当中的。</p><p>如果main函数没有指明返回语句，则认为return 0;是返回语句。</p><p>C++提供两种注释的方式//(C++)或/**/(C)。C99标准在C语言中加入了//注释。</p><p>#include编译指令会让预处理器添加指定文件内容到程序中。</p><p>不同的头文件名可被不同的程序使用。</p><div class="table-container"><table><thead><tr><th>头文件类型</th><th>约定</th><th>示例</th><th>说明</th></tr></thead><tbody><tr><td>C++旧式风格</td><td>以.h结尾</td><td>iostream.h</td><td>C++程序可以使用</td></tr><tr><td>C旧式风格</td><td>以.h结尾</td><td>math.h</td><td>C,C++程序可以使用</td></tr><tr><td>C++新式风格</td><td>没有扩展名</td><td>iostream</td><td>C++程序可以使用，使用namespace std</td></tr><tr><td>转换后的C</td><td>加上前缀c，没有扩展名</td><td>cmath</td><td>C++程序可以使用，可以使用不是C的特性，如namespace std</td></tr></tbody></table></div><p>C++中可以使用命名空间来避免名字冲突。可以使用using编译指令来使用命名空间中的函数或类对象。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cin</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>cout中，可以使用endl和”\n”表示换行符。不同的是endl确保程序继续运行前刷新输出，使用”\n”不能提供这样的保证。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello World!\n"</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Hello world!"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>尽量遵循好的C++代码风格，程序会便于阅读。</p><h2 id="C-语句"><a href="#C-语句" class="headerlink" title="C++语句"></a>C++语句</h2><p>变量在使用前必须进行声明，通常是为了指出要存储的类型和程序对存储在这里的数据使用的名称。</p><p>对于声明变量，C++的做法是尽可能在首次使用变量前声明它。</p><p>cout可以根据变量的类型相应的调整行为。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="number">12</span> &lt;&lt; <span class="string">"12"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d %s\n"</span>, <span class="number">12</span>, <span class="string">"12"</span>);</span><br></pre></td></tr></table></figure></p><p>类描述了一种数据类型的全部属性(包括可使用它执行的操作)，对象是根据这些描述创建的实体。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>C++程序应当为程序中使用的每个函数提供原型。</p><p>不要混淆函数原型和函数定义。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int <span class="function"><span class="keyword">fun</span>();</span></span><br><span class="line"><span class="function"><span class="title">int</span></span> <span class="function"><span class="keyword">fun</span>()</span></span><br><span class="line"><span class="function">&#123;</span></span><br><span class="line"><span class="function">  <span class="title">return</span></span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>函数可以有返回值和无返回值。无返回值的函数用void来标识。</p><p>函数的格式为：<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> functionname(argumentlist)</span><br><span class="line">&#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="第三章-处理数据"><a href="#第三章-处理数据" class="headerlink" title="第三章 处理数据"></a>第三章 处理数据</h1><h2 id="简单变量"><a href="#简单变量" class="headerlink" title="简单变量"></a>简单变量</h2><p>在程序中，为了存储信息，必须记录三个基本属性：</p><ul><li>信息将存储在哪里</li><li>要存储什么值</li><li>存储何种类型的信息</li></ul><p>声明变量恰好记录了这些信息。</p><h3 id="变量名"><a href="#变量名" class="headerlink" title="变量名"></a>变量名</h3><p>C++变量名必须遵循如下规则，并尽量使用有意义的变量名：</p><ul><li>在名称中只能使用字母字符，数字和下划线(_)</li><li>名称的第一个字符不能是数字</li><li>区分大写字符与小写字符</li><li>不能将C++关键字用作名称</li><li>一两个下划线或下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)使用。以一个下划线开头的名称被保留给实现，用作全局标识符。违反这一点并不会导致编译器错误，但可能会导致行为的不确定性。</li><li>C++对名称没有长度限制，名称中的所有字符都有意义，但有些平台有长度限制。C99标准只保证名称中的前63个字符有意义</li></ul><h3 id="整形"><a href="#整形" class="headerlink" title="整形"></a>整形</h3><p>语言只能表示所有整数的子集。C++提供多种不同的整型，以便根据程序具体要求选择最合适的整型</p><p>C++的基本整型分别是char、short、int、long和C++ 11新增的long long，其中每种类型都有有符号版本和无符号版本</p><p>C++对整型提供了灵活的标准，确保整型的最小长度</p><ul><li>short至少16位</li><li>int至少与short一样长</li><li>long至少32位，且至少与int一样长</li><li>long long至少64位，且至少与long一样长</li></ul><p>实际上，short是short int的简称，long是long int的简称</p><p>sizeof运算符返回类型或变量的长度，单位为字节<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span> a &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 变量可以这样写，类型必须加括号</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(a) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">int</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><p>头文件climits(limits.h)定义了符号常量来表示类型的限制</p><div class="table-container"><table><thead><tr><th>符号常量</th><th>表示</th></tr></thead><tbody><tr><td>CHAR_BIT</td><td>char的位数</td></tr><tr><td>CHAR_MAX</td><td>char的最大值</td></tr><tr><td>CHAR_MIN</td><td>char的最小值</td></tr><tr><td>SCHAR_MAX</td><td>signed char的最大值</td></tr><tr><td>SCHAR_MIN</td><td>signed char的最小值</td></tr><tr><td>UCHAR_MAX</td><td>unsigned char的最大值</td></tr><tr><td>SHRT_MAX</td><td>short的最大值</td></tr><tr><td>SHRT_MIN</td><td>short的最小值</td></tr><tr><td>USHRT_MAX</td><td>unsigned short的最大值</td></tr><tr><td>INT_MAX</td><td>int的最大值</td></tr><tr><td>INT_MIN</td><td>int的最小值</td></tr><tr><td>UINT_MAX</td><td>unsigned int的最大值</td></tr><tr><td>LONG_MAX</td><td>long的最大值</td></tr><tr><td>LONG_MIN</td><td>long的最小值</td></tr><tr><td>ULONG_MAX</td><td>unsigned long的最大值</td></tr><tr><td>LLONG_MAX</td><td>long long的最大值</td></tr><tr><td>LLONG_MIN</td><td>long long的最小值</td></tr><tr><td>ULLONG_MAX</td><td>unsigned long long的最大值</td></tr></tbody></table></div><p>C++支持类似C的符号常量，其进行简单的字符串替换。C++还提供了const来定义符号常量</p><p>C++提供了不同于C的初始化方式：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">b</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">int</span> c&#123;<span class="number">2</span>&#125;;<span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">int</span> d = &#123;<span class="number">3</span>&#125;;<span class="comment">// C++ 11</span></span><br><span class="line"><span class="keyword">int</span> e = &#123;&#125;;<span class="comment">// set to 0</span></span><br><span class="line"><span class="keyword">int</span> f&#123;&#125;;<span class="comment">// set to 0</span></span><br></pre></td></tr></table></figure></p><p>无符号类型整数不能存储负数，但可以增大变量能够存储的整数的最大值</p><p>C++确保无符号整数溢出时会取范围另一端的值，但并不保证有符号整数超越限制(上溢和下溢出)时不出错，而这正是当前实现中最为常见的行为</p><p>通常int被设置为对目标计算机而言最“自然”的长度，自然长度是只计算机处理起来效率最高的长度，如果没有非常有说服力的理由选择其他类型，则应使用int。其他根据具体取值范围来选择整数类型</p><p>整型字面值(常量)是显式书写的常量。C++同C一样能以三种不同的方式来书写整数：基数为10，基数为8，基数为16。C++使用前一(两)位来标识数字常量的基数。如果第一位为1-9，则基数为10；如果第一位为0，第二位为1-7，则基数为8；如果前两位为0x或0X，则基数为16</p><p>C++通过后缀，长度来确定常量的类型。除非有理由(使用了后缀或值超出int存储范围)存储为其他类型，否则C++就将整数常量存储为int。</p><p>后缀是放在数字常量后的字母，用于表示类型。l或L表示long，u或U表示unsigned int，ul(可以采用任何一种顺序，大小写均可)表示unsigned long(由于l看起来像1，推荐使用大写L后缀)。C++提供了用于表示long long的后缀ll或LL，还提供了用于表示unsigned long long的后缀ull，Ull，uLL，ULL</p><p>对于长度，C++中，对10进制整数采用的规则与16进制和8进制稍有不同。对于不带后缀的十进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、long或long long。对于不带后缀的16进制或8进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、unsigned int、long、unsigned long、long long或unsigned long long</p><p>char类型是专为存储字符而设计的，编程语言将字符存储为数值，实际上char类型是一种整型，可以当做比short更小的整型</p><p>char字面值有两种表示方式：直接单引号括起来的单个字符，如’a’；使用转义字符表示的特殊字符，如’\n’</p><p>与int类型不同，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++的实现来决定，但可以显式的指定char为有符号或无符号，这在把char当做数值类型是就十分重要</p><p>bool类型的值可以为true或false，分别表示真假。字面值true和false都可以通过提升转化为int类型。任何数字值或指针值都可以被隐式转换为bool值</p><p>C++中可以使用const来修改变量声明和初始化，创建一个符号常量。其被初始化后，编译器就不允许修改该常量的值。如果在定义常量是没有初始化值，则该常量的值是不确定的，且无法修改<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const<span class="built_in"> type </span>name = value;</span><br></pre></td></tr></table></figure></p><h3 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h3><p>浮点数可以用来表示小数，浮点数有两种表示：一是常用的标准小数点表示，如8.2等；二是E表示法，如3.45E6表示3.45与1000000相乘的结果，指数为负表示除以10的乘方。E表示法确保数字以浮点格式存储。</p><p>有三种浮点类型：float、double和long double。C和C++对有效位数(数字中有意义的位数)的要求分别是：至少32位，至少48位且不少于float，long double至少和double一样多。可以从cfloat头文件获取这些类型的相关限制。</p><p>默认情况下的浮点常量存储为double，如果想使用float存储，请加f或F后缀</p><p>浮点数由于精度有限，在计算时可能会出现错误</p><p>signed char，short，int和long统称为符号整型；它们的无符号版本统称为无符号整型；C++ 11新增了long long。bool、char、wchar_t、符号整型和无符号整型统称为整型；C++ 11新增了char16_t和char32_t。float，double和long double统称为浮点型。整型和浮点型统称为算术类型</p><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>C++提供了5中基本算术运算：+、-、*、/、%</p><ul><li>对于除法，如果两个操作数都是整数，则结果为商的整数部分</li><li>对于取模，两个操作数必须是整数，如果其中一个是负数，结果符合如下规则：(a/b)*b+a%b=a</li><li>为了完成复杂的运算，需要规定运算符的优先级和结合性。*和/的优先级高于+和-。+，-，*，/都是从做到右结合的。从左到右的结合性意味着如果优先级相同的操作符被同时作用于同一个操作数，则首先计算左侧的操作符。从右到左亦然。</li></ul><p>对于如下表达式，程序必须在做加法前计算乘法，但并没有指出先计算哪个乘法，这取决于实现。结合性在这里不起作用，因为两个乘号没有作用到同一个操作数<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">20</span>*<span class="number">5</span>+<span class="number">24</span>*<span class="number">6</span></span><br></pre></td></tr></table></figure></p><p>C++自动执行多种类型转化：</p><ul><li>将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换</li><li>表达式中包含不同类型的类型时，C++将对值进行转换</li><li>将参数传递给函数时，C++将对值进行转换</li></ul><p>初始化和赋值进行的转换有可能会丢失数值或损失精度</p><p>以{}方式进行的初始化，不允许缩窄</p><p>在表达式中，有两种转换：一些类型在出现时就会自动转换，有些类型在与其他类型同时出现在表达式中时将被自动转换</p><p>在计算表达式时，C++将bool，char，unsigned char，signed char和short值转换为int<br>如果short比int短，则unsigned short类型被转换成int，如果两种类型长度相同，则unsigned short转换为unsigned int，这确保转换时不会丢失数据，同样wchar_t被提升为下列类型中第一个宽度足够的类型：int，unsigned int，long或unsigned long</p><p>不同类型进行计算时也会进行转化：</p><ul><li>如果有一个操作数类型为long double，则将另一个操作数转换为long double</li><li>否则，如果有一个操作数类型为double，则将另一个操作数转换为double</li><li>否则，如果有一个操作数类型为float，则将另一个操作数转换为float</li><li>否则，说明操作数都是整型，则执行整型提升</li><li>在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数级别比另一个低，则转换为较高的类型</li><li>如果一个操作数为有符号的，另一个操作数为无符号的，且无符号数的级别比有符号数的级别高，则将有符号数转换为无符号操作数对应的类型</li><li>否则，如果有符号类型可表示无符号类型的所有可能值，则将无符号操作数转换为有符号操作数的类型</li><li>否则，将两个操作数都转换为有符号类型的无符号版本</li></ul><p>注：传统C总是将float提升为double，即使两个操作数都是float</p><p>传递参数时的类型转换通常由C++函数原型控制，然而也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short(signed和unsigned)应用整型提升。另外为保持传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double</p><p>C++允许强制类型转换：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(type_name)value <span class="comment">// C</span></span><br><span class="line"><span class="function"><span class="title">type_name</span><span class="params">(value)</span></span> <span class="comment">// C++</span></span><br></pre></td></tr></table></figure></p><p>在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器把变量的类型设置成与初始值相同</p><h1 id="第四章-复合类型"><a href="#第四章-复合类型" class="headerlink" title="第四章 复合类型"></a>第四章 复合类型</h1><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种数据格式，能够存储多个同类型的值</p><p>要创建数组，可使用声明语句，数组声明应指出一下三点：</p><ul><li>存储在每个元素中的值的类型</li><li>数组名</li><li>数组中的元素数</li></ul><p>array_size指定元素数目，它必须是整型常数或const值，也可以是常量表达式，其中的值在编译时必须已知<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name array_name[array_size]<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>数据的下标从0开始编号，编译器并不会检查使用下标的有效性</p><p>只有在定义数组时才能使用数组初始化，以后就不能使用了，不能将一个数组赋值给另一个数组<br>初始化数组时，提供的值可以少于数组的元素数目，编译器将其他元素设置为0<br>初始化时，方括号内为空，C++编译器将计算元素个数<br>C++ 11提供的列表初始化{}可以省略等号；大括号内不包含任何东西，则将所有元素设置为0；列表初始化进制缩窄<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int a[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">int b[<span class="number">4</span>];</span><br><span class="line">int c[<span class="number">4</span>] = &#123;<span class="number">1</span>&#125;; <span class="comment">// 1,0,0,0</span></span><br><span class="line">int d[<span class="number">4</span>] = &#123;<span class="number">0</span>&#125;;<span class="comment">// 0,0,0,0</span></span><br><span class="line">int e[<span class="number">4</span>] = &#123;&#125;;</span><br></pre></td></tr></table></figure></p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>C-风格字符串以空字符结尾，空字符写为\0，ASCII值为0，用来标记字符串的结尾<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">4</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>&#125;;<span class="comment">// not a string</span></span><br><span class="line"><span class="keyword">char</span> b[<span class="number">4</span>] = &#123;<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'\0'</span>&#125;;<span class="comment">// a string</span></span><br><span class="line"><span class="keyword">char</span> c[<span class="number">4</span>] = <span class="string">"abc"</span>;</span><br></pre></td></tr></table></figure></p><p>用引号括起来的字符串隐式的包括结尾的空字符，这种表示方式成为字符串字面值</p><p>确定存储字符串需要的最短数组时，不要忘记将结尾的空字符计算在内</p><p>字符串常量不能与字符常量互换，即’s’和”s”表示不同的含义。后者表示s和\0两个字符组成的字符串</p><p>任何两个由空白分割的字符串常量都将自动拼接成一个字符串常量，拼接时不会再字符串之间添加空格</p><p>cin使用空白来确定字符串的结束位置，并不能读取包含空白的一行字符串</p><p>cin提供的成员函数getline(char *arr, int size)提供读取一行的能力，它通过回车来确定输入结尾，但不保存换行符（用空字符来替换换行符）。getline最多读取size-1或遇到换行符结束，会在结尾自动添加空字符。</p><p>get()方法提供了另外一种读取行的方式，该方法有几种变体。与getline不同的是get不再读取并丢弃换行符，而是将其保留在输入对列中。使用不带参数的get函数可以读取一个字符</p><p>getline使用起来更简单，get使得错误检查更简单。更多介绍请参考C++手册</p><h2 id="string类简介"><a href="#string类简介" class="headerlink" title="string类简介"></a>string类简介</h2><p>string使用来比数组简单，同时提供了将字符串作为一种数据类型的方法，更多介绍可参考C++手册</p><p>C++新增了另一种类型的原始字符串，原始字符串使用“(和)”来界定边界，并使用前缀R来标识原始字符串<br>在原始字符串中按回车键不仅会移动到下一行，还将在原始字符串中添加回车符<br>还可以在界定符”(或)”的两个字符之间添加相同的其他字符，来标识结尾，这样可以在原始字符串中添加)”这样的字符<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">R"(nihao\n)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; R<span class="string">"(nihao\n</span></span><br><span class="line"><span class="string">)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">R"a(nihao\n)a"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h2 id="结构简介"><a href="#结构简介" class="headerlink" title="结构简介"></a>结构简介</h2><p>结构是一种更加灵活的数据格式，同一个结构可以存储多种类型的数据。结构是用户自定义的类型，定义了类型后，便可以创建这种类型的变量</p><p>C++允许在声明结构变量时省略struct关键字</p><p>结构声明的位置很重要，可以将声明放在函数中，这样这个结构只能在本函数中使用。放在函数外的声明称为外部声明，外部声明可以被其后的任何函数使用</p><p>C++支持使用列表初始化的方式初始化结构变量，等号是可选的，如果大括号内为空，则各个成员被初始化为0，且不允许缩窄</p><p>结构变量可以进行赋值</p><p>可以声明结构数组，数组中每个元素都是该结构类型的变量</p><p>与C一样，C++允许指定占用特定位数的结构成员，字段的类型应为整型或枚举，接下来是冒号，后跟着一个数字，表示使用的位数。可以使用没有名字的字段来提供间距<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">struct</span> <span class="string">torgle_register</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line">  <span class="attr">unsigned int SN:</span> <span class="number">4</span><span class="string">;</span></span><br><span class="line">  <span class="attr">unsigned int :</span> <span class="number">4</span><span class="string">;</span></span><br><span class="line">  <span class="attr">bool flag:</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line">  <span class="attr">bool retry:</span> <span class="number">1</span><span class="string">;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">torgle_register</span> <span class="string">tr</span> <span class="string">=</span> <span class="string">&#123;14,</span> <span class="literal">true</span><span class="string">,</span> <span class="literal">true</span><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure></p><h2 id="共用体"><a href="#共用体" class="headerlink" title="共用体"></a>共用体</h2><p>共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，共用体的语法与结构类似，但含义不同</p><p>匿名共用体没有名称，其成员将成为位于同地址处的变量，每次只有一个成员是当前的成员<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">widget</span></span></span><br><span class="line">&#123;</span><br><span class="line">  int <span class="keyword">type</span>;</span><br><span class="line">  <span class="class"><span class="keyword">union</span></span></span><br><span class="line">  &#123;</span><br><span class="line">    long id_num;</span><br><span class="line">    char id_char[<span class="number">20</span>];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line">widget price;</span><br><span class="line"><span class="keyword">if</span> (price.<span class="keyword">type</span>)</span><br><span class="line">&#123;</span><br><span class="line">  cin &gt;&gt; price.id_num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  cin &gt;&gt; price.id_char</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;<span class="title">red</span>, <span class="title">green</span>, <span class="title">yellow</span>&#125;;</span></span><br></pre></td></tr></table></figure></p><p>这样color成为枚举类型，大括号中的名称作为符号常量，它们对应0-2，这些常量叫做枚举量</p><p>在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举常量赋值给这中枚举变量</p><p>对于枚举只定义了赋值运算符。枚举是整型，可被提升为int类型，但int类型不能自动转换为枚举类型</p><p>如果试图将不适当的值强制类型转换赋值给枚举变量，结果将是不确定的</p><p>枚举更常被用来定义符号常量，而不是定义新类型，如果不创建枚举类型，则可以省略枚举类型的名称</p><p>枚举的值可以显式指定，red默认为0，后边没有初始化的将比前一个大1，orange为7<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;<span class="built_in">red</span>, <span class="built_in">green</span> = <span class="number">4</span>, yellow = <span class="number">6</span>, orange&#125;;</span><br></pre></td></tr></table></figure></p><p>每个枚举都有取值范围，通过强制类型转化，可以将取值范围内的任何整数值赋给枚举变量，即使这个值不是枚举值</p><p>取值范围定义如下，首先找出上限，需要知道枚举的最大值，找到大于这个最大值的，最小的2的幂，将它减去1，这个值就是范围的上限。要计算下限，需要知道枚举常量的最小值，如果它不小于0，则取值范围的下限为0；否则，采用寻找上限方式相同的方式，但加上负号。如果最小的枚举值是-6，而比它小的，最大的2的幂是-8(加上负号)，因此下限为-7</p><h2 id="指针和自由存储空间"><a href="#指针和自由存储空间" class="headerlink" title="指针和自由存储空间"></a>指针和自由存储空间</h2><h3 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h3><p>指针是一个变量，其存储的是值的地址</p><p>对于常规变量，在变量名前加地址运算符(&amp;)，就可以获得它的位置</p><p>cout在显示地址时，使用16进制表示法</p><p>使用常规变量时，值是指定的量，地址是派生量。指针策略刚好相反，将地址视为指定的量，而将值视为派生量。指针用于存储值的地址</p><p>*运算符被成为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值</p><p>C++中，int *是一种复合类型，是指向int的指针，也可以声明其他类型的指针</p><p>指针和指针指向的值是不同的概念，它们的长度可能不同</p><p>在指针声明中可以初始化指针，被初始化的是地址，而不是指针指向的值</p><p>使用为初始化的指针，可能导致严重的运行时错误。一定要在对指针应用解除引用运算符前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律</p><p>指针和整型是截然不同的类型，不能将int类型直接赋值给指针类型，而要通过强制类型转换来进行赋值</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>指针的真用用武之地是在运行阶段分配未命名的内存以存储值。这种情况只能通过指针来访问内存。</p><p>在C语言中可以使用库函数malloc来分配内存，在C++中仍然可以这样做，但C++提供了更好的方法——new运算符</p><p>new运算符的使用格式如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type_name *pointer_name = <span class="keyword">new</span> <span class="type">type_name</span>;</span><br></pre></td></tr></table></figure></p><p>需要再两个地方制定数据类型，用来指定需要什么类型的内存和声明什么类型的指针</p><p>new分配的内存块通常与常规变量声明分配的内存块不同，一个在堆中分配，一个在栈中分配</p><p>当内存使用完成时，使用delete运算符能够将其归还给内存池，归还后的内存可供程序的其他部分使用，一定要配对的使用new和delete，否则将发生内存泄露</p><p>不要尝试释放已经释放的内存块，这种结果是不确定的，不能使用delete来释放声明变量获得的内存，对空指针使用delete是安全的</p><p>在编译时给数组分配内存称为静态联编，意味着数组是在编译时加入程序的，这种必须在编译时指定数组的长度。与之对应，数组在程序运行时创建被称为动态联编，这种情况程序在运行时确定数组的长度</p><p>使用下边的来创建和释放动态数组：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">delete</span> [] arr;</span><br></pre></td></tr></table></figure></p><p>new运算符返回第一个数组元素的地址，不同于普通变量，应使用delete []来释放整个数组</p><p>对于使用new和delete时，应注意：</p><ul><li>不要使用delete来释放不是new分配的内存</li><li>不要使用delete来释放同一个内存块两次</li><li>如果使用new []为数组分配内存，则应使用delete []来释放</li><li>如果使用new来为一个实体分配内存，则应使用delete来释放</li><li>对空指针使用delete是安全的</li></ul><p>使用动态数组只需要把返回的指针当做数组名来使用即可，在C和C++内部使用指针来处理数组</p><p>不能修改数组名的值，但动态数组的指针是变量可以修改它的值</p><h2 id="指针、数组和指针算术"><a href="#指针、数组和指针算术" class="headerlink" title="指针、数组和指针算术"></a>指针、数组和指针算术</h2><p>指针和数组基本等价的原因在于指针算术和C++内部处理数组的方式</p><p>不同于整数算术，对指针来说，增加1相当于增加它指向类型的字节数，两个指针相减，得到的是他们之间的间隔（同一个数组中才有意义）</p><p>对于数组表达式arr[i]，编译器将该表达式看做*(arr + i)，如果使用指针，也进行这样的转换</p><p>对数组名使用sizeof得到的是数组的长度，对数组指针应用sizeof得到的是指针的长度</p><p>对数组名取地址得到的是数组的地址，数组名实际上代表数组中第一个元素的地址<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*p_arr)[<span class="number">10</span>] = &amp;arr;</span><br></pre></td></tr></table></figure></p><p>在cout和多数C++表达式中，char数组名，char指针，以及用引号括起来的字符串常量都被解释为字符串的第一个字符的地址</p><p>对于字符串常量，不应尝试修改它</p><p>应使用strcpy而不是赋值运算符来将字符串赋给数组</p><p>对于结构指针，应使用箭头成员运算符(-&gt;)来访问结构成员。另一种方法是(*p)-&gt;b</p><p>可以将new和delete放在不同的函数中，但这容易遗忘使用delete</p><p>C++有三种管理数据内存的方式：自动存储、静态存储和动态存储。C++ 11新增了线程存储</p><p>在函数内部定义的常规变量使用自动存储空间，被称为自动变量。这表明它们在所属的函数被调用时自动产生，在函数结束时消亡。自动变量时一个局部变量，其作用于为包含它的代码块。代码块是被包含在花括号中的一段代码，自动变量通常存储在栈中</p><p>静态存储是在整个程序运行期间都存在的存储方式，有两种方式定义静态变量：在函数外定义它和在声明变量时使用个关键字static</p><p>new和delete提供了比自动存储和静态存储更加灵活的方法。数据的声明周期不完全受程序或函数的生存时间控制，动态分配的变量通常存储在堆中</p><p>数组、结构和指针，可以使用各种方式组合它们</p><p>模板类vector和array(C++ 11)提供了动态数组和定长数组的替代品</p><p>vector可以在运行阶段设置vector对象的长度，它使用new和delete来管理内存</p><p>vector的功能比数组强大，但付出的代价是效率稍低。array提供了固定长度的数组，使用栈来存储数据，其更方便和安全</p><p>可以像使用普通数组一样使用vector和array，vector和array对象可以使用赋值，但数组不行。</p><p>vector和array可以使用at方法来确保不使用非法索引，这将在运行时捕获错误，程序默认将中断</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;第一章-预备知识&quot;&gt;&lt;a href=&quot;#第一章-预备知识&quot; class=&quot;headerlink&quot; title=&quot;第一章 预备知识&quot;&gt;&lt;/a&gt;第一章 预备知识&lt;/h1&gt;&lt;h2 id=&quot;C-简介&quot;&gt;&lt;a href=&quot;#C-简介&quot; class=&quot;headerlink&quot; title=&quot;C++简介&quot;&gt;&lt;/a&gt;C++简介&lt;/h2&gt;&lt;p&gt;C++融合了三种不同的编程方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C语言代表的过程性语言&lt;/li&gt;
&lt;li&gt;以类为代表的面向对象于艳&lt;/li&gt;
&lt;li&gt;模板支持的泛型编程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;面向对象编程&quot;&gt;&lt;a href=&quot;#面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;面向对象编程&quot;&gt;&lt;/a&gt;面向对象编程&lt;/h2&gt;&lt;p&gt;面向对象编程(OOP)强调的是数据。理念是设计与问题本质特性相对应的数据格式。&lt;/p&gt;
&lt;h2 id=&quot;泛型编程&quot;&gt;&lt;a href=&quot;#泛型编程&quot; class=&quot;headerlink&quot; title=&quot;泛型编程&quot;&gt;&lt;/a&gt;泛型编程&lt;/h2&gt;&lt;p&gt;泛型编程强调编程要独立于特定数据类型，即创建独立于类型的代码。&lt;/p&gt;
&lt;h2 id=&quot;C与C&quot;&gt;&lt;a href=&quot;#C与C&quot; class=&quot;headerlink&quot; title=&quot;C与C++&quot;&gt;&lt;/a&gt;C与C++&lt;/h2&gt;&lt;p&gt;C++是C的超集，尽管有一些细微差别，但这种差别很小。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://blog.gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://blog.gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>cpp必读书籍推荐</title>
    <link href="https://blog.gwq5210.com/2017/07/02/cpp%E5%BF%85%E8%AF%BB%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    <id>https://blog.gwq5210.com/2017/07/02/cpp必读书籍推荐/</id>
    <published>2017-07-02T20:56:49.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容来自国外著名编程问答网站Stackoverflow评选的C++推荐书单！推荐大家看原版英文，但这些书大部分也都有中文版！</p><h1 id="手册类-–-所有级别"><a href="#手册类-–-所有级别" class="headerlink" title="手册类 – 所有级别"></a>手册类 – 所有级别</h1><ul><li>C++程序设计语言(The C++ Programming Language) 作者：Bjarne Stroustrup(更新到C++11) C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了C++11的内容。<br>电子书：第三版（中文）、第四版（英文）</li><li>C++标准程序库(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发行的第二版涵盖了C++11。<br>电子书：第一版（中文）、第一版（英文）、第二版（英文）</li><li>The C++ IO Streams and Locales 作者：Angelika Langer and Klaus Kreft 除了这本书，市面上基本没有讲解streams and locales的书。<br>电子书：96年版（英文）</li><li>C++ 11手册:<br>The C++ Standard (INCITS/ISO/IEC 14882-2011) 作者：C++标准委员会 这当然是C++最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有人会买现在价值$30US的电子发行版。<br>电子书：N3225（英文）</li><li><p>Overview of the New C++ (C++11/14) 作者：Scott Meyers(更新到C++11/C++14) 这是Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。<br>电子书：2011年版（英文）</p><a id="more"></a><h1 id="初级"><a href="#初级" class="headerlink" title="初级"></a>初级</h1><h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>如果你是一个无编程经验的C++初学者，或者有其它语言经验的C++初学者，那强烈推荐下面的书籍。</p></li><li><p>C++ Primer 作者：Stanley Lippman, Josée Lajoie, and Barbara E. Moo (更新到C++11) 近1千页，本书透彻的介绍了C++，以浅显和详细的方式讲到C++语言差不多所有内容。2012年8月发行的第五版包含C++11的内容。不要和 C++ Primer Plus (Stephen Prata)搞混了。<br>电子书：第三版（中文）、第四版（中文）、第五版（英文版）</p></li><li>Accelerated C++ 作者：Andrew Koenig and Barbara Moo 这本书覆盖了和C++ Primer一样的内容，但厚度只有C++ Primer的四分之一。这主要是因为本书面向的不是编程的初学者，而是有其它语言经验的C++初学者。对于初学者，本书学习曲线稍显陡峭，但对于能克服这一点的学习者而言，它确实非常紧凑的介绍了C++这门语言。<br>电子书：中文版，英文版</li><li>C++编程思想（Thinking in C++) 作者：Bruce Eckel 共两卷，第二卷主要将标准库，但还是不错的。<br>电子书：第二版V1（英文版）、第二版V2（英文版）、第二版V1（中文版）、第二版V2（中文版）<br>C++程序设计原理与实践 （Programming: Principles and Practice Using C++ ）作者：Bjarne Stroustrup C++之父写的C++入门书籍。本书面向没有编程经验的初学者，但相信有编程经验的人也能从本书中学到不少东西。<br>电子书：中文版<h2 id="最实用"><a href="#最实用" class="headerlink" title="最实用"></a>最实用</h2></li><li>Effective C++ 作者：Scott Meyers 本书以瞄准成为C++程序员必读的第二本书籍而写，Scott Meyers成功了。早期的版本面向从C语言转过来的程序员。第三版修改为面向从类似Jave等语言转来的程序员。内容覆盖了50多个很容易记住的条款，每个条款深入浅出（并且有趣）讲到了你可能没有考虑过的C++规则。<br>电子书：第二版（英文）、第三版（英文）、第三版（中文)</li><li>Effective STL 作者：Scott Meyers 讲解方式和Effective类似，但内容主要面向于STL。<br>电子书：中文版，英文版<h1 id="中级"><a href="#中级" class="headerlink" title="中级"></a>中级</h1></li><li>More Effective C++ 作者：Scott Meyers 更多（深入）关于C++的规则。没有前一本Effective C++重要。但同样值得一读。<br>电子书：中文版</li><li>Exceptional C++ 作者：Herb Sutter 讲解方式为提出并解决一系列的C++难题。本书极其透彻的讲解了C++资源管理、异常安全和RAII。同时覆盖了一些较为深入的技术，比如：编译防火墙（pimpl idiom)、名字查找规则,、好的类设计和C++内存模型。<br>电子书：中文版，英文版</li><li>More Exceptional C++ 作者：Herb Sutter 讲到了Exceptional C++没有涉及到的更高级的异常安全技术, 同时讨论了高效的C++ OOP方式和如何正确的使用STL。<br>电子书：中文版，英文版</li><li>Exceptional C++ Style 作者：Herb Sutter 讨论了泛型编程、最优化和资源管理。本书出彩之处在于谈到了如何用非成员函数和单职责原则编写模块化的C++代码。<br>电子书：中文版</li><li>C++编程规范(C++ Coding Standards) 作者：Herb Sutter and Andrei Alexandrescu “编程规范”这里并不是”代码缩进要用几个空格”。这本书包含了101个例子、惯用法、缺陷，通过这些可以帮助你编写正确、清晰高效的C++代码。<br>电子书：中文版</li><li>C++ 模板完全指南(C++ Templates: The Complete Guide)作者：David Vandevoorde and Nicolai M. Josuttis 本书是关于C++11之前的模板的。它覆盖了从非常基础到最高级的元编程知识，解释了模板工作原理的细节(概念和实现方式）。并且讨论了大量的缺陷。附录中包含关于ODR和重载的精彩总结。<br>电子书：中文版、英文版<h1 id="高级"><a href="#高级" class="headerlink" title="高级"></a>高级</h1></li><li>C++设计新思维-泛型编程与设计模式之应用(Modern C++ Design ) 作者：Andrei Alexandrescu 泛型编程鼻祖级书籍。本书先介绍了基于策略（policy-based)的设计、type lists 和泛型编程基础， 然后讲到了许多有用的设计模式(包括small object allocators, functors, factories, visitors, and multimethods) 如何被高效、模块化、清晰的泛型代码实现。<br>电子书：中文版、英文版</li><li>C++模板元编程(C++ Template Metaprogramming)作者：David Abrahams and Aleksey Gurtovoy 更多的是讲解boost::mpl，想要深入理解mpl的可以看一下。<br>电子书：中文版</li><li>C++ Concurrency In Action 作者：Anthony Williams 这本书主要内容是C++11的并发支持，包括线程库、原子(atomics)库、内存模型、锁和互斥量。同时也讲解了开发和调试多线程程序的一些难题。<br>电子书：英文版</li><li><p>Advanced C++ Metaprogramming 作者：Davide Di Gennaro 前C++11时代TMP技术的手册级书籍。本书更侧重于工程实践。里面有大量的可能几乎无人知道但很实用的技术写成的代码。本书可能比Alexandrescu的书更值得读。对于资深的开发者来说，这是一个学习C++暗角技术的绝佳机会，通常这些技术要通过资深的编程经历才能获取。<br>电子书：没找到</p><h1 id="经典-古老"><a href="#经典-古老" class="headerlink" title="经典 / 古老"></a>经典 / 古老</h1><p>注意: 下列书中的部分内容可能有些过时</p></li><li><p>C++的设计与演化(The Design and Evolution of C++ )作者：Bjarne Stroustrup 如果你想知道为什么C++是今天这个样子，那么这本书将给你答案。本书覆盖C++标准化之前的一切东西。<br>电子书：中文版</p></li><li>C++沉思录(Ruminations on C++) 作者：Andrew Koenig and Barbara Moo 本书不是为了讲解具体的C++技术细节，而是如何通过C++编写出色的OO代码。<br>电子书：中文版</li><li>Advanced C++ Programming Styles and Idioms 作者：James Coplien 讲解了一些C++特有的惯用法. 它确实是一本不错的书籍，如果时间闲暇也可一读。不过它确实很老了，可能有些不符合现代的C++。<br>电子书：中文版</li><li>大规模C++程序设计（Large Scale C++ Software Design） 作者：John Lakos 本书介绍了如何管理大规模C++软件项目的技术。很值得一读，除了有些过时以外。它是在C++98以前写的，缺少了好多对大规模项目重要的特性（比如名字空间）。假如你工作在一个大规模的C++项目中，你可能想要读它, 不过你需要注意那些不适用甚至错误的技术点。<br>电子书：中文版</li><li>深度探索C++对象模型 (Inside the C++ Object Model ) 作者：Stanley Lippman 如果你想知道虚函数是如何实现、多继承时基类是如何在内存中排布的和所有影响性能的东西，那么这本书会给你答案。不过这本书有好多低级的拼写排版错误，英文原版错误更多，侯捷翻译的版本中注明和纠正了很多，但本书绝对值得一读，你将明白编译器如何实现C++的对象模型。<br>电子书：中文版、英文版</li></ul><p>原文链接：<a href="http://bestcbooks.com/recommended-cpp-books/" target="_blank" rel="noopener">http://bestcbooks.com/recommended-cpp-books/</a><br>原文有电子书下载链接</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文内容来自国外著名编程问答网站Stackoverflow评选的C++推荐书单！推荐大家看原版英文，但这些书大部分也都有中文版！&lt;/p&gt;
&lt;h1 id=&quot;手册类-–-所有级别&quot;&gt;&lt;a href=&quot;#手册类-–-所有级别&quot; class=&quot;headerlink&quot; title=&quot;手册类 – 所有级别&quot;&gt;&lt;/a&gt;手册类 – 所有级别&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;C++程序设计语言(The C++ Programming Language) 作者：Bjarne Stroustrup(更新到C++11) C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了C++11的内容。&lt;br&gt;电子书：第三版（中文）、第四版（英文）&lt;/li&gt;
&lt;li&gt;C++标准程序库(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发行的第二版涵盖了C++11。&lt;br&gt;电子书：第一版（中文）、第一版（英文）、第二版（英文）&lt;/li&gt;
&lt;li&gt;The C++ IO Streams and Locales 作者：Angelika Langer and Klaus Kreft 除了这本书，市面上基本没有讲解streams and locales的书。&lt;br&gt;电子书：96年版（英文）&lt;/li&gt;
&lt;li&gt;C++ 11手册:&lt;br&gt;The C++ Standard (INCITS/ISO/IEC 14882-2011) 作者：C++标准委员会 这当然是C++最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有人会买现在价值$30US的电子发行版。&lt;br&gt;电子书：N3225（英文）&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Overview of the New C++ (C++11/14) 作者：Scott Meyers(更新到C++11/C++14) 这是Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。&lt;br&gt;电子书：2011年版（英文）&lt;/p&gt;
    
    </summary>
    
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="书籍推荐" scheme="https://blog.gwq5210.com/tags/%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>protobuf的编码</title>
    <link href="https://blog.gwq5210.com/2016/07/30/protobuf%E7%9A%84%E7%BC%96%E7%A0%81/"/>
    <id>https://blog.gwq5210.com/2016/07/30/protobuf的编码/</id>
    <published>2016-07-30T19:35:53.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章介绍protobuf消息的二进制格式。你在你的应用中使用protobuf不必了解这些，但是它可以更好的让你知道protobuf的编码格式是怎样影响你编码后消息的大小的。</p><h2 id="一个简单的消息"><a href="#一个简单的消息" class="headerlink" title="一个简单的消息"></a>一个简单的消息</h2><p>比方说，你有一个非常简单的消息定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test1</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int32</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在一个应用中，如果你创建一个Test1的消息，将a设置成150，然后序列化到流中，如果你能看到序列化的消息，会看到三个字节：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">08 </span><span class="number">96</span> <span class="number">01</span></span><br></pre></td></tr></table></figure></p><p>这是什么意思呢？继续阅读。。。<br><a id="more"></a></p><h2 id="Base-128-Varints"><a href="#Base-128-Varints" class="headerlink" title="Base 128 Varints"></a>Base 128 Varints</h2><p>为了理解这个简单的protobuf编码，你首先需要了解varints，varints是一个使用一个字节或多个字节编码整数的方法。较小的数字使用较少的字节。</p><p>在varint中，除了最后一个字节，都会设置最高位（most significant bit，msb），这个最高位指示后边仍然有字节。低7bits用来存储数字补码表示，低的7bits组会优先存储。</p><p>因此，这里是数字1的表示，它是单个字节的因此，msb不会被设置：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0000 </span><span class="number">0001</span></span><br></pre></td></tr></table></figure></p><p>下边是比较复杂的300：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">1010 </span><span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><p>怎样才能得出这个是300呢？首先你丢弃每个字节的msb，它仅仅是用来告诉我们数字字节表示的结尾。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1010</span> <span class="number">1100</span> <span class="number">0000</span> <span class="number">0010</span></span><br><span class="line">→ <span class="number">010</span> <span class="number">1100</span>  <span class="number">000</span> <span class="number">0010</span></span><br></pre></td></tr></table></figure></p><p>然后交换这两个7bits的组，因为varint先存储低7bits组，组合之后就能得到最终的数字：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">000</span> <span class="number">0010</span>  <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">000</span> <span class="number">0010</span> ++ <span class="number">010</span> <span class="number">1100</span></span><br><span class="line">→  <span class="number">100101100</span></span><br><span class="line">→  <span class="number">256</span> + <span class="number">32</span> + <span class="number">8</span> + <span class="number">4</span> = <span class="number">300</span></span><br></pre></td></tr></table></figure></p><h2 id="消息结构"><a href="#消息结构" class="headerlink" title="消息结构"></a>消息结构</h2><p>正如你了解到的，protobuf消息是一系列key-value的组合，二进制格式的消息，仅仅使用字段数字作为key，这个key的名称和声明的类型可以在解码时引用消息类型定义得到，如proto文件。</p><p>当编码消息时，键和值会组合成字节流。解析的时候，解析器需要能够跳过不能解析的字段。这样的话，新的字段加入的时候，较老的程序就不必修改，它可以不使用这些字段。这样，每个键值对编码成二进制的时候就会有两个值，一个是proto文件中的字段数字，另一个是能够提供值长度的二进制类型。</p><p>可用的二进制类型如下表：</p><div class="table-container"><table><thead><tr><th>类型</th><th>意义</th><th>用于</th></tr></thead><tbody><tr><td>0</td><td>Varint</td><td>int32, int64, uint32, uint64, sint32, sint64, bool, enum</td></tr><tr><td>1</td><td>64-bit</td><td>fixed64, sfixed64, double</td></tr><tr><td>2</td><td>Length-delimited</td><td>string, bytes, embedded messages, packed repeated fields</td></tr><tr><td>3</td><td>Start group</td><td>groups (deprecated)</td></tr><tr><td>4</td><td>End group</td><td>groups (deprecated)</td></tr><tr><td>5</td><td>32-bit</td><td>fixed32, sfixed32, float</td></tr></tbody></table></div><p>在序列化后的消息中，每一个key是类似这样的varint：(field_number &lt;&lt; 3) | wire_type，换句话说，低3位用来存储二进制类型。</p><p>现在让我们来看看开始提到的那个例子，现在知道序列化后的消息中，第一个数字永远是varint，这里是08，丢弃msb之后：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">000 </span><span class="number">1000</span></span><br></pre></td></tr></table></figure></p><p>取出低3位得到二进制类型0，右移3位后得到字段数字1。因此，我们知道了标签为1的值是varint，也就是说接下来的序列是varint，使用varint编码规则我们可以得到接下来的两个字节96 01存储的是150：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">96</span> <span class="number">01</span> = <span class="number">1001</span> <span class="number">0110</span>  <span class="number">0000</span> <span class="number">0001</span></span><br><span class="line">       → <span class="number">000</span> <span class="number">0001</span>  ++  <span class="number">001</span> <span class="number">0110</span> (drop the msb and reverse the groups of <span class="number">7</span> bits)</span><br><span class="line">       → <span class="number">10010110</span></span><br><span class="line">       → <span class="number">2</span> + <span class="number">4</span> + <span class="number">16</span> + <span class="number">128</span> = <span class="number">150</span></span><br></pre></td></tr></table></figure></p><h2 id="更多值得类型"><a href="#更多值得类型" class="headerlink" title="更多值得类型"></a>更多值得类型</h2><h3 id="有符号整数"><a href="#有符号整数" class="headerlink" title="有符号整数"></a>有符号整数</h3><p>正如前面提到的，和wire类型0关联的值都被编码成varint。然而，对于有符号整数（sint32和sint64）与一般整数（int32和int64）的一个很重要的不同点是它们对负数编码的处理。如果你使用int32或int64表示负数，那么这个varint总是10个字节长——它被当做一个非常大的无符号数。如果你使用任意一个有符号数，那么varint将会使用ZigZag编码，它对负数编码更有效率。</p><p>ZigZag编码将有符号整数映射到无符号整数，这样它的绝对值就很小，相应的varint编码长度也比较小。zig-zags在正数和负数之间来回交叉进行编码，-1编码是当做1,1在编码是当做2，-2编码成3，等等：</p><div class="table-container"><table><thead><tr><th>Signed Original</th><th>Encoded As</th></tr></thead><tbody><tr><td>0</td><td>0</td></tr><tr><td>-1</td><td>1</td></tr><tr><td>1</td><td>2</td></tr><tr><td>-2</td><td>3</td></tr><tr><td>2147483647</td><td>4294967294</td></tr><tr><td>-2147483648</td><td>4294967295</td></tr></tbody></table></div><p>换句话说，n在sint32的时候被编码为(n &lt;&lt; 1) ^ (n &gt;&gt; 31)，在sint64的时候被编码为(n &lt;&lt; 1) ^ (n &gt;&gt; 63)。</p><p>运算的第二部分，(n&gt;&gt;31)是算术右移，也就是说，如果n是正数，右移补的位为0，否则是1。</p><p>当sint32或sint64解析的时候，会解析成原来得数字。</p><h3 id="非varint数字"><a href="#非varint数字" class="headerlink" title="非varint数字"></a>非varint数字</h3><p>这个数字类型很简单——double和fixed64的wire类型是1，这告诉解析器接下来是固定的64bits数据，相应的float和fixed32的wire类型时5，说明拥有32bits数据。这两种情况下的值都以小端字节序存储。</p><h3 id="strings"><a href="#strings" class="headerlink" title="strings"></a>strings</h3><p>wire类型为2意味着值是一个varint编码的长度，接下来是指定字节长度的数据。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test2</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> b = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将b设置成testing的编码为：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">12 </span><span class="number">07</span> <span class="number">74</span> <span class="number">65</span> <span class="number">73</span> <span class="number">74</span> <span class="number">69</span> <span class="number">6e</span> <span class="number">67</span></span><br></pre></td></tr></table></figure></p><p>后七个字节是UTF-8编码的testing，key是0x12，wire类型是2，tag是2，0x07表示值的长度是7，然后是7个字节的字符串。</p><h2 id="嵌套消息"><a href="#嵌套消息" class="headerlink" title="嵌套消息"></a>嵌套消息</h2><p>现在定义一个消息，其字段是Test1类型的消息：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test3</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> Test1 c = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们将a设置成150，下边是编码后的消息：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>a <span class="number">03</span> <span class="number">08</span> <span class="number">96</span> <span class="number">01</span></span><br></pre></td></tr></table></figure></p><p>正如你看到的，最后三个字节和第一个例子是一样的，它前边有一个值为3的varint标识长度——嵌套消息被当做和字符串一样处理。</p><h2 id="可选和可重复元素"><a href="#可选和可重复元素" class="headerlink" title="可选和可重复元素"></a>可选和可重复元素</h2><p>在proto2中定义的repeated字段（没有[packed=true]选项），编码后的消息是零个或多个拥有相同标签的键值对。这些重复的值不一定连续出现，可能会和其他字段交错出现。解析的时候，各个元素之间的顺序被保留，尽管其他字段的顺序是不确定的。在proto3中，repeated字段使用<a href="https://developers.google.com/protocol-buffers/docs/encoding#packed" target="_blank" rel="noopener">packed encoding</a>，下边将会介绍。</p><p>在proto3中非repeated字段和proto2中的optional字段，编码后的消息中可能有也可能没有包含标签数字的key-value对。</p><p>一般的，编码后的消息不会超过一个非repeated的字段，不过，我们期望解析器能够处理这种情况。对于数值类型和字符串类型，如果相同的数字标签出现了多次，那么解析器会保存最后一个出现的值。对于嵌套消息字段，解析器将多个相同数字标签的值合并，就像调用Message::MergeFrom一样——对于普通字段，用后边实例的值代替前边实例的值，对于嵌套消息字段进行合并，重复字段进行连接。这个规则使得解析连续两个编码后的消息一样和分别解析两个消息然后把它们合并的效果是一样的：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyMessage <span class="keyword">message</span>;</span><br><span class="line"><span class="keyword">message</span>.ParseFromString(str1 + str2);</span><br></pre></td></tr></table></figure></p><p>等价于：<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">MyMessage <span class="keyword">message</span>, message2;</span><br><span class="line"><span class="keyword">message</span>.ParseFromString(str1);</span><br><span class="line">message2.ParseFromString(str2);</span><br><span class="line"><span class="keyword">message</span>.MergeFrom(message2);</span><br></pre></td></tr></table></figure></p><p>这个属性偶尔会用到，它允许在你不知道他们类型的情况下进行合并消息。</p><h3 id="打包重复字段"><a href="#打包重复字段" class="headerlink" title="打包重复字段"></a>打包重复字段</h3><p>2.1.0版本引入了打包重复字段，在proto2中需要在重复字段中添加[packed=true]选项。在proto3中，重复字段默认就是打包的。它的功能和重复字段类似，但采取了不同的编码。当一个打包的重复字段不包含任何元素时，它不会出现在编码后的消息中。否则，这个字段的全部元素被打包成wrie类型为2的单个键值对。除了没有标签数字前缀外，每个元素被编码成它本来的样子。</p><p>假设你又个消息<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Test4</span> </span>&#123;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> d = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，你定义一个Test4变量，给重复字段d提供值3，170和86942，那么它的编码为：<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">22 </span>       // tag (<span class="keyword">field</span> number <span class="number">4</span>, wire type <span class="number">2</span>)</span><br><span class="line"><span class="symbol">06 </span>       // payload size (<span class="number">6</span> bytes)</span><br><span class="line"><span class="symbol">03 </span>       // first element (varint <span class="number">3</span>)</span><br><span class="line"><span class="number">8E</span> <span class="number">02</span>     // second element (varint <span class="number">270</span>)</span><br><span class="line"><span class="number">9E</span> A7 <span class="number">05</span>  // third element (varint <span class="number">86942</span>)</span><br></pre></td></tr></table></figure></p><p>仅仅原始数字类型（varint，32-bit或64-bit）的重复字段才能够声明为packed。</p><p>需要注意的是，虽然有通常没有理由为打包重复字段编码多个键值对，但编码器必须要能够接受多个键值对。在这种情况下，有效数据应该串联起来。每个键值对必须包含全部的元素。</p><p>编译器必须能够像它们没有packed一样解析packed的重复字段，反之亦然。为这样的字段添加[packed=true]是一种向前向后兼容的方式。</p><h2 id="字段顺序"><a href="#字段顺序" class="headerlink" title="字段顺序"></a>字段顺序</h2><p>虽然你能够在proto文件中以任何顺序使用字段数字，当消息序列化的时候，它应该按照字段数字的顺序写入，就像C++，Java和Python序列化代码那样。这就允许解析代码依赖字段数字的顺序进行优化。然而，protobuf解析器必须能够以任何顺序解析它们，并不是所有的消息是通过简单序列化得到的——举例来说，一个合并两个消息的简单方法是将它们序列化后的消息串联。</p><p>如果一个消息中包含未知的字段，母线的Java和C++实现会将它们以任意的顺序写入已知字段的后边。当前的Python实现并不追踪未知字段。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1) <a href="https://developers.google.com/protocol-buffers/docs/encoding#packed" target="_blank" rel="noopener">Google Protocol Buffer Encoding</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章介绍protobuf消息的二进制格式。你在你的应用中使用protobuf不必了解这些，但是它可以更好的让你知道protobuf的编码格式是怎样影响你编码后消息的大小的。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的消息&quot;&gt;&lt;a href=&quot;#一个简单的消息&quot; class=&quot;headerlink&quot; title=&quot;一个简单的消息&quot;&gt;&lt;/a&gt;一个简单的消息&lt;/h2&gt;&lt;p&gt;比方说，你有一个非常简单的消息定义：&lt;br&gt;&lt;figure class=&quot;highlight protobuf&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;message&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Test1&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;	&lt;span class=&quot;keyword&quot;&gt;required&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;int32&lt;/span&gt; a = &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在一个应用中，如果你创建一个Test1的消息，将a设置成150，然后序列化到流中，如果你能看到序列化的消息，会看到三个字节：&lt;br&gt;&lt;figure class=&quot;highlight basic&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;symbol&quot;&gt;08 &lt;/span&gt;&lt;span class=&quot;number&quot;&gt;96&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;01&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是什么意思呢？继续阅读。。。&lt;br&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="protobuf" scheme="https://blog.gwq5210.com/tags/protobuf/"/>
    
      <category term="编码方式" scheme="https://blog.gwq5210.com/tags/%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>google protobuf简介及使用</title>
    <link href="https://blog.gwq5210.com/2016/07/30/google%20protobuf%E7%AE%80%E4%BB%8B/"/>
    <id>https://blog.gwq5210.com/2016/07/30/google protobuf简介/</id>
    <published>2016-07-30T14:17:10.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Google-ProtoBuf？"><a href="#什么是Google-ProtoBuf？" class="headerlink" title="什么是Google ProtoBuf？"></a>什么是Google ProtoBuf？</h2><p>ProtoBuf是一种灵活高效的结构化数据存储机制，像XML一样，但是其更加轻巧、快速、简单。<br>使用ProtoBuf十分简单，只需要在.proto文件中定义数据就好了，然后你可以利用ProtoBuf提供的工具生成不同语言的序列化和反序列化的代码，目前提供C++、Java、Python、C#、GO等语言版本。</p><h2 id="ProtoBuf的优点"><a href="#ProtoBuf的优点" class="headerlink" title="ProtoBuf的优点"></a>ProtoBuf的优点</h2><p>同XML数据相比，ProboBuf有这许多优点：<br>1：简单<br>2：小3-10倍<br>3：快20-100倍<br>4：更少的二义性<br>5：生成的数据访问类更加容易编程</p><a id="more"></a><p>举个例子，为了描述一个人的name和email，在XML中你需要这样做：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>John Doe<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">email</span>&gt;</span>jdoe@example.com<span class="tag">&lt;/<span class="name">email</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>相应的在ProtoBuf中，类似这样（文本格式，编码后的二进制格式不是这样）：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Textual representation of a protocol buffer.</span></span><br><span class="line"><span class="comment"># This is *not* the binary format used on the wire.</span></span><br><span class="line">person &#123;</span><br><span class="line"><span class="built_in">name</span>: <span class="string">"John Doe"</span></span><br><span class="line">email: <span class="string">"jdoe@example.com"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编码为二进制后，其仅仅占用28个字节，解析也只需要100-200纳秒；但是XML版本就需要至少69个字节来表示（去掉空格以后），解析需要的时间为5000-10000纳秒。</p><p>同样在访问上，ProtoBuf也更加简便：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span> &lt;&lt; person.name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"E-mail: "</span> &lt;&lt; person.email() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Whereas with XML you would have to do something like:</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"Name: "</span></span><br><span class="line">&lt;&lt; person.getElementsByTagName(<span class="string">"name"</span>)-&gt;item(<span class="number">0</span>)-&gt;innerText()</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"E-mail: "</span></span><br><span class="line">&lt;&lt; person.getElementsByTagName(<span class="string">"email"</span>)-&gt;item(<span class="number">0</span>)-&gt;innerText()</span><br><span class="line">&lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p><h2 id="定义一个简单的Message"><a href="#定义一个简单的Message" class="headerlink" title="定义一个简单的Message"></a>定义一个简单的Message</h2><p>ProtoBuf文件以proto为后缀，如定义一个person类型的消息person.proto，如下：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// person.proro</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">person</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> name = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> email = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int32</span> age = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> address = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">optional</span> <span class="built_in">string</span> phone = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述文件可以使用以下命令生成C++的源代码：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要安装protoc</span></span><br><span class="line">protoc person.proto -cpp<span class="number">_</span><span class="keyword">out</span>=.</span><br></pre></td></tr></table></figure></p><p>我们注意到，消息中的每一个字段由四个部分构成，如name字段，其结构为：<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 规则 类型 名字 = 唯一标签</span></span><br><span class="line">required <span class="keyword">string</span> <span class="keyword">name</span> = <span class="number">1</span>;</span><br></pre></td></tr></table></figure></p><h3 id="字段的类型"><a href="#字段的类型" class="headerlink" title="字段的类型"></a>字段的类型</h3><p>在上边的例子中，我们使用了两种类型：string和int32，除此之外你还可以声明其他的一些基本类型，如bool等，同时还可以是一些自定义的类型，如枚举和一个pb消息。</p><h3 id="分配标签"><a href="#分配标签" class="headerlink" title="分配标签"></a>分配标签</h3><p>每一个字段后，都分配了一个独一无二的数字标号，这个标号是用来在二进制格式中区分某一个字段用的。因此，一个标号只能使用一次，也就是说即使你将旧的字段删除，也不能再重用为之分配的标签了，需要重新指定一个没使用过得标签号。</p><p>标签号的值在1-15之前的，编码后仅仅使用一个字节（包括标识号和字段类型）。标签号范围在16-2047占用2个字节，因此你应该将1-15分配给频率使用很高的字段，可以给使用频繁的字段预留1-15的标签号。</p><p>标签号最小为1，最大为2^29-1（536870911），数字19000到19999 (FieldDescriptor::kFirstReservedNumber到FieldDescriptor::kLastReservedNumber)是预留给ProtoBuf实现的，因此你也不能使用这些标签号。</p><h3 id="字段的规则"><a href="#字段的规则" class="headerlink" title="字段的规则"></a>字段的规则</h3><p>ProtoBuf消息中的字段有如下三种规则：<br>1、required：这个字段是必须的。<br>2、optional：这个字段是可选的，在消息中有或者没有均可。<br>3、repeated：这个字段是可以重复任意次（包括0），可以理解为数组。</p><p>出于历史原因，repeated字段对于数字类型来说，不一定以最高效的方式编码，可以使用[packed=true]选项来获得更高的效率。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure></p><p>对于required字段，一定要谨慎的使用，required如果更改为optional字段，新生成的消息在老版本的程序中就会拒绝解析，认为这是一个不完整的消息；但是对于optional和repeated字段就没有这个问题。</p><h3 id="添加更多的消息"><a href="#添加更多的消息" class="headerlink" title="添加更多的消息"></a>添加更多的消息</h3><p>可以再一个proto文件中定义多个message。当你需要定义多个有关联的消息时，这就十分有用。例如你想定义一个请求和回复的消息，在一个proto文件中定义就十分方便。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="使用注释"><a href="#使用注释" class="headerlink" title="使用注释"></a>使用注释</h3><p>在proto文件中你可以使用C/C++风格的注释：//<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;<span class="comment">// Which page number do we want?</span></span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span>;<span class="comment">// Number of results to return per page.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="保留字段"><a href="#保留字段" class="headerlink" title="保留字段"></a>保留字段</h3><p>在你更新你的消息时，你可能删除掉一些字段，当其他人更新时，可能会重新使用之前用到的标签号，这个使用你可以使用reversed关键字，当其他人使用到reversed中的标号时，ProtoBuf会给出警告。你不能将名字和标号在一个reserved语句中混用。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">message Foo &#123;</span><br><span class="line">reserved <span class="number">2</span>, <span class="number">15</span>, <span class="number">9</span> to <span class="number">11</span>;</span><br><span class="line">reserved <span class="string">"foo"</span>, <span class="string">"bar"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ProtoBuf从proto文件中生成了什么？"><a href="#ProtoBuf从proto文件中生成了什么？" class="headerlink" title="ProtoBuf从proto文件中生成了什么？"></a>ProtoBuf从proto文件中生成了什么？</h3><p>ProtoBuf编译器会将proto文件编译成你选择语言的相应代码，这些代码中包括了获取和设置字段的方法，序列化到输出流和从输入流解析的方法。<br>对于C++，编译器对每一个proto文件生成相应的h和cc文件，其中包括了每个消息对应的类。<br>对于Java，编译器为每一个消息生成一个对应的java文件。<br>对于生成代码的API的详细介绍，可以在<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">API reference</a>找到。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>一个只使用基本类型的消息，可以选择的类型在如下的表格中，包括proto中可以选择的类型和生成类的相应类型：</p><div class="table-container"><table><thead><tr><th>.proto类型</th><th>备注</th><th>C++类型</th><th>Java类型</th><th>Python类型</th></tr></thead><tbody><tr><td>double</td><td></td><td>double</td><td>double</td><td>float</td></tr><tr><td>float</td><td></td><td>float</td><td>float</td><td>float</td></tr><tr><td>int32</td><td>使用变长编码，编码负数效率不高，如果字段大部分是负数，应该使用sint32代替</td><td>int32</td><td>int</td><td>int</td></tr><tr><td>int64</td><td>使用变长编码，编码负数效率不高，如果字段大部分是负数，应该使用sint64代替</td><td>int64</td><td>long</td><td>int/long</td></tr><tr><td>uint32</td><td>使用变长编码</td><td>uint32</td><td>int</td><td>int/long</td></tr><tr><td>uint64</td><td>使用变长编码</td><td>uint64</td><td>long</td><td>int/long</td></tr><tr><td>sint32</td><td>使用变长编码，编码负数效率比int32高</td><td>int32</td><td>int</td><td>int</td></tr><tr><td>sint64</td><td>使用变长编码，编码负数效率比int64高</td><td>int64</td><td>long</td><td>int/long</td></tr><tr><td>fixed32</td><td>总是4个字节，当值大于2^28时比uint32效率高</td><td>uint32</td><td>int</td><td>int</td></tr><tr><td>fixed64</td><td>总是8个字节，当值大于2^28时比uint32效率高</td><td>uint64</td><td>long</td><td>int/long</td></tr><tr><td>sfixed32</td><td>总是4个字节</td><td>int32</td><td>int</td><td>int</td></tr><tr><td>sfixed64</td><td>总是8个字节</td><td>int64</td><td>long</td><td>int/long</td></tr><tr><td>bool</td><td></td><td>bool</td><td>boolean</td><td>bool</td></tr><tr><td>string</td><td>必须由UTF-8编码的或者7-bit的ASCII组成的文本</td><td>string</td><td>String</td><td>str/unicode</td></tr><tr><td>bytes</td><td>可以包括任意序列的字节</td><td>string</td><td>ByteString</td><td>str</td></tr></tbody></table></div><h2 id="可选字段和默认值"><a href="#可选字段和默认值" class="headerlink" title="可选字段和默认值"></a>可选字段和默认值</h2><p>一个消息中的字段可以定义为optional，即可选的，一个合法的消息可以包括也可以不包括这个可选的字段。当解析消息时，如果不包括可选字段，那么可选字段就会被设置为默认值，这个默认值可以指定。例如：<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">optional int32 result_per_page = <span class="number">3</span> [<span class="section">default</span> = <span class="number">10</span>];</span><br></pre></td></tr></table></figure></p><p>如果没有显示指定默认值，ProtoBuf会为每个类型指定默认值：string类型指定为空串，bool指定为false，对于数值类型，指定为0，对于枚举类型，默认为列表中的第一个值。因此如果修改枚举定义，就需要注意兼容性问题了。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>protobuf同样提供了枚举类型，这种类型只能使用预定义列表中的值。例如你想为SearchResult添加corpus字段，它可以是：UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS or VIDEO。这利用枚举就可以很方便的实现。下边是一个例子：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchRequest</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> query = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> page_number = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> result_per_page = <span class="number">3</span> [default = <span class="number">10</span>];</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Corpus</span> </span>&#123;</span><br><span class="line">UNIVERSAL = <span class="number">0</span>;</span><br><span class="line">WEB = <span class="number">1</span>;</span><br><span class="line">IMAGES = <span class="number">2</span>;</span><br><span class="line">LOCAL = <span class="number">3</span>;</span><br><span class="line">NEWS = <span class="number">4</span>;</span><br><span class="line">PRODUCTS = <span class="number">5</span>;</span><br><span class="line">VIDEO = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">optional</span> Corpus corpus = <span class="number">4</span> [default = UNIVERSAL];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>枚举类型中，可以把两个不同的标识赋为相同的值，进而实现别名的功能。为了能够支持这个特性，你需要设置allow_alias为true，否则，将会编译错误。<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumAllowingAlias</span> &#123;</span></span><br><span class="line">option allow_alias = <span class="literal">true</span>;</span><br><span class="line">UNKNOWN = <span class="number">0</span>;</span><br><span class="line">STARTED = <span class="number">1</span>;</span><br><span class="line"> RUNNING = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumNotAllowingAlias</span> &#123;</span></span><br><span class="line">UNKNOWN = <span class="number">0</span>;</span><br><span class="line">STARTED = <span class="number">1</span>;</span><br><span class="line">/<span class="regexp">/ RUNNING = 1;  /</span><span class="regexp">/ Uncommenting this line will cause a compile error inside Google and a warning message outside.</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure></p><p>枚举常量必须是32-bit的整数。枚举使用<a href="https://developers.google.com/protocol-buffers/docs/encoding" target="_blank" rel="noopener">varint encoding</a>编码，负数效率不高，因此不推荐使用负数。你可以将枚举定义在一个消息内或者整个proto文件中，此外，还可以通过MessageType.EnumType语法在一个消息中使用另一个消息中定义的枚举类型。</p><p>当protobuf编译器生成enum类型时，生成的代码将会包含一个相应的枚举类型（Java和C++）或一个包含符号常量的特定的EnumDescriptor类（python）。可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">generated code guide</a>获取更多信息。</p><h2 id="使用其他类型消息"><a href="#使用其他类型消息" class="headerlink" title="使用其他类型消息"></a>使用其他类型消息</h2><p>你可以将一个消息中的字段设置为其他消息类型。例如，你想在SearchResponse中包含一个Result类型：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line"><span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="导入定义"><a href="#导入定义" class="headerlink" title="导入定义"></a>导入定义</h3><p>上边的例子中，Result和SearchResponse定一在一个proto文件中，同样，也可以使用其他proto文件中定义的类型。这就需要在你的proto文件的开头加入类似的语句：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"myproject/other_protos.proto"</span>;</span><br></pre></td></tr></table></figure></p><p>一般来说，你直接使用import就可以满足要求了。但有时，你可能想将一个proto文件移动到新的位置。你可以不直接移动proto文件，在老的位置放一个dummy .proto文件使用import public来将所有的imports跳转到新的位置。import public的依赖可以通过导入任何包含了import public语句的proto文件来传递。<br><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// new.proto</span></span><br><span class="line"><span class="comment">// All definitions are moved here</span></span><br><span class="line"><span class="comment">// old.proto</span></span><br><span class="line"><span class="comment">// This is the proto that all clients are importing.</span></span><br></pre></td></tr></table></figure></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> public <span class="string">"new.proto"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">"other.proto"</span>;</span><br></pre></td></tr></table></figure><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"old.proto"</span>;</span><br><span class="line"><span class="comment">// You use definitions from old.proto and new.proto, but not other.proto</span></span><br></pre></td></tr></table></figure><p>protobuf编译器通过命令行参数-I或—proto_path来指定导入文件的搜索目录，如果没有指定，则使用编译器被调用的目录，一般来说，应该在命令行指定这个参数，确保全部合法的名字是可以被真长导入的。</p><h3 id="使用proto3消息类型"><a href="#使用proto3消息类型" class="headerlink" title="使用proto3消息类型"></a>使用proto3消息类型</h3><p>可以在proto2中导入<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">proto3</a>的消息类型，反之亦然。但是，proto2的枚举不能在proto3语法中使用。</p><h2 id="嵌套类型"><a href="#嵌套类型" class="headerlink" title="嵌套类型"></a>嵌套类型</h2><p>你可以将一个消息定义在另一个消息内。例如：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SearchResponse</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Result</span> </span>&#123;</span><br><span class="line"><span class="keyword">required</span> <span class="built_in">string</span> url = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> title = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">repeated</span> <span class="built_in">string</span> snippets = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">repeated</span> Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以在其他消息中用Parent.Type使用嵌套的消息类型：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SomeOtherMessage</span> </span>&#123;</span><br><span class="line"><span class="keyword">optional</span> SearchResponse.Result result = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>同样的，可以支持多层嵌套：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Outer</span> </span>&#123;                  <span class="comment">// Level 0</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MiddleAA</span> </span>&#123;  <span class="comment">// Level 1</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">// Level 2</span></span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int64</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MiddleBB</span> </span>&#123;  <span class="comment">// Level 1</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Inner</span> </span>&#123;   <span class="comment">// Level 2</span></span><br><span class="line"><span class="keyword">required</span> <span class="built_in">int32</span> ival = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">bool</span>  booly = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="组"><a href="#组" class="headerlink" title="组"></a>组</h3><p>这个特性已经被弃用，不应该使用其来创建新的类型，可以用嵌套消息类型代替。</p><h2 id="更新一个消息类型"><a href="#更新一个消息类型" class="headerlink" title="更新一个消息类型"></a>更新一个消息类型</h2><p>如果一个已存在的消息类型已经不能满足你的需要——例如，你希望消息包含一些额外的字段，但是你仍然希望使用旧消息格式的代码，不必担心！！！protobuf不需要修改已有代码就可以非常简单的来更新一个消息类型。有如下规则：</p><ul><li>不要改变任何已存在字段的数字标签</li><li>任何新加的字段都应该是optional或repeated。这意味着任何使用旧代码序列化后的消息可以使用新的代码解析，它不会缺失任何required字段。你应该为这些字段设置默认值，以便新的代码能够和老的代码进行交互。相应的，新的代码创建的消息也能够被老的代码解析：老的二进制简单的在解析的过程中忽略新的字段。但是，解析的过程中新的字段并不会被丢弃，如果重新被序列化，新的字段仍然会被序列化，因此，如果消息重新发送给新的程序，新的字段仍然能够被正确解析。</li><li>非必须字段能够被移除——它的数字标签不能在你的新消息类型中重新使用。为了防止出现类似的情况，你可以重新命名这个字段，如添加前缀”OBSOLETE_”或者将这个数字标签保留。</li><li>非必须字段可以转换成扩展，反之亦然——要保证类型和数字标签一样。</li><li>int32, uint32, int64, uint64和bool是兼容的——这意味着你能够将一个字段从其中一种类型转换到另一种类型，而不会破坏向前或向后兼容。如果一个数字从一个不一致的类型解析出来，将会出现类似C++中的问题（例如，一个64-bit数字按照32-bit数字读，其会截断成32-bit的数字）。</li><li>sint32和sint64是兼容的，但是与其他整数类型不兼容。</li><li>string和bytes（只要bytes是有效的UTF-8）是兼容的。</li><li>嵌入消息和bytes（如果bytes包含一个消息版本的编码）是兼容的。</li><li>fixed32和sfixed32是兼容的，fixed64和sfixed64是兼容的。</li><li>optional和repeated是兼容的。Given serialized data of a repeated field as input, clients that expect this field to be optional will take the last input value if it’s a primitive type field or merge all input elements if it’s a message type field.</li><li>更改默认值一般是可以的，但要记住，默认值不会通过网络发送，因此，如果程序收到一个特定字段没有设置的消息，这个程序会从程序的协议版本中读取默认值。它不会看到发送者代码中的默认值。</li><li>enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit), but be aware that client code may treat them differently when the message is deserialized. Notably, unrecognized enum values are discarded when the message is deserialized, which makes the field’s has.. accessor return false and its getter return the first value listed in the enum definition, or the default value if one is specified. In the case of repeated enum fields, any unrecognized values are stripped out of the list. However, an integer field will always preserve its value. Because of this, you need to be very careful when upgrading an integer to an enum in terms of receiving out of bounds enum values on the wire.</li><li>In the current Java and C++ implementations, when unrecognized enum values are stripped out, they are stored along with other unknown fields. Note that this can result in strange behavior if this data is serialized and then reparsed by a client that recognizes these values. In the case of optional fields, even if a new value was written after the original message was deserialized, the old value will be still read by clients that recognize it. In the case of repeated fields, the old values will appear after any recognized and newly-added values, which means that order will not be preserved.</li></ul><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>扩展让你能够在消息中声明一个第三方可用的数字标签范围。其他人可以使用这些数字标签在新的proto文件中为你的消息定义新的字段而不需要修改原始文件，如：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">extensions <span class="number">100</span> to <span class="number">199</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这是说在Foo中数字标签[100-199]是预留给扩展的。其他人现在导入你的proto文件后就能在他们自己的proto文件中使用特定的数字标签范围为Foo添加字段，如：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extend </span>Foo &#123;</span><br><span class="line">optional int32 <span class="keyword">bar </span>= <span class="number">126</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在Foo有了一个名称为bar的optional字段。<br>当Foo编码之后，其二进制表示与用户直接在Foo中定义一个新的字段编码之后的表示是一样的。然而，其访问扩展字段和访问普通字段的方式是不一样的。在C++中：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Foo</span> foo<span class="comment">;</span></span><br><span class="line"><span class="symbol">foo.SetExtension</span>(<span class="keyword">bar, </span><span class="number">15</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>Foo类定义了一个模板化的访问器HasExtension(), ClearExtension(), GetExtension(), MutableExtension()和AddExtension()，All have semantics matching the corresponding generated accessors for a normal field. For more information about working with extensions, see the generated code reference for your chosen language.</p><p>扩展可以是除了oneof或map的任何类型任何类型。</p><h3 id="嵌套扩展"><a href="#嵌套扩展" class="headerlink" title="嵌套扩展"></a>嵌套扩展</h3><p>你可以在其他消息中定义扩展：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">extend Foo &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> bar = <span class="number">126</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>相应的：<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Foo</span> <span class="selector-tag">foo</span>;</span><br><span class="line"><span class="selector-tag">foo</span><span class="selector-class">.SetExtension</span>(<span class="selector-tag">Baz</span><span class="selector-pseudo">::bar</span>, 15);</span><br></pre></td></tr></table></figure></p><p>换句话说，bar定义在Baz的作用域中了。</p><p>This is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it’s simply a static member.</p><p>A common pattern is to define extensions inside the scope of the extension’s field type – for example, here’s an extension to Foo of type Baz, where the extension is defined as part of Baz:<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">extend Foo &#123;</span><br><span class="line"><span class="keyword">optional</span> Baz foo_ext = <span class="number">127</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，在其他类型定义中定义扩展是不必要的：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Baz</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This can even be in a different file.</span></span><br><span class="line">extend Foo &#123;</span><br><span class="line"><span class="keyword">optional</span> Baz foo_baz_ext = <span class="number">127</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>实际上，这种语法可以避免混乱。如果不熟悉扩展，用户很可能会将扩展误会成子类。</p><h3 id="选择扩展数字"><a href="#选择扩展数字" class="headerlink" title="选择扩展数字"></a>选择扩展数字</h3><p>确保两个用户不会使用同一个数字标签为消息添加不同的扩展是很重要的，将扩展意外的解析成错误的类型能够造成数据损坏。你可以在定义消息的时候指定扩展数字标签的范围。如果你想使用很大的数字，可以使用关键字max代替：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">extensions <span class="number">1000</span> to max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>max最大是2^29-1或536870911。</p><p>除此之外，你还要避免使用保留数字标签从19000到19999 (FieldDescriptor::kFirstReservedNumber到FieldDescriptor::kLastReservedNumber)，你能够在指定扩展数字范围时指定这些数字，但是编译器会阻止你真正使用这些保留的数字。</p><h2 id="Oneof"><a href="#Oneof" class="headerlink" title="Oneof"></a>Oneof</h2><p>如果你的消息有很多可选的字段，但是同一时间只能表现为一个消息，那么你可以使用oneof特性来实现。</p><p>oneof像所有的可选字段使用共享的内存区域，同时只能有一个可选字段被设置。设置任一oneof的消息，会自动的清除其他消息，你可以使用case()或WhichOneof()检查那个消息被设置了。</p><h3 id="使用Oneof"><a href="#使用Oneof" class="headerlink" title="使用Oneof"></a>使用Oneof</h3><p>使用oneof非常简单：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">SampleMessage</span> </span>&#123;</span><br><span class="line"><span class="keyword">oneof</span> test_oneof &#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="number">4</span>;</span><br><span class="line">SubMessage sub_message = <span class="number">9</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>你可以在oneof定义中添加任何类型的字段而不能使用required、optional或repeated关键字。</p><p>在生成的代码中，oneof字段拥有和optional字段一样的getter和setter方法。另外还有检查哪一个字段被设置的api，可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">这里</a>。</p><h3 id="Oneof特性"><a href="#Oneof特性" class="headerlink" title="Oneof特性"></a>Oneof特性</h3><ul><li><p>设置一个oneof字段，会自动将其他字段清空。因此，如果你设置了许多字段，只有最后一个设置的字段是有效的</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">SampleMessage</span> <span class="selector-tag">message</span>;</span><br><span class="line"><span class="selector-tag">message</span><span class="selector-class">.set_name</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="selector-tag">CHECK</span>(message.has_name());</span><br><span class="line"><span class="selector-tag">message</span><span class="selector-class">.mutable_sub_message</span>();   <span class="comment">// Will clear name field.</span></span><br><span class="line"><span class="selector-tag">CHECK</span>(!message.has_name());</span><br></pre></td></tr></table></figure></li><li><p>如果解析器遇到了多个oneof成员，只有最后一个遇到的成员在解析的消息中有效</p></li><li>扩展不支持oneof</li><li>oneof不能是repeated的</li><li>反射API能够在oneof字段上使用</li><li><p>如果你使用C++，确保你的代码不会崩溃。下面简单的代码因为使用了被set_name已经清除的sub_message，会导致崩溃</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">SampleMessage</span> message<span class="comment">;</span></span><br><span class="line"><span class="keyword">SubMessage* </span><span class="keyword">sub_message </span>= message.mutable_sub_message()<span class="comment">;</span></span><br><span class="line"><span class="symbol">message.set_name</span>(<span class="string">"name"</span>)<span class="comment">;      // Will delete sub_message</span></span><br><span class="line"><span class="keyword">sub_message-&gt;set_... </span>           // Crashes here</span><br></pre></td></tr></table></figure></li><li><p>在C++中，如果你让oneof消息使用Swap函数，这两个消息会拥有对方的值，如下，msg1会有sub_message的值，msg2会有name的值</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">SampleMessage</span> <span class="selector-tag">msg1</span>;</span><br><span class="line"><span class="selector-tag">msg1</span><span class="selector-class">.set_name</span>(<span class="string">"name"</span>);</span><br><span class="line"><span class="selector-tag">SampleMessage</span> <span class="selector-tag">msg2</span>;</span><br><span class="line"><span class="selector-tag">msg2</span><span class="selector-class">.mutable_sub_message</span>();</span><br><span class="line"><span class="selector-tag">msg1</span><span class="selector-class">.swap</span>(&amp;msg2);</span><br><span class="line"><span class="selector-tag">CHECK</span>(msg1.has_sub_message());</span><br><span class="line"><span class="selector-tag">CHECK</span>(msg2.has_name());</span><br></pre></td></tr></table></figure></li></ul><h3 id="向后兼容问题"><a href="#向后兼容问题" class="headerlink" title="向后兼容问题"></a>向后兼容问题</h3><p>在消息中添加或删除oneof字段时，要特别小心。如果检查到字段的结果是None或NOT_SET，可能意味着消息还没有被设置或者在不同版本的oneof消息中被设置了。没法知道一个不知道的字段是不是oneof消息的成员，这种情况就没有办法区分。</p><h3 id="标签重用问题"><a href="#标签重用问题" class="headerlink" title="标签重用问题"></a>标签重用问题</h3><ul><li>将可选字段移动到或者移出oneof：序列化或反序列化消息的时候可能会丢失一些信息（一些字段会被清空）。</li><li>删除一个oneof字段并且将它加回来：序列化或反序列化消息的时候可能会清空你当前设置的字段。</li><li>分割或合并oneof消息：这和移动optional字段类似。</li></ul><h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><p>如果你想在你数据定义中使用map，protobuf提供了一个简单的语法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;key_type, value_type&gt; map_field = N;</span><br></pre></td></tr></table></figure></p><p>key_type可以是整数或者string类型（因此除了浮点数的原生类型都可以），value_type可以是任何类型。</p><p>例如，你想创建一个和字符串关联的Project变量projects，可以使用如下的语法：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, Project&gt; projects = <span class="number">3</span>;</span><br></pre></td></tr></table></figure></p><p>更多的api可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/overview" target="_blank" rel="noopener">这里</a>。</p><h3 id="Map特性"><a href="#Map特性" class="headerlink" title="Map特性"></a>Map特性</h3><ul><li>扩展不支持map</li><li>map不能是repeated、optional或required</li><li>二进制格式的顺序或map迭代的顺序是未定义的，因此你不能依赖map的items以特定的顺序进行遍历</li><li>当proto转换成text格式的时候，map会按照key排序，key是数字的时候按照数字大小排序</li><li>当从二进制解析或合并的时候，如果map的key重复了，只有最后一个value会被用到。当从text格式解析的时候，遇到重复的键值，会解析失败</li></ul><h3 id="向后兼容问题-1"><a href="#向后兼容问题-1" class="headerlink" title="向后兼容问题"></a>向后兼容问题</h3><p>map在二进制格式下与下边的语法一样，因此protobuf实现虽然不支持map，但仍然能后处理你的数据：<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">message</span> MapFieldEntry &#123;</span><br><span class="line"><span class="attribute">key_type</span> key = <span class="number">1</span>;</span><br><span class="line"><span class="attribute">value_type</span> value = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="attribute">repeated</span> MapFieldEntry map_field = N;</span><br></pre></td></tr></table></figure></p><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>你可以在proto文件中加入可选的package指定包名称，这样可以避免消息的名称出现冲突。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> foo.bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Open</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure></p><p>为消息添加包名之后需要添加包名来取到特定的消息：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">required</span> foo.bar.Open open = <span class="number">1</span>;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在不同的语言中使用不同的语法来拿到包中的消息：</p><ul><li>在C++中，包使用名称空间实现，例如Open在名称空间foo::bar中</li><li>在Java中，可以像Java中的包一样使用，除非你在proto文件中额外指定了option java_package选项</li><li>在Python中，包直接被忽略了，因为Python使用源代码在文件系统中的位置来组织模块</li></ul><h3 id="包和名称解析"><a href="#包和名称解析" class="headerlink" title="包和名称解析"></a>包和名称解析</h3><p>在protobuf中的类型名称解析和C++中类似，首先在最内层的作用域搜寻，然后是次内层，等等。每一个包是它父包的内一层。一个前导的点表示从最外边的作用域开始搜寻，如.foo.bar.Baz。</p><p>protobuf编译器通过导入proto文件来解析所有的类型名。即使生成代码的语言有着不同的作用域规则，它也能引用到每一种类型。</p><h2 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h2><p>如果你想在RPC（Remote Procedure Call）系统中使用你的消息，你可以在proto文件中定义一个RPC服务的接口，protobuf编译器会自动生成这些服务接口的代码。例如，你想定义一个接收SearchRequest和返回SearchResponse方法的RPC服务，你可以在proto文件中类似这样定义：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">SearchService</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> Search (SearchRequest) <span class="keyword">returns</span> (SearchResponse)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>默认的，protobuf编译器会生成一个名为SearchService的抽象接口，并且有一个相应的“桩”实现。这个实现将所有的请求转发给一个必须实现抽象接口的RpcChannel。例如，你想实现一个将序列化消息通过HTTP发送给服务器的RpcChannel。换句话说，生成的代码提供了一个使用基于protobuf类型安全的RPC调用，而你不需要关注特定的RPC实现，因此，在C++中，你可以像这样写代码：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> google::protobuf;</span><br><span class="line"></span><br><span class="line">protobuf::RpcChannel* channel;</span><br><span class="line">protobuf::RpcController* controller;</span><br><span class="line">SearchService* service;</span><br><span class="line">SearchRequest request;</span><br><span class="line">SearchResponse response;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DoSearch</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// You provide classes MyRpcChannel and MyRpcController, which implement</span></span><br><span class="line"><span class="comment">// the abstract interfaces protobuf::RpcChannel and protobuf::RpcController.</span></span><br><span class="line">channel = <span class="keyword">new</span> MyRpcChannel(<span class="string">"somehost.example.com:1234"</span>);</span><br><span class="line">controller = <span class="keyword">new</span> MyRpcController;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The protocol compiler generates the SearchService class based on the</span></span><br><span class="line"><span class="comment">// definition given above.</span></span><br><span class="line">service = <span class="keyword">new</span> SearchService::Stub(channel);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set up the request.</span></span><br><span class="line">request.set_query(<span class="string">"protocol buffers"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute the RPC.</span></span><br><span class="line">service-&gt;Search(controller, request, response, protobuf::NewCallback(&amp;Done));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">delete</span> service;</span><br><span class="line"><span class="keyword">delete</span> channel;</span><br><span class="line"><span class="keyword">delete</span> controller;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所有的服务类会实现一个服务的接口，它提供了一个不需要在编译时知道方法名或它的输入类型和输出类型而调用特定接口的方式。在服务端，这可以用来实现一个可以注册服务的RPC服务器。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> google::protobuf;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExampleSearchService</span> :</span> <span class="keyword">public</span> SearchService</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search</span><span class="params">(protobuf::RpcController* controller, <span class="keyword">const</span> SearchRequest* request,</span></span></span><br><span class="line"><span class="function"><span class="params">SearchResponse* response, protobuf::Closure* done)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (request-&gt;query() == <span class="string">"google"</span>) &#123;</span><br><span class="line">response-&gt;add_result()-&gt;set_url(<span class="string">"http://www.google.com"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (request-&gt;query() == <span class="string">"protocol buffers"</span>) &#123;</span><br><span class="line">response-&gt;add_result()-&gt;set_url(<span class="string">"http://protobuf.googlecode.com"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">done-&gt;Run();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// You provide class MyRpcServer.  It does not have to implement any</span></span><br><span class="line"><span class="comment">// particular interface; this is just an example.</span></span><br><span class="line">MyRpcServer server;</span><br><span class="line"></span><br><span class="line">protobuf::Service* service = <span class="keyword">new</span> ExampleSearchService;</span><br><span class="line">server.ExportOnPort(<span class="number">1234</span>, service);</span><br><span class="line">server.Run();</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> service;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除此之外，你可以使用<a href="https://github.com/grpc/grpc-common" target="_blank" rel="noopener"> gRPC</a>：一个谷歌开发的语言和平台无关的开源RPC系统。gRPC可以很好的和protobuf一起工作，通过一个特殊的protobuf编译器插件从proto文件生成相应的RPC代码。然而，因为客户端和服务器使用的proto2和proto3生成代码之间潜在的兼容性问题，推荐你使用proto3来定义RPC服务。你可以在<a href="https://developers.google.com/protocol-buffers/docs/proto3" target="_blank" rel="noopener">Proto3 Language Guide</a>这里找到更多关于proto3的语法。如果你想在gRPC中使用proto2，你需要使用version 3.0.0或更高版本的protobuf编译器和库。</p><p>除了gRPC，有许多不断基于protobuf的正在开发中的第三方RPC项目。你可以在这里找到这些列表：<a href="https://github.com/google/protobuf/blob/master/docs/third_party.md" target="_blank" rel="noopener">third-party add-ons wiki page</a>。</p><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><p>在一个单独的proto文件中可以声明一些选项。选项不会改变一些整体声明的含义，但是可能会影响一些它在特定上下文的处理。全部的选项在google/protobuf/descriptor.proto中。</p><p>一些选项是文件级的选项，意味着你应该将这些选项写在top-level的作用域，而不是在任何消息，枚举或服务的定义中。一些选项是消息级别的定义，意味着应该写在消息定义里。一些选项是字段级别的选项，意味着它们应该写在字段定义中。选项也可以应用在枚举类型，枚举值，服务类型和服务方法，然而这些选项对它们没有用。</p><p>这里是很多常用的选项：</p><ul><li><p>java_package（文件选项）：你想在生成的java类中使用的包名。如果没有在proto文件中指定java_package选项，那么将会使用默认的proto包（在proto文件中使用package关键字指定）。然而，proto的包通常不用来代替Java包，因为proto的包不期望是一个反向域名。如果不生成Java代码，这个选项不起作用。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">option java_package</span> = <span class="string">"com.example.foo"</span>;</span><br></pre></td></tr></table></figure></li><li><p>java_outer_classname（文件选项）：这个类名是你生成的Java外部类的名字（也是文件名字）。如果不指定java_outer_classname，类名由proto文件的名字驼峰方式组成（如foo_bar.proto 的名字FooBar.java）。如果不生成Java代码，这个选项不起作用。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">option java_outer_classname</span> = <span class="string">"Ponycopter"</span>;</span><br></pre></td></tr></table></figure></li><li><p>optimize_for (文件选项): 可以设置为SPEED，CODE_SIZE或者LITE_RUNTIME。这个对C++和Java代码生成器（或其他第三方代码生成器）的起作用的方式如下：</p><ul><li>SPEED（默认）：protobuf编译器为序列化，解析和在消息类型上执行其他通用的操作而生成代码。这个代码性能是很高的。</li><li>CODE_SIZE：在这个选项下protobuf编译器会生成较小的类，它们会依赖共享的，基于反射的代码来实现序列化、解析和变量的其他操作。生成的代码比SPEED小，但是操作的速度会变慢。类仍然会实现和SPEED模式下一样的公共API。这个模式比较适合那些包含了很多数量的proto文件，而又对它们的性能没有很高要求的场景。</li><li>LITE_RUNTIME：protobuf编译器会生成在运行时依赖”lite”库（用libprotobuf-lite替代libprotobuf）的类。lite运行时库比全量的库小很多（大概小一个数量级），但是它去除了一些类似描述器和反射的特性。这对运行在特定平台如移动电话上的应用格外有用。编译器会生成与SPEED模式速度一样的方法。生成的类在每种语言中仅仅会实现MessageLite接口中的方法，它提供了Message全部方法的子集。<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">option optimize_for</span> = CODE_SIZE;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>cc_generic_services, java_generic_services, py_generic_services (文件选项): 它们分别决定编译器在生成C++、Java和Python代码时是否基于服务定义生成抽象服务代码。因为历史原因，它们默认是true。然而，2.3.0版本（2010年1月）认为更好实现RPC系统的方法是提供代码生成插件去为每一个系统去生成代码，而不是依赖抽象服务。</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// This <span class="keyword">file</span> relies <span class="keyword">on</span> plugins to generate service code.</span><br><span class="line"><span class="keyword">option</span> cc_generic_services = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">option</span> java_generic_services = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">option</span> py_generic_services = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure></li><li><p>cc_enable_arenas (文件选项)：Enables <a href="https://developers.google.com/protocol-buffers/docs/reference/arenas" target="_blank" rel="noopener">arena allocation</a> for C++ generated code</p></li><li><p>message_set_wire_format (消息选项)：如果设置成true，这个消息使用一个不同的意图兼容以前在Google内部使用被叫做MessageSet的二进制格式。在Google之外的使用者或许永远也不会用到这个选项。消息必须被定义为如下形式：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> message_set_wire_format = <span class="literal">true</span>;</span><br><span class="line">  extensions <span class="number">4</span> to max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>packed(字段选项)：如果设置为true，在基本数字类型的repeated字段上会使用更加紧凑的编码。使用这个选项没有缺点。2.3.0之前的版本遇到packed数据会忽略它，因此，改变一个存在的字段不可能不打破wire的兼容性。在2.3.0之后的版本，这个改变是安全的，因为解析器总是能接受这两种格式，但是要在使用老版本protobuf的程序中小心的处理这个字段。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">repeated</span> <span class="built_in">int32</span> samples = <span class="number">4</span> [packed=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li><li><p>deprecated (字段选项)：如果设置为true，表示这个字段是废弃的，不应该在新的代码中使用这个字段。在多数语言中这个选项没有实际的用处，在Java中，这会变成一个@Deprecated的注解。在未来，其他特定语言的生成器也许会生成在字段访问器上添加废弃符号，在真正编译代码的时候如果尝试使用这个字段，则发出一个警告。如果这个字段没有被任何人使用，而且希望新用户不会使用这个字段，可以考虑将其放置在保留语句中。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> old_field = <span class="number">6</span> [deprecated=<span class="literal">true</span>];</span><br></pre></td></tr></table></figure></li></ul><h3 id="自定义选项"><a href="#自定义选项" class="headerlink" title="自定义选项"></a>自定义选项</h3><p>Protobuf甚至可以允许你定义和使用你自己的选项。注意到这个高级特性大多数人并不需要用到。选项例如FileOptions或FieldOptions在google/protobuf/descriptor.proto文件中定义，因此，定义自己的选项可以简单的扩展这些消息。例如：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.MessageOptions &#123;</span><br><span class="line">  <span class="keyword">optional</span> <span class="built_in">string</span> my_option = <span class="number">51234</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line">  <span class="keyword">option</span> (my_option) = <span class="string">"Hello world!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里我们通过扩展MessageOptions定义了一个消息选项。当我们使用这个选项时，这个选项的名字必须使用括号括起来，表示这是一个扩展的选项。我们可以在C++中类似这样来读取my_option的值：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string value = MyMessage::descriptor<span class="function"><span class="params">()</span>-&gt;</span>options().GetExtension(my_option);</span><br></pre></td></tr></table></figure></p><p>MyMessage::descriptor()-&gt;options()返回MyMessage类型的MessageOptions，读取自定义选项，就像读取其他扩展字段。<br>相应的，在Java中可以写成这样：<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String value = MyProtoFile.MyMessage.getDescriptor<span class="params">()</span><span class="string">.getOptions</span><span class="params">()</span></span><br><span class="line"><span class="string">.getExtension</span><span class="params">(MyProtoFile.myOption)</span>;</span><br></pre></td></tr></table></figure></p><p>在Python类似：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">value = my_proto_file_pb2<span class="selector-class">.MyMessage</span><span class="selector-class">.DESCRIPTOR</span>.GetOptions()</span><br><span class="line"><span class="selector-class">.Extensions</span>[my_proto_file_pb2.my_option]</span><br></pre></td></tr></table></figure></p><p>自定义选项可以用在使用protobuf构造的任何结构中，下边是例子：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FileOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> my_file_option = <span class="number">50000</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.MessageOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> my_message_option = <span class="number">50001</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">float</span> my_field_option = <span class="number">50002</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.EnumOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">bool</span> my_enum_option = <span class="number">50003</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.EnumValueOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">uint32</span> my_enum_value_option = <span class="number">50004</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.ServiceOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> MyEnum my_service_option = <span class="number">50005</span>;</span><br><span class="line">&#125;</span><br><span class="line">extend google.protobuf.MethodOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> MyMessage my_method_option = <span class="number">50006</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> (my_file_option) = <span class="string">"Hello world!"</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line"><span class="keyword">option</span> (my_message_option) = <span class="number">1234</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> foo = <span class="number">1</span> [(my_field_option) = <span class="number">4.5</span>];</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> bar = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">MyEnum</span> </span>&#123;</span><br><span class="line"><span class="keyword">option</span> (my_enum_option) = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">FOO = <span class="number">1</span> [(my_enum_value_option) = <span class="number">321</span>];</span><br><span class="line">BAR = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">RequestType</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">ResponseType</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">service</span> <span class="title">MyService</span> </span>&#123;</span><br><span class="line"><span class="keyword">option</span> (my_service_option) = FOO;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">rpc</span> MyMethod(RequestType) <span class="keyword">returns</span>(ResponseType) &#123;</span></span><br><span class="line"><span class="function">// Note:  my_method_option has type MyMessage.  We can set each field</span></span><br><span class="line"><span class="function">//   within it using a separate "option" line.</span></span><br><span class="line"><span class="function">option (my_method_option).foo = 567</span>;</span><br><span class="line"><span class="keyword">option</span> (my_method_option).bar = <span class="string">"Some string"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意如果你希望使用在一个package中定义的选项，你必须在选项名字前加上package名，就像使用类型那样：<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"google/protobuf/descriptor.proto"</span>;</span><br><span class="line"><span class="keyword">package</span> foo;</span><br><span class="line">extend google.protobuf.MessageOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> my_option = <span class="number">51234</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar.proto</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">"foo.proto"</span>;</span><br><span class="line"><span class="keyword">package</span> bar;</span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">MyMessage</span> </span>&#123;</span><br><span class="line"><span class="keyword">option</span> (foo.my_option) = <span class="string">"Hello world!"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最后一点：因为自定义选项是扩展，他们必须像其他字段或扩展那样指定标签号。在上边的例子中，我们使用了范围为50000-99999的字段号，这个范围时预留给独立组织内部使用的，因此你可以自由的在你自己的应用中使用。如果你想使用自定义选项在公共的应用中，你必须确保你的字段数字是全局唯一的。你可以向protobuf-global-extension-registry@google.com发送申请来获取一个全局唯一的字段数字，只需要提供你的项目名称和网站（如果可用的话）。通常，你只需要一个扩展数字，你可以声明多个选项在一个扩展消息中。<br><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">FooOptions</span> </span>&#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> opt1 = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">string</span> opt2 = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">extend google.protobuf.FieldOptions &#123;</span><br><span class="line"><span class="keyword">optional</span> FooOptions foo_options = <span class="number">1234</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// usage:</span></span><br><span class="line"><span class="class"><span class="keyword">message</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> a = <span class="number">1</span> [(foo_options).opt1 = <span class="number">123</span>, (foo_options).opt2 = <span class="string">"baz"</span>];</span><br><span class="line"><span class="comment">// alternative aggregate syntax (uses TextFormat):</span></span><br><span class="line"><span class="keyword">optional</span> <span class="built_in">int32</span> b = <span class="number">2</span> [(foo_options) = &#123; opt1: <span class="number">123</span> opt2: <span class="string">"baz"</span> &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为不同的选项级别有着不同的字段数字空间，因此，你可以在不同的选项级别中使用相同的扩展数字。</p><h2 id="生成你的消息类"><a href="#生成你的消息类" class="headerlink" title="生成你的消息类"></a>生成你的消息类</h2><p>为了生成与你定义的proto文件相应的Java，Python或C++代码，你需要运行protobuf编译器来作用在你的proto文件上。如果你还没有protobuf编译器，下载<a href="https://developers.google.com/protocol-buffers/docs/downloads.html" target="_blank" rel="noopener">安装包</a>，然后阅读README。<br>可以像这样调用protobuf编译器：<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc <span class="attribute">--proto_path</span>=IMPORT_PATH <span class="attribute">--cpp_out</span>=DST_DIR <span class="attribute">--java_out</span>=DST_DIR <span class="attribute">--python_out</span>=DST_DIR path/<span class="keyword">to</span>/file.proto</span><br></pre></td></tr></table></figure></p><ul><li>IMPORT_PATH：指定了当使用import指令时寻找proto文件的路径。如果省略，就会搜寻当前路径。可以通过指定多次—proto_path来指定多个搜寻路径，他们会按照顺序搜寻。-I=IMPORT_PATH是—proto_path的简写。</li><li>你可以提供一个活多个输出目录：<ul><li>—cpp_out：生成C++代码的目录。了解更多可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/cpp-generated" target="_blank" rel="noopener">这里</a>。</li><li>—java_out：生成Java代码的目录。了解更多可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/java-generated" target="_blank" rel="noopener">这里</a>。</li><li>—python_out：生成Python代码的目录。了解更多可以参考<a href="https://developers.google.com/protocol-buffers/docs/reference/python-generated" target="_blank" rel="noopener">这里</a>。</li></ul></li></ul><p>作为便利，如果这个目录是以.zip或.jar结尾的，编译器将会把文件输出到给定名字的zip文件中，对于.jar还会加入Java JAR需要的manifest文件。如果文件已经存在，将会覆盖写入。</p><ul><li>你必须提供一个或多个proto文件作为输入。多个proto文件可以在一次提供，尽管名字是以当前目录的相对路径确定的，但是仍然需要的IMPORT_PATHs中包含，以确定它的位置。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1) <a href="https://developers.google.com/protocol-buffers" target="_blank" rel="noopener">Google Protocol Buffer 的在线帮助</a><br>2) <a href="https://www.ibm.com/developerworks/cn/linux/l-cn-gpb" target="_blank" rel="noopener">Google Protocol Buffer 的使用和原理 - IBM</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是Google-ProtoBuf？&quot;&gt;&lt;a href=&quot;#什么是Google-ProtoBuf？&quot; class=&quot;headerlink&quot; title=&quot;什么是Google ProtoBuf？&quot;&gt;&lt;/a&gt;什么是Google ProtoBuf？&lt;/h2&gt;&lt;p&gt;ProtoBuf是一种灵活高效的结构化数据存储机制，像XML一样，但是其更加轻巧、快速、简单。&lt;br&gt;使用ProtoBuf十分简单，只需要在.proto文件中定义数据就好了，然后你可以利用ProtoBuf提供的工具生成不同语言的序列化和反序列化的代码，目前提供C++、Java、Python、C#、GO等语言版本。&lt;/p&gt;
&lt;h2 id=&quot;ProtoBuf的优点&quot;&gt;&lt;a href=&quot;#ProtoBuf的优点&quot; class=&quot;headerlink&quot; title=&quot;ProtoBuf的优点&quot;&gt;&lt;/a&gt;ProtoBuf的优点&lt;/h2&gt;&lt;p&gt;同XML数据相比，ProboBuf有这许多优点：&lt;br&gt;1：简单&lt;br&gt;2：小3-10倍&lt;br&gt;3：快20-100倍&lt;br&gt;4：更少的二义性&lt;br&gt;5：生成的数据访问类更加容易编程&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c++" scheme="https://blog.gwq5210.com/tags/c/"/>
    
      <category term="protobuf" scheme="https://blog.gwq5210.com/tags/protobuf/"/>
    
      <category term="python" scheme="https://blog.gwq5210.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>c语言中使用数据库</title>
    <link href="https://blog.gwq5210.com/2016/01/23/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <id>https://blog.gwq5210.com/2016/01/23/c语言中使用数据库/</id>
    <published>2016-01-23T20:21:40.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先，要安装mysql数据库，安装好后，可能还不能使用mysql的c语言库，还要安装mysql的库，命令如下：sudo apt-get install libmysql++-dev。<br>安装好后，就可以包含<mysql mysql.h>头文件，然后使用mysql的c语言api了。</mysql></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>1）MYSQL<br>这个结构体代表一个数据库连接的句柄，它被大多数的mysql函数使用。不要尝试拷贝MYSQL结构体，不保证这样的拷贝是可以使用的。<br>MYSQL的定义如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  NET       net;            <span class="comment">/* Communication parameters */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> *connector_fd;      <span class="comment">/* ConnectorFd for SSL */</span></span><br><span class="line">  <span class="keyword">char</span>      *host,*user,*passwd,*unix_socket,*server_version,*host_info;</span><br><span class="line">  <span class="keyword">char</span>          *info, *db;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">charset_info_st</span> *<span class="title">charset</span>;</span></span><br><span class="line">  MYSQL_FIELD   *fields;</span><br><span class="line">  MEM_ROOT  field_alloc;</span><br><span class="line">  my_ulonglong affected_rows;</span><br><span class="line">  my_ulonglong insert_id;       <span class="comment">/* id if insert on table with NEXTNR */</span></span><br><span class="line">  my_ulonglong extra_info;      <span class="comment">/* Not used */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> thread_id;      <span class="comment">/* Id for connection in server */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> packet_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  port;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> client_flag,server_capabilities;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  protocol_version;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  field_count;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  server_status;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  server_language;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  warning_count;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_options</span> <span class="title">options</span>;</span></span><br><span class="line">  <span class="keyword">enum</span> mysql_status status;</span><br><span class="line">  my_bool   free_me;        <span class="comment">/* If free in mysql_close */</span></span><br><span class="line">  my_bool   reconnect;      <span class="comment">/* set to 1 if automatic reconnect */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* session-wide random string */</span></span><br><span class="line">  <span class="keyword">char</span>          scramble[SCRAMBLE_LENGTH+<span class="number">1</span>];</span><br><span class="line">  my_bool unused1;</span><br><span class="line">  <span class="keyword">void</span> *unused2, *unused3, *unused4, *unused5;</span><br><span class="line"></span><br><span class="line">  LIST  *stmts;                     <span class="comment">/* list of all statements */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_methods</span> *<span class="title">methods</span>;</span></span><br><span class="line">  <span class="keyword">void</span> *thd;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">    Points to boolean flag in MYSQL_RES  or MYSQL_STMT. We set this flag </span></span><br><span class="line"><span class="comment">    from mysql_stmt_close if close had to cancel result set of this object.</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  my_bool *unbuffered_fetch_owner;</span><br><span class="line">  <span class="comment">/* needed for embedded server - no net buffer to store the 'info' */</span></span><br><span class="line">  <span class="keyword">char</span> *info_buffer;</span><br><span class="line">  <span class="keyword">void</span> *extension;</span><br><span class="line">&#125; MYSQL;</span><br></pre></td></tr></table></figure><p>2）MYSQL_RES<br>这个结构体代表查询结果的所有列（SELECT，SHOW，DESCRIBE，EXPLAIN）。查询返回的结果叫做数据集，可以在后边使用。<br>MYSQL_RES的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_res</span> &#123;</span></span><br><span class="line">  my_ulonglong  row_count;</span><br><span class="line">  MYSQL_FIELD   *fields;</span><br><span class="line">  MYSQL_DATA    *data;</span><br><span class="line">  MYSQL_ROWS    *data_cursor;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *lengths;       <span class="comment">/* column lengths of current row */</span></span><br><span class="line">  MYSQL     *handle;        <span class="comment">/* for unbuffered reads */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_methods</span> *<span class="title">methods</span>;</span></span><br><span class="line">  MYSQL_ROW row;            <span class="comment">/* If unbuffered read */</span></span><br><span class="line">  MYSQL_ROW current_row;        <span class="comment">/* buffer to current row */</span></span><br><span class="line">  MEM_ROOT  field_alloc;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  field_count, current_field;</span><br><span class="line">  my_bool   eof;            <span class="comment">/* Used by mysql_fetch_row */</span></span><br><span class="line">  <span class="comment">/* mysql_stmt_close() had to cancel this result */</span></span><br><span class="line">  my_bool       unbuffered_fetch_cancelled;  </span><br><span class="line">  <span class="keyword">void</span> *extension;</span><br><span class="line">&#125; MYSQL_RES;</span><br></pre></td></tr></table></figure></p><p>3，MYSQL_ROW<br>用来表示查询出来的一行，可以通过mysql_fetch_row()函数获得。<br>MYSQL_ROW的定义如下：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef char **MYSQ<span class="class">L_ROW;</span>       /*<span class="built_in"> return </span>data as<span class="built_in"> array </span>of strings */</span><br></pre></td></tr></table></figure></p><p>4，MYSQL_FIELD<br>用来表示数据库中的字段。包含的信息有字段名，类型，大小等。可以通过mysql_fetch_field()函数获得。<br>MYSQL_FIELD的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_field</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;                 <span class="comment">/* Name of column */</span></span><br><span class="line">  <span class="keyword">char</span> *org_name;             <span class="comment">/* Original column name, if an alias */</span></span><br><span class="line">  <span class="keyword">char</span> *table;                <span class="comment">/* Table of column if column was a field */</span></span><br><span class="line">  <span class="keyword">char</span> *org_table;            <span class="comment">/* Org table name, if table was an alias */</span></span><br><span class="line">  <span class="keyword">char</span> *db;                   <span class="comment">/* Database for table */</span></span><br><span class="line">  <span class="keyword">char</span> *catalog;          <span class="comment">/* Catalog for table */</span></span><br><span class="line">  <span class="keyword">char</span> *def;                  <span class="comment">/* Default value (set by mysql_list_fields) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> length;       <span class="comment">/* Width of column (create length) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> max_length;   <span class="comment">/* Max width for selected set */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> name_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> org_name_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> table_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> org_table_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> db_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> catalog_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> def_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;         <span class="comment">/* Div flags */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> decimals;      <span class="comment">/* Number of decimals in field */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> charsetnr;     <span class="comment">/* Character set */</span></span><br><span class="line">  <span class="keyword">enum</span> enum_field_types type; <span class="comment">/* Type of field. See mysql_com.h for types */</span></span><br><span class="line">  <span class="keyword">void</span> *extension;</span><br><span class="line">&#125; MYSQL_FIELD;</span><br></pre></td></tr></table></figure></p><h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><p>1）mysql_init<br>头文件：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>函数原型为：<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MYSQL *mysql_init(MYSQL *mysql)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>在连接数据库之前，必须调用mysql_init函数来初始化一个MYSQL结构体。这个结构体可以使用mysql_real_connect()函数连接数据库。如果mysql是NULL，那么函数初始化一个新的结构体，分配新的内存空间，并返回内存空间的地址，如果不是NULL，则初始化mysql指向的内存，返回传进来的地址。函数执行成功返回MYSQL结构体的指针，否则返回NULL。</p><p>2）mysql_real_connect<br>连接数据库需要设置相关的参数，可以使用这个函数来完成，并进行实际的连接。原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *host,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *user,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *passwd,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *db,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">int</span> port,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">const</span> <span class="keyword">char</span> *unix_socket,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">unsigned</span> <span class="keyword">long</span> clientflag)</span></span>;</span><br></pre></td></tr></table></figure></p><p>需要包含头文件：<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>来说明参数的含义:</p><ul><li>mysql是使用mysql_init()函数初始化的结构体；</li><li>host是mysql服务器所在的服务器计算机名或者ip地址，如果host是NULL或者是字符串”localhost”，那么就连接到本地计算机；</li><li>user和passwd是数据库登陆时的用户名和密码，如果user是NULL或者空字符串””，那么假设用户名为当前登陆的用户ID，如果passwd是NULL，则只可以访问这个服务器中不需要口令的数据，口令在传递到网络以前是加密的；</li><li>db表示数据库的名字，如果db不是NULL，那么连接将这个数据库设置为默认的数据库；</li><li>如果port非零，那么这个值用来当做TCP/IP连接的端口，一般来说port取0；</li><li>如果unix_socket不是NULL，那么这个字符串指定的socket或者命名管道会使用，这与host参数有关；一般来unix_socket取NULL；</li><li>clientflag通常为0，在很特殊的情况下可以是一些标志的组合，下面列出一些，详细请见文档。<ol><li>CLIENT_FOUND_ROWS，返回找到的（匹配的）行数，而不是收到影响的行数。</li><li>CLIENT_NO_SCHEMA，不允许db_name.tbl_name.col_name语法，这是为了ODBC，如果使用该语法，将导致语法分析器产生一个错误，它在一些有bugs的ODBC程序中是有用的。</li><li>CLIENT_COMPRESS，使用压缩协议。</li></ol></li></ul><p>mysql_real_connect函数成功返回一个只想MYSQL结构体的指针，返回值与第一个参数值相同，如果连接失败返回NULL，可以使用mysql_error()函数来查看错误原因。</p><p>3）mysql_close<br>完成连接任务后，可以用mysql_close()来关闭连接，原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_close</span><span class="params">(MYSQL *sock)</span></span>;</span><br></pre></td></tr></table></figure></p><p>关闭连接后，sock会被清空，指针也变的无效而不能再使用。</p><p>4）mysql_options<br>这个函数与连接函数关系紧密，它只能在mysql_init()函数和mysql_real_connect函数之间调用。原型如下：<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;mysql/mysql.h&gt;</span></span><br><span class="line"></span><br><span class="line">int mysql_options(MYSQL *mysql,<span class="class"><span class="keyword">enum</span> <span class="title">mysql_option</span> <span class="title">option</span>,  </span></span><br><span class="line">         const void *arg);</span><br></pre></td></tr></table></figure></p><p>这个函数用来设置额外的连接选项，并影响连接的行为。可以多次调用该函数来设置数个选项。option是打算设置的选项，arg是打算设置的值。如果选项是整数，那么arg应该指向整数的值，下面列出一些选项，详细请见文档。</p><ul><li>MYSQL_INIT_COMMAND，参数类型为char *，当连接到mysql服务器时执行的命令，再次执行连接时会自动的调用。</li><li>MYSQL_OPT_CONNECT_TIMEOUT，参数类型为unsigned int *，以秒为单位的连接超时。</li><li>MYSQL_OPT_PROTOCOL，参数类型为unsigned int *，要使用的协议类型，应该是mysql.h中定义的mysql_protocal_type的枚举类型之一。</li><li>MYSQL_OPT_COMPRESS，参数没有使用，在网络连接中使用压缩。</li></ul><p>mysql_options()函数成功调用返回0，否则返回非零值。</p><p>5）mysql_errno<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysql_errno</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数用来获取制定的连接最近调用函数的错误代码。这个函数调用可能成功，也可能失败。返回0表示未出现错误。在MYSQL errmsg.h头文件中列出了错误信息的代码。</p><p>6）mysql_error<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mysql_error</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>对于mysql指定的连接，mysql_error()函数返回最近调用函数失败原因的字符串表示，字符串以’\0’作为终结字符，如果没有错误，则返回的可能时上一个错误，或者返回空串。如果返回空串，说明没有产生错误。</p><p>7）mysql_query，mysql_real_query<br>函数原型如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *q)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_real_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *q,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">unsigned</span> <span class="keyword">long</span> length)</span></span>;</span><br></pre></td></tr></table></figure></p><p>对于制定mysql连接，执行q指向的字符串的SQL语句，与命令行不同，它不需要包含表示终止的分号。如果运行成功，函数返回0，否则返回非零。mysql_query()函数不能用来执行包含二进制数据的语句操作，这时，就必须使用mysql_real_query()函数，length代表字符串的长度，此外，mysql_real_query不需要调用strlen来，所以更快。你可以使用mysql_field_count()函数来检查语句是否返回结果集。<br>错误信息可能是如下情况：</p><ul><li>CR_COMMANDS_OUT_OF_SYNC，以不恰当的顺序执行了命令。</li><li>CR_SERVER_GONE_ERROR，mysql服务器不可用。</li><li>CR_SERVER_LOST，查询过程中，与服务器的连接丢失了。</li><li>CR_UNKNOWN_ERROR，未知的错误。</li></ul><p>8）mysql_affected_rows<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">my_ulonglong <span class="title">mysql_affected_rows</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数用在不返回数据的SQL语句中，也就是UPDATA，DELETE和INSERT语句。这个函数返回上次UPDATE更改的行数，上次DELETE删除的行数或者上次INSERT插入的行数，或SELECT返回的行数。可以在执行过mysql_query()函数或者mysql_real_query()函数后调用。对于SELECT语句这个函数类似mysql_num_rows()。<br>返回值大于零表示影响的行数。零表示对于UPDATE没有数据被更新，在执行中没有行匹配WHERE子句或者没有语句被执行。-1表示出错，或者对于SELECT语句，mysql_affected_rows()函数的调用先于mysql_store_result()。因为这个函数返回无符号的值，所以，可以使用如下的方式检查-1，(my_ulonglong)-1或(my_ulonglong)~0，这两个方式是等价的。</p><p>通常，从mysql数据库中检索数据有四个步骤。</p><ul><li>发出查询。</li><li>检索数据。</li><li>处理数据。</li><li>整理所需要的数据。</li></ul><p>用mysql_query或mysql_real_query发出查询。检索数据可以用mysql_store_result或mysql_use_result，取决于怎样检索数据，接着是调用mysql_fetch_row来处理数据，最后必须调用mysql_free_result来让mysql进行必要的整理工作。</p><p>9）mysql_store_result<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_store_result</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数必须在调用mysql_query或者mysql_real_query函数后才能使用，用来在结果集中存储数据。可以产生数据的语句有SELECT，SHOW，DESCRIBE，EXPLAIN，CHECK TABLE等等。在对结果集操作完成后，你必须调用mysql_free_result。<br>这个函数返回一个结果集的指针，如果失败，则返回NULL。MYSQL_RES结构体定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_res</span> &#123;</span></span><br><span class="line">  my_ulonglong  row_count;</span><br><span class="line">  MYSQL_FIELD   *fields;</span><br><span class="line">  MYSQL_DATA    *data;</span><br><span class="line">  MYSQL_ROWS    *data_cursor;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> *lengths;       <span class="comment">/* column lengths of current row */</span></span><br><span class="line">  MYSQL     *handle;        <span class="comment">/* for unbuffered reads */</span></span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_methods</span> *<span class="title">methods</span>;</span></span><br><span class="line">  MYSQL_ROW row;            <span class="comment">/* If unbuffered read */</span></span><br><span class="line">  MYSQL_ROW current_row;        <span class="comment">/* buffer to current row */</span></span><br><span class="line">  MEM_ROOT  field_alloc;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span>  field_count, current_field;</span><br><span class="line">  my_bool   eof;            <span class="comment">/* Used by mysql_fetch_row */</span></span><br><span class="line">  <span class="comment">/* mysql_stmt_close() had to cancel this result */</span></span><br><span class="line">  my_bool       unbuffered_fetch_cancelled;  </span><br><span class="line">  <span class="keyword">void</span> *extension;</span><br><span class="line">&#125; MYSQL_RES;</span><br></pre></td></tr></table></figure></p><p>10）mysql_num_rows<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">my_ulonglong STDCALL <span class="title">mysql_num_rows</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure></p><p>如果调用mysql_store_result成功，则可以使用mysql_num_rows函数来检索实际返回的行数，返回结果当然可能为0。如果mysql_store_result成功，这个函数也会成功。<br>一旦调用mysql_store_result成功，那么所有查询的数据都将存储在客户端，不需要冒着网络出错的危险。如果查询的数据量很大，最好还是按照需要检索数据。<br>检索到数据后，需要对数据进行处理，可以使用这些函数：mysql_fetch_row,mysql_data_seek,mysql_row_tell,mysql_row_seek，将在下面介绍。</p><p>11）mysql_fetch_row<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_ROW <span class="title">mysql_fetch_row</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数返回结果集中的下一行数据。如果没有更多数据或出错，则返回NULL。</p><p>12）mysql_data_seek<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_data_seek</span><span class="params">(MYSQL_RES *result,  </span></span></span><br><span class="line"><span class="function"><span class="params">                    my_ulonglong offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>13）mysql_row_tell<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_ROW_OFFSET <span class="title">mysql_row_tell</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数返回一个偏移值，它表示结果集的当前位置，它不是行号，不能用于mysql_data_seek。但是可以将它用于mysql_row_seek。</p><p>14）mysql_row_seek<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_ROW_OFFSET <span class="title">mysql_row_seek</span><span class="params">(MYSQL_RES *result,</span></span></span><br><span class="line"><span class="function"><span class="params">                        MYSQL_ROW_OFFSET offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数移动结果集的位置，并且返回当前位置。这在已知的点之间跳转是很有用的。</p><p>15）mysql_free_result<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mysql_free_result</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br></pre></td></tr></table></figure></p><p>当完成对一个结果集的操作后，必须调用这个函数来释放内存空间。不要试图在调用此函数后，再次使用结果集。</p><p>16）mysql_use_result<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_RES *<span class="title">mysql_use_result</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数也和mysql_store_result一样，返回一个结果集的指针，不过，实际上它并没有检索到任何数据，仅仅初始化来接收数据，为了获得数据必须反复调用mysql_fetch_row，知道检索完数据。出错返回NULL。这中情况下，将不能使用函数mysql_num_rows，mysql_data_seek，mysql_row_seek，mysql_rows_tell，准确的说，mysql_num_rows可以被调用，不过在mysql_fetch检索完之前是不可能获取到可用的行数的。使用这个降低了网络通信量。<br>仅仅检索数据是没有用的，应该能够做进一步工作，返回的数据一般有两种：</p><ul><li>检索到的实际数据</li><li>关于数据的数据，即元数据</li></ul><p>17）mysql_field_count<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">mysql_field_count</span><span class="params">(MYSQL *mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>可以使用mysql_field_count函数返回最近一次执行查询中字段的数目。当mysql_store_result返回NULL的时候，可以调用这个函数来确定mysql_store_result为什么调用失败。一般来说，mysql_store_result失败的原因有：</p><ul><li>malloc调用失败，例如，结果集太大了。</li><li>不能读数据，如连接出现了错误。</li><li>查询没有返回数据，如查询语句是INSERT，UPDATE和DELETE。</li></ul><p>总是可以用这个函数来检查查询是否返回了空结果集。</p><p>18）mysql_fetch_field,mysql_fetch_fields<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_field</span><span class="params">(MYSQL_RES *result)</span></span>;</span><br><span class="line"><span class="function">MYSQL_FIELD *<span class="title">mysql_fetch_fields</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数返回一个MYSQL_FIELD结构体或数组，是结果集中的列定义。重复调用这个函数返回所有关于列的信息，当没有更多列时，返回NULL。<br>其中MYSQL_FIELD结构体的定义如下：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">st_mysql_field</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> *name;                 <span class="comment">/* Name of column */</span></span><br><span class="line">  <span class="keyword">char</span> *org_name;             <span class="comment">/* Original column name, if an alias */</span></span><br><span class="line">  <span class="keyword">char</span> *table;                <span class="comment">/* Table of column if column was a field */</span></span><br><span class="line">  <span class="keyword">char</span> *org_table;            <span class="comment">/* Org table name, if table was an alias */</span></span><br><span class="line">  <span class="keyword">char</span> *db;                   <span class="comment">/* Database for table */</span></span><br><span class="line">  <span class="keyword">char</span> *catalog;          <span class="comment">/* Catalog for table */</span></span><br><span class="line">  <span class="keyword">char</span> *def;                  <span class="comment">/* Default value (set by mysql_list_fields) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> length;       <span class="comment">/* Width of column (create length) */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> max_length;   <span class="comment">/* Max width for selected set */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> name_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> org_name_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> table_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> org_table_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> db_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> catalog_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> def_length;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> flags;         <span class="comment">/* Div flags */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> decimals;      <span class="comment">/* Number of decimals in field */</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> charsetnr;     <span class="comment">/* Character set */</span></span><br><span class="line">  <span class="keyword">enum</span> enum_field_types type; <span class="comment">/* Type of field. See mysql_com.h for types */</span></span><br><span class="line">  <span class="keyword">void</span> *extension;</span><br><span class="line">&#125; MYSQL_FIELD;</span><br></pre></td></tr></table></figure></p><p>19）IS_NUM<br>这是一个宏定义，用来检测字段是否是数字形式的，如果是，返回真。参数为MYSQL_FIELD结构体中的枚举类型type。</p><p>20）mysql_field_seek<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_FIELD_OFFSET <span class="title">mysql_field_seek</span><span class="params">(MYSQL_RES *result,</span></span></span><br><span class="line"><span class="function"><span class="params">                       MYSQL_FIELD_OFFSET offset)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数将字段光标移动到给定的偏移量，下一调用mysql_fetch_field将返回该偏移量指定的列。返回当前的偏移量。</p><p>21）mysql_field_tell<br>函数原型为；<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">MYSQL_FIELD_OFFSET <span class="title">mysql_field_tell</span><span class="params">(MYSQL_RES *res)</span></span>;</span><br></pre></td></tr></table></figure></p><p>这个函数用来设置当前连接的字符编码。csname指向一个有效的字符编码名字。函数作用与SET NAMES类似。这个函数会影响mysql_real_escape_string()的行为。<br>执行成功返回0，否则返回非0。一般来说，要显式的指定编码。<br>一个例子：<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">MYSQL mysql;</span><br><span class="line"></span><br><span class="line">mysql_init(<span class="variable">&amp;mysql</span>);</span><br><span class="line">if (!mysql_real_connect(<span class="variable">&amp;mysql</span>,<span class="string">"host"</span>,<span class="string">"user"</span>,<span class="string">"passwd"</span>,<span class="string">"database"</span>,<span class="number">0</span>,NULL,<span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line">    fprintf(stderr, <span class="string">"Failed to connect to database: Error: %s\n"</span>,</span><br><span class="line">          mysql_error(<span class="variable">&amp;mysql</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!mysql_set_character_set(<span class="variable">&amp;mysql</span>, <span class="string">"utf8"</span>))</span><br><span class="line">&#123;</span><br><span class="line">    printf(<span class="string">"New client character set: %s\n"</span>,</span><br><span class="line">           mysql_character_set_name(<span class="variable">&amp;mysql</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>23）mysql_autocommit<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">my_bool <span class="title">mysql_autocommit</span><span class="params">(MYSQL * mysql, my_bool auto_mode)</span></span>;</span><br></pre></td></tr></table></figure></p><p>mysql的默认提交操作是自动提交（autocommit），除非显式的开始一个事务，否则，每个查询被当做一个单独的事务自动执行，可以通过这个函数来开始一个事务。<br>MySQL默认的存储引擎是MyISAM，MyISAM存储引擎不支持事务处理，所以改变autocommit没有什么作用，InnoDB存储引擎支持事务处理。InnoDB表引擎下关闭mysql自动事物提交可以大大提高数据插入的效率，这是因为如果需要插入1000条数据，mysql会自动发起（提交）1000次的数据写入请求，如果把autocommit关闭掉，通过程序来控制，只要一次commit就可以搞定。<br>auto_mode参数为0或1。执行成功返回0，否则返回非0。</p><p>24）mysql_commit<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">my_bool <span class="title">mysql_commit</span><span class="params">(MYSQL * mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>手动进行一次提交操作。执行成功返回0，否则返回非0。</p><p>25）mysql_rollback<br>函数原型为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">my_bool <span class="title">mysql_rollback</span><span class="params">(MYSQL * mysql)</span></span>;</span><br></pre></td></tr></table></figure></p><p>手动进行一次回滚操作，执行成功返回0，否则返回非0。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1）<a href="http://www.cnblogs.com/yeahgis/p/3381485.html" target="_blank" rel="noopener">http://www.cnblogs.com/yeahgis/p/3381485.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;p&gt;首先，要安装mysql数据库，安装好后，可能还不能使用mysql的c语言库，还要安装mysql的库，命令如下：sudo apt-get install libmysql++-dev。&lt;br&gt;安装好后，就可以包含&lt;mysql mysql.h&gt;头文件，然后使用mysql的c语言api了。&lt;/mysql&gt;&lt;/p&gt;
&lt;h2 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h2&gt;&lt;p&gt;1）MYSQL&lt;br&gt;这个结构体代表一个数据库连接的句柄，它被大多数的mysql函数使用。不要尝试拷贝MYSQL结构体，不保证这样的拷贝是可以使用的。&lt;br&gt;MYSQL的定义如下：&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="mysql" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/mysql/"/>
    
    
      <category term="c语言" scheme="https://blog.gwq5210.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="数据库" scheme="https://blog.gwq5210.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
      <category term="mysql" scheme="https://blog.gwq5210.com/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>c语言中的可变参数</title>
    <link href="https://blog.gwq5210.com/2016/01/22/c%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    <id>https://blog.gwq5210.com/2016/01/22/c语言中的可变参数/</id>
    <published>2016-01-22T22:54:30.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<p>c语言中可变参数列表有关的内容在stdarg.h头文件中。这个头文件中的内容可以让函数实现类似scanf函数的功能，接收不确定个数的参数。<br>使用方法稍微复杂一些，必须按照如下步骤进行：<br>1.在函数原型中使用省略号。<br>2.在函数定义中创建一个va_list类型的变量。<br>3.用宏将该变量初始化为一个参数列表。<br>4.用宏访问这个参数列表。<br>5.用宏完成清理工作。</p><p>下面详细介绍这些步骤，函数原型中的参数列表中至少有一个后跟省略号的参数，这个参数成为parmN，如：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> n, ...)</span></span>;</span><br><span class="line"><span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">const</span> <span class="keyword">char</span> *s, ...)</span></span>;</span><br><span class="line"><span class="comment">// 无效，省略号不是最后一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">f3</span><span class="params">(<span class="keyword">char</span> c1, ..., <span class="keyword">char</span> c2)</span></span>;</span><br><span class="line"><span class="comment">// 无效，没有任何参数</span></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">f4</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>接下来，在头文件stdarg.h中声明的va_list类型代表一种数据对象，该数据对象用于存放参数列表中省略号部分代表的参数。可变参数函数的定义应该像下边这样：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">doube</span></span> <span class="keyword">sum</span>(int lim, ...)</span><br><span class="line">&#123;</span><br><span class="line">        va_list ap;        <span class="comment">// 声明用于存放参数的变量</span></span><br></pre></td></tr></table></figure><p>然后，函数将使用stdargs.h中定义的宏va_start()把参数列表复制到va_list变量中。宏va_start()有两个参数：va_list类型的变量和变量parmN。如前所述，这里两个参数分别为va和lim，所以，va_start()函数的调用如下所示：</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">va_start<span class="comment">(vp, lim)</span>;        <span class="comment">// 把vp初始化为参数列表</span></span><br></pre></td></tr></table></figure><p>下一步是访问参数列表中的内容，这涉及宏va_arg()的使用，该宏接受两个参数：一个va_list类型的变量和一个类型名。<br>第一次调用va_arg()时，它返回参数列表的第一项，下次调用返回第二项，一次类推。参数类型制定返回值的类型。例如，如果参数列表中第一个参数为double类型，第二个为int类型，那么可使用下列语句：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> tic;</span><br><span class="line"><span class="keyword">int</span> toc;</span><br><span class="line">...</span><br><span class="line">tic = va_arg(ap, <span class="keyword">double</span>);        <span class="comment">// 取得第一个参数</span></span><br><span class="line">toc = va_arg(ap, <span class="keyword">int</span>);        <span class="comment">// 取得第二个参数</span></span><br></pre></td></tr></table></figure><p>这里需要注意的是，实际参数的类型必须与说明的类型相匹配，如果第一个参数为10.0，那么前面的tic部分的代码正常工作；但是如果参数为10，代码就可能无法正常工作。这里不会像赋值过程中那样进行double到int的自动转换。<br>最后，应该使用va_end()完成清理工作。该宏接受一个va_list变量作为参数：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">va_end</span>(ap);        <span class="comment">// 清理工作</span></span><br></pre></td></tr></table></figure><p>此后，只有用va_start()重新对ap初始化后，才能使用变量ap。<br>因为va_arg()不提供后退回先前参数的方法，所以保存va_list变量的副本是有用的，C99为此专门添加了宏va_copy()。该宏的两个参数均为va_list类型变量，它将第二个参数复制到第一个参数中：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">va_list <span class="keyword">ap</span>;</span><br><span class="line">va_list apcopy;</span><br><span class="line">double tic;</span><br><span class="line">int toc;</span><br><span class="line">...</span><br><span class="line">va_start(<span class="keyword">ap</span>, lim);        <span class="comment">// 把ap初始化为参数列表</span></span><br><span class="line">va_copy(apcopy, <span class="keyword">ap</span>);       <span class="comment">// apcopy是ap一个副本</span></span><br><span class="line">tic = va_arg(<span class="keyword">ap</span>, double);        <span class="comment">// 取得第一个参数</span></span><br><span class="line">toc = va_arg(<span class="keyword">ap</span>, int);        <span class="comment">// 取得第二个参数</span></span><br></pre></td></tr></table></figure><p>这时，虽然已从ap中删除了前两项，但是还可以从apcopy中重新获取这两项。<br>下面是一个例子：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; File Name: varargs.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Author: gwq</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Mail: gwq5210@qq.com </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Created Time: 2015年01月07日 星期三 20时13分16秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line"><span class="built_in">double</span> sum(<span class="built_in">int</span> <span class="built_in">num</span>, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">double</span> res = <span class="number">0.0</span>;</span><br><span class="line">    va_start(ap, <span class="built_in">num</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>; ++i) &#123;</span><br><span class="line">        res += va_arg(ap, <span class="built_in">double</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">double</span> s = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    s = sum(<span class="number">3</span>, <span class="number">1.1</span>, <span class="number">2.5</span>, <span class="number">13.3</span>);</span><br><span class="line">    printf(<span class="string">"sum(3, 1.1, 2.5, 13.3) = %.2f\n"</span>, s);</span><br><span class="line">    <span class="comment">// 如果不对应，会出现错误，这与放的位置有关</span></span><br><span class="line">    <span class="comment">//s = sum(3, 1, 2.5, 13.3);</span></span><br><span class="line">    <span class="comment">//printf("sum(3, 1, 2.5, 13.3) = %.2f\n", s);</span></span><br><span class="line">    s = sum(<span class="number">6</span>, <span class="number">1.1</span>, <span class="number">2.1</span>, <span class="number">13.1</span>, <span class="number">4.1</span>, <span class="number">5.1</span>, <span class="number">6.1</span>);</span><br><span class="line">    printf(<span class="string">"sum(6, 1.1, 2.5, 13.1, 4.1, 5.1, 6.1) = %.2f\n"</span>, s);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上边也测试了，传进来的参数不对应的情况，发生了错误。<br>下面是另一个程序，说明了va_arg传入的类型还可以是自定义的类型：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; File Name: testargs.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Author: gwq</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Mail: gwq5210@qq.com </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Created Time: 2015年01月07日 星期三 20时21分44秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">struct point_t &#123;</span><br><span class="line">    <span class="built_in">int</span> x, y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct point_t add(<span class="built_in">int</span> <span class="built_in">num</span>, ...)</span><br><span class="line">&#123;</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, <span class="built_in">num</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line">    struct point_t p;</span><br><span class="line">    struct point_t res;</span><br><span class="line">    res.x = <span class="number">0</span>;</span><br><span class="line">    res.y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="built_in">num</span>; ++i) &#123;</span><br><span class="line">        p = va_arg(ap, struct point_t);</span><br><span class="line">        res.x += p.x;</span><br><span class="line">        res.y += p.y;</span><br><span class="line">    &#125;</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    struct point_t p;</span><br><span class="line">    struct point_t sum;</span><br><span class="line">    p.x = <span class="number">1</span>;</span><br><span class="line">    p.y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    sum = add(<span class="number">3</span>, p, p, p);</span><br><span class="line"></span><br><span class="line">    printf(<span class="string">"add(3, p, p, p) = &#123;%d, %d&#125;\n"</span>, sum.x, sum.y);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面说说stdio.h中与va_list相关的几个函数：<br>这几个函数有vprintf,vfprintf,vsprintf,vsnprintf。<br>函数原型分别为：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vprintf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vfprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">vsnprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">const</span> <span class="keyword">char</span> *format, va_list ap)</span></span>;</span><br></pre></td></tr></table></figure><p>这几个函数分别与printf,fprintf,sprintf,snprintf类似，不过，他们接受一个va_list类型的变量，而不是参数列表。<br>利用这几个函数可以实现方便的函数如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; File Name: execute_cmd.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Author: gwq</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Mail: gwq5210@qq.com </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">    &gt; Created Time: 2015年01月07日 星期三 20时44分17秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;stdarg.h&gt;</span><br><span class="line"></span><br><span class="line">#define BUFSIZE <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> execute_cmd(<span class="keyword">const</span> char *fmt, ...)</span><br><span class="line">&#123;</span><br><span class="line">    char cmd[BUFSIZE];</span><br><span class="line">    va_list ap;</span><br><span class="line">    va_start(ap, fmt);</span><br><span class="line">    vsprintf(cmd, fmt, ap);</span><br><span class="line">    va_end(ap);</span><br><span class="line">    <span class="keyword">return</span> system(cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    execute_cmd(<span class="string">"echo %s"</span>, <span class="string">"dir"</span>);</span><br><span class="line">    execute_cmd(<span class="string">"ls %s"</span>, <span class="string">"/"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里边的大部分内容都是从书上摘下来的，程序部分经过了修改。</p><p>参考：<br>1）C Primer Plus（第五版）中文版 16.13<br>2）hustoj项目源代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;c语言中可变参数列表有关的内容在stdarg.h头文件中。这个头文件中的内容可以让函数实现类似scanf函数的功能，接收不确定个数的参数。&lt;br&gt;使用方法稍微复杂一些，必须按照如下步骤进行：&lt;br&gt;1.在函数原型中使用省略号。&lt;br&gt;2.在函数定义中创建一个va_list类型的变量。&lt;br&gt;3.用宏将该变量初始化为一个参数列表。&lt;br&gt;4.用宏访问这个参数列表。&lt;br&gt;5.用宏完成清理工作。&lt;/p&gt;
&lt;p&gt;下面详细介绍这些步骤，函数原型中的参数列表中至少有一个后跟省略号的参数，这个参数成为parmN，如：&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c语言" scheme="https://blog.gwq5210.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="可变参数" scheme="https://blog.gwq5210.com/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>url转码解码-c语言实现</title>
    <link href="https://blog.gwq5210.com/2016/01/22/url%E8%BD%AC%E7%A0%81%E8%A7%A3%E7%A0%81-c%E8%AF%AD%E8%A8%80%E5%AE%9E%E7%8E%B0/"/>
    <id>https://blog.gwq5210.com/2016/01/22/url转码解码-c语言实现/</id>
    <published>2016-01-22T22:07:10.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<p>url提交信息为何要转码呢？因为url本身会有很多特殊字符。而提交的参数中如果再有特殊字符的话，url就不能区分哪些是参数内容，哪些是分隔符。尤其是unicode，gb18030，big5等多字节的编码，不知道里面会隐藏什么字节，因此必须全部转码。</p><p>好像C语言里面没有现成的转码函数。参考<a href="http://blog.csdn.net/wudishine/article/details/39025407" target="_blank" rel="noopener">这里</a>，从php的转码中引出两个函数，进行转码。</p><p>字符’a’-‘z’,’A’-‘Z’,’0’-‘9’,’.’,’-‘,’*’和’_’ 都不被编码，维持原值；</p><p>空格’ ‘被转换为加号’+’。</p><p>其他每个字节都被表示成”%XY”的格式，X和Y分别代表一个十六进制位。编码为UTF-8。</p><a id="more"></a><p>下面是代码实现：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"><span class="markdown">/<span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="emphasis">***</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">&gt; File Name: url.c</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">&gt; Author: gwq</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">&gt; Mail: gwq5210@qq.com </span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"><span class="code">&gt; Created Time: 2014年12月19日 星期五 14时05分41秒</span></span></span></span><br><span class="line"><span class="comment"><span class="markdown"> <span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span><span class="strong">*****</span>**/</span></span></span><br><span class="line"></span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">#define BURSIZE <span class="number">1024</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> hex2dec(char c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">'0'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'f'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">'a'</span> + <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'F'</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c - <span class="string">'A'</span> + <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char dec2hex(short <span class="built_in">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">0</span> &lt;= c &amp;&amp; c &lt;= <span class="number">9</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c + <span class="string">'0'</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="number">10</span> &lt;= c &amp;&amp; c &lt;= <span class="number">15</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> c + <span class="string">'A'</span> - <span class="number">10</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 编码一个url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> urlencode(char url[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> len = strlen(url);</span><br><span class="line"><span class="built_in">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">char res[BURSIZE];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">char c = url[i];</span><br><span class="line"><span class="keyword">if</span> ((<span class="string">'0'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'9'</span>) ||</span><br><span class="line">(<span class="string">'a'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'z'</span>) ||</span><br><span class="line">(<span class="string">'A'</span> &lt;= c &amp;&amp; c &lt;= <span class="string">'Z'</span>) || c == <span class="string">'/'</span> || c == <span class="string">'.'</span>) &#123;</span><br><span class="line">res[res_len++] = c;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">int</span> j = (short <span class="built_in">int</span>)c;</span><br><span class="line"><span class="keyword">if</span> (j &lt; <span class="number">0</span>)</span><br><span class="line">j += <span class="number">256</span>;</span><br><span class="line"><span class="built_in">int</span> i1, i0;</span><br><span class="line">i1 = j / <span class="number">16</span>;</span><br><span class="line">i0 = j - i1 * <span class="number">16</span>;</span><br><span class="line">res[res_len++] = <span class="string">'%'</span>;</span><br><span class="line">res[res_len++] = dec2hex(i1);</span><br><span class="line">res[res_len++] = dec2hex(i0);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">strcpy(url, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 解码url</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> urldecode(char url[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">int</span> len = strlen(url);</span><br><span class="line"><span class="built_in">int</span> res_len = <span class="number">0</span>;</span><br><span class="line">char res[BURSIZE];</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">char c = url[i];</span><br><span class="line"><span class="keyword">if</span> (c != <span class="string">'%'</span>) &#123;</span><br><span class="line">res[res_len++] = c;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">char c1 = url[++i];</span><br><span class="line">char c0 = url[++i];</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">num</span> = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">num</span> = hex2dec(c1) * <span class="number">16</span> + hex2dec(c0);</span><br><span class="line">res[res_len++] = <span class="built_in">num</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">res[res_len] = <span class="string">'\0'</span>;</span><br><span class="line">strcpy(url, res);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> main(<span class="built_in">int</span> argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">char url[BURSIZE] = <span class="string">"http://'www.baidu.com/a b"</span>;</span><br><span class="line">urlencode(url);</span><br><span class="line">printf(<span class="string">"%s\n"</span>, url);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>1) <a href="https://github.com/BNUACM/bnuoj-vjudge.git" target="_blank" rel="noopener">bnuoj vjudge</a><br>2) <a href="http://abloz.com/2011/09/07/c-language-the-url-to-the-code-submit-content-to-the-site.html" target="_blank" rel="noopener">wudishine的专栏</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;url提交信息为何要转码呢？因为url本身会有很多特殊字符。而提交的参数中如果再有特殊字符的话，url就不能区分哪些是参数内容，哪些是分隔符。尤其是unicode，gb18030，big5等多字节的编码，不知道里面会隐藏什么字节，因此必须全部转码。&lt;/p&gt;
&lt;p&gt;好像C语言里面没有现成的转码函数。参考&lt;a href=&quot;http://blog.csdn.net/wudishine/article/details/39025407&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;这里&lt;/a&gt;，从php的转码中引出两个函数，进行转码。&lt;/p&gt;
&lt;p&gt;字符’a’-‘z’,’A’-‘Z’,’0’-‘9’,’.’,’-‘,’*’和’_’ 都不被编码，维持原值；&lt;/p&gt;
&lt;p&gt;空格’ ‘被转换为加号’+’。&lt;/p&gt;
&lt;p&gt;其他每个字节都被表示成”%XY”的格式，X和Y分别代表一个十六进制位。编码为UTF-8。&lt;/p&gt;
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c语言" scheme="https://blog.gwq5210.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="url转码" scheme="https://blog.gwq5210.com/tags/url%E8%BD%AC%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>C语言笔记</title>
    <link href="https://blog.gwq5210.com/2015/11/08/C%E8%AF%AD%E8%A8%80%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.gwq5210.com/2015/11/08/C语言笔记/</id>
    <published>2015-11-08T21:40:48.000Z</published>
    <updated>2021-09-13T08:00:57.712Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C语言笔记"><a href="#C语言笔记" class="headerlink" title="C语言笔记"></a>C语言笔记</h2><p>变量相关：</p><ul><li>C99以前的C要求在一个代码块的开始处声明变量。</li><li>声明语句为变量创建，标定存储空间并为其制定初始值。</li><li>C99引入_Bool类型表示布尔值。它还提供stdbool.h头文件，包含这个头文件可以使用bool来代替_Bool，并把true和false定义为1和0的符号常量。</li><li>C99提供一个可选的名字集合，用来描述确定的位数。如int16_t表示一个16位有符号整数类型，uint32_t表示一个32位无符号整数类型。使用这些名字，需要包含头文件inttypes.h。另外，这种确切的长度类型在某些系统上可能不支持。不如，不能保证某些系统上存在一种int8_t类型（8位有符号整数）。为了解决这个问题，C99标准定义了第二组名字集合。这些名字保证所表示的类型至少大于指定长度的最小类型，被称为“最小长度类型”。例如，int_least8_t是可以容纳8位有符号数的那些类型中长度最小的一个别名。因为一些程序员更关心速度而非空间。C99为他们定义了一组可使计算达到最快的类型集合。这组集合被称为“最快最小长度类型”。如，int_fast8_t定义为系统中对8位有符号数而言计算最快的整数类型的别名。为了使用printf输出这些类型，C99还提供了一些串宏来帮助打印这些类型。（注：可能一些编译器并不支持这一特性）<a id="more"></a></li><li>浮点数的上溢和下溢。当一个计算结果是一个大的不能表达的数时，会发生上溢，现在C语言用一个特殊值表示这个太大的数，printf函数显示此值为inf或infinity。如果将浮点数能表示的最小的数除以2，将会得到一个低于正常的值，如果除以一个足够大的数，将使所有位都为0。现在C库提供了用于检查计算是否会产生低于正常的值的函数。有一个特殊的浮点值NaN（Not-a-Number）。例如asin函数返回反正弦值，但是正弦值不能大于1，所以它的输入参数不能大于1，否则函数返回NaN值，printf函数显示此值为nan，NaN或类似形式。</li><li>C99还支持复数和虚数类型。</li><li>在将浮点数转换为整数时，C简单的丢弃小数部分（截尾），而不进行四舍五入。</li><li>sizeof运算符返回一个size_t类型的数，这个类型通常是unsigned或unsigned long。对于某个具体量的大小sizeof的括号是可选的，但对于类型来说，括号是必需的。如sizeof(int)，sizeof(2.0)&lt;=&gt;sizeof 2.0。</li><li>C99标准要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符。在这之前分别为31个和6个字符。</li></ul><hr><h2 id="参数传递机制"><a href="#参数传递机制" class="headerlink" title="参数传递机制"></a>参数传递机制</h2><p>对于下面的代码段：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> n1 = <span class="number">3.0</span>;</span><br><span class="line">double n2 = <span class="number">3.0</span>;</span><br><span class="line">long n3 = <span class="number">300000</span>;</span><br><span class="line">long n4 = <span class="number">123456790</span>;</span><br><span class="line">printf(<span class="string">"%ld %ld %ld %ld<span class="subst">\n</span>"</span>, n1, n2, n3, n4);</span><br></pre></td></tr></table></figure><p>该调用告诉计算机把变量n1,n2,n3,n4的值传递给计算机，计算机把他们放置到被称为堆栈（stack）的一块内存区域中来实现。计算机根据变量的类型而非转换说明符把这些值放到堆栈中。所以，n1,n2,n3,n4四个变量在堆栈中分别占8,8,4,4个字节，其中n1的float被转换成了double。然后，控制交给了printf函数。该函数中堆栈中把值读出来，但是在读取时，它根据转换说明符去读取。%ld说明符指出，printf应该读取4个字节，所以printf在堆栈中读取前4个字节作为它的一个值。这就是n1的前半部分，它被解释成一个long类型。写一个%ld说明符再读取4个字节；这就是n1的后半部分，它也被解释成一个long类型。同样，第三个和第四个%ld说明符分别读取n2的前半部分和后半部分，并解释成一个long类型。所以虽然n3和n4的说明符都正确，但是printf仍然读取了错误的字节。<br>一般来说，栈从高地址向低地址生长，即高地址是栈的底部。而函数的入栈顺序是从右向左。从右向左入栈的原因是，这样可以使得编译器可以支持可变参数，通过第一个参数可以获得参数的个数和每个参数的大小，这样就能取得每个参数。<br>在C中，会发生许多自动类型转换。当char和short类型出现在表达式里或者作为函数的参数时，它们都被提升为int类型。当float类型作为一个函数参数时被提升为double。<br>在包含两种数据类型的任何运算里，两个值都被转换成两种类型里较高的级别。</p><h2 id="优先级和求值顺序"><a href="#优先级和求值顺序" class="headerlink" title="优先级和求值顺序"></a>优先级和求值顺序</h2><ol><li>运算符的优先级为决定表达式里求值的顺序提供了重要的规则，但是它并不决定所有的规则。如：<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">6</span> * <span class="number">12</span> + <span class="number">5</span> * <span class="number">20</span>;</span><br></pre></td></tr></table></figure></li></ol><p>当两个运算符共享一个操作数的时候，优先级规定了求值顺序。例如，12既是<em>运算符的操作数，又是+运算符的操作数，根据优先级的规定乘法运算先进行。与之类似，优先级规定了对5进行乘法操作而不是加法操作。总之，两个乘法操作在加法操作之前进行。但是优先级并没有确定的是这两个乘法运算中到底那个先进行。C将这个选择权留给实现者，这是因为可能一种选择在一种硬件上效率更高，而另一种选择在另一种硬件上效率更高。但是不管先执行那个乘法运算，表达式都会简化成72+100。虽然乘法运算符的结合性是从左到右，但因为两个\</em>运算符不共享一个操作数，所以从左到右的规则对它并不适用。也就是说结合规则适用于共享同一操作数的运算符。</p><ol><li>对于参数传递，参数的求值顺序也是不确定的。所以，下边的语句的结果在不同的系统上可能会产生不同的结果。<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"%d %d\n"</span>, num, num * num++);</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"%d\n"</span>, n++ + n++);</span><br></pre></td></tr></table></figure></li></ol><p>但是我们可以通过一下原则来避免这些问题。</p><ul><li>如果一个变量出现在同一个函数的多个参数中，不要将增量或减量运算符用于它上边。</li><li>当一个变量多次出现在一个表达式里时，不要将增量或减量运算符用于它上边。</li></ul><p>顺序点是程序执行中的一点，在该点处，所有的副作用都在进入下一步之前被计算。在C中语句里的分号标志了一个顺序点。任何一个完整的表达式结束也是一个顺序点。一个完整的表达式是这样一个表达式——它不是一个更大的表达式的子表达式。逗号运算符是一个顺序点。</p><h2 id="分支和跳转"><a href="#分支和跳转" class="headerlink" title="分支和跳转"></a>分支和跳转</h2><ul><li>C99标准要求编译器最少支持127层else-if嵌套。</li><li>C99标准为逻辑运算符增加了可供选择的拼写方法。它们在iso646.h头文件中定义，包含这个头文件可以使用and，or，not来代替相应的逻辑运算符。同时，C还提供了3元字符扩展。</li><li>switch语句里的case必须是整型（包括char）常量或者整型常量表达式（仅包含整数常量的表达式）。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><ul><li>C99标准不再支持函数的int类型的默认设置。类型声明是函数定义的一部分。</li><li>一般来讲，尾递归的空间复杂度是常量。</li><li>所有的C函数地位同等，也就是说，main函数也可以被其本身或者被其他函数递归掉调用——尽管很少这么做。</li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ul><li><p>数组制定初始化项目，对数组中指定的项目初始化。如多次对一个元素初始化，则最后一次有效。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 传统语法</span></span><br><span class="line">int arr1[<span class="number">6</span>] = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">123</span>&#125;;</span><br><span class="line"><span class="comment">// C99语法</span></span><br><span class="line">int arr2[<span class="number">6</span>] = &#123;[<span class="number">5</span>] = <span class="number">123</span>&#125;;</span><br><span class="line">int arr3[<span class="number">3</span>] = &#123;[<span class="number">2</span>] = <span class="number">3</span>, <span class="number">4</span>&#125;; <span class="comment">// 数组内容为0， 3， 4</span></span><br></pre></td></tr></table></figure></li><li><p>C99之前声明数组的方括号内只能使用整数常量表达式（表达式的值必须大于0）。注意，与C++不同，const值不是一个整数常量。</p></li><li><p>C99引入了变长数组，即声明数组的方括号内可以使用变量。变长数组必须是自动存储类型的，这意味着他们必须在函数内部或者作为函数形式参数声明，而且声明时不可以进行初始化。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int sum2d(int, int, int ar[<span class="string">*</span>][<span class="symbol">*</span>]);// ar是一个边长数组，必须使用*号代替省略的维数</span><br><span class="line">int sum2d(int a, int b, int ar[<span class="string">a</span>][<span class="symbol">b</span>]);// a和b的声明一定要在ar的前边</span><br><span class="line">int sum2d(int ar[<span class="string">a</span>][<span class="symbol">b</span>], int a, int b);// 错误</span><br></pre></td></tr></table></figure></li><li><p>C99复合文字。可以使用复合文字创建一个无名数组。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个包含两个int值的数组</span></span><br><span class="line">(int [<span class="number">2</span>])&#123;<span class="number">10</span>, <span class="number">20</span>&#125;</span><br><span class="line"><span class="comment">// 可以通过指针来使用他们，也可以将他们用做函数参数</span></span><br><span class="line">int *p = (int [<span class="number">3</span>])&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul><li><p>可以使用const来创建指向常量的指针或指针常量，当然也可以创建指向常量的指针常量。如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *pi1;<span class="comment">// 指向常量的指针，指针指向的值不能改变</span></span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> pi2;<span class="comment">// 指针常量，指针指向的地址不能改变，但是指针指向地址的值可以改变</span></span><br></pre></td></tr></table></figure></li><li><p>指向多为数组的指针。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> (*pz)<span class="selector-attr">[2]</span>;<span class="comment">// pz指向一个包含两个int值的数组</span></span><br><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">p</span><span class="selector-attr">[2]</span>;<span class="comment">// p是一个数组，这个数组的每一个元素是一个指向一个int值的指针</span></span><br></pre></td></tr></table></figure></li><li><p>指针兼容性。多维数组指针要求指针的维数是一致的。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int *pt;</span><br><span class="line">int (*pa)[3];</span><br><span class="line">int ar1[<span class="string">2</span>][<span class="symbol">3</span>];</span><br><span class="line">int ar2[<span class="string">3</span>][<span class="symbol">2</span>];</span><br><span class="line">int **p2;// 指向指针的指针</span><br><span class="line">pt = &amp;ar1[<span class="string">0</span>][<span class="symbol">0</span>];</span><br><span class="line">pt = ar1[0];</span><br><span class="line">pt = ar1;// 非法</span><br><span class="line">pa = ar1;</span><br><span class="line">pa = ar2;// 非法</span><br><span class="line">p2 = &amp;pt;</span><br><span class="line">*p2 = ar2[0];</span><br><span class="line">p2 = ar2;// 非法</span><br></pre></td></tr></table></figure></li><li><p>const指针与非const指针。可以把一个非const指针赋值给一个const指针，但是不能把一个const指针赋值给一个非const指针。这个结论有一个前提，值进行一层间接运算。在两层间接运算时，这样的赋值就不再安全。</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const<span class="built_in"> int </span>**pp2;</span><br><span class="line">int *p1;</span><br><span class="line">const<span class="built_in"> int </span>n = 13;</span><br><span class="line">pp2 = &amp;p1;// 不允许，但我们假设允许</span><br><span class="line">*pp2 = &amp;n;// 合法，二者都是const，这同时会使p1指向n</span><br><span class="line">*p1 = 10;// 合法，但这会改变const n的值</span><br></pre></td></tr></table></figure></li><li><p>void指针。在C中void指针可以赋给其他类型的指针而不需要强制转换。但在C++中需要。</p></li><li>在C99中同样可以声明一个变长数组指针。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>字符串属于静态存储类。</li><li>ANSI C提供了函数：atoi, atof, atol, strtol, strtoul, strtod来将字符串转换成数值。</li><li>可以使用sprintf来将数值转换成字符串。</li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>一个C变量的作用域可以是代码块作用域，函数原型作用域或者文件作用域。</li><li>一个C变量有静态存储时期和自动存储时期。除非你显示的初始化自动变量，否则他们不会被自动初始化。</li><li>如果一个变量被声明为寄存器变量，你无法获得它的地址。</li><li>一个外部变量只能进行一次初始化，而且一定是在变量被定义时进行。</li></ul><h2 id="类型限定符"><a href="#类型限定符" class="headerlink" title="类型限定符"></a>类型限定符</h2><ul><li>限定词volatile告诉编译器该变量除了可被程序修改外还可以被其他代理改变。因此，这告诉编译器要小心的优化这个变量。</li><li>限定词restrict只可以用于指针，表明该指针是访问一个数据对象的唯一且初始的方式。这样编译器就可以进行合适的优化。一个例子是memcpy的参数使用了restrict，要求两个内存区域不能有重叠，而memmove则不做这个假定。</li></ul><h2 id="文件I-O"><a href="#文件I-O" class="headerlink" title="文件I/O"></a>文件I/O</h2><ul><li>stdout和stderr的一个区别是，当出现输出重定向的时候，stderr仍然将输出打印到屏幕上。即stderr不受重定向的影响。</li><li>在Unix和Linux这样只有一种文件类型的系统，打开文件时使用带b字母的模式和不带b字母的模式是相同的。</li><li>程序中可以同时打开的文件数目是有限制的，这取决于系统和实现，通常为10到20之间。</li></ul><h2 id="结构，联合和枚举"><a href="#结构，联合和枚举" class="headerlink" title="结构，联合和枚举"></a>结构，联合和枚举</h2><ul><li><p>指定项目初始化。与数组的类似。</p><figure class="highlight thrift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span> p = </span>&#123;.name = <span class="string">"gwq"</span>&#125;; <span class="comment">// 仅仅指定名字</span></span><br></pre></td></tr></table></figure></li><li><p>在一些系统上，结构的占用空间大小可能会大于他内部各个成员大小之和，这是因为系统对数据的对齐存储要求所致。</p></li><li>和数组名不同，单独的结构名不是该结构地址的同义词。</li><li>可以允许一个结构赋值给另一个结构，但是对数组不能这么做。</li><li><p>C99复合文字和结构。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无名结构对结构赋值</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span> p = （<span class="class"><span class="keyword">struct</span> <span class="title">person</span></span>)&#123;<span class="string">"gwq"</span>, <span class="number">21</span>&#125;;</span><br><span class="line"><span class="comment">// 如果需要一个结构的地址，可以使用&amp;获得一个复合结构的地址。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span></span> *pp = &amp;（<span class="class"><span class="keyword">struct</span> <span class="title">person</span></span>)&#123;<span class="string">"gwq"</span>, <span class="number">21</span>&#125;;</span><br></pre></td></tr></table></figure></li><li><p>C99的伸缩型数组成员。声明一个伸缩型数组成员的规则是：1）伸缩性数组成员必须是最后一个数组成员。2）结构中必须至少有一个其他成员。3）伸缩型数组就像普通数组一样被声明，除了它的方括号内是空的。该数组成员的特殊属性之一是它不存在，至少不立即存在。C99的意图是使用malloc来分配足够的空间来使用这个数组成员。如：</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> flex &#123;</span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="keyword">double</span> average;</span><br><span class="line"><span class="keyword">double</span> scores[];   <span class="comment">// 伸缩型数组成员</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 现在这个pf指向的结构，拥有了5个元素的double类型数组。</span></span><br><span class="line"><span class="keyword">struct</span> flex *pf = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> flex) + <span class="number">5</span> * <span class="keyword">sizeof</span>(<span class="keyword">double</span>));</span><br></pre></td></tr></table></figure></li><li><p>联合是一个能在同一个存储空间里（但不同时）存储不同类型数据的数据类型。</p></li><li>枚举可以声明代表整数常量的符号名称。实际上，枚举常量是int类型的。虽然枚举常量是int类型的，但是枚举变量较为宽松的限定为任一种整数类型，只要该整数类型能保存这些枚举常量。</li><li>C的某些枚举属性不能延伸到C++中，如C允许对枚举变量使用++，但C++不允许。</li><li><p>枚举的默认值是从零开始递增。但可以制定特定的值。</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">color</span> &#123;<span class="title">red</span>, <span class="title">green</span>, <span class="title">blue</span>&#125;;</span>/<span class="regexp">/ 分别为0， 1， 2</span></span><br><span class="line"><span class="regexp">enum levels &#123; low, medium = 500; high&#125;;分别为0， 500， 501</span></span><br></pre></td></tr></table></figure></li><li><p>C使用术语名字空间（namespace）来表示识别一个名字的程序的部分。作用域是这个概念的一部分：名字相同但具有不同作用域的两个变量不会冲突；而名字相同并在相同作用域中的两个变量就会冲突。名字空间是分类别的。在一个特定作用域内的结构标记，联合标记以及枚举标记都共享一个名字空间，并且这个名字空间与普通变量使用的名字空间是不同的。如：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rect</span> &#123;</span><span class="keyword">double</span> x; <span class="keyword">double</span> y&#125;;</span><br><span class="line"><span class="keyword">int</span> <span class="built_in">rect</span>;<span class="comment">// 在C中不会引起冲突</span></span><br></pre></td></tr></table></figure></li></ul><p>但是这种方式会引起混乱；而且，C++不允许在同一个作用域内对一个变量和一个标记使用同一个名字，因为它把标记和变量名放在同一个名字空间中。</p><h2 id="奇特的声明"><a href="#奇特的声明" class="headerlink" title="奇特的声明"></a>奇特的声明</h2><p>如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">int</span> <span class="selector-tag">board</span><span class="selector-attr">[8]</span><span class="selector-attr">[8]</span>;<span class="comment">// int数组的数组</span></span><br><span class="line"><span class="selector-tag">int</span> **<span class="selector-tag">ptr</span>;<span class="comment">// 指向int指针的指针</span></span><br><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">risks</span><span class="selector-attr">[10]</span>;<span class="comment">// 具有10个元素的数组，每个元素是一个指向int的指针</span></span><br><span class="line"><span class="selector-tag">int</span> (*rusks)<span class="selector-attr">[10]</span>;<span class="comment">// 一个指针，指向具有10个元素的int数组</span></span><br><span class="line"><span class="selector-tag">int</span> *<span class="selector-tag">oof</span><span class="selector-attr">[3]</span><span class="selector-attr">[4]</span>;<span class="comment">// 一个3*4的数组，每个元素是一个指向int的指针</span></span><br><span class="line"><span class="selector-tag">int</span> (*uuf)<span class="selector-attr">[3]</span><span class="selector-attr">[4]</span>;<span class="comment">// 一个指针，指向3*4的int数组</span></span><br><span class="line"><span class="selector-tag">int</span> (*uof[<span class="number">3</span>])<span class="selector-attr">[4]</span>;<span class="comment">// 一个具有3个元素的数组，每一个元素是指向具</span></span><br><span class="line"><span class="comment">// 有四个元素的int数组的指针</span></span><br></pre></td></tr></table></figure></p><p>弄清楚这些声明的诀窍便是理解使用修饰符的顺序。</p><ul><li>表示一个数组的[]和表示一个函数的()具有相同的优先级，这个优先级高于间接运算符<em>的优先级。如：int </em>arr[10]声明一个指针数组，而不是一个指向数组的指针。</li><li>[]和()都是从左到右结合的。声明int goods[10][50]使得goods是一个由12个具有50个int值的数组构成的数组，而不是一个由50个具有12个int值的数组构成的数组。</li><li>[]和()具有相同的优先级，但是由于他们是从左到右结合的，所以声明int (*rusks)[10]在应用方括号之前先将*和rusks组合在一起。这意味着rusks是一个指向具有10个int值的数组的指针。</li></ul><h2 id="函数和指针"><a href="#函数和指针" class="headerlink" title="函数和指针"></a>函数和指针</h2><ul><li>声明一个指向特定函数类型的指针，首先声明一个该类型的函数，然后用(*pf)形式的表达式代替函数名称；pf就成为了指向那种类型函数的指针了。</li><li>使用指针调用函数有两种看起来都合理的方式。如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToUpper</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ToLower</span><span class="params">(<span class="keyword">char</span> *)</span></span>;</span><br><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">char</span> *);</span><br><span class="line"><span class="keyword">char</span> mis[] = <span class="string">"Nina Metier"</span>;</span><br><span class="line">pf = ToUpper;</span><br><span class="line">(*pf)(mis);<span class="comment">// 把ToUpper作用于mis</span></span><br><span class="line">pf = ToLower;</span><br><span class="line">pf(mis);<span class="comment">// 把ToLower作用于mis</span></span><br></pre></td></tr></table></figure></li></ul><p>K&amp;R C不允许第二种形式，但是有的实现却采用第二种形式，为了保持与现有代码的兼容性，ANSI C把这二者作用等价形式全部接受。</p><ul><li>不能拥有一个函数的数组，但是可以拥有一个函数指针的数组。如char (*pf[3])(void);</li></ul><h2 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h2><ul><li>掩码。使用位与（&amp;）可以获得特定某个位或某些位的值。</li><li>打开位。使用位或（|）可以将某一位置为1而不管这个位原来是多少。</li><li><p>关闭位。使用位与（&amp;）与求反（～）可以将某个位置为0，不管这个位原来是多少。如：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> mask = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">int</span> <span class="built_in">n</span> = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">int</span> m = <span class="built_in">n</span> &amp; ~mask;// 将最低位关闭</span><br></pre></td></tr></table></figure></li><li><p>转置位，因为1与0异或为1，1与1异或为0。而0与0异或为0,0与1异或为1。所以可以使用异或操作（^）来转置某些位。只需要将需要转置的位的掩码置为1，其余置为0就行了。</p></li><li>左移位运算符（&lt;&lt;）将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出的位用0填充，并且丢弃移出左侧操作数末端的位。</li><li>右移位运算符（&gt;&gt;）将其左侧操作数的值的每位向右移动，移动的位数由其右侧操作数指定。丢弃移出左侧操作数右端的位。对于unsigned类型，使用0填充左端空出的位。对于有符号数，结果依赖机器。空出的位可能用0填充，或者使用符号（最左端的）位的副本填充。</li><li>移位运算符能够提供快捷，高效的（依赖于硬件）的对2的幂的乘法和除法。</li><li>可以在结构中使用位字段，即对其的操作仅仅是对这个或这几个位的操作。使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐。不允许一个字段跨越两个unsigned int之间的边界，编译器自动的移位这样一个字段定义，使得字段按unsigned int边界对齐。发生这种情况时，会在第一个unsigned int中留下一个未命名的洞。如：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> field1: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>       : <span class="number">2</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> field2: <span class="number">1</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span>       : <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> field3: <span class="number">1</span>;</span><br><span class="line">&#125;stuff;</span><br></pre></td></tr></table></figure></li></ul><p>以上例子中，stuff.field1与stuff.field2之间有一个2位的间隙，stuff.field3存储在下一个int中。</p><ul><li>一个重要的机器依赖性是将字段放置到一个int中的顺序。在有些机器上，这个顺序是从左向右；在另一些机器上顺序是从右向左。另外，不同机器在两个字段间边界的位置上也有区别。由于这些原因，位字段往往难以移植。</li><li>同样也可使用位运算来模仿位字段的功能，但这要稍微复杂一些。</li></ul><h2 id="C预处理器和库"><a href="#C预处理器和库" class="headerlink" title="C预处理器和库"></a>C预处理器和库</h2><ul><li><p>C的预处理只进行字符替换，不会进行算数运算。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="keyword">int</span> x = TWO * TWO;    <span class="comment">// 进过预处理后是2 * 2，实际想乘发生在编译阶段</span></span><br></pre></td></tr></table></figure></li><li><p>预处理器不会替换在字符串中的宏。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TWO 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OW <span class="meta-string">"nihao"</span></span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"TWO:OW"</span>);<span class="comment">// 打印出来TWO:OW而不是2:nihao</span></span><br></pre></td></tr></table></figure></li><li><p>对于重定义宏，ANSI C只允许新定义与旧定义完全相同。相同定义意味着主体具有相同顺序的语言符号。</p></li><li>在宏定义中可以使用参数。但这使用不当可能会带来难以理解的结果。因为宏只进行简单的文本替换，可能一个参数在宏中会出现好多次，这对有副作用的表达式，会产生多次副作用，典型的就是自增和自减运算符。</li><li><p>可以使用#号将一个宏的参数字符串化。如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define PR(<span class="name">x</span>) printf(<span class="name">#x</span> <span class="string">" = %d.\n"</span>, x)<span class="comment">;</span></span><br><span class="line">int x = <span class="number">56</span><span class="comment">;</span></span><br><span class="line">PR(<span class="name">x</span>)<span class="comment">;        // 替换为:printf("x" " = %d.\n", x);</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用##符号来将一个语言符号组合成一个语言符号，可以理解为生成一个变量的名称。如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XNAME(n) x #<span class="meta"># n</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">XNAME</span><span class="params">(<span class="number">1</span>)</span> </span>= <span class="number">4</span>;       <span class="comment">// 替换为int x1 = 4;</span></span><br></pre></td></tr></table></figure></li><li><p>可以使用…和__VA_ARGS__来定义一个可变参数的宏。方法是将宏定义中参数列表的最后一个参数写为省略号，然后在被替换部分就可以使用__VA_ARGS__来代替省略的部分。如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#define</span> <span class="selector-tag">PR</span>(...) <span class="selector-tag">printf</span>(__VA_ARGS__)</span><br><span class="line"><span class="selector-tag">PR</span>(<span class="string">"nihao"</span>);    <span class="comment">// printf("nihao");</span></span><br><span class="line"><span class="selector-tag">PR</span>(<span class="string">"%d"</span>, x);    <span class="comment">// printf("%d", x);</span></span><br></pre></td></tr></table></figure></li><li><p>函数调用需要一定的开销，这意味着执行调用时花费了时间用于建立调用，传递参数，跳转到函数代码段并返回。使用类函数宏的一个原因就是可以减少执行时间。此外C99还提供了另外一种方法：内敛函数。C99标准这样叙述：“把函数变为内联函数将建议编译器尽可能快速地调用该函数。上述建议的效果由实现来定义”。因此，使函数变为内联函数可能会简化函数的调用机制，但也可能不起作用。</p></li><li>因为内联函数没有预留给它单独代码块，所以无法获得内敛函数的地址（实际上，可以获得地址，但这样会使编译器产生非内联代码）。另外，内联函数不会在调试器中显示。</li><li>内联函数应该比较短小。对于很长的函数，调用函数的时间少于执行函数主体的时间；此时，使用内敛函数不会节省很多时间。</li><li>编译器在优化内联函数时，必须知道函数定义的内容，这意味着内联函数的定义和对该函数的调用必须在同一文件中，正因为这样，内联函数通常具有内部连接。在多文件的程序中，每个调用内联函数的文件，都要对该函数进行定义。</li><li>main函数在结束时会隐式的调用exit()；可以使用atexit函数注册在程序（隐式或显示）调用exit函数前，调用的函数。可以注册多个函数，最后注册的函数最先被调用。ANSI保证这个列表中至少可以放置32个函数。</li></ul><p>注：以上这些文字，大部分抄录自C Primer Plus（第五版）中文版。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;C语言笔记&quot;&gt;&lt;a href=&quot;#C语言笔记&quot; class=&quot;headerlink&quot; title=&quot;C语言笔记&quot;&gt;&lt;/a&gt;C语言笔记&lt;/h2&gt;&lt;p&gt;变量相关：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C99以前的C要求在一个代码块的开始处声明变量。&lt;/li&gt;
&lt;li&gt;声明语句为变量创建，标定存储空间并为其制定初始值。&lt;/li&gt;
&lt;li&gt;C99引入_Bool类型表示布尔值。它还提供stdbool.h头文件，包含这个头文件可以使用bool来代替_Bool，并把true和false定义为1和0的符号常量。&lt;/li&gt;
&lt;li&gt;C99提供一个可选的名字集合，用来描述确定的位数。如int16_t表示一个16位有符号整数类型，uint32_t表示一个32位无符号整数类型。使用这些名字，需要包含头文件inttypes.h。另外，这种确切的长度类型在某些系统上可能不支持。不如，不能保证某些系统上存在一种int8_t类型（8位有符号整数）。为了解决这个问题，C99标准定义了第二组名字集合。这些名字保证所表示的类型至少大于指定长度的最小类型，被称为“最小长度类型”。例如，int_least8_t是可以容纳8位有符号数的那些类型中长度最小的一个别名。因为一些程序员更关心速度而非空间。C99为他们定义了一组可使计算达到最快的类型集合。这组集合被称为“最快最小长度类型”。如，int_fast8_t定义为系统中对8位有符号数而言计算最快的整数类型的别名。为了使用printf输出这些类型，C99还提供了一些串宏来帮助打印这些类型。（注：可能一些编译器并不支持这一特性）
    
    </summary>
    
      <category term="编程" scheme="https://blog.gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="c语言" scheme="https://blog.gwq5210.com/tags/c%E8%AF%AD%E8%A8%80/"/>
    
      <category term="编程" scheme="https://blog.gwq5210.com/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>2015年腾讯阿里实习生招聘面试经历</title>
    <link href="https://blog.gwq5210.com/2015/11/08/2015%E5%B9%B4%E8%85%BE%E8%AE%AF%E9%98%BF%E9%87%8C%E5%AE%9E%E4%B9%A0%E7%94%9F%E6%8B%9B%E8%81%98%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    <id>https://blog.gwq5210.com/2015/11/08/2015年腾讯阿里实习生招聘面试经历/</id>
    <published>2015-11-08T21:35:07.000Z</published>
    <updated>2021-09-13T08:00:57.708Z</updated>
    
    <content type="html"><![CDATA[<p>每年毕业生找工作都是一个问题，对于个人来说，无非就是笔试和面试的问题。对于应届生来说，最头疼的或许不是笔试而是面试。对于笔试，只要自身实力过硬，一般都没有问题（退一步讲，万一笔试没过，还可以在面试的时候霸面）；对于面试，就不一样了，应届生没有接触过面试，所以对于面试可能有些害怕，面试之前会在网上搜一些面试注意事项之类的，而这些都是对所有面试的一般概括，没有什么针对性，无非就是提醒面试者注意着装、礼貌、准备一些各种版本的自我介绍之类的，不得不说这些还是有很大帮助的。但在我看来，这些都没有自己实打实的来一次真正的面试有帮助。所以，我鼓励那些想要找工作的同学，可以尝试着真的去准备一场面试，运气好的话，说不定就被录取了呢。下面，我分享一下我的今年（2015年）的面试经历和感想，希望对一些同学有所帮助。</p><a id="more"></a><p>对于面试的着装，技术类的面试，穿平常的便装就行，不用穿的特别正式，穿的正式反而显得不自然，而且在面试官看来也多少会有几分怪异。非技术类的，具体应该也没有什么特别的标准，如果自己之前有正式的西装之类的衣服，可以穿上去面试，如果没有，感觉也没有必要去准备一下，穿自己平常的衣服应该也不会有多大的问题。这纯属个人见解，可以根据实际的情况，询问学长之类的，应该都会得到满意的解答。</p><p>一般来说，公司会通知你在特定的时间地点面试，我们最好提前15到30分钟到达指定的地点（有的会明确要求你提前15分钟到达）。之前在网上看到有说让提前5到10分钟左右，如果提前半个小时去，可能会被公司视为没有时间观念，根据我个人的面试经历，这完全就是扯淡，去公司面试的人那么多，根本不会有人注意到你的，更别说什么看出来一个人的时间观念了；况且，面试官面试时间会在某个范围内波动，遇到你前面的人没来面试，你提前被面试的可能性不是没有；另外，如果太赶的话，很容易造成紧张情绪，面试的时候发挥不好，提前去的话，还可以和其他人交流一下，缓解一下紧张情绪，如果是多个人一块儿去，边等边聊天，基本上也不会有什么紧张的情绪。</p><p>另外需要注意的就是个人礼仪等方面的问题，不过，对于一个有基本素质的人，这应该都不是问题，只要稍微注意下就ok了。</p><p>最后，面试的时候一定要带上自己的简历，一般来说面试都是三面（不排除更多次面试的可能，貌似这些都是大牛，是要给他们加工资的），带上三份或者更多的简历保证万无一失，如果不带，可以想象面试官要求你给他一份简历你却没有的尴尬情景；最好还有带上纸和笔，技术面试，少不了要在纸上写程序之类的，如果面试官没提供纸，或者提供的纸用完了，那么我们自己带的就派上用场了。</p><p>以上这些，个人感觉只要面试的时候稍稍注意一些，都不是问题，毕竟一个公司招聘人才，主要考察的是个人的专业能力，其他方面，只要不是做的太差，都不会有什么问题。</p><p>下面，我先来说一下腾讯的面试经历。腾讯我总共面试了三次，一面和二面是技术面，三面是HR面。可能是我个人简历和自我介绍的问题，一面和二面都是面试官在一张纸上指出一些题让写代码或者说思路，没有问我项目或者其他具体的技术问题；HR面基本就是聊天，了解一下你的个人情况之类的，一般来说，技术类的HR是不会刷人的，但也不排除后边的人比你优秀之类的，然后，你就被悲催的刷掉了。</p><p>先说一面，一面大学持续了40分钟，刚开始先是自我介绍，我大概说了有三分钟，主要说了ACM的经历，学过linux，写过后台小程序，重点介绍的是ACM的经历，可能是这个原因，面试官上来就让我写程序，问了两个题目。</p><p>第一道题目是将字符串”I am student”变成”student am I”，要求尽量节省内存。当时我看道题目后，大致看了一下，就开始写了，也没仔细看题，就写了一个字符串翻转的函数，给面试官看了，面试官明确说错了，我当时就懵了，心想这下完了，但是，我还是静下心来看哪里错了，我看了一遍程序，感觉是没错的，就又再看了一遍题目，立刻就明白了，md，原来题目看错了，当时就给我自己跪了。然后，我就又开始写，写的时候，询问了下面试官，分割单词的空格是不是只有一个，他和我说你可以只考虑一个的情况，然后问我，如果有多个空格怎么处理，我就说可以先做一次预处理，将多个空格变成一个空格。然后，我就开始写了，这次的思路是从字符串的后边往前找空格，找到空格后，将空格替换成’\0’，用printf函数打印空格后紧邻的那个字符串，一直处理到字符串开头；面试官看的过程中，我开始说思路，说好后，面试官说，不是让打印出来，是让在原来字符串的基础上将字符串改变成这个样子；说完之后，我就开始不淡定了，但是还得想呀，想了一会儿，我感觉写程序时间可能不够用，我就和面试官说，可不可以说思路，他说可以，我就说可以使用循环移位，我想的时候，想的是循环左移，说的时候突然想到循环右移的效率更高一点，这时面试官可能不太理解，就让我画了一个示意图，标明循环右移后额结果，面试官大概明白后，就和我说，你这个想法的时间复杂度有点高呀，我说是的，复杂度是O(n^2)，然后，他让我想想有没有时间复杂度低而且还节省内存的方法，我想的过程中，面试官上了个厕所，回来就问我想出来了没，我说没有，然后，就又指了一道题目让我想；其实，当时我差点就问他，有没有既快又省内存的方法，不过，我是忍着没问，后来，面试完后，我查了一下，还真有，方法真是巧妙，先将字符串中的单词（以空格为分隔符）翻转一次，然后，再以整个字符串为单位翻转一次，就得到了结果；当时就被这种方法惊呆了，太特么妙了。这里附带说下，前几天做360的笔试题目，最后写代码的题目就是这个题，不过是以’.’为分隔符。代码贴到下面：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现字符串相应范围翻转</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">begin</span>, <span class="keyword">char</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">begin</span> &lt; <span class="built_in">end</span>) &#123;</span><br><span class="line"><span class="keyword">char</span> c = *<span class="built_in">begin</span>;</span><br><span class="line">*<span class="built_in">begin</span> = *<span class="built_in">end</span>;</span><br><span class="line">*<span class="built_in">end</span> = c;</span><br><span class="line">++<span class="built_in">begin</span>;</span><br><span class="line">--<span class="built_in">end</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 翻转两次，第一次以整个字符串为单位翻转，第二次以点分割的单词为单位翻转</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">str_rev</span><span class="params">(<span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">begin</span> = str;</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">char</span> *p;</span><br><span class="line">reverse(<span class="built_in">begin</span>, <span class="built_in">begin</span> + len - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (*p != <span class="string">'\0'</span> &amp;&amp; *p != <span class="string">'.'</span>) &#123;</span><br><span class="line">++p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (*p == <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">reverse(<span class="built_in">begin</span>, p - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">begin</span> = p + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[] = <span class="string">"www.soso.com"</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s\n"</span>, str_rev(str));</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>面试官让我看第二道题目的时候说，你说下思路，时间不多了，只能给你5分钟的时间考虑；看过题目后，还算好，是一道字典树的题目，说的是有好多电话区号，每一个数字代表一级的地址，比如8213代表A市B区C街道D号等；要求给一个区号，在给定的列表中尽可能快的找到这个区号对应的地址，当时看到后就想到是字典树，面试官让写个数据结构，写好后，让面试官看了下，面试官问的过程中意识到结构体中还得有一个记录地址的字符数组，然后就问我这个数组存什么东西，我说存这个数字对应的地址，没有想到找的过程中将字符串连接起来也得浪费时间，面试官就指出了这一点；另外，还问了一个其他的问题，我也支支吾吾没说清楚。说完之后，面试官就表示面试就到这里，让我问问题，我就问了一些面试结果什么时候出来之类的问题。当时出来后，心里感觉，这下肯定特么要挂了，表现这么不好，当时心里感觉就挺蛋疼的，但也没办法，回到住的地方后，就进入了焦急的等待过程，到了晚上七点左右吧（我是下午两点的一面），在微信里查询状态变成了复试环节，当时就很高兴，没想到竟然过了一面；晚上就点左右，给我发了短信，让第二天早上十点去二面。后边，我就开始大概准备了下，早早的睡下了。</p><p>接下来是二面。二面面试官也是开始先让自我介绍，我的介绍和一面大概一样，然后面试官就拿出一张纸，让我做题，中间也没问我其他的问题。这次总做了六道题目。</p><p>第一道是类数学题。说是一瓶汽水1元，每两个空瓶可以换一瓶汽水，你现在有20元，问最多可以喝多少瓶汽水？当时，我在纸上大概写了下，算了个39。大概是这样：20+10+5+2+1+1=39，最后一个1是5个空瓶中4瓶换了2瓶汽水，剩了一个空瓶加上最后的一个空瓶。这样最后还剩下一个空瓶，当时没想那么多，就说了个39，然后面试官问我的思路，我大概说了下，然后就让我做下一道题了。面试完后，在网上查了下，还真查到了，发现大部分说的是39，还有一些说的是40，因为可以先和老板借一瓶汽水，喝完后，就有两个瓶子了，把瓶子给老板就ok了。感觉还是40个是最好的答案。其实网上还可以找到其他类似的题目，也十分有趣，就是稍微坑一点儿，看完绝对感觉智商被碾压。</p><p>第二道也是道有趣的题目。有10个箱子，每个箱子里有10个苹果，其中，9个箱子里的苹果1斤1个，另外的1个箱子中的苹果9两1个，现在有一个电子秤，要求只称一次（只能得到一个读数，苹果可以拿出来称），区分出来装9两1个苹果的那个箱子。大家可以想一下这道题目怎么做。</p><p>当时，看完题目后，也是看错题了，以为是天平，说了一下思路，然后，面试官就说不是天平，是电子秤，可以得到斤两数的。然后，我就开始想，想了好久好久，中间也提出了些疑问，面试官说，只称一次就是只能得到一个读数。想了好久之后，面试官说，从每个箱子里边拿出苹果来称试试，当时，我就傻了，之前我一直在想苹果是以箱子为单位的，只能以一个箱子为单位来称，我就将我之前的误区说了出来，然后，就在纸上开始画，我先写下了1到10十个数字，作为箱子的标号，然后突然想到，可以从1号箱子里边拿出1个苹果，一次类推，然后将拿出来的苹果称一次，得到一个斤两数，根据斤两数是可以区分出来那个箱子装了9两1个的苹果的。当时，只是有这个想法，没有具体的做法，然后面试官问我，怎么区分，我说的比较模糊，他就问我少1两是那个箱子，我就说是1号箱子，一次类推，然后这道题目就算过了，让我做下一道题（这里，我想说的是在面试过程中，有什么疑问，一定要询问面试官，要不然坑的就是自己）。<br>剩下的题目忘记顺序了，就按照我的记忆来标记题号吧。</p><p>第三道是说，有5个人ABCDE，写程序输出5个人的排队的所有可能顺序。面试官拿出纸和笔让写，因为这比较基础，就开始写了。写了一会儿，可能嫌我写的慢了或者是时间快到了，就让我说思路，我就说用dfs枚举，大概说了下，就开始下一道题了。</p><p>第四道是一个栈的题目，让判定一个给定的括号序列是否匹配，这个序列由{,},(,)四中符号组成。当时看了下，就说出思路了。</p><p>第五道是让实现一个atoi函数，就是把一个字符串转换成一个整数，我问了下用不用考虑非法情况，面试官说不用，然后，我就开始写了，很快就写完了。</p><p>第六道题目是：有100个乒乓球，两个人轮流拿乒乓球，每个人最多拿5个球，最少拿1个球，拿到最后一个球的人获胜，你先拿，拿几个球才能保证获胜，策略是什么？了解博弈论的人都知道这是nim博弈的一种特殊情况，100%（5+1）为0时，先手输，否则，先手一定有赢的策略，先手先拿4个，假如后手拿x个，那么先手就拿6-x个，这样就能保证先手获胜。不懂博弈论的人可以采用另一种思路，想拿到第100个球，就必须拿到第94个球才能保证获胜；想拿到第94个球，就必须拿到第88个球才能保证获胜；。。。;依次类推，就得到先手必须拿走4个球。</p><p>问完后，看我是本科生就问了我考不考研，我说不考，问我什么原因，我说了下。然后，我问了下结果什么时候出来之类的就出来了。这次感觉比一面好多了，除了第一道题目，其他的都答的不错。果然，在中午12点左右，我查微信状态的时候，状态已将变成了HR面试环节了。然后就是漫长的等待了，也一直没有发通知，到了官网上说的面试的最后一天，我坐不住了，去现场问了下情况，说是第二天还有面试，我就又回来继续等待了，等了一天左右吧，面试的前一天晚上给我发了短信，让我去面试，到了才发现，我应该是这个HR的倒数第三个面试者，我之前有一个人正在面试，我就站在门口听（感觉好无耻），听的过程中，也想了下自己的回答。</p><p>HR面试，其实就是了解下你自己的性格，价值观之类的，不会问你技术的问题的。面我的HR刚开始也是让自我介绍，这次，我想了另外一个版本的。自我介绍完后，就开始问我家庭情况，父母对自己的态度，自己最成功和最失败的事是什么，感觉大学和高中的区别是什么，上大学后收获最大的是什么，自己对自己的评价，工作城市，录取后要去的部门，为什么想进这个部门，还有没有其他的实习机会，如果都得到了offer，怎么选择，最后，让我问问题，我问了些转正，面试结果等方面的问题，然后就结束了，总共聊了大概45分钟左右，感觉还不错。</p><p>面完HR后，虽然说不怎么刷人，但是也是很担心，在T派上找到了一个西安等offer的群，加了进去，也关注着其他人的情况，发现基本都是这个状况，我也就不那么担心了，后来，还有个人把西安HR领队的拉进群里了，解答了好多问题。等了3天吧，收到了签约的短信，过了几个小时，收到了深圳打来的电话，就是确认下信息啥的。到这里总算结束了。</p><p>等腾讯offer的过程中，还去阿里面了一下，刚好腾讯和阿里面试的地点只隔了一条马路，很近。可能是腾讯的面试太过顺利，把rp都用完了，阿里的面试就有点坑了。阿里一面就跪了。下面大致介绍一下阿里的面试经历。</p><p>面试的基本流程也差不多，不过，阿里的组织感觉没有腾讯做的好，有人说，阿里面试的地方就像一个菜市场，阿里面试的地方是一个大厅，里边摆了好多桌子，距离差不多刚刚好，而且，说话基本上是可以听见的；而腾讯是在面试官住的房间里边面试的，感觉要好一点吧。</p><p>面试的时候，也是先让做自我介绍（和之前面腾讯的版本差不多），然后，就开始问我问题，看我简历上说了用过linux，就开始问我关于linux的问题，问我linux程序加载进内存后，有哪些区域，我大概说了下有代码区，静态存储区，栈区，为进程私有，地址向下生长，大小一般为1M左右，堆区，为进程共享，地址向上生长，可分配的内存理论上要无限大，取决于物理内存的大小（这里我说错了，当时面试官指出，每个进程要有一个虚拟的地址空间，这个地址空间要和字长对应，堆的大小要取决于字长），还说了局部变量在进入作用域自动在栈区分配，超出作用域自动回收，而堆区需要使用malloc等函数手动申请，使用free函数手动释放。然后，问我了一下关于计算机存储结构的问题，说CPU速度很快，而硬盘读写很慢，问我在存储方面，CPU读取数据的访问顺序是什么，我表示顺序为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘；关于缓存，没有说明缓存的分级，经过提醒才想到有一级缓存，二级缓存，三级缓存，还问我这些存储器的访问时间的差距大概有多大，我就大概说了下，他问我是了解过具体的数字，还是只有这个概念，不能定量确定，我说是只有概念，不能确定准确的差距；最后问我知道哪些外存的形式，我说普通硬盘7200转，5400转的，还有SSD，光盘，U盘等；然后，问我有没有了解过多核系统的问题，我说没有了解过，这个阶段基本就结束了。</p><p>接下来问我做过什么项目没有，我说在linux下用c语言写过用curl抓取网页的东西，解析html，存到数据库里；还写过用curl库模拟http登陆，提交表单之类的程序。我说其中用到了一些linux系统调用。问了项目中一些具体的细节，我说是用linux系统调用实现的。</p><p>下面就问我用什么编程工具，我说在linux用vim，gcc，gdb，makefile等，就问我关于gdb的命令，我大概说了下，说完后，就问我有没有想过gdb是怎么实现的，我当时说了半天也没说清楚，然后他给提示说操作系统有什么东西可以使程序停下来，暗示了好久，我才意识到时中断。接下来问我有没有看过linux内核源代码，我说没有。然后，他就问我有没有学过目前比较流行的技术之类的，也没明确说什么技术，自己也确实没学过，就说没有，然后说感觉要先打好基础，然后再去接触一些比较高级的技术。前面关于技术的差不多就问到这里了，下来想想感觉真是被虐成狗，不过当时面试官也挺和气的，感觉也没怎么糟。</p><p>问完技术就让我写代码了。第一题是写一个宏，求一个结构体类型中指定的成员在这个结构体中的偏移量。当时想了一会，没有思路，面试官说，这是linux内核中的一个宏，给定一个结构体类型，和一个这个结构体中的成员名，返回偏移量，还解释说，linux内核中的结构体是很大的，有时候只知道结构体中成员的地址，想要知道整个结构体的地址，就要使用这个宏。下面是我根据面试官的说法写的，还真是这样。具体思路是，将0强制转换成这个结构体的指针，来访问这个结构体中的成员，然后，取这个成员的地址，得到的就是成员相对结构体起始的偏移量，不过，按照这个宏，貌似是访问了地址为0的空间，但起始编译器是聪明的，不会真的去访问，而是根据结构体在内存中的内存布局直接得到偏移量就ok了，OFFSET宏定义如下，注意运算符的优先级：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define OFFSET(type, field) (&amp;((type *)0)-&gt;field)</span></span><br><span class="line"></span><br><span class="line">struct <span class="keyword">Node</span> <span class="title">&#123;</span></span><br><span class="line"><span class="title">int</span> a;</span><br><span class="line">char b;</span><br><span class="line">short c;</span><br><span class="line">char *d;</span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">printf(<span class="string">"%p\n"</span>, OFFSET(struct <span class="keyword">Node</span><span class="title">, a</span>));</span><br><span class="line">printf(<span class="string">"%p\n"</span>, OFFSET(struct <span class="keyword">Node</span><span class="title">, b</span>));</span><br><span class="line">printf(<span class="string">"%p\n"</span>, OFFSET(struct <span class="keyword">Node</span><span class="title">, c</span>));</span><br><span class="line">printf(<span class="string">"%p\n"</span>, OFFSET(struct <span class="keyword">Node</span><span class="title">, d</span>));</span><br><span class="line">return <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>第二个题目是给定一个二叉树，判断给定的二叉树是不是一个二叉搜索树（BST），当时脑抽了，认为BST就是一个节点的左子节点小于这个节点，右子节点大于这个节点就行了，然而，其实是一个节点的左子树的所有节点都小于这个节点，右子树的所有结点都大于这个节点。我是按照第一种方法写的，当然是错的，后来经过提示，意识到错了，纠正了之后，问我有一个BST要得到一个升序序列，是什么遍历，我说了好几次，才说是中序遍历，其实一个判定一个二叉树是不是BST，就只需要中序遍历，记录前一个节点的值就行了，和现在访问的比较，只要全部小于就是一个BST。真是对二叉树的理解还是不够深入。不过感觉leetcode里应该会用很多这样的题目。</p><p>第三个题是一个函数指针的题。相对来说比较简单，让写一个函数指针，这个函数指针指向一个有两个int参数，返回一个char指针的函数。写函数指针有一种技巧，就是先写这样一个函数f，最后将函数名替换为(*pf)就行了，这个方法是在C primer中提到的。这个答案如下：<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">char *(<span class="name">*pf</span>)(<span class="name">int</span> a, int b)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>做完题目，就结束了，让我问问题，我就问面试结果什么时候出来，他说在外边等着。然后我就在外边等通知，等了差不多30分钟，还没见消息，这时看到了面试指引，上边说如果面试完10分钟没有消息，就到签到处询问，我去问了，然后就说，今天的面试已经结束，你可以走了，当时就知道是被刷掉了，走后，过了2个小时左右，收到了短信，说面试已经结束，在网站上查的状态是待回绝，就知道是挂了。不过阿里比腾讯好的一点是当时就可以知道结果，不用等那么长时间，反正感觉等消息最蛋疼了。</p><p>经过这两次面试，大致也知道了自己在哪些方面的不足，从总也学习到了不少的面试经验，感觉也是不错的。</p><p>最后，就是说，去面试一定要有自信，要抱着挑战自我，挑战offer的心态去面试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;每年毕业生找工作都是一个问题，对于个人来说，无非就是笔试和面试的问题。对于应届生来说，最头疼的或许不是笔试而是面试。对于笔试，只要自身实力过硬，一般都没有问题（退一步讲，万一笔试没过，还可以在面试的时候霸面）；对于面试，就不一样了，应届生没有接触过面试，所以对于面试可能有些害怕，面试之前会在网上搜一些面试注意事项之类的，而这些都是对所有面试的一般概括，没有什么针对性，无非就是提醒面试者注意着装、礼貌、准备一些各种版本的自我介绍之类的，不得不说这些还是有很大帮助的。但在我看来，这些都没有自己实打实的来一次真正的面试有帮助。所以，我鼓励那些想要找工作的同学，可以尝试着真的去准备一场面试，运气好的话，说不定就被录取了呢。下面，我分享一下我的今年（2015年）的面试经历和感想，希望对一些同学有所帮助。&lt;/p&gt;
    
    </summary>
    
      <category term="面试" scheme="https://blog.gwq5210.com/categories/%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="面试" scheme="https://blog.gwq5210.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
      <category term="腾讯" scheme="https://blog.gwq5210.com/tags/%E8%85%BE%E8%AE%AF/"/>
    
      <category term="阿里" scheme="https://blog.gwq5210.com/tags/%E9%98%BF%E9%87%8C/"/>
    
  </entry>
  
</feed>
