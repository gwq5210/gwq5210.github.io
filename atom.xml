<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gwq5210&#39;s Blog</title>
  
  <subtitle>凡是过往，皆为序章！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gwq5210.com/"/>
  <updated>2022-07-22T07:33:50.189Z</updated>
  <id>https://gwq5210.com/</id>
  
  <author>
    <name>gwq5210</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APUE笔记-三</title>
    <link href="https://gwq5210.com/2022/07/19/APUE%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <id>https://gwq5210.com/2022/07/19/APUE笔记-三/</id>
    <published>2022-07-19T17:03:04.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-进程控制"><a href="#第八章-进程控制" class="headerlink" title="第八章 进程控制"></a>第八章 进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。虽然是唯一的，但是进程ID是可复用的，当一个进程终止后，其进程ID就成为复用的候选者，大多数UNIX系统实现延迟算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID</p><p>系统中有一些专用进程，但是具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。进程ID 1通常是init进程，init进程绝不会终止，它是一个普通的用户进程，但是他以超级用户特权运行。init会成为孤儿进程的父进程</p><p>下列函数返回进程的标识符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的父进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的实际用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的实际组ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的有效组ID</span></span><br></pre></td></tr></table></figure><p>以上函数都没有出错返回</p><h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有的进程可以调用fork函数创建一个新进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">子进程返回<span class="number">0</span>，父进程返回子进程Id；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>由fork创建的新进程被称为子进程（child process），fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。一个进程的子进程可以有多个，但并没有一个函数使一个进程可以获得其所有子进程的进程ID。子进程ID不可能为0，因为进程ID 0总是由内核交换进程使用</p><p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本，父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段</p><p>由于在fork之后经常跟着exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为代替，使用了写时复制（Copy-On-Write，COW）技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一页</p><p>Linux 3.2.0提供clone系统调用，是fork的推广形式，允许调用者控制哪些部分由父进程和子进程共享</p><p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信</p><p>fork之后标准IO库的缓存区也被复制，如果缓冲区中存在数据，则在子进程中也存在相应的数据，可能会输出两次</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，就好像对每个文件描述符来说，执行了dup函数，父进程和子进程每个相同的打开描述符共享一个文件表项。</p><p>重要的一点是父进程和子进程共享同一个文件偏移量。如果不共享，则要实现父子进程都写到同一个文件则要困难的多。但如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步，那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的），但这并不是常用的操作模式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fork之后父进程和子进程之间对打开文件的共享.png" alt="fork之后父进程和子进程之间对打开文件的共享" title>                </div>                <div class="image-caption">fork之后父进程和子进程之间对打开文件的共享</div>            </figure><p>在fork之后，处理文件描述符有以下两种常见的情况</p><ul><li>父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新</li><li>父进程和子进程各自执行不同的程序段。这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的</li></ul><p>除了打开文件之外，父进程的很多其他属性也由子进程继承</p><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>对任一打开文件描述符的执行时关闭（close-on-exec）标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li>资源限制</li></ul><p>父进程和子进程之间的区别如下</p><ul><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程ID，而父进程的父进程ID则不变</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空</li></ul><p>fork失败的两个主要原因是</p><ul><li>系统中已经有了太多的进程（通常意味着某个方面除了问题）</li><li>该实际用户ID的进程总数超过了系统限制</li></ul><p>fork有以下两种用法</p><ul><li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求</li><li>一个进程要执行一个不同的程序。这对shell是常见的。在这种情况下，子进程从fork返回后立即调用exec</li></ul><p>某些操作系统将第二种用法中的两个操作组合成一个操作，称为spawn，UNIX将这两个操作分开，使得子进程在fork和exec之间可以更改自己的树形，如IO重定向、用户ID、信号安排等</p><h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同，但两者的语义不同</p><p>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。</p><p>不过在子进程调用exec或exit之前，它在父进程的空间运行，这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改数据（除了用于存放vfork返回值的变量）、进行函数调用、或者没有调用exec或exit就返回都可能带来未知的结果。</p><p>vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数的任意一个时，父进程会恢复运行。如果在调用这两个函数之前，子进程依赖于父进程的进一步动作，则会导致死锁</p><h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程5种正常终止方式如下</p><ul><li>在main函数内执行return语句，这等效于调用exit</li><li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序（调用atexit登记），然后关闭所有标准IO流等。因为ISO C并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的</li><li>调用_exit和_Exit函数。ISO C定义_Exit函数其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对于标准IO流是否进行冲洗，这取决于实现。在UNIX系统中_Exit和_exit是同义的，并不冲洗标准IO流。_exit函数由exit调用，它处理UNIX系统特定的细节。大多数UNIX系统实现中，exit是C库的一个函数，_exit是一个系统调用</li><li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用做进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回</li><li>进程的最后一个线程调用pthread_exit函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给pthread_exit的参数无关</li></ul><p>3种异常终止具体如下</p><ul><li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例</li><li>当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生</li><li>最后一个线程对“取消”（cancellation）请求做出相应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止</li></ul><p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器</p><p>上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数（exit、_exit和_Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传递给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态</p><p>子进程是父进程调用欧冠fork之后生成的。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，又将如何呢？其回答是：对于父进程已经终止的所有进程，它们父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1（init的进程ID），这种处理方法保证了每个进程有一个父进程</p><p>另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时可以得到这些信息。这些信号至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX系统术语中，一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程（zombie）。ps命令将僵死进程的状态打印为Z。如果一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程</p><p>被init收养的进程不会变成僵死进程。因为init进程在子进程终止时会调用wait函数取得其终止状态</p><h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是一个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它。</p><p>调用wait或waitpid的进程可能发生如下情况</p><ul><li>如果其所有子进程都还在运行，则阻塞</li><li>如果一个子进程已终止，正等待父进程获取其状态，则取得该子进程的终止状态立即返回</li><li>如果它没有任何子进程，则立即出错返回</li></ul><p>如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程ID；若出错，返回<span class="number">0</span>或<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>这两个函数的区别如下</p><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞</li><li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，它可以控制它所等待的进程</li></ul><p>如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如果调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪个子进程终止了</p><p>statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在statloc中，如果不关心终止状态，则可以将该参数设置为空指针</p><p>依据传统，这两个函数返回的整型状态字是由实现定义的，终止状态使用如下宏来查看</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/终止状态的宏.png" alt="终止状态的宏" title>                </div>                <div class="image-caption">终止状态的宏</div>            </figure><p>如果需要等待一个指定进程终止，在早期的UNIX系统中，必须调用wait，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则该进程ID和终止状态保存起来，然后再次调用wait，反复调用直到指定进程终止，下一次又想等待一个特定进程时，先查看已终止的进程列表或继续调用wait。</p><p>waitpid可以实现这一功能及其他功能，根据pid参数，作用如下</p><ul><li>pid等于-1：等待任一子进程。此种情况下，waitpid和wait等效</li><li>pid大于0：等待进程ID与pid相等的子进程</li><li>pid等于0：等待组ID等于调用进程组ID的任一子进程</li><li>pid小于-1：等待组ID等于pid绝对值的任一子进程</li></ul><p>对于wait其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错</p><p>参数options可以进一步控制waitpid的操作，此参数或者是0或者是如下常量按位或运算的结果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitpid的options参数.png" alt="waitpid的options参数" title>                </div>                <div class="image-caption">waitpid的options参数</div>            </figure><p>waitpid提供了wait函数没有的3个功能</p><ul><li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态</li><li>waitpid提供了一个wait的非阻塞版本</li><li>wait通过WUNTRACED和WCONTINUED选项支持作业控制</li></ul><p>如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态知道父进程终止，实现这一要求的诀窍是调用fork两次，子进程的子进程会被init收养</p><h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>Single UNIX Specification包括了另一个取得进程终止状态的函数waitid，此函数类似于waitpid，但提供了更多的灵活性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span>* infop, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>与waitpid类似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数</p><p>idtype类型如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitid的idtype常量.png" alt="waitid的idtype常量" title>                </div>                <div class="image-caption">waitid的idtype常量</div>            </figure><p>options是以下各标志的按位或运算，这些标志指示调用者关注哪些状态变化</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitid的options常量.png" alt="waitid的options常量" title>                </div>                <div class="image-caption">waitid的options常量</div>            </figure><p>WCONTINUED、WEXITED或WSTOPPED这三个常量之一必须在options参数中指定</p><p>infop是指向siginfo结构的指针，该结构包含了造成子进程进程状态改变有关信号的详细信息</p><h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>大多数UNIX系统实现提供了另外两个函数wait3和wait4。该函数允许内核返回由终止进程机器所有子进程使用的资源概况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。可以参考getrusage(2)手册页</p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。fork之后无法确定哪个进程先运行，因此需要某种形式的同步</p><p>如果一个进程需要等待其父进程终止，则可使用下列形式的循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getppid() != <span class="number">1</span>) &#123;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的循环称为轮询（polling），它的问题是浪费了CPU的时间</p><p>为了避免竞争条件和轮询，在多个进程间需要某种形式的信号发送和接收的方法，比如使用信号和各种形式的进程间通信</p><h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。</p><p>调用exec并不创建新进程，其进程ID并不会改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</p><p>有7中不同的exec函数，常常被统称为exec函数。</p><p>fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止，这是我们需要的基本进程控制原语。我们可以用这些原语构造另外一些如popen和system之类的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ..., <span class="comment">/* (char*)0, */</span> <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>这些函数之间的第一个区别是前4个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时：</p><ul><li>如果filename包含/，则就将其视为路径名</li><li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件</li></ul><p>如果execlp或execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的可执行文件，则就认为该文件是一个shell脚本，于是试着调用/bin/sh，并以该filename作为shell输入</p><p>fexecve函数避免了寻找正确的可执行文件，而是依赖调用进程来完成这项工作。调用进程可以使用文件描述符验证所需文件并且无竞争的执行该文件</p><p>第二个区别与参数表的传递相关（l表示list，v表示矢量vector）。函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外四个函数，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数</p><p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境。通常一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的环境</p><p>函数名中的字符会给我们一些记忆的帮助。字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个<code>argv[]</code>矢量。最后字母e表示该函数取<code>envp[]</code>数组，而不使用当前环境变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/7个exec函数之间的区别.png" alt="7个exec函数之间的区别" title>                </div>                <div class="image-caption">7个exec函数之间的区别</div>            </figure><p>每个系统对参数表和环境表的总长度都有一个限制。这种限制是由ARG_MAX给出的，此值至少是4096字节</p><p>执行exec后，进程ID没有改变，但新程序从调用进程继承了下列属性</p><ul><li>进程ID和父进程ID</li><li>实际用户ID和实际组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>闹钟尚余留的时间</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>文件锁</li><li>进程信号屏蔽</li><li>资源限制</li><li>nice值</li><li>tms_utime、tms_stime、tms_cutime以及tms_cstime值</li></ul><p>对打开文件的处理与每个描述符的执行时关闭（close-on-exec）标志值有关。若设置了该标志，则在执行exec时关闭该描述符；否则该描述符仍打开。除非特地的用fcntl设置了该执行时关闭标志，否则系统的默认操作是在exec后仍保持这种描述符打开</p><p>POSIX.1明确要求再exec时关闭打开目录流（opendir函数）。这通常是由opendir函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志</p><p>注意，在exec前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID位和设置组ID位是否设置。如果新程序的设置用户ID位已设置，则有效用户ID变成程序文件所有者的ID；否则有效用户ID不变。对组ID的处理方式与此相同</p><p>在很多UNIX系统实现中只有execve是内核的系统调用，另外6个只是库函数，它们最终都要调用该系统调用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/7个exec函数之间的关系.png" alt="7个exec函数之间的关系" title>                </div>                <div class="image-caption">7个exec函数之间的关系</div>            </figure><h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权（如能改变当前日期的表示法）以及访问控制（如能否读、写一个特定文件），是基于用户ID和组ID的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。同样如果需要降低权限，则也需要更换用户ID或组ID</p><p>一般而言，在设计应用时，我们总是视图使用最小特权（least privilege）模型。依照此模型，我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的进程以未预料的方式使用特权造成的安全性风险</p><p>可以用setuid函数设置实际用户ID和有效用户ID，与此类似，可以用setgid函数设置实际组ID和有效组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>更改用户ID的规则如下（适用于组ID）</p><ul><li>若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID（saved set-user-ID）设置为uid</li><li>若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID</li><li>如果上边两个条件都不满足，则errno设置为EPERM，并返回-1</li></ul><p>上述假定_POSIX_SAVED_IDS为真，如果没有提供这种功能，则上边关于保存的设置用户ID部分都无效</p><p>关于内核维护的3个用户ID，还需要注意</p><ul><li>只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时，有login程序设置的，而且绝不会改变它。login是一个超级用户进程</li><li>仅当对程序文件设置了设置用户ID位时，exec函数才设置有效用户ID。如果设置用户ID位没有设置，exec函数不会改变有效用户ID，而将维持其现有值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置用户ID。</li><li>保存的设置用户ID是由exec复制有效用户ID而得到的，如果设置了文件的设置用户ID位则在exec根据文件的用户ID设置了进程的有效用户ID以后，这个副本就被保存起来了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/更改3个用户ID的不同方法.png" alt="更改3个用户ID的不同方法" title>                </div>                <div class="image-caption">更改3个用户ID的不同方法</div>            </figure><p>历史上BSD支持setreuid函数，其功能是交换实际用户ID和有效用户ID的值，具体用法参考手册</p><p>函数seteuid和setegid只更改有效用户ID和有效组ID，一个非特权用户可以将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户则可将有效用户ID设置为uid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/设置不同用户ID的各函数.png" alt="设置不同用户ID的各函数" title>                </div>                <div class="image-caption">设置不同用户ID的各函数</div>            </figure><p>以上说的一切都以类似方式适用于各个组ID。附属组ID不受setgid、setregid和setegid函数影响</p><h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>现如今的UNIX系统都支持解释器文件（interpreter file）。这种文件是文本文件，其起始行的形式是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! pathname [optional-argument]</span></span><br></pre></td></tr></table></figure><p>感叹号和pathname之间的空格是可选的，最常见的解释器文件以下列行开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br></pre></td></tr></table></figure><p>pathname通常是绝对路径名，对它不进行什么特殊的处理（不使用PATH进行路径搜索）。对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的文件并不是解释器文件，而是在该解释器文件第一行中pathname所指定的文件，而是在该解释器文件第一行中pathname所指定的文件。注意解释器文件（文本文件，它以#!开头）和解释器（由该解释器文件第一行中的pathname指定）的区别</p><p>解释器文件的第一行一般由长度限制，这包括#!、pathname、可选参数、终止换行符以及空格数。Linux 3.2.0中是128字节</p><p>当内核exec解释器时，argv[0]参数是该解释器的pathname，其后是解释器文件中的可选参数，其余参数是exec的pathname以及调用exec的参数（argv[1]及其后参数），此时调用exec的argv[1]和其后参数已经右移。注意内核取exec调用中的pathname而不是argv[0]，因为一般而言pathname包含了比第一个参数更多的信息</p><p>解释器文件使得用户得到效率方面的好处，其代价是内核的额外开销（因为识别解释器文件的是内核）。</p><ul><li>有些程序是用某种语言写的脚本，解释器文件可以将这一事实隐藏起来。使用somecmd optional-arguments调用即可</li><li>解释器脚本在效率方面也提供了好处。我们可以编写shell脚本来实现相同的功能，但要求做更多动作。首先shell读此命令，然后试图execlp此文件，因为shell脚本是一个可执行文件，但却不是机器可执行的，于是返回一个错误，execlp就认为该文件是一个shell脚本，然后执行/bin/sh，并以该shell脚本的路径名作为其参数。shell正确的执行我们的shell脚本，但是为了运行shell脚本中的程序（如awk程序），它调用fork、exec和wait，于是一个shell脚本代替解释器脚本需要更多的开销</li><li>解释器脚本使我们可以使用除/bin/sh意外的其他shell来编写shell脚本</li></ul><h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>system函数可以执行给定的命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmdstring)</span></span>;</span><br></pre></td></tr></table></figure><p>如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，这一特征可以确定在一个给定的操作系统上是否支持system函数。在UNIX系统中system总是可用的</p><p>system在其实现中调用了fork、exec和waitpid，因此有3中返回值</p><ul><li>fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno</li><li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit(127)一样</li><li>否则所有3个函数都成功，那么system的返回值是shell的终止状态，其格式已在waitpid中说明</li></ul><h3 id="system的安全性漏洞"><a href="#system的安全性漏洞" class="headerlink" title="system的安全性漏洞"></a>system的安全性漏洞</h3><p>如果在一个设置用户ID程序中调用system，会发生什么呢？这是一个安全性方面的漏洞，决不应该这样做</p><p>有些实现通过更改/bin/sh，当有效用户ID与实际用户ID不匹配时，将有效用户ID设置为实际用户ID</p><p>如果一个进程正以特殊的权限运行，它又想生成另一个进程执行另一个程序，则它应该直接使用fork和exec，而且在fork之后，exec之前要更改回普通权限。设置用户ID或设置组ID程序决不应该调用system函数</p><h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个宣讲以进行进程会计（process accounting）处理，启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名，所适用的CPU时间总量、用户ID和组ID、启动时间等</p><p>会计记录所需的各个数据都由内核保存在进程表中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生两个后果</p><ul><li>我们不能获取永远不终止的进程的会计记录。如init或内核守护进程</li><li>会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li></ul><p>会计记录对应进程而不是程序，在fork之后，内核为子进程初始化一个记录，而不是在一个新程序被执行时初始化。虽然exec并不创建一个新的会计记录，但相应记录中的命令名改变了，AFORK则被清除。如果一个程序执行了3个程序（A exec B、B exec C，最后C exit）只会写一个会计记录，命令名对应C，CPU时间是A、B和C之和</p><h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>一个人在口令文件中可以有多个登录项，它们的用户ID相同，但登录shell不同（因此通过getpwuid(getuid())不可行）。可以使用getlogin函数可以获取登录名。如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败，通常称这些进程为守护进程（daemon）</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。进程可以通过调整nice值选择以更低优先级运行。只有特权进程允许提高调度权限。</p><p>nice值的返回在<code>0~(2*NZERO)-1</code>之间，nice值越小，优先级越高。NZERO是系统默认的nice值。</p><p>进程可以通过nice函数获取或更改它的nice值。使用这个函数，进程只能影响自己的nice值，不能影响任何其他进程的nice值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回新的nice值NZERO；若出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>incr参数会被增加到调用进程的nice值上，如果incr太大，系统直接把它降到最大合法值，不给出提示。类似的如果incr太小，系统会把它提高到最小合法值。由于-1是合法的成功返回值，在调用nice函数之前需要清除errno，在nice函数返回-1时，需要检查errno。如果nice调用成功，并且返回值为-1，那么errno仍然为0。如果errno不为0，说明nice调用失败</p><p>getpriority函数可以向nice函数那样用于获取进程的nice值，但是getpriority还可以获取一组相关进程的nice值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回-NZERO~NZERO<span class="number">-1</span>之间的nice值；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>which参数可以取以下三个值之一：PRIO_PROCESS表示进程，PRIO_PGRP表示进程组，PRIO_USER表示用户ID。which参数控制who参数是如何解释的，who参数选择感兴趣的一个或多个进程。如果who参数为0，表示调用进程、进程组或用户。当which设置为PRIO_USER并且who为0时，使用调用进程的实际用户ID。如果which参数作用域多个进程，则返回所有作用进程中优先级最高的（最小的nice值）</p><p>setpriority函数可用于为进程，进程组和属于特定用户ID的所有进程设置优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参数which和who与getpriority函数中相同。value增加到NZERO上，然后变为新的nice值</p><p>遵循XSI的系统要求进程调用exec后保留nice值。如Linux 3.2.0、MacOS等</p><h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的时间有三个：墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可以调用times获得它自己以及已终止进程的上述时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">times</span><span class="params">(struct tms* buf)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回流逝的墙上时钟时间（以时钟滴答数为单位）；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>此函数填写由buf指向的tms结构，定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_utime;  <span class="comment">/* user CPU time */</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_stime;  <span class="comment">/* system CPU time */</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cutime; <span class="comment">/* user CPU time of children, all waited-for terminated children*/</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cstime; <span class="comment">/* system CPU time of children, all waited-for terminated children */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>times函数返回墙上时钟时间作为其函数值。次值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。例如，调用times两次，其差值就是墙上时钟时间</p><p>结构中两个针对子进程的字段包含了此进程用wait函数族已等待到的各子进程的值。所有由此函数返回的clock_t值都用_SC_CLK_TCK转换成秒数</p><p>大多数实现提供了getrusage(2)函数，该函数返回CPU时间以及指示资源使用情况的另外14个值</p><h1 id="第九章-进程关系"><a href="#第九章-进程关系" class="headerlink" title="第九章 进程关系"></a>第九章 进程关系</h1><h2 id="终端登录和网络登录"><a href="#终端登录和网络登录" class="headerlink" title="终端登录和网络登录"></a>终端登录和网络登录</h2><p>我们可以经由终端登录至UNIX系统，终端的类型可以是基于字符的终端、图形终端等</p><p>系统使用伪终端（pseudo terminal），来处理终端登录和网络登录</p><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID外，还属于一个进程组。进程组是一个或多个进程的集合。通常它们是在同一作业中结合起来的，同一进程组中各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID，它是一个正整数，并可存放在pid_t数据类型中。函数getpgrp返回调用进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">返回调用进程的进程组ID</span><br></pre></td></tr></table></figure><p>getpgid返回指定进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>若pid是0，返回调用进程的进程组ID，即<code>getpgid(0)</code>等价于<code>getpgrp()</code></p><p>每个进程组有一个组长进程，组长进程的进程组ID等于其进程ID，进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组</p><p>进程调用setpgid可以加入一个现有的进程组或者创建一个新的进程组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>setpgid将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID</p><p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用exec之后，它就不再更改该子进程的进程组ID</p><p>大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID，这两个调用有一个是冗余的，但让父进程和子进程都这样可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在fork之后，由于父子进程运行的先后次序不确定，会导致子进程的组员身份不确定。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话（session）是一个或多个进程组的集合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/会话中的进程组安排.png" alt="会话中的进程组安排" title>                </div>                <div class="image-caption">会话中的进程组安排</div>            </figure><p>进程调用setsid函数建立一个新会话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。会发生以下3件事</p><ul><li>该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程</li><li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li><li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断</li></ul><p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程继续，因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长</p><p>getsid函数返回会话首进程的进程组ID。会话首进程总是一个进程组的组长进程，所以可以将“会话首进程的进程组ID”称为会话ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回会话首进程的进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如若pid是0，getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑，一些实现有如下限制：如果pid并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID</p><h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p><ul><li>一个会话可以有一个控制终端（controlling terminal）。这通常是终端设备（终端登录）或伪终端设备（网络登录）</li><li>建立与控制终端连接的会话首进程被称为控制进程（controlling process）</li><li>一个会话中的几个进程组可被分成一个前台进程组（foreground process group）以及一个或多个后台进程组（background process group）</li><li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组</li><li>无论何时键入终端的中断键（常常是Delete或Ctrl+C），都会将中断信号发送至前台进程组的所有进程</li><li>无论何时键入终端的退出键（常常是Ctrl+\），都会将推出信号发送至前台进程组的所有进程</li><li>如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（会话首进程）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/控制终端.png" alt="控制终端" title>                </div>                <div class="image-caption">控制终端</div>            </figure><p>通常我们不必担心控制终端，登录时，将自动建立控制终端</p><p>可以open文件/dev/tty（在内核中，此设备是控制终端的同义词）来与控制终端对话，如果程序没有终止终端，则对于此设备的open将失败</p><h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组，这样终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回前台进程组ID；若出错，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数tcgetpgrp返回前台进程组ID，它与在fd打开的终端相关联</p><p>如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid。pgrpid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端</p><p>大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用</p><p>给出控制TTY的文件描述符，通过tcgetsid函数，应用程序就能获得会话首进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetsid</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回会话首进程的进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会话ID（它等价于会话首进程的进程组ID）</p><h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问控制终端以及哪些作业在后台运行。作业控制要求以下3中形式的支持</p><ul><li>支持作业控制的shell</li><li>内核中的终端驱动程序必须支持作业控制</li><li>内核必须提供对某些作业控制信号的支持</li></ul><p>我们可以在终端上键入影响前台作业的特殊字符</p><ul><li>中断字符（一般采用Delete或Ctrl+C）产生SIGINT</li><li>退出字符（一般采用Ctrl+\）产生SIGQUIT</li><li>挂起字符（一般采用Ctrl+Z）产生SIGTSTP</li></ul><h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>一个其父进程已终止的进程称为孤儿进程（orphan process），这种进程由init进程收养。整个进程组也可成为孤儿</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八章-进程控制&quot;&gt;&lt;a href=&quot;#第八章-进程控制&quot; class=&quot;headerlink&quot; title=&quot;第八章 进程控制&quot;&gt;&lt;/a&gt;第八章 进程控制&lt;/h1&gt;&lt;h2 id=&quot;进程标识&quot;&gt;&lt;a href=&quot;#进程标识&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记-二</title>
    <link href="https://gwq5210.com/2022/07/17/APUE%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://gwq5210.com/2022/07/17/APUE笔记-二/</id>
    <published>2022-07-17T23:58:29.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-标准IO库"><a href="#第五章-标准IO库" class="headerlink" title="第五章 标准IO库"></a>第五章 标准IO库</h1><p>标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标准IO库</p><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>在第三章所有的文件IO都是围绕文件描述符的。对于标准IO库，其操作是围绕流（stream）进行的，打开或创建一个文件时，使一个流与一个文件相关联</p><p>标准IO文件流可用于单字节和多字节字符集。流的定向（stream’s orientation）决定了读、写字符是单字节还是多字节的。</p><p>当一个流最初被创建时，它并没有定向。若在流上使用一个单字节IO函数，则将流设置为字节定向的。若在流上使用一个多字节IO函数，则将流设置为字宽定向的。</p><p>只有freopen和fwide这两个函数可以改变流的定向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE* fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: &gt;<span class="number">0</span> : 宽定向；&lt;<span class="number">0</span> 字节定向；<span class="number">0</span> : 未定向</span><br></pre></td></tr></table></figure><p>fwide并不能改变已定向流的定向。fwide无法返回出错。需要在调用fwide前清除errno，返回时再检查errno的值</p><p>一个流的结构（FILE*，通常称为文件指针）通常包含一些必要的信息，如实际IO的文件描述符，缓存区指针和长度，当前在缓冲区中的字符数和出错标志等</p><p>一个进程预定义了3个流，标准输入流，标准输出流，标准出错流(分别是stdin, stdout, stderr)可以自动被进程使用。分别对应文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准IO库提供缓冲的目的是尽可能减少read、write系统调用的次数。它对每个IO流自动进行缓冲管理，避免应用程序考虑应使用多大的缓冲区。</p><p>标准IO提供3中类型的缓冲</p><ul><li>全缓冲。这种情况下，缓冲区满才进行实际的IO操作，磁盘文件通常是全缓冲的。当然我们可以通过fflush手动冲洗流的缓冲区</li><li>行缓冲。这种情况下，输入和输出遇到换行符执行IO操作。流涉及一个终端时通常使用行缓冲。行缓冲有以下两个限制<ul><li>缓冲区大小固定。缓冲区满时，即使没有换行符也进行IO操作</li><li>任何时候，只要通过标准IO库要求从a）不带缓冲的流或b)一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流</li></ul></li><li>不带缓冲。标准IO库不对字符进行缓冲存储。标准错误流通常是不带缓冲的，这使得出错信息可以尽快的显示出来</li></ul><p>ISO C要求</p><ul><li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的</li><li>标准错误绝不会是全缓冲的</li></ul><p>一般系统默认如下方案</p><ul><li>标准错误流是不带缓冲的</li><li>若是指向终端的流，则是行缓冲的；否则是全缓冲的</li></ul><p>我们可以通过如下函数修改系统默认的缓冲类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上函数应在流被打开后调用，且应在对流执行任何一个其他操作之前调用</p><p>可以使用setbuf打开或关闭缓冲机制。buf为NULL，则关闭缓冲；为了带缓冲进行IO，参数buf必须指向一个长度为BUFSIZ的缓冲区。一般在此之后流就是全缓冲的，但是如果一个流与一个终端设备相关，某些系统也可将其设置为行缓冲的</p><p>使用setvbuf可以通过mode精确的指定缓冲类型</p><ul><li>_IOFBF：全缓冲</li><li>_IOLBF：行缓冲<ul><li>以上可以通过buf和size设置缓冲区和长度；如果buf为NULL，则标准IO库将自动分配合适的缓冲区，适当长度一般由BUFSIZ指定（GNU C使用stat结构中的st_blksize来决定最佳缓冲区长度）</li></ul></li><li>_IONBF：不带缓冲，忽略buf和size参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/setbuf和setvbuf函数.png" alt="setbuf和setvbuf函数" title>                </div>                <div class="image-caption">setbuf和setvbuf函数</div>            </figure><p>一般而言我们应该由系统选择缓冲区的长度，并自动分配缓冲区，流关闭时，将自动释放缓冲区</p><p>任何时候我们可以强制冲洗一个流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>此函数使所有未写的数据都传送至内核。如果fp是NULL，则导致所有的输出流被冲洗</p><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>以下3个函数打开一个标准流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>说明如下</p><ul><li>fopen打开路径名为pathname的指定文件</li><li>freopen在一个指定流上打开一个指定文件，如若流已经被打开，则先关闭该流。若流已经定向，则使用freopen清除该定向。此函数一般用于将一个指定文件打开为一个预定义的流：标准输入、标准输出、标准错误</li><li>fdopen函数取一个已有的文件描述符（如从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到），并使一个标准的IO流与此文件描述符相结合</li></ul><p>参数type有如下组合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fopen的type.png" alt="fopen的type" title>                </div>                <div class="image-caption">fopen的type</div>            </figure><p>使用字符b可以使得标准IO系统区分二进制和文本文件。UNIX内核并不区分这两种文件，所以在UNIX系统下并无作用</p><p>对于fdopen，type参数的作用稍有区别。因为该描述符已被打开，所有fdopen为写打开并不截断文件。标准IO追加写方式也不能用于创建该文件（该文件一定存在，fd引用一个文件）</p><p>当以读和写类型（type中+号）打开一个文件时，有如下限制</p><ul><li>如果中间没有fflush、fseek、fsetpos或rewind，则在输出后边不能直接跟随输入</li><li>如果中间没有fseek、fsetpos或rewind或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/打开流的不同方式.png" alt="打开流的不同方式" title>                </div>                <div class="image-caption">打开流的不同方式</div>            </figure><p>在w和a类型创建一个文件时，我们无法指定文件的访问权限位，我们可以通过调整umask值来限制这些权限或创建之后修改权限</p><p>调用fclose可以关闭一个打开的流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>在该文件被关闭之前，冲洗缓冲区中的输出数据，缓冲区中的任何输入数据被丢弃。如果分配和缓冲区，则自动释放缓冲区</p><p>进程正常终止时（直接调用exit或从main函数返回），则所有带未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭</p><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>有三种不同的非格式化IO可以对流进行读写操作</p><ul><li>每次一个字符的IO。如果流带缓冲，则标准IO函数处理所有缓冲</li><li>每次一行的IO。</li><li>直接IO，或者称为二进制IO。fread和fwrite支持这种类型的IO</li></ul><h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><p>以下函数可以一次读取一个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 等同于fgetc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回下一个字符；若已到文件结尾或出错，返回EOF</span><br></pre></td></tr></table></figure><p>返回值会将unsigned char转换为int类型。无符号即使最高位为1也不会返回负值。要求int返回值是因为除了返回所有可能的字符，还要加上一个已出错或到达文件尾端的标记值。EOF被要求是一个负值，通常为-1</p><p>为了区分出错或到达文件尾端，需要使用以下函数进行区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若条件为真，返回非<span class="number">0</span>；否则，返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数实现在文件指针中维护了两个标志：出错标志和文件结束标志；调用clearerr可以清除这两个标志</p><p>从流中读取数据后，可以调用ungetc再将字符压入流中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>压送回流的字符又可以从流中读出，但读出字符的顺序与压送回流的顺序相反。回送的字符不一定必须是上次读到的字符，不能回送EOF。但是当已经达到文件尾端时，仍可以回送一个字符。调用ungetc只是将字符写入流缓冲区中</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>; <span class="comment">// 等同于fputc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><h2 id="每次一行IO"><a href="#每次一行IO" class="headerlink" title="每次一行IO"></a>每次一行IO</h2><p>由以下函数提供每次输入一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;  <span class="comment">// 可能造成缓冲区溢出，应使用fgets(buf, n, stdin)替换</span></span><br><span class="line"></span><br><span class="line">若成功，返回buf；若已到达文件末尾或出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>fgets读取不超过n-1个字符，buf总是以null字节结尾。gets不将换行符写入buf，而fgets则将换行符写入buf</p><p>fputs和puts提供每次输出一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;  <span class="comment">// 等价于fputs(str, stdout); fputs("\n", stdout);</span></span><br><span class="line"></span><br><span class="line">若成功，返回非负值；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>应尽量使用fget和fputs组合，以便记得在每行终止时必须处理换行符</p><h2 id="标准IO的效率"><a href="#标准IO的效率" class="headerlink" title="标准IO的效率"></a>标准IO的效率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/标准IO库的效率.png" alt="标准IO库的效率" title>                </div>                <div class="image-caption">标准IO库的效率</div>            </figure><h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><p>使用以下函数处理二进制IO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回读或写的对象数</span><br></pre></td></tr></table></figure><p>对于读，如果出错或到达文件尾端，则此数字可以小于nobj，这时应调用ferror或feof判断是哪种情况。对于写如果返回值小于nobj则出错</p><p>二进制IO需要对读写的数据有限制，否则可能产生兼容性的问题。如结构体对齐问题，导致数据错误</p><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有三种方法定位标准IO流</p><ul><li>ftell和fseek，用long进行定位</li><li>ftello和fseeko，用off_t进行定位</li><li>fgetpos和fsetpos，由ISO C引入，使用fpos_t进行定位；移植到非UNIX系统的应用程序应当使用这两个函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回当前文件位置指示；若出错，返回<span class="number">-1L</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;  <span class="comment">// whence与lseek的参数相同</span></span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用rewind将流设置到文件的起始位置</p><p>除了偏移类型是off_t外，ftello和fseeko函数与上述函数相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span>* <span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><p>格式化IO有scanf和printf函数族来实现，同时也提供了vscanf和vprintf函数族来处理可变参数</p><p>有关格式化IO的详细信息，这里不过多介绍，需要时可以参考手册或书籍</p><h2 id="标准IO库的文件描述符"><a href="#标准IO库的文件描述符" class="headerlink" title="标准IO库的文件描述符"></a>标准IO库的文件描述符</h2><p>fileno可以获取对应流关联的文件描述符，其不是ISO C标准，不可移植</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回与流相关联的文件描述符</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准库提供了两个函数来帮助创建临时文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向唯一路径名的指针</span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>tmpnam函数产生一个与现有文件名不通的有效路径名字符串，最多调动TMP_MAX次。若ptr是NULL，则所产生的路径名存放在静态存储区中，指向该静态区的指针作为返回值返回。若ptr不为空，则长度至少为L_tmpnam，并返回ptr</p><p>tmpfile创建一个临时二进制文件（wb+），在关闭该文件或程序结束时将自动删除这中文件。其原理一般是调用tmpnam函数产生一个唯一路径名，然后用该路径名创建一个文件，并立即unlink它</p><p>另外mkdtemp和mkstemp也可以创建临时目录或文件。</p><p>一般应使用mkstemp（文件不会自动删除）和tmpfile，因为使用tmpnam和tempnam至少有一个缺点：因为在调用其获取唯一文件名和创建文件之间，可能有其他进程使用相同名字创建文件，而mkstemp和tmpfile不存在这个问题</p><h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>内存流一般不会用到，不做介绍</p><h2 id="标准IO库的替代软件"><a href="#标准IO库的替代软件" class="headerlink" title="标准IO库的替代软件"></a>标准IO库的替代软件</h2><p>标准IO库有一些缺点。效率不高，通常需要复制两次数据：内核到标准IO库缓冲区、标准IO库缓冲区到用户程序缓冲区。</p><p>mmap函数也可以用来读写文件</p><h1 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h1><p>UNIX系统有很多与系统有关的数据文件，由于历史原因这些数据文件都是ASCII文本文件，本章简单介绍这些文件。除此之外还介绍系统标识函数、时间和日期函数</p><h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含如下字段，其定义在&lt;pwd.h&gt;中的passwd结构中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/passwd文件中的字段.png" alt="passwd文件中的字段" title>                </div>                <div class="image-caption">passwd文件中的字段</div>            </figure><p>可以通过getpwuid和getpwunam获取uid或name，同时也提供了函数来读取/etc/passwd文件，具体可查看文档</p><p>目前，加密口令一般存放在阴影口令文件中，一般为/etc/shadow，可以通过函数来读取加密口令</p><p>组文件一般为/etc/group。UNXI系统一般支持附属组，一个用户可以加入多个附属组中，用户附属组可以通过函数获取</p><h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX会提供utmp——记录当前登录到系统的各个用户，wtmp——跟踪各个登录和注销事件，其一般为二进制文件，存放相应的结构体</p><h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>可以通过uname获取系统标识，一般包括如下字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> sysname[];  <span class="comment">// name of the operating system</span></span><br><span class="line">  <span class="keyword">char</span> nodename[];  <span class="comment">// name of the node</span></span><br><span class="line">  <span class="keyword">char</span> release[];  <span class="comment">// current release of operating system</span></span><br><span class="line">  <span class="keyword">char</span> version[];  <span class="comment">// current version of release</span></span><br><span class="line">  <span class="keyword">char</span> machine[];  <span class="comment">// name of hardware type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>历史上，BSD派生的系统提供gethostname函数，它只返回主机名，改名字通常就是TCP/IP网络上主机的名字</p><h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>time函数返回自协调世界时公元1970年1月1日 00:00:00这一特定时间以来经过的秒数</p><p>clock_gettime函数可用于获取指定时钟时间，clock_getres用于获取指定时钟精度，clock_settime对特定的时钟设置时间</p><p>gettimeofday可以获取微秒级的时间</p><p>其余函数可以将秒数转换为tm结构体，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;                   <span class="comment">/* Seconds.     [0-60] (1 leap second) */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;                   <span class="comment">/* Minutes.     [0-59] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;                  <span class="comment">/* Hours.       [0-23] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;                  <span class="comment">/* Day.         [1-31] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;                   <span class="comment">/* Month.       [0-11] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;                  <span class="comment">/* Year - 1900.  */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;                  <span class="comment">/* Day of week. [0-6] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;                  <span class="comment">/* Days in year.[0-365] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;                 <span class="comment">/* DST.         [-1/0/1]*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/时间函数之间的关系.png" alt="时间函数之间的关系" title>                </div>                <div class="image-caption">时间函数之间的关系</div>            </figure><h1 id="第七章-进程环境"><a href="#第七章-进程环境" class="headerlink" title="第七章 进程环境"></a>第七章 进程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，其原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argc为命令行参数的个数</span></span><br><span class="line"><span class="comment">// argv是指向参数的各个指针构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>内核（使用exec函数，后续将会介绍）执行C程序时，在调用main函数前会先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地——这是由链接编辑器指定的，而链接编辑器由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按照上述方式调用main函数做好准备</p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有八种方式终止进程（termination），前5种为正常终止，后3种为异常终止</p><ul><li>从main函数返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit</li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出响应</li></ul><p>启动例程一般是从main函数返回后立即调用main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语义为如下C语言调用，但启动例程一般用汇编语言编写</span></span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv));</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>_exit和_Exit立即进入内核，exit则先执行一些清理，然后返回内核</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p>exit函数总是执行一个标准IO库的相关清理工作：对于所有打开流调用fclose函数</p><p>3个函数都带一个整型参数，称为终止状态（exit status）。大多数UNIX系统shell都提供检查进程终止状态的方法（echo $?）</p><p>main函数推荐声明为int，并且需要返回整型值，否则，可能终止状态是未定义的</p><p>main函数返回一个整型值与用该值调用exit是等价的，即exit(0)等价于return 0</p><h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>ISO C规定一个进程可以登记多至32个函数，这些函数将由exit自动调用，这些函数称为终止处理程序（exit handler），使用atexit来登记这些函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>其参数是一个函数地址，其无参数也无返回值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数若登记多次也会被调用多次</p><p>exit首先调用各种终止处理程序，然后关闭所有打开的流。若程序调用exec函数族的任一函数，则将清除所有已安装的终止处理程序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/程序的启动和终止.png" alt="程序的启动和终止" title>                </div>                <div class="image-caption">程序的启动和终止</div>            </figure><p>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式的（通过调用exit）调用_exit或_Exit。进程也可非自愿的由一个信号使其终止</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>执行一个程序时，调用exec的进程可以将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。参数<code>argv[argc]</code>被要求为NULL</p><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表，与参数一样环境表也是一个字符串指针数组，其中每个指针包含一个以null字节结尾的C字符串地址。全局变量environ包含了该指针数组的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br></pre></td></tr></table></figure><p>environ称为环境指针（environment pointer），指针数组称为环境表，各指针指向的字符串称为环境字符串</p><p>环境字符串的格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/环境指针.png" alt="环境指针" title>                </div>                <div class="image-caption">环境指针</div>            </figure><p>大多数环境预定义名全部由大写字母组成，这只是一个惯例。历史上UNIX系统支持main函数带3个参数，第三个参数是环境表指针。但通常我们应使用environ全局变量，而不是使用第3个参数。更好的方法是getenv和putenv函数，但如果要查看整个环境，则必须访问environ全局变量</p><h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>历史沿袭至今，C程序一直由以下部分组成</p><ul><li>正文段。这是由CPU执行的机器指令部分。通常正文段是共享的和只读的（防止程序由于意外而修改其指令）</li><li>初始化数据段。通常将此段称为数据段，它包含了程序中需明确的赋初值的变量（已初始化的全局变量和静态变量）。如C程序中任何函数外的声明int maxcount = 99;则此变量和初值存放在初始化数据段中</li><li>未初始化数据段。通常将此段称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。包含未初始化的全局变量和静态变量</li><li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后最近被调用的函数在栈上为其自动变量和临时变量分配空间。通过此方式使用栈，C递归函数可以工作。一次函数的调用产生一个新的栈帧，因此一次函数的调用不会影响另一次函数调用实例中的变量</li><li>堆。通常在堆中进行动态内存分配。由于历史上形成的惯例，堆位于未初始化段和栈之间</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/典型的存储空间安排.png" alt="典型的存储空间安排" title>                </div>                <div class="image-caption">典型的存储空间安排</div>            </figure><p>程序中还有其他的段，如包含符号表的段、包含调试信息的段，包含动态共享库链接表的段，这些部分并不装载到进程执行的程序映像中</p><p>未初始化段的内容并不存放在磁盘程序文件中，其原因是内核在程序开始运行前都将它们设置为0，需要存放在磁盘文件中的段只有正文段和初始化数据段</p><p>size(1)命令可以报告正文段、数据段和bss段的以字节为单位的长度</p><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件不再需要包含共用的函数库，而只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</p><p>程序第一次执行或者第一次调用某个函数库时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。</p><p>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑（假定参数的数目和类型都没有发生改变）。</p><p>gcc可使用-static阻止使用共享库</p><h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个可用于存储空间动态分配的函数</p><ul><li>malloc，分配指定字节数的存储区。此存储区中的初始值不确定</li><li>calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一个bit都初始化为0</li><li>realloc，增加或减少以前分配区的长度。当增加长度时，可能需要将以前分配区的内容移动到另一个足够大的区域，以便在尾端提供增加的存储区，而新增加区域内的初始值则不确定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">recalloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回非空指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>这3个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象</p><p>realloc的最后一个参数是存储区的新长度，不是新旧存储区长度之差。作为一个特例，如果ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度为newsize的存储区</p><p>这些分配例程通常用sbrk(2)系统调用实现，该系统调用扩充或缩小进程的堆。虽然sbrk可以扩充或缩小进程的存储空间，但是大多数malloc和free实现都不减少进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核</p><p>大多数实现所分配的存储空间比所要求的的要稍大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。这就意味着，如果超过一个已分配区的尾端或者在已分配区的起始位置之前进行写操作，则会改写另一块的管理记录信息。这种类型的错误是灾难性的，但是这种错误不会很快暴露出来，所以也就很难发现</p><p>常见的错误是：释放一个已经释放的块；调用free时所用的指针不是3个alloc函数返回的指针</p><p>常见的代替分配方法为jemalloc和tcmalloc</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>UNIX内核并不查看环境变量字符串，它们的解释完全取决于各个应用程序。</p><p>getenv可以取环境变量值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向与name关联的value的指针；若未找到，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>此函数返回一个指针，它指向<code>name=value</code>字符串中的value</p><p>我们也希望可以改变现有变量的值，或者是增加新的环境变量。我们能影响的只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><ul><li>putenv取形式为<code>name=value</code>的字符串，将其放到环境表中，如果name已经存在，则先删除原来的定义。其参数str指针直接放到环境变量中</li><li>setenv将name设置为value。若环境中name已经存在，那么a）若rewrite非0，则首先删除其现有定义；b)若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）。与putenv不同setenv必须分配存储空间</li><li>unsetenv删除name的定义，即使不存在这种定义也不算出错</li></ul><h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的函数是setjmp和longjmp。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p><p>如果对嵌套层次很深的错误进行判断，逐层返回，会比较麻烦。可以使用setjmp和longjmp来实现非局部跳转。其不是由普通C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"></span><br><span class="line">若直接调用，返回<span class="number">0</span>；若从longjmp返回，则为非<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>在希望返回到的位置调用setjmp。jmp_buf是某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息。</p><p>longjmp参数val将成为setjmp处返回的值，因为一个setjmp可以有多处longjmp，通过val值就可以进行区分</p><p>当longjmp发生跳转时，自动变量和寄存器变量的值会如何变化，这是不确定的，大多数实现并不回滚这些自动变量和寄存器变量的值，而所有的标准则称它们的值是不确定的。如果你有一个自动变量，而又不想使其回滚，则可以定义其为volatile属性。声明为全局变量、静态变量的值在执行longjmp时保持不变。</p><h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制，其中一些是可以用getrlimit和setrlimit函数查询和更改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys//resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit* rlptr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">// soft limit: current limit</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">// hard limit: maximum value for rlim_cur</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更改资源时，需要遵循下列规则</p><ul><li>任何一个进程都可以将一个软限制更改为小于或等于其硬限制值</li><li>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的</li><li>只有超级用户进程才可以提高硬限制值</li></ul><p>常量RLIM_INFINITY指定一个无限量的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/对资源限制的支持.png" alt="对资源限制的支持" title>                </div>                <div class="image-caption">对资源限制的支持</div>            </figure><p>资源限制影响到调用进程并由其子进程继承。shell具有内置ulimit命令，用于修改限制值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-标准IO库&quot;&gt;&lt;a href=&quot;#第五章-标准IO库&quot; class=&quot;headerlink&quot; title=&quot;第五章 标准IO库&quot;&gt;&lt;/a&gt;第五章 标准IO库&lt;/h1&gt;&lt;p&gt;标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>STL之string</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E4%B9%8Bstring/"/>
    <id>https://gwq5210.com/2021/11/14/STL之string/</id>
    <published>2021-11-14T20:20:57.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string概述"><a href="#string概述" class="headerlink" title="string概述"></a>string概述</h1><p>string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常使用string，否则就使用vector</p><p>string和vector自动管理动态数组，并自动扩充数组的大小，析构时自动释放内存</p><p>string提供了字符串查找，替换等成员函数，方便使用</p><h1 id="string实现"><a href="#string实现" class="headerlink" title="string实现"></a>string实现</h1><p>string在编程中十分常见，了解字符串的实现很有帮助</p><p>为了提高string的性能，一般有三种方式来实现string，有时会对这几种方法相结合</p><ul><li>eager copy，即每次都执行深拷贝</li><li>SSO，即Small String Optimization，较小的字符串在栈中分配内存</li><li>COW，即Copy On Write，写时复制</li></ul><h2 id="string的结构"><a href="#string的结构" class="headerlink" title="string的结构"></a>string的结构</h2><p>介绍三种实现前，先大致介绍下string的结构</p><p>如果按照我们自己的设计，字符串必定包含以下三个数据成员：字符串长度，字符串的容量和字符数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringStorage</span> &#123;</span></span><br><span class="line">  size_type size;</span><br><span class="line">  size_type capacity;</span><br><span class="line">  pointer data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eager-copy"><a href="#eager-copy" class="headerlink" title="eager copy"></a>eager copy</h2><p>直接深拷贝的方式很容易理解，因为string中保存的是指向堆内存的指针，在复制时，需要执行以下步骤执行深拷贝</p><ul><li>分配新的内存</li><li>将字符串的内容复制到新内存</li><li>设置字符串大小和容量</li></ul><p>这种字符串的实现方式，相对简单，比较容易理解，但带来的问题是每次复制都需要分配内存和执行复制的操作，当字符串很大时，会带来性能的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringStorage <span class="title">AllocateMediumStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = kMaxMediumSize;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(Allocate(kMaxMediumSize + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitMedium</span><span class="params">(const_pointer str, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  assert(len &lt;= kMaxMediumSize);</span><br><span class="line">  store_ = AllocateMediumStorage();</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kMedium;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>短字符串优化是一个很巧妙的优化方法，利用string本身结构的buffer来存储较小的字符串</p><p>上边给出的例子中，至少需要三个变量，因此string的结构本身需要24个字节</p><p>当字符串较小时，如果仍在堆上分配内存，但size和capacity本身的值则很小，高位bit都是0，浪费了许多空间</p><p>因此在SSO的实现，只用一个字节表示字符串大小，容量大小是固定的，不需要存储，则可以有24-1=23个字节存储字符串，除去尾部的’\0’，则实际的容量为22，这便是llvm/clang/libc++采用的实现</p><p>SSO的字符串，复制时只需简单的复制SmallString结构即可，无需在堆上分配内存</p><p>另外，他们的实现，会结合SSO、COW和eager copy的实现，因此需要标记字符串的类型，它用一个bit来区分是长字符还是短字符，然后用位操作和掩码 (mask) 来取重叠部分的数据，因此实现是最复杂的。</p><p>本文的实现，为了简单，使用一个字节来区分字符串类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallString</span> &#123;</span></span><br><span class="line">  SmallString() &#123; Init(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    data[size] = <span class="string">'\0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(const_pointer str, size_type len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">      assert(len &lt;= kMaxSmallSize);</span><br><span class="line">      size = len;</span><br><span class="line">      <span class="built_in">memcpy</span>(data, str, <span class="keyword">sizeof</span>(value_type) * len);</span><br><span class="line">      data[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint8_t</span> size;</span><br><span class="line">  value_type data[kMaxSmallSize + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/sso_string.png" alt="sso_string" title>                </div>                <div class="image-caption">sso_string</div>            </figure><h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>写时复制（Copy-on-write，简称COW）是一种很重要的优化手段。核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享资源，当需要修改时，才真正进行资源的分配</p><p>Linux内核在进程fork时对进程地址空间的处理就使用到了COW技术</p><h3 id="COW优点"><a href="#COW优点" class="headerlink" title="COW优点"></a>COW优点</h3><ul><li>减少了分配（和复制）大量资源带来的瞬间延迟（实际上该延迟被分摊到后续的操作中，其累积耗时很可能比一次统一处理的延迟要高，造成throughput下降是有可能的）</li><li>减少了不必要的资源分配。（例如只读的复制没有必要执行深拷贝）</li></ul><p>当然COW不是没有缺点，下文会进行介绍</p><h3 id="COW实现"><a href="#COW实现" class="headerlink" title="COW实现"></a>COW实现</h3><p>基于COW的思想，我们知道，在string复制时，只进行浅拷贝，而在需要修改对象时，则执行深拷贝的动作。</p><p>我们要在什么时候需要执行深拷贝？</p><ul><li>当前字符串没有被共享，则不需要拷贝</li><li>当前字符串被共享，当需要修改时，进行深拷贝的动作</li></ul><p>因此，为了区分是否被共享，我们引入一个引用计数来记录字符串被多少个string共享</p><p>引用计数一般是原子操作，保证线程安全，下文会详细介绍；引用计数需要在堆上分配，保证不同的string对象能够共享</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeString</span> &#123;</span></span><br><span class="line">  LargeString() : ref_count(<span class="number">1</span>) &#123; data[<span class="number">0</span>] = <span class="string">'\0'</span>; &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;size_type&gt; ref_count;</span><br><span class="line">  value_type data[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">StringStorage <span class="title">AllocateLargeStorage</span><span class="params">(size_type capacity)</span> </span>&#123;</span><br><span class="line">  assert(capacity &gt; kMaxMediumSize);</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = capacity;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(Allocate(LargeString::GetDataOffset() + capacity + <span class="number">1</span>)) + LargeString::GetDataOffset());</span><br><span class="line">  LargeString::ConstrctAt(store);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitLarge</span><span class="params">(const_pointer str, size_type len, size_type c = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  store_ = AllocateLargeStorage(c &gt; <span class="number">0</span> ? c : len);</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kLarge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">MutableData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 引用计数大于1，则执行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (type_ == StringType::kLarge &amp;&amp; LargeString::RefCount(store_) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    LargeString::DecRefCount(store_);</span><br><span class="line">    UnsafeInitLarge(store_.data, store_.size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> store_.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="COW在多线程中的问题"><a href="#COW在多线程中的问题" class="headerlink" title="COW在多线程中的问题"></a>COW在多线程中的问题</h1><p>像STL的其他容器一样，多线程操作共享的string不是线程安全的。但不同的线程操作不同的字符串是线程安全的。</p><p>聪明的同学立马会想到，在COW的string实现中，不同的string对象，可能共享同一块内存，那不同线程同时修改COW实现的string时，怎么保证线程安全呢？</p><p>这就要求COW的string必须能够正确的处理这种竞争条件：</p><ul><li>对引用计数进行原子操作</li><li>需要修改时，先分配和复制，再将引用计数减1（当引用计数为0时，负责释放内存）</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>比起mutex之类的同步手段，原子操作自然要轻上不少，但比起普通的算术指令，依然算得上完全的重量级</p><p>COW为了保证“线程安全”而使用了原子操作，而原子操作本身的效率并不十分高。而且在多线程环境下，多个CPU对同一个地址的原子操作开销更大。COW中”共享“的实现，反而影响了多线程环境下string”拷贝“的性能。</p><h2 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h2><p>COW中，需要修改时，先分配和复制，再将引用计数减1，这在多线程操作中，会导致不必要的分配和复制</p><p>两个线程同时操作两个string，这两个string共享同一片内存（即引用计数为2），当两个线程都需要对string修改时，他们都需要先分配和复制，再将引用计数减1（最终会有一个线程释放内存）</p><p>这时，COW一共进行了3次内存分配和复制（初始化时1次，修改时2次）和1次内存释放</p><p>但如果没有使用COW技术，从string的初始化到目前为止也只进行了2次内存分配和复制（都是在初始化时进行）</p><h1 id="COW的失效问题"><a href="#COW的失效问题" class="headerlink" title="COW的失效问题"></a>COW的失效问题</h1><p>这个问题其实是字符串接口导致的问题，string类提供了data、operator[]等接口，可以直接修改字符串本身，但由于他们返回的是指针和引用，只读操作也会导致分配和复制</p><p>这可能导致COW不能完全发挥作用，每次都是在深拷贝。</p><p>这当然可以通过重新设计接口，严格区分只读和修改造作来解决。但维护非标准接口，并非是一个简单的工作</p><h2 id="代理类区分读写操作"><a href="#代理类区分读写操作" class="headerlink" title="代理类区分读写操作"></a>代理类区分读写操作</h2><p>区分读写的另一种方式是，定义CharProxy类，operator[]返回CharProxy，在对CharProxy赋值时，才执行分配和复制</p><p>但这也会增加编码的复杂度</p><h1 id="fbstring"><a href="#fbstring" class="headerlink" title="fbstring"></a>fbstring</h1><p>Fackbook的开源库folly中提供了fbstring，它是std::string的替代。其对string类的设计进行了许多优化</p><ul><li>将字符串区分为small/medium/large，针对他们分别采用SSO、eager copy和COW的策略（使用capacity最高位的4个bits来判断string的种类）<ul><li>small：结构体长度为24字节，减去末尾的1字节（用来表示长度）和为结束符’\0’（data()和c_str()方法的需要）预留的1字节，可以放置22字节的有效长度</li><li>medium：不超过255字节</li><li>large：超过255字节</li></ul></li><li>word-wise copy（逐字拷贝）</li><li>直接使用malloc/free，并在使用jemalloc时，使用非标准扩展接口来提高性能</li><li>末尾’\0’的处理：平时预留空间，在调用data或c_str时，才添加’\0’，避免了每次修改字符串时的额外开销</li><li>find使用BM算法</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/1792179/" target="_blank" rel="noopener">Effective STL中文版</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html" target="_blank" rel="noopener">std::string的Copy-on-Write：不如想象中美好</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html" target="_blank" rel="noopener">漫步Facebook开源C++库folly：string类的设计</a></li><li><a href="https://www.cnblogs.com/cthon/p/9181979.html" target="_blank" rel="noopener">c++再探string之eager-copy、COW和SSO方案</a></li><li><a href="https://github.com/facebook/folly" target="_blank" rel="noopener">folly</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;string概述&quot;&gt;&lt;a href=&quot;#string概述&quot; class=&quot;headerlink&quot; title=&quot;string概述&quot;&gt;&lt;/a&gt;string概述&lt;/h1&gt;&lt;p&gt;string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="字符串" scheme="https://gwq5210.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://gwq5210.com/2021/11/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://gwq5210.com/2021/11/14/智能指针/</id>
    <published>2021-11-14T20:18:54.000Z</published>
    <updated>2022-07-22T07:33:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>了解智能指针前，我们先了解下C++编程中常用的RAII的思想</p><p>RAII全称为Resource Acquisition is Initialization，直译就是资源获取即初始化。</p><p>它的思想是将必须在使用前获取的资源（堆内存，线程，文件，互斥锁等）与一个对象的声明周期绑定，常用做法是在构造函数中请求资源，在析构函数中释放资源</p><p>以上由C++的语言机制保证，当对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数</p><p>智能指针就是使用RAII思想的例子</p><h1 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h1><p>智能指针本质是模板类独享，其行为类似指针。其最主要的功能是帮助管理动态内存，防止发生内存泄漏</p><p>C++提供了四种智能指针</p><ul><li>auto_ptr(C++11废弃，C++17移除)</li><li>unique_ptr(C++11)：独占智能指针</li><li>shared_ptr(C++11)：引用计数智能指针</li><li>weak_ptr(C++11)：弱引用智能指针，解决shared_ptr的循环引用，不能访问直接访问对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="comment">// p析构时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto_ptr是C++98提供的，现已废弃，应使用unique_ptr或shared_ptr替代</p><p>考虑如下情况，将p赋值给p2会发生什么？</p><p>按照常规指针的做法，p2和p会指向同一个对象，但是如果这样，p2和p在析构时会释放两次内存，这当然是不可行的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">  p2 = p; <span class="comment">// 会发生什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上问题，有如下解决方案</p><ul><li>执行深拷贝，但这会造成两个指针指向不同对象</li><li>建立所有权（ownership）的概念，仅可以让一个智能指针拥有该对象，该智能指针析构时执行内存释放操作。赋值操作将所有权转移。<ul><li>auto_ptr和unique_ptr都采用此策略，unique_ptr的策略更加严格</li></ul></li><li>使用引用计数，记录有多少个智能指针指向该对象，当引用计数变为0时，执行内存释放操作<ul><li>shared_ptr采用此策略</li></ul></li></ul><h1 id="auto-ptr使用"><a href="#auto-ptr使用" class="headerlink" title="auto_ptr使用"></a>auto_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>auto_ptr对象的复制构造和赋值会转移所有权</li><li>作为参数不要按值传递</li><li>auto_ptr不支持数组</li><li>无法作为STL容器的元素，auto_ptr的复制构造和赋值要求参数左值引用</li><li>仅支持new分配的内存</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">p2 = p; <span class="comment">// p的所有权被转移给p2，p不再有效</span></span><br><span class="line">*p = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递，调用时会将所有权转移给临时对象p3，函数结束时将内存释放</span></span><br><span class="line"><span class="comment">// 这里应采用按引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, *p3);</span><br><span class="line">&#125;</span><br><span class="line">test(p2);</span><br><span class="line">*p2 = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line">auto_ptr&lt;double[]&gt; pa(new double[100]()); // bad</span><br></pre></td></tr></table></figure><h2 id="auto-ptr实现"><a href="#auto-ptr实现" class="headerlink" title="auto_ptr实现"></a>auto_ptr实现</h2><ul><li>auto_ptr的复制构造函数和赋值运算符要求左值引用</li><li>需要考虑右值的构造和赋值，通过AutoPtrRef的方式实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoPtrRef</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtrRef</span><span class="params">(T* p)</span> : <span class="title">ptr</span><span class="params">(p)</span> </span>&#123;&#125;</span><br><span class="line">  T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  AutoPtr(AutoPtr&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  <span class="comment">// 为了实现右值的初始化</span></span><br><span class="line">  AutoPtr(AutoPtrRef&lt;element_type&gt; ref) : data_(ref.ptr) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr(AutoPtr&lt;Y&gt;&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  ~AutoPtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;Y&gt;&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&lt;Y&gt;&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtrRef&lt;Y&gt; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtrRef&lt;Y&gt; other)\n"</span>);</span><br><span class="line">    reset(other.ptr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">element_type* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  element_type* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtrRef&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtrRef&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtr&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtr&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type* ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data_;</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  element_type* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr使用"><a href="#unique-ptr使用" class="headerlink" title="unique_ptr使用"></a>unique_ptr使用</h1><p>相比于auto_ptr，unique_ptr有如下优点</p><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>禁用拷贝构造函数和赋值运算符</li><li>使用移动语义std::move转移所有权</li><li>使用移动语义可以作为STL容器的元素，但某些需要拷贝和赋值的算法操作会受限</li><li>支持数组，并提供operator[]，使用delete[]释放内存</li><li>支持自定义deleter</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">"student1"</span>;</span><br><span class="line">  <span class="keyword">double</span> score = <span class="number">100.0</span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Student&gt; <span class="title">p</span><span class="params">(gtl::make_unique&lt;Student&gt;(name, score))</span></span>;</span><br><span class="line">  <span class="keyword">auto</span>* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(name, p-&gt;name());</span><br><span class="line">  EXPECT_EQ(score, p-&gt;score());</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p))</span></span>;</span><br><span class="line">  EXPECT_EQ(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line">  p2 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line"></span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; p3;</span><br><span class="line">  p3 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 支持数组指针即使用new[]/delete[]</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person[]&gt; p = gtl::make_unique&lt;Person[]&gt;(n);</span><br><span class="line">  Person* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line">  p = <span class="built_in">std</span>::move(p);</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    p[i].set_name(<span class="built_in">std</span>::to_string(i));</span><br><span class="line">    EXPECT_EQ(<span class="built_in">std</span>::to_string(i), p[i].name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h1><ul><li>unique_ptr存在针对对象和数组的两个版本<ul><li>分别使用new/delete和new[]/delete[]</li></ul></li><li>需要支持自定义deleter</li><li>禁用拷贝构造函数和赋值运算符</li><li>定义移动构造函数和移动复制运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = <span class="built_in">std</span>::default_delete&lt;T&gt;&gt;</span><br><span class="line">class UniquePtr &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  explicit UniquePtr(pointer data = nullptr, deleter_type deleter = deleter_type()) : data_(data), deleter_(deleter) &#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr(UniquePtr&lt;Y&gt;&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.get_deleter())) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span>&lt;T[], Deleter&gt; &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    Destroy();</span><br><span class="line">    data_ = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr使用"><a href="#shared-ptr和weak-ptr使用" class="headerlink" title="shared_ptr和weak_ptr使用"></a>shared_ptr和weak_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>shared_ptr是共享所有权的智能指针，使用上更像普通指针</li><li>支持数组（C++17）</li><li>注意循环引用——将任一shared_ptr替换为weak_ptr打破循环即可</li><li>weak_ptr无法访问其所管理的资源，其是为了解决循环引用的问题，weak_ptr不会增加引用计数<ul><li>weak_ptr可以通过expired函数判断对应的资源是否已经释放</li><li>访问所管理的对象必须通过lock函数返回一个shared_ptr对象（注意判断返回值是否为空，可能其所对应的资源已经释放）</li></ul></li><li>线程安全问题<ul><li>多个线程在不同shared_ptr的实例上调用所有成员函数（包含复制构造和赋值）是安全的，即使他们共享同一个对象的所有权</li><li>多个线程只读方式访问同一个shared_ptr的实例是安全的</li><li>多个线程访问同一个shared_ptr的实例的非const成员函数是不安全的，会出现数据竞争</li><li>所拥有资源的线程安全由资源本身决定</li></ul></li></ul><p>循环引用的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> score_;</span><br><span class="line">  SharedPtr&lt;Teacher&gt; teacher_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">  SharedPtr&lt;Student&gt; student_;</span><br><span class="line">  WeakPtr&lt;Student&gt; student_weak_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// teacher包含student，student包含teacher，会造成循环引用</span></span><br><span class="line">  <span class="comment">// 析构时引用数都不会变为0，造成内存泄漏</span></span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">1</span>);</span><br><span class="line">  teacher-&gt;set_student(student);</span><br><span class="line">  student-&gt;set_teacher(teacher);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  gtl::WeakPtr&lt;Student&gt; student_weak_bak;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher_weak</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher_weak"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student_weak</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student_weak"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    teacher_weak-&gt;set_student_weak(student_weak);</span><br><span class="line">    student_weak-&gt;set_teacher(teacher_weak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">2</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    student_weak_bak = student_weak;</span><br><span class="line">    EXPECT_EQ(student_weak_bak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak_bak.expired(), <span class="literal">false</span>);</span><br><span class="line">    EXPECT_EQ(<span class="keyword">bool</span>(student_weak_bak.lock()), <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, student_weak.get());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"weak test\n"</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.use_count(), <span class="number">0</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.expired(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">auto</span> stucent_shared_ptr = student_weak_bak.lock();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, stucent_shared_ptr.get());</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(stucent_shared_ptr), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr实现"><a href="#shared-ptr和weak-ptr实现" class="headerlink" title="shared_ptr和weak_ptr实现"></a>shared_ptr和weak_ptr实现</h1><ul><li>shared_ptr包含指向对象的指针和引用计数的指针<ul><li>包含对象指针是为了不同的对象共享所有权</li><li>包含引用计数的指针而不是对象，是为了共享所有权的shared_ptr得到的引用计数是相同的</li></ul></li><li>引用计数包含use_count和weak_count<ul><li>由于weak_ptr需要在所有的shared_ptr都释放时也能够判断引用计数的数量是否为0，因此shared_ptr释放时，如果weak_count&gt;1，则仅可以释放所管理对象的资源，引用计数的资源不能释放</li><li>当weak_ptr析构时，需要判断是否需要释放引用计数的资源</li></ul></li><li>shared_ptr的use_count和weak_count如何变化<ul><li>以空指针构造，两个指针都为空</li><li>以非空指针构造，use_count和weak_count都设置为1</li><li>复制构造，若非空则use_count加1</li><li>移动构造use_count不变，资源转移到新构造的shared_ptr，被移动的shared_ptr变为空</li><li>赋值操作，左侧操作数use_count减1，右侧操作数use_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数use_count减1，右侧操作数use_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>shared_ptr析构，use_count减1</li><li>use_count为0时，释放所管理对象的资源，weak_count减1（为0时释放引用计数的资源）</li></ul></li><li>weak_ptr的use_count和weak_count如何变化<ul><li>默认构造，weak_ptr不管理任何对象</li><li>weak_ptr不接受普通指针构造</li><li>复制构造，若非空则weak_count加1</li><li>以shared_ptr构造，若非空则weak_count加1</li><li>移动构造，weak_count不变，被移动weak_ptr变为空</li><li>赋值操作，左侧操作数weak_count减1，右侧操作数weak_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数weak_count减1，右侧操作数weak_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>weak_ptr析构，weak_count减1</li><li>weak_count为0时，释放引用计数的资源</li><li>调用lock函数构造shared_ptr，use_count加1</li></ul></li></ul><p>具体实现可参考<a href="https://github.com/gwq5210/gtl/blob/main/gtl/memory/smart_pointers.h" target="_blank" rel="noopener">smart_pointers.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RefCount</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; use_count; <span class="comment">// 有多少个shared_ptr指向这个对象</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; weak_count; <span class="comment">// 有多少个weak_ptr指向这个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  RefCount* ref_count_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">raii</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory" target="_blank" rel="noopener">memory</a></li><li><a href="https://item.jd.com/11017238.html" target="_blank" rel="noopener">C++ Primer Plus（第6版 中文版）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RAII&quot;&gt;&lt;a href=&quot;#RAII&quot; class=&quot;headerlink&quot; title=&quot;RAII&quot;&gt;&lt;/a&gt;RAII&lt;/h1&gt;&lt;p&gt;了解智能指针前，我们先了解下C++编程中常用的RAII的思想&lt;/p&gt;
&lt;p&gt;RAII全称为Resource Acquisit
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="智能指针" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    
      <category term="智能指针" scheme="https://gwq5210.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之无序关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之无序关联容器/</id>
    <published>2021-11-14T20:17:36.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><p>无序关联容器有以下几种</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><p>无序关联容器底层由哈希表实现，下文主要对哈希表进行介绍</p><h1 id="哈希表概述"><a href="#哈希表概述" class="headerlink" title="哈希表概述"></a>哈希表概述</h1><p>哈希表的基本原理是利用数组可以随机存取的特点，通过哈希函数（hasher）将键（key_type）均匀的映射到数组的下标，这样我们可以很快的通过数组下标快速找到对应的元素</p><p>数组中的每个元素称为桶（bucket）</p><p>这样会存在两个问题：</p><ul><li>不同的键映射到了相同的数组下标</li><li>数组大小是固定的，添加了更多元素之后，如何对数组进行扩容</li></ul><h2 id="解决哈希表碰撞"><a href="#解决哈希表碰撞" class="headerlink" title="解决哈希表碰撞"></a>解决哈希表碰撞</h2><p>不同的的元素被映射到相同的数组下标，被称为碰撞。解决碰撞有许多种方法</p><ul><li>开放定址法：哈希冲突时，从冲突的位置按照一定的次序寻找一个空闲的桶。删除元素时需要进行标记，否则会导致查找错误<ul><li>线性探测：依次判断位置为i+1,i+2,i+3,到达最后一个桶时从头开始判断</li><li>二次探测：依次判断位置为i+1^2,i+2^2,i+3^2</li></ul></li><li>链地址法：哈希冲突时，冲突的元素放在链表中。可以理解为数组的每个桶都是一个链表，只是大部分的链表仅包含一个元素</li></ul><p>大部分的实现采用链地址法处理冲突</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/hashtable.png" alt="hashtable" title>                </div>                <div class="image-caption">hashtable</div>            </figure><h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>在一般的实现中，哈希桶的数量为2的次幂，这样可以通过位运算得到元素哈希桶的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type bucket_idx = hasher()(key) % bucket_count();</span><br><span class="line">size_type bucket_idx = hasher()(key) &amp; (bucket_count() - <span class="number">1</span>); <span class="comment">// 当bucket_count为2的幂时</span></span><br></pre></td></tr></table></figure><h3 id="负载因子和初始容量"><a href="#负载因子和初始容量" class="headerlink" title="负载因子和初始容量"></a>负载因子和初始容量</h3><p>首先介绍一个负载因子（load factor）的概念：即元素个数除以桶个数。</p><p>哈希表一般通过负载因子来指定扩容的临界值。例如负载因子可以设置为0.75。当元素的数量超过bucket_count*load_factor时，会触发扩容操作</p><p>哈希表另一个比较重要的概念是初始容量，即初始哈希桶的数量，插入元素较多的情况下可以指定较大的初始容量减少扩容的次数。默认初始容量可以设置为16</p><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p>哈希表的扩容也称为重新哈希（rehash），大致步骤如下</p><ul><li>以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组</li><li>遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中<ul><li>在同数量为2的次幂时，可以将桶中元素分为两部分，这两部分元素在新桶数组中的位置分别是：i和i+old_bucket_count（按照位运算很好理解）</li></ul></li><li>所有元素迁移完成之后，释放原桶数组</li></ul><p>以下例子是数组+单链表（下文介绍）的重新哈希的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_rehash</span><span class="params">(size_type new_bucket_count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 新分配桶数组</span></span><br><span class="line">  BucketStorage new_buckets = alloc_buckets(new_bucket_count);</span><br><span class="line">  SListNode old_head = head_;</span><br><span class="line">  buckets_.swap(new_buckets); <span class="comment">// 与旧桶数组交换</span></span><br><span class="line">  head_.next = <span class="literal">nullptr</span>;</span><br><span class="line">  get_size() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash new bucket count %zu %zu\n"</span>, bucket_count(), new_bucket_count);</span><br><span class="line">  SListNode* prev = &amp;old_head; <span class="comment">// 旧链表的伪头节点，便于实现</span></span><br><span class="line">  SListNode* first = prev-&gt;next;</span><br><span class="line">  <span class="comment">// 2. 遍历所有元素的链表</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    <span class="comment">// 计算链表头节点在新桶数组中的位置</span></span><br><span class="line">    <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(first));</span><br><span class="line">    size_type new_bucket_idx = bucket(key);</span><br><span class="line">    <span class="comment">// 找到相同key的元素</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, prev);</span><br><span class="line">    <span class="comment">// 将(range_res.first.before, range_res.first.node]这些元素从链表中移除</span></span><br><span class="line">    RemoveAfter(range_res.first.before, range_res.first.node);</span><br><span class="line">    <span class="comment">// 插入到新链表中并设置桶的所在元素的范围</span></span><br><span class="line">    insert_node(new_bucket_idx, buckets_[new_bucket_idx].node_before_begin ? buckets_[new_bucket_idx].node_before_begin : &amp;head_, first, range_res.first.node, range_res.second);</span><br><span class="line">    <span class="comment">// 旧链表的新头节点</span></span><br><span class="line">    first = prev-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash done. new bucket count %zu\n"</span>, bucket_count());</span><br><span class="line">  <span class="comment">// 3. 旧桶数组在作用域结束时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表的具体实现"><a href="#哈希表的具体实现" class="headerlink" title="哈希表的具体实现"></a>哈希表的具体实现</h1><p>哈希表一般有以下几种实现</p><ul><li>仅数组<ul><li>迭代元素需要遍历整个桶数组</li><li>元素迭代的顺序与插入顺序无关，与在桶中的位置有关</li><li>同一个桶内的元素以相反的顺序遍历（在头部插入）</li></ul></li><li>数组+单链表：所有的元素用单链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相反（找不到元素时在头部插入）</li><li>桶的结构中保存链表节点的指针或迭代器(before, node]</li><li>插入元素时如果更改了某个桶的尾元素node，则需要更新node-&gt;next元素所在桶的before指针</li><li>单链表包含一个伪头结点head_利于实现</li><li>swap时要更新链表头结点的before指针</li></ul></li><li>数组+双链表：所有的元素用双链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相同（找不到元素时在尾部插入）</li><li>桶的结构中保存链表节点的指针或迭代器[begin, node]</li><li>实现相较数组+单链表简单</li></ul></li></ul><p>说明</p><ul><li>以上只说明大致思路，具体的实现可能略有不同</li><li>以上针对元素key唯一的情况，key相同的情况下，相同的key元素在链表中紧邻存放(相同key的元素的迭代顺序由实现决定，可以不做保证)</li><li>哈希表是无序的，不对key进行排序</li><li>哈希表重新哈希之后元素迭代顺序会发生变化</li><li>哈希表的实现中，会提供两个函数insert_unique和insert_equal分别来实现unordered_set/unordered_map和unordered_multiset/unordered_multimap（也可通过模板特化来针对唯一key或相同key实现不同的逻辑，提升性能）</li></ul><h2 id="数组-单链表的实现介绍"><a href="#数组-单链表的实现介绍" class="headerlink" title="数组+单链表的实现介绍"></a>数组+单链表的实现介绍</h2><h3 id="数据结构结构"><a href="#数据结构结构" class="headerlink" title="数据结构结构"></a>数据结构结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span> &#123;</span></span><br><span class="line">  SListNode* next;</span><br><span class="line">  SListNode() : next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">typename</span> KeyEquel = <span class="built_in">std</span>::equal_to&lt;Key&gt;&gt;</span><br><span class="line">class HashTable &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 哈希桶的结构，链表中范围(node_before_begin, node_finish]内的节点在该桶内</span></span><br><span class="line">  struct HashNode &#123;</span><br><span class="line">    HashNode(): node_before_begin(<span class="literal">nullptr</span>), node_finish(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    HashNode(SListNode* b, SListNode* f): node_before_begin(b), node_finish(f) &#123;&#125;</span><br><span class="line">    SListNode* node_before_begin;</span><br><span class="line">    SListNode* node_finish;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ExtractKey get_key_func_;</span><br><span class="line">  key_equal key_equal_;</span><br><span class="line">  hasher hasher_;</span><br><span class="line">  SListNode head_;</span><br><span class="line">  <span class="keyword">float</span> max_load_factor_;</span><br><span class="line">  BucketStorage buckets_;</span><br><span class="line">  CompressedPair&lt;size_type, NodeAllocator&gt; size_alloc_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* first, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将新的[first, last]内的元素插入到before节点后</span></span><br><span class="line">  InsertAfter(before, first, last);</span><br><span class="line">  <span class="comment">// 更新该桶内的元素范围</span></span><br><span class="line">  buckets_[bucket_idx].insert_node(before, first, last);</span><br><span class="line">  incr_size(count);</span><br><span class="line">  <span class="comment">// 更新下一个bucket的前一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; insert_node(bool unique, const_iterator hint, Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="comment">// 原位构造元素</span></span><br><span class="line">  Node* node = NewNode(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  SListNode* prev = hint.node;</span><br><span class="line">  <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(node));</span><br><span class="line">  size_type bucket_idx = bucket(key);</span><br><span class="line">  <span class="comment">// 元素唯一的情况下，已找到元素直接结束插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev &amp;&amp; (key_equal_(get_key(Node::Value(prev)), key) || (prev-&gt;next &amp;&amp; key_equal_(get_key(Node::Value(prev-&gt;next)), key)))) &#123;</span><br><span class="line">    <span class="comment">// hint或hint-&gt;next对应元素的key与新元素的key相同，使用hint作为插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到对应元素的插入位置</span></span><br><span class="line">    FindNodeResult result = find_node(key, bucket_idx);</span><br><span class="line">    <span class="keyword">if</span> (unique &amp;&amp; result.node) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = result.before;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  insert_node(bucket_idx, prev, node);</span><br><span class="line">  <span class="comment">// 可以先添加，然后再rehash</span></span><br><span class="line">  check_for_rehash(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(node), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><h4 id="查找单节点"><a href="#查找单节点" class="headerlink" title="查找单节点"></a>查找单节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定位到哈希桶</span></span><br><span class="line">  <span class="keyword">return</span> find_node(key, bucket(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key, size_type bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">  <span class="comment">// 该桶为空直接返回未找到</span></span><br><span class="line">  <span class="keyword">if</span> (hnode.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">const_cast</span>&lt;SListNode*&gt;(&amp;head_), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依次查找该桶的元素，找到相同的key则返回</span></span><br><span class="line">  <span class="keyword">for</span> (SListNode* prev = hnode.node_before_begin; prev-&gt;next != hnode.node_finish-&gt;next; prev = prev-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key_equal_(key, get_key(Node::Value(prev-&gt;next)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;prev, prev-&gt;next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 到这里说明没找到</span></span><br><span class="line">  <span class="keyword">return</span> &#123;hnode.node_before_begin, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找范围"><a href="#查找范围" class="headerlink" title="查找范围"></a>查找范围</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;iterator, iterator&gt; equal_range(bool unique, const key_type&amp; key) &#123;</span><br><span class="line">  <span class="comment">// 先查找单个元素，未找到则直接返回</span></span><br><span class="line">  <span class="keyword">auto</span> res = find_node(key);</span><br><span class="line">  <span class="keyword">if</span> (!res.node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), iterator());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果键唯一，则找到后直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(res.node-&gt;next));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 键不唯一，从before开始查找相同key的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, res.before);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(range_res.first.node-&gt;next));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::pair&lt;FindNodeResult, size_type&gt; find_range(const key_type&amp; key, const SListNode* before) const &#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;FindNodeResult, size_type&gt; res = <span class="built_in">std</span>::make_pair(FindNodeResult(), <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 从before-&gt;next开始，直到key不相同</span></span><br><span class="line">  res.first.before = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">while</span> (before-&gt;next &amp;&amp; key_equal_(key, get_key(Node::Value(before-&gt;next)))) &#123;</span><br><span class="line">    before = before-&gt;next;</span><br><span class="line">    ++res.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时before为key的最后一个元素</span></span><br><span class="line">  res.first.node = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除单个元素的操作相对简单，这里是删除范围的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 范围为空，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到first的前一个节点before</span></span><br><span class="line">  <span class="keyword">const</span> value_type&amp; value = Node::Value(first.node);</span><br><span class="line">  size_type bucket_idx = bucket(get_key(value));</span><br><span class="line">  SListNode* before = PrevNode(buckets_[bucket_idx].node_before_begin, first.node);</span><br><span class="line">  SListNode* prev = before;</span><br><span class="line">  <span class="comment">// printf("erase range before key: %d\n", get_key(Node::Value(before)));</span></span><br><span class="line">  <span class="comment">// 遍历[first, last)的节点并删除</span></span><br><span class="line">  <span class="keyword">while</span> (prev-&gt;next != last.node) &#123;</span><br><span class="line">    HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">    SListNode* node_end = hnode.node_finish-&gt;next;</span><br><span class="line">    <span class="comment">// printf("erase begin\n");</span></span><br><span class="line">    size_type count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断该桶内元素删除的范围</span></span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != node_end &amp;&amp; prev-&gt;next != last.node) &#123;</span><br><span class="line">      <span class="comment">// printf("erase range key: %d\n", Node::Value(prev-&gt;next));</span></span><br><span class="line">      prev = prev-&gt;next;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行元素的删除</span></span><br><span class="line">    erase_node(bucket_idx, before, prev, count);</span><br><span class="line">    prev = before;</span><br><span class="line">    <span class="comment">// printf("bucket %zu size %zu\n", bucket_idx, hnode.size());</span></span><br><span class="line">    <span class="comment">// 已经删除完毕，break</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == last.node) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个删除元素的桶位置</span></span><br><span class="line">    bucket_idx = bucket(get_key(Node::Value(prev-&gt;next)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是最后一个元素，则下一个bucket的前一个节点需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = before;</span><br><span class="line">  &#125;</span><br><span class="line">  SListNode* first = before-&gt;next;</span><br><span class="line">  SListNode* next = first-&gt;next;</span><br><span class="line">  <span class="comment">// 更新该桶节点的范围</span></span><br><span class="line">  buckets_[bucket_idx].erase_node(before, last);</span><br><span class="line">  <span class="comment">// 将元素从链表中删除</span></span><br><span class="line">  RemoveAfter(before, last);</span><br><span class="line">  <span class="comment">// 更新size</span></span><br><span class="line">  incr_size(-count);</span><br><span class="line">  <span class="comment">// 析构节点并释放内存</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    next = first-&gt;next;</span><br><span class="line">    DeleteNode(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作</h3><p>上文已介绍</p><h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>可直接使用单链表的迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = SListIteratorBase;</span><br><span class="line">  SListNode* node;</span><br><span class="line">  SListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  SListIteratorBase(SListNode* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    SListNode* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Difference = <span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">struct SListConstIterator : <span class="keyword">public</span> SListIteratorBase &#123;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">const</span> T&amp;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">const</span> T*;</span><br><span class="line">  <span class="keyword">using</span> difference_type = Difference;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> Node = singly_list::SListNodeT&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> Base = SListIteratorBase;</span><br><span class="line">  <span class="keyword">using</span> Self = SListConstIterator;</span><br><span class="line">  SListConstIterator(): Base() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SListConstIterator</span><span class="params">(<span class="keyword">const</span> SListNode* node)</span> : <span class="title">Base</span><span class="params">(<span class="keyword">const_cast</span>&lt;SListNode*&gt;(node))</span> </span>&#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Node::Value(node); &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><ul><li>无重新哈希：无序关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</li><li>插入元素导致重新哈希：迭代器（包括end迭代器）非法化，引用有效</li></ul><h1 id="无序关联式容器的注意事项"><a href="#无序关联式容器的注意事项" class="headerlink" title="无序关联式容器的注意事项"></a>无序关联式容器的注意事项</h1><ul><li>unordered_map的operator[]可能会新增元素</li><li>无序关联式容器的元素没有顺序</li><li>删除元素时注意迭代器失效的问题；代码<code>unordered_map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改unordered_map/unordered_multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" target="_blank" rel="noopener">HashMap&amp;HashSet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h1&gt;&lt;p&gt;无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="无序关联容器" scheme="https://gwq5210.com/tags/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之关联容器/</id>
    <published>2021-11-14T20:16:41.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><p>关联容器有以下几种</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h1><p>关联容器的内部由红黑树实现，红黑树是一颗平衡的二叉搜索树（BST，Binary Search Tree）</p><p>在二叉搜索树中，任何节点的值一定大于左子树每一个节点的键值，小于右子树中每一个节点的键值</p><p>但是在极端的情况下，二叉搜索树可能失去平衡，退化为一个链表，造成查找效率低下。因此出现了平衡二叉搜索树，如AVL-tree，红黑树等</p><p>STL的红黑树实现中，会提供两个函数insert_unique和insert_equal分别来实现set/map和multiset/multimap</p><p>由于实现的特性，关联式容器是根据键值有序的，默认从小到大排序（使用std::less<t>进行比较）</t></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/rbtree.png" alt="rbtree" title>                </div>                <div class="image-caption">rbtree</div>            </figure><h2 id="为什么选择红黑树"><a href="#为什么选择红黑树" class="headerlink" title="为什么选择红黑树"></a>为什么选择红黑树</h2><p>AVL树要求每个节点的左右子树高度差不超过1，因此其最坏的查找时间为O(logn)</p><p>但为了严格满足AVL树的高度要求，在每次插入或删除节点时，几乎都会破坏AVL树的平衡，进而我们需要通过旋转来使之平衡</p><p>显然这对插入，删除频繁的场景很不友好，性能大大降低</p><p>而红黑树的高度要求不像AVL树那样严格，频繁插入删除不会频繁破坏平衡，也就不需要频繁调整，这其实是一种折中的方案</p><p>但仅从查找效率来说，AVL树要由于红黑树</p><p>总的来说：平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况</p><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><p>关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</p><h1 id="关联式容器的注意事项"><a href="#关联式容器的注意事项" class="headerlink" title="关联式容器的注意事项"></a>关联式容器的注意事项</h1><ul><li>map的operator[]可能会新增元素</li><li>关联式容器实现了lower_bound，upper_bound和equal_range的成员函数<ul><li>使用通用的lower_bound，upper_bound和equal_range函数会导致查找效率变低（用在非随机存取迭代器上都会导致效率变低）</li></ul></li><li>删除元素时注意迭代器失效的问题；代码<code>map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改map/multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">平衡树和红黑树</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联容器&quot;&gt;&lt;a href=&quot;#关联容器&quot; class=&quot;headerlink&quot; title=&quot;关联容器&quot;&gt;&lt;/a&gt;关联容器&lt;/h1&gt;&lt;p&gt;关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。&lt;/p&gt;
&lt;p&gt;关联容器有以下几种&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="关联容器" scheme="https://gwq5210.com/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之priority_queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bpriority-queue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之priority-queue/</id>
    <published>2021-10-26T00:15:50.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元素</p><p>可以通过模板参数Compare更改顺序，默认使用std::less<t>进行比较，返回最大元素</t></p><p>priority_queue的底层用堆实现</p><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>堆并不属于容器组件，是一个数据结构，堆实际上是一个完全二叉树（整个二叉树除了最底层的叶节点外，是填满的），并且每个节点的键值都大于等于/小于等于其父节点的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/heap.png" alt="heap" title>                </div>                <div class="image-caption">heap</div>            </figure><p>由于二叉树的性质，我们可以使用数组来表示一个二叉堆(假设下标从0开始)</p><ul><li>下标为i的节点的子节点为<code>2*i+1</code>和<code>2*i+2</code></li><li>下标为i的节点的父节点为<code>(i-1)/2</code></li></ul><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>在已有的堆中插入元素，一般在堆最下层最右边的叶子之后插入一个元素（或者新增一层）</p><p>插入新元素之后，可能不满足堆的性质，这时候需要进行向上调整（sift_up）的操作</p><ul><li>如果这个节点的值大于父节点的值，则与父节点进行交换，重复次过程直到满足堆的条件或者到达根</li></ul><p>向上调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span> &amp;&amp; arr[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[i]; i = (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作是删除堆的最大元素，一般将最大元素即根节点与最后一个节点交换，再将新的根节点进行向下调整（sift_down）的操作</p><ul><li>在该节点的儿子中选择较大节点与该节点进行交换，重复此操作直到底层或已满足堆的条件</li></ul><p>向下调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; n / <span class="number">2</span>; i = <span class="number">2</span> * x + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= arr[j]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h2><h3 id="向上调整建堆"><a href="#向上调整建堆" class="headerlink" title="向上调整建堆"></a>向上调整建堆</h3><p>即相当于每次在堆的结尾添加一个元素，比较好理解</p><p>复杂度为log1+log2+…+logn=O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    sift_up(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下调整建堆"><a href="#向下调整建堆" class="headerlink" title="向下调整建堆"></a>向下调整建堆</h3><p>从叶子开始建堆，逐个向下调整，相当于每次”合并”两个已经调整好的堆</p><p>复杂度为O(n)，每个节点最多向下调整一次，只需要从最后一个非叶子结点进行调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    sift_down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆操作算法"><a href="#堆操作算法" class="headerlink" title="堆操作算法"></a>堆操作算法</h1><p>STL提供了以下几个算法，可以方便的实现优先队列</p><h2 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h2><p>将位置<code>last-1</code>的元素插入到<code>[first, last - 1)</code>定义的堆中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    gtl::sift_up(first, last, gtl::distance(first, last) - <span class="number">1</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::push_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h2><p>交换在位置<code>first</code>的值和位置<code>last-1</code>的值，并将范围<code>[first, last-1)</code>调整为堆</p><p>这达到将范围<code>[first, last)</code>所定义的堆移除首个元素的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    --last;</span><br><span class="line">    gtl::iter_swap(first, last);</span><br><span class="line">    gtl::sift_down(first, last, <span class="number">0</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::pop_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>将最大堆<code>[first, last)</code>转换为为以升序排序的序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; --last) &#123;</span><br><span class="line">    gtl::pop_heap(first, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::sort_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>在范围<code>[first, last)</code>中构造最大堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = gtl::distance(first, last) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      gtl::sift_down(first, last, i, comp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::make_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap-until"><a href="#is-heap-until" class="headerlink" title="is_heap_until"></a>is_heap_until</h2><p>检验范围<code>[first, last)</code>并寻找始于<code>first</code>且为最大堆的最大范围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> n = gtl::distance(first, last);</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::difference_type i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> it = first;</span><br><span class="line">  <span class="keyword">auto</span> left_it = first + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n / <span class="number">2</span>; ++i, ++it, ++left_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">    ++left_it;</span><br><span class="line">    <span class="keyword">if</span> (left_it &lt; last &amp;&amp; comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap"><a href="#is-heap" class="headerlink" title="is_heap"></a>is_heap</h2><p>检查范围 [first, last) 中的元素是否为最大堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, comp) == last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h1><p>有了堆的操作算法，很容易通过这些算法实现优先队列</p><p>具体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = <span class="built_in">std</span>::less&lt;T&gt;, <span class="keyword">typename</span> Container = Vector&lt;T&gt;&gt;</span><br><span class="line">class PriorityQueue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                        <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  PriorityQueue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  PriorityQueue(InputIt first, InputIt last) : c_(first, last) &#123;</span><br><span class="line">    gtl::make_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(v);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(<span class="built_in">std</span>::move(v));</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gtl::pop_heap(c_.begin(), c_.end());</span><br><span class="line">    c_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(PriorityQueue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">  Compare compare_;</span><br><span class="line">&#125;;  <span class="comment">// class PriorityQueue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">算法库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://oi-wiki.org/ds/binary-heap/" target="_blank" rel="noopener">二叉堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先队列&quot;&gt;&lt;a href=&quot;#优先队列&quot; class=&quot;headerlink&quot; title=&quot;优先队列&quot;&gt;&lt;/a&gt;优先队列&lt;/h1&gt;&lt;p&gt;与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="优先队列" scheme="https://gwq5210.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bqueue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之queue/</id>
    <published>2021-10-26T00:15:39.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h1><p>queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许在一个入口(队尾)添加元素，在另一个入口(队头)获取和删除元素</p><p>queue不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/queue.png" alt="queue" title>                </div>                <div class="image-caption">queue</div>            </figure><p>通常使用deque来作为queue的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此queue往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改queue的底层容器</p><h1 id="queue实现"><a href="#queue实现" class="headerlink" title="queue实现"></a>queue实现</h1><p>queue的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Queue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Queue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Queue(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line">  ~Queue() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_front(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Queue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Queue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;queue概述&quot;&gt;&lt;a href=&quot;#queue概述&quot; class=&quot;headerlink&quot; title=&quot;queue概述&quot;&gt;&lt;/a&gt;queue概述&lt;/h1&gt;&lt;p&gt;queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="队列" scheme="https://gwq5210.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之stack</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bstack/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之stack/</id>
    <published>2021-10-26T00:15:34.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stack概述"><a href="#stack概述" class="headerlink" title="stack概述"></a>stack概述</h1><p>stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出口。</p><p>stack不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/stack.png" alt="stack" title>                </div>                <div class="image-caption">stack</div>            </figure><p>stack是一种很简单的数据接口，只允许在栈顶新增，删除，获取元素</p><p>通常使用deque来作为stack的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此stack往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改stack的底层容器</p><h1 id="stack实现"><a href="#stack实现" class="headerlink" title="stack实现"></a>stack实现</h1><p>stack的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Stack() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Stack(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  reference top() &#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_back(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Stack&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Stack</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stack概述&quot;&gt;&lt;a href=&quot;#stack概述&quot; class=&quot;headerlink&quot; title=&quot;stack概述&quot;&gt;&lt;/a&gt;stack概述&lt;/h1&gt;&lt;p&gt;stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="栈" scheme="https://gwq5210.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之deque</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之deque/</id>
    <published>2021-10-26T00:15:29.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快速插入或删除数据。与vector的连续空间存储不同，deque的元素可能不是相邻存储的</p><p>vecotr也允许在头尾两端添加或删除数据，但可能会涉及到元素的移动和扩容，导致效率不高</p><p>deque的迭代器也提供随机存储功能，但与vector的迭代器是普通指针不同，为了实现随机存取，deque的迭代器实现比较复杂</p><p>deque的存储按需自动扩展及收缩。deque的扩容相比vector更优，它既不会涉及到元素的移动，也不会过多的浪费存储空间</p><h2 id="deque常见操作的复杂度"><a href="#deque常见操作的复杂度" class="headerlink" title="deque常见操作的复杂度"></a>deque常见操作的复杂度</h2><ul><li>随机访问——常数 O(1)</li><li>在结尾或起始插入或移除元素——常数 O(1)</li><li>插入或移除元素——线性 O(n)</li></ul><h1 id="deque的实现"><a href="#deque的实现" class="headerlink" title="deque的实现"></a>deque的实现</h1><p>deque由一段一段固定大小的连续空间组成，扩容时，便在deque的首或尾新增一个固定大小的连续空间，这就需要额外的结构来串联起这一段段的固定大小空间</p><p>同时为了实现随机存取的接口，则实现了复杂的迭代器架构</p><p>deque采用的是两层架构，采用map（与STL的map不同），记录有多少个固定的连续空间，其中的每个元素称为节点缓冲区，存储实际的元素。</p><p>有的实现我们可以指定固定缓冲区的大小</p><p>这就意味着为了访问真实的元素，必须先定为到节点缓冲区，然后再定位到元素本身，需要进行两次指针访问，而vector只需要一次指针访问</p><p>map中的节点缓冲区满时，需要重新分配map本身的区域，移动原有的节点缓冲区到新的map区域，但这代价很小，仅仅是移动指针而已</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/deque.png" alt="deque" title>                </div>                <div class="image-caption">deque</div>            </figure><p>deque的数据结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  map_pointer <span class="built_in">map</span>; <span class="comment">// 记录节点缓冲区</span></span><br><span class="line">  size_type map_size; <span class="comment">// map可以容纳多少个缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>通过deque的结构可以知道，deque的迭代器至少需要保存两个信息：当前元素在哪个节点缓冲区；当前元素在这个缓冲区的哪个位置</p><p>如可能的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      ++cur;</span><br><span class="line">      <span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 到达该节点缓冲区的尾部就切换到下一个缓冲区</span></span><br><span class="line">        set_node(node + <span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* cur; <span class="comment">// 当前元素</span></span><br><span class="line">  T* first; <span class="comment">// 当前节点缓冲区的第一个元素</span></span><br><span class="line">  T* last; <span class="comment">// 当前节点缓冲区的尾，包含备用空间</span></span><br><span class="line">  map_pointer node; <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代器的失效"><a href="#迭代器的失效" class="headerlink" title="迭代器的失效"></a>迭代器的失效</h2><ul><li>在队列中间的插入操作导致所有迭代器和引用失效——可能涉及到元素移动或map中控器扩容</li><li>在队列头尾插入操作会导致迭代器失效——可能涉及map中控器扩容，但不会非法化引用</li><li>在队列中间擦除操作导致所有迭代器和引用失效——涉及元素移动</li><li>在队列头尾擦除操作导致擦除元素的迭代器失效（在尾部删除还会导致end迭代器失效），但不会非法化未擦除元素的引用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/deque" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deque概述&quot;&gt;&lt;a href=&quot;#deque概述&quot; class=&quot;headerlink&quot; title=&quot;deque概述&quot;&gt;&lt;/a&gt;deque概述&lt;/h1&gt;&lt;p&gt;deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="双端队列" scheme="https://gwq5210.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之list</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Blist/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之list/</id>
    <published>2021-10-26T00:15:25.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h1><p>不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针进行关联</p><p>同时list也不会浪费空间(实际上会多占用前后指针的空间)，有多少个元素就占用多少空间</p><p>list的元素插入是常数级别，但无法想vector一样实现随机元素访问</p><p>在list内添加，删除或移动元素不会导致已有迭代器失效或引用非法，对应元素被删除时该迭代器失效或引用非法</p><h1 id="list的实现"><a href="#list的实现" class="headerlink" title="list的实现"></a>list的实现</h1><h2 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h2><p>list本身和list的节点是不同的结构，常见的list节点如下，包含前后指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要实现一个通用的链表需要使用模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  ListNode* prev;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h2><p>在STL的list实现中，list不仅是一个双向链表，还是一个环形双向链表</p><p>实现list的一个技巧是添加一个虚拟的空白节点，让list的end迭代器指向该空白节点，既符合STL迭代器前闭后开的要求，也方便了编程的实现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/list.png" alt="list" title>                </div>                <div class="image-caption">list</div>            </figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  List() &#123;</span><br><span class="line">    dummy_head_ = node_allocator::allocate(); <span class="comment">// 分配一个空间，不设置值</span></span><br><span class="line">    dummy_head_-&gt;prev = dummy_head_; <span class="comment">// 头尾都指向自己</span></span><br><span class="line">    dummy_head_-&gt;next = dummy_head_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_-&gt;next; &#125; <span class="comment">// begin是next节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_; &#125; <span class="comment">// end是虚拟节点自身</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ListNode&lt;T&gt;* dummy_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>由于list的特殊实现方式，因此我们需要实现一个list的迭代器，允许用户遍历list中保存的元素</p><p>迭代器的表现类似指针，list的迭代器是双向迭代器，支持++和–操作，同时要实现*和-&gt;运算符</p><p>典型的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::bidirectional_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = ListIteratorBase;</span><br><span class="line">  ListNode&lt;T&gt;* node;</span><br><span class="line">  ListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  ListIteratorBase(ListNode&lt;T&gt;* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ++it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// --it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> node-&gt;data; &#125;</span><br><span class="line">  <span class="comment">// *(*this) *this即为迭代器本身，则第一个*为调用迭代器的operator*，返回数据的引用</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/list" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list概述&quot;&gt;&lt;a href=&quot;#list概述&quot; class=&quot;headerlink&quot; title=&quot;list概述&quot;&gt;&lt;/a&gt;list概述&lt;/h1&gt;&lt;p&gt;不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="链表" scheme="https://gwq5210.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之空间配置器</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之空间配置器/</id>
    <published>2021-10-26T00:12:46.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了</p><p>allocator为什么叫做空间配置器，不叫内存配置器？因为allocator的实现不仅可以从内存分配空间，也可以从磁盘分配空间</p><p>在STL容器的实现中，每个容器都有一个模板参数，可以指定使用的空间配置器</p><p>allocator包含以下类型</p><ul><li>value_type：T</li><li>pointer (C++17 中弃用)(C++20 中移除)：T*</li><li>const_pointer (C++17 中弃用)(C++20 中移除)：const T*</li><li>reference (C++17 中弃用)(C++20 中移除)：T&amp;</li><li>const_reference (C++17 中弃用)(C++20 中移除)：const T&amp;</li><li>size_type：std::size_t</li><li>difference_type：std::ptrdiff_t</li></ul><p>allocator主要包含以下成员函数</p><ul><li>allocate：分配未初始化的存储</li><li>deallocate：解分配存储</li><li>construct(C++17 中弃用)(C++20 中移除)：在分配的存储构造对象</li><li>destroy (C++17 中弃用)(C++20 中移除)：析构在已分配存储中的对象</li></ul><p>在C++的头文件<code>&lt;memory&gt;</code>中定义了一些与未初始化内存相关的函数，在STL容器的实现中，起到了很大的作用，如construct_at(C++20)，uninitialized_copy，uninitialized_fill等</p><h1 id="空间配置器在STL容器中的应用"><a href="#空间配置器在STL容器中的应用" class="headerlink" title="空间配置器在STL容器中的应用"></a>空间配置器在STL容器中的应用</h1><p>STL容器的实现思想中，实际上将空间的分配/释放和对象的构造/析构进行了拆分：空间配置器负责空间的分配/释放；<code>&lt;memory&gt;</code>中的未初始化内存相关的函数负责对象构造/析构，移动等</p><p>能够实现上述拆分，主要由于C++的以下特性</p><ul><li>operator new只进行内存分配，不进行对象构造</li><li>placement new是operator new的一个特殊版本，在已分配的内存上构造对象</li><li>new关键字的作用是：调用operator new，并调用对象的构造函数</li></ul><p>以下两种代码实际上是等价的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name): name_(name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  ~Test() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destroy %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码1</span></span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">new</span> Test(<span class="string">"new_test"</span>);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码2</span></span><br><span class="line">    <span class="keyword">void</span>* p = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">reinterpret_cast</span>&lt;Test*&gt;(p);</span><br><span class="line">    t-&gt;Test::Test(<span class="string">"allocator_test"</span>);</span><br><span class="line">    <span class="comment">// auto* t = new (p) Test("allocator_test"); // placement new</span></span><br><span class="line">    t-&gt;~Test();</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">construct new_test</span></span><br><span class="line"><span class="comment">destroy new_test</span></span><br><span class="line"><span class="comment">construct allocator_test</span></span><br><span class="line"><span class="comment">destroy allocator_test</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="未初始化内存算法的实现"><a href="#未初始化内存算法的实现" class="headerlink" title="未初始化内存算法的实现"></a>未初始化内存算法的实现</h1><p>有了上述基础，可以实现简单的未初始化内存的算法，更多实现参见<a href="https://github.com/gwq5210/gtl/blob/main/gtl/algorithm/gtl_memory.h" target="_blank" rel="noopener">gtl_memory.h</a></p><p>construct_at用到了std::forward的完美转发（C++11），两次强制转换是为了除去cv限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在给定地址 p 创建以参数 args... 初始化的 T 对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T* <span class="title">construct_at</span><span class="params">(T* p, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  ::<span class="keyword">new</span> (<span class="keyword">const_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>*&gt;(p))) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁指针p指向的对象</span></span><br><span class="line"><span class="comment"> * 若 T 不是数组类型，则调用 p 所指向对象的析构函数，如同用 p-&gt;~T()</span></span><br><span class="line"><span class="comment"> * 若 T 是数组类型，则按顺序递归地销毁 *p 的元素，如同通过调用 std::destroy(std::begin(*p), std::end(*p))</span></span><br><span class="line"><span class="comment"> * C++17 version:</span></span><br><span class="line"><span class="comment"> * template&lt;class T&gt; void destroy_at(T* p) &#123; p-&gt;~T(); &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 指向要被销毁的对象的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_at</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_array_v&lt;T&gt;)</span> </span>&#123;  <span class="comment">// C++ 20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : *p) &#123;</span><br><span class="line">      gtl::destroy_at(gtl::addressof(v));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;~T();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first, ++d_first) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range_n</span><span class="params">(InputIt first, SizeType count, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; ++first, ++d_first, --count) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制来自范围 [first, last) 的元素到始于 d_first 的未初始化内存</span></span><br><span class="line"><span class="comment"> * 若初始化中抛异常，则以未指定顺序销毁已构造的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return ForwardIt 指向最后复制的元素后一元素的迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 处理异常的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> input_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> forward_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">return</span> gtl::uninitialized_copy_range(first, last, d_first, input_iterator_category(), forward_iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">std::allocator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;空间配置器&quot;&gt;&lt;a href=&quot;#空间配置器&quot; class=&quot;headerlink&quot; title=&quot;空间配置器&quot;&gt;&lt;/a&gt;空间配置器&lt;/h1&gt;&lt;p&gt;从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了
      
    
    </summary>
    
      <category term="STL" scheme="https://gwq5210.com/categories/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/categories/STL/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://gwq5210.com/2021/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/26/设计模式之适配器模式/</id>
    <published>2021-10-26T00:08:42.000Z</published>
    <updated>2022-07-22T07:33:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器</p><p>适配器模式的定义为：将一个类的接口转换为另一个类的接口，使原本因接口不兼容而不能工作的类可以一起工作</p><p>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>在很多业务场景中符合开闭原则。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h1 id="适配器的实现"><a href="#适配器的实现" class="headerlink" title="适配器的实现"></a>适配器的实现</h1><p>适配器模式（Adapter）包含以下主要角色。</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h2 id="类适配器实现"><a href="#类适配器实现" class="headerlink" title="类适配器实现"></a>类适配器实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口。</p><p>Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/class_adapter.gif" alt="class_adapter" title>                </div>                <div class="image-caption">class_adapter</div>            </figure><h2 id="对象适配器实现"><a href="#对象适配器实现" class="headerlink" title="对象适配器实现"></a>对象适配器实现</h2><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/object_adapter.gif" alt="object_adapter" title>                </div>                <div class="image-caption">object_adapter</div>            </figure><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>在STL中有三种容器适配器，这里不过多介绍</p><ul><li><a href="/2021/10/26/STL容器之queue/">stack</a></li><li><a href="/2021/10/26/STL容器之stack/">queue</a></li><li><a href="/2021/10/26/STL容器之priority-queue/">priority_queue</a></li></ul><h1 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h1><ul><li>reverse_iterator: 逆序遍历的迭代器适配器(类模板)</li><li>make_reverse_iterator(C++14): 创建拥有从实参推出的类型的 std::reverse_iterator(函数模板)</li><li>move_iterator(C++11): 解引用结果为右值引用的迭代器适配器(类模板)</li><li>make_move_iterator(C++11): 创建拥有从实参推出的类型的 std::move_iterator(函数模板)</li><li>back_insert_iterator: 用于在容器尾部插入的迭代器适配器(类模板)</li><li>back_inserter: 创建拥有从实参推出的类型的 std::back_insert_iterator(函数模板)</li><li>front_insert_iterator: 用于在容器头部插入的迭代器适配器(类模板)</li><li>front_inserter: 创建拥有从实参推出的类型的 std::front_insert_iterator(函数模板)</li><li>insert_iterator: 用于插入容器的迭代器适配器(类模板)</li><li>inserter: 创建拥有从实参推出的类型的 std::insert_iterator(函数模板)</li></ul><p>如ReverseIterator的实现，将++操作换成迭代器的–操作，实现逆向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator_type = Iterator;</span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::reference;</span><br><span class="line"></span><br><span class="line">  ReverseIterator() : it_() &#123;&#125;</span><br><span class="line">  ReverseIterator(iterator_type it) : it_(it) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) : it_(other.it_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) &#123;</span><br><span class="line">    it_ = other.it_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> it_; &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">return</span> *gtl::prev(it_);</span><br><span class="line">  &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> gtl::addressof(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) &#123; <span class="keyword">return</span> *gtl::prev(n + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    it_ -= n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">    it_ += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ - n); &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ + n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  iterator_type it_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h1><p>早期的C++提供了一些函数适配器，如bind1st和bind2nd（C++11后可用bind替代）</p><p>早期提供功能支持的几个工具在C++11中弃用，并于 C++17 中移除（旧否定器于 C++17 中弃用并于 C++20 中移除），这里不再过多介绍</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1361.html" target="_blank" rel="noopener">适配器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">迭代器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/utility/functional" target="_blank" rel="noopener">函数对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器&lt;/p&gt;
&lt;p&gt;适配器模式的定义为：将一
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之迭代器模式/</id>
    <published>2021-10-22T12:12:43.000Z</published>
    <updated>2022-07-22T07:33:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素<br>通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p><p>既然将遍历方法封装在容器类中不可取，那么容器类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ul><li>暴露了容器类的内部表示，使其数据不安全</li><li>增加了客户的负担</li></ul><p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与容器类之间插入一个迭代器，这分离了容器对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</p><p>迭代器模式定义：提供一种方法，使之能够依次访问某个容器所含的各个元素，而又无需暴露该容器的内部实现。</p><p>迭代器模式是一种对象行为型模式，其主要优点如下</p><ul><li>访问一个容器对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了容器类。</li><li>它支持以不同方式遍历一个容器，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的容器类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的容器结构提供一个统一的接口。</li></ul><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><p>在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。</p><p>一般来说，迭代器需要了解容器类的内部实现，才能正确的遍历容器中的元素</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>迭代器模式主要包含以下角色。</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/iterator.gif" alt="迭代器模式结构" title>                </div>                <div class="image-caption">迭代器模式结构</div>            </figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>迭代器模式通常在以下几种情况使用。</p><ul><li>当需要为容器对象提供多种遍历方式时。</li><li>当需要为遍历不同的容器结构提供一个统一的接口时。</li><li>当访问一个容器对象的内容而无须暴露其内部细节的表示时。</li></ul><p>由于容器与迭代器的关系非常密切，所以大多数语言在实现容器类时都提供了迭代器类，因此大数情况下使用语言中已有的容器类的迭代器就已经够了。</p><h1 id="STL中的迭代器"><a href="#STL中的迭代器" class="headerlink" title="STL中的迭代器"></a>STL中的迭代器</h1><p>在STL中的vector、list、set、map等容器都包含了迭代器，迭代器的行为与指针类似，迭代器可以是原生指针，也可以是重载operator*和operator-&gt;的对象。</p><p>与容器相似，该容器对应的迭代器可以获取特定类型的值，我们需要通过特性萃取技术（traits）来获取迭代器对应的类型。c++提供了iterator_traits来实现该功能。</p><p>一般来说，迭代器需要提供以下几种类型，针对原生指针，可以通过对iterator_traits进行模板特化来获取对应的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value_type</span><br><span class="line">difference_type</span><br><span class="line">pointer</span><br><span class="line">reference</span><br><span class="line">iterator_category</span><br></pre></td></tr></table></figure><h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输入迭代器，只读，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输出迭代器，可写，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;; <span class="comment">// 前向迭代器，只能向前移动，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;; <span class="comment">// 可双向移动，可++，--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;; <span class="comment">// 可随机访问，与原生指针类似</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">contiguous_iterator_tag</span>:</span> <span class="keyword">public</span> random_access_iterator_tag &#123; &#125;; <span class="comment">//  (C++20) 要求逻辑相邻元素在内存中物理上也相邻</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1395.html" target="_blank" rel="noopener">迭代器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h1&gt;&lt;p&gt;实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素&lt;br&gt;通常的做法是将链表的创建和遍历都放在同
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之状态模式/</id>
    <published>2021-10-22T12:04:33.000Z</published>
    <updated>2022-07-22T07:33:50.193Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式概述"><a href="#状态模式概述" class="headerlink" title="状态模式概述"></a>状态模式概述</h1><p>在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理</p><p>但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展</p><p>以上问题如果采用“状态模式”就能很好地得到解决。</p><p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><h1 id="状态模式定义与特点"><a href="#状态模式定义与特点" class="headerlink" title="状态模式定义与特点"></a>状态模式定义与特点</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li><li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h1 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h1><p>状态模式涉及的角色如下</p><ul><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https/gwq5210.com/images/state.gif" alt="状态模式结构图" title>                </div>                <div class="image-caption">状态模式结构图</div>            </figure><h1 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h1><p>本例子实现了一个投票的简单例子</p><ul><li>同一个用户可以投一次票，初始状态为正常状态(NormalVoteState)</li><li>成功投票之后，状态转换为重复投票状态(RepeatVoteState)，不能再进行投票</li></ul><p>例子十分简单，具体工程上，可以实现很复杂的状态转换</p><p>核心代码如下，具体可参见代码<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.cc" target="_blank" rel="noopener">state.cc</a>和<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.h" target="_blank" rel="noopener">state.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NormalVoteState::vote</span><span class="params">(VoteManager* manager, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; username)</span> </span>&#123;</span><br><span class="line">  manager-&gt;inc_vote(username);</span><br><span class="line">  manager-&gt;set_state(&amp;VoteManager::repeat_vote_state);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s, 投票成功!\n"</span>, username.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  VoteManager manager;</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境和状态处理对象"><a href="#环境和状态处理对象" class="headerlink" title="环境和状态处理对象"></a>环境和状态处理对象</h2><p>在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。</p><p>在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。</p><p>客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1388.html" target="_blank" rel="noopener">状态模式（详解版）</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html" target="_blank" rel="noopener">《JAVA与模式》之状态模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式概述&quot;&gt;&lt;a href=&quot;#状态模式概述&quot; class=&quot;headerlink&quot; title=&quot;状态模式概述&quot;&gt;&lt;/a&gt;状态模式概述&lt;/h1&gt;&lt;p&gt;在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之vector</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器之vector/</id>
    <published>2021-10-22T12:02:02.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在物理上也是相邻的</p><p>vector的底层是数组，这也说明必要的时候，vector的元素指针可以当做数组指针来使用</p><p>一般的实现中，vector的迭代器就是指针本身</p><p>vector元素访问复杂度</p><ul><li>随机访问——常数 O(1)</li><li>在末尾插入或移除元素——均摊常数 O(1)</li><li>插入或移除元素——与到 vector 结尾的距离成线性 O(n)</li></ul><p>vector有两个特点</p><ul><li>数据连续存储</li><li>空间动态分配</li></ul><p>下边主要针对空间动态分配进行介绍</p><h1 id="vector的实现"><a href="#vector的实现" class="headerlink" title="vector的实现"></a>vector的实现</h1><p>vector的空间是动态分配的，随着元素的增加，vector会自动扩充空间以容纳新元素</p><p>当需要扩充空间时，vector内部会进行如下操作</p><ul><li>分配一块更大的空间</li><li>将原有的数据移动到新的位置</li><li>释放原有空间</li></ul><p>可以看到自动扩充空间涉及到内存分配和元素移动，时间成本很高，需要设计一个合理的数据结构和空间配置策略</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>vector需要表示一块连续存储空间，因此我们需要知道内存的位置，内存的大小和已存储元素的个数</p><p>一个简单的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* start_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了降低内存分配的时间成本，vector的实际空间要比使用的空间要大一些，为将来的元素增加做好准备，为此就需要一个容量来表示当前内存的最大大小</p><h2 id="空间配置策略"><a href="#空间配置策略" class="headerlink" title="空间配置策略"></a>空间配置策略</h2><p>当vector空间满时，新添加元素，会触发自动空间分配，这个时候再分配多少合适呢</p><p>选的扩容太小比如新的大小是当前大小的1.1倍，可能会频繁导致空间分配，如果新的大小是当前大小的3或4倍，可能会导致内存的浪费</p><p>我们先看下主流的实现，gcc新的大小是当前空间大小的2倍，vs是新大小是当前空间大小的1.5倍</p><p>如果选择增长因子为2，可能是最坏的可能，因为它不允许vector重用先前分配好的任何内存，因此选择1.5是一个更好的选择</p><p>如果增长因子为k，则每次分配的内存为，当为2的时候每次分配的内存都比先前分配的所有内存和都大，选择1.5时，则可以在4次分配后重用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C, C*k,  C*k^2, C*k^3, ...</span><br><span class="line">1 + 2^1 + 2^2 + 2^3... + 2^n = 2^(n+1) - 1</span><br></pre></td></tr></table></figure><h2 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h2><p>vector删除元素并不会删除已经申请好的内存，即使vector里已经不包含任何元素</p><p>C++11增加公共成员函数shrink_to_fit，允许释放未使用的内存</p><p>或者通过swap临时变量的方式释放内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v);</span><br></pre></td></tr></table></figure><h1 id="vector的迭代器失效"><a href="#vector的迭代器失效" class="headerlink" title="vector的迭代器失效"></a>vector的迭代器失效</h1><p>对容器的操作影响了元素的存放位置，称为迭代器失效</p><p>由于vector的实现特点，在发生以下情况时，迭代器和引用都会失效</p><ul><li>容量发生改变</li><li>插入或移除元素后的迭代器(插入或移除元素前的迭代器和引用不会失效)</li></ul><h1 id="vector原位构造元素"><a href="#vector原位构造元素" class="headerlink" title="vector原位构造元素"></a>vector原位构造元素</h1><p>C++11提供以下两个函数来原位构造元素</p><ul><li>emplace</li><li>emplace_back</li></ul><p>这两个函数通过完美转发实现原位构造，相比push_back这一类函数，少了一次拷贝的动作</p><p>实际上，当前的push_back实现会使用move语义，不会进行拷贝</p><h1 id="vector的特化"><a href="#vector的特化" class="headerlink" title="vector的特化"></a>vector的特化</h1><p>STL针对vector<bool>进行了特化，可以提供更优的存储空间，实际上它实现了一个动态bitmap</bool></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://github.com/facebook/folly/blob/main/folly/docs/FBVector.md" target="_blank" rel="noopener">fbvector</a></li><li><a href="https://segmentfault.com/a/1190000040103598" target="_blank" rel="noopener">vector实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector概述&quot;&gt;&lt;a href=&quot;#vector概述&quot; class=&quot;headerlink&quot; title=&quot;vector概述&quot;&gt;&lt;/a&gt;vector概述&lt;/h1&gt;&lt;p&gt;vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="顺序容器" scheme="https://gwq5210.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器概述</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器概述/</id>
    <published>2021-10-22T11:59:54.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL容器概述"><a href="#STL容器概述" class="headerlink" title="STL容器概述"></a>STL容器概述</h1><p>容器被设计来存储数据，可以使程序员简单的访问常见的数据结构</p><p>每种不同的容器底层使用不同的数据结构，并拥有不同的特征，可在特定场景提供高效的数据存储和访问的方式</p><p>每种容器提供<a href="/2021/10/22/设计模式之迭代器模式/">迭代器</a>来访问存储在其中的元素</p><p>容器一般分为以下几种类别</p><h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>顺序容器实现能按顺序访问的数据结构</p><ul><li>array：静态连续数组</li><li>vector：动态连续数组</li><li>deque：双端队列</li><li>forward_list：单链表</li><li>list：双链表</li></ul><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器提供顺序容器的不同接口</p><ul><li>stack：栈</li><li>queue：队列</li><li>priority_queue：优先队列</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL容器概述&quot;&gt;&lt;a href=&quot;#STL容器概述&quot; class=&quot;headerlink&quot; title=&quot;STL容器概述&quot;&gt;&lt;/a&gt;STL容器概述&lt;/h1&gt;&lt;p&gt;容器被设计来存储数据，可以使程序员简单的访问常见的数据结构&lt;/p&gt;
&lt;p&gt;每种不同的容器底层使用不同
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://gwq5210.com/2019/03/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)/"/>
    <id>https://gwq5210.com/2019/03/28/Lambda表达式(匿名函数)/</id>
    <published>2019-03-28T11:35:53.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，C++，Python中的Lambda表达式</p><h1 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h1><p>在编程中，Lambda表达式就是指匿名函数（anonymous function），它是一类无需定义标识符（函数名）的函数<br>匿名函数通常作为参数传递给高阶函数或者作为高阶函数的返回值<br>如果函数只使用一次或者有限的次数，则使用匿名函数会比较方便<br>现在越来越多的编程语言支持匿名函数</p><p>闭包常常被用作匿名函数的同义词，严格来说，匿名函数仅仅是没有名字的函数，闭包是任何能够访问自由变量（free variable or non-local variable，不在局部和参数列表里定义的变量）的函数实例</p><h1 id="Java中的Lambda表达式"><a href="#Java中的Lambda表达式" class="headerlink" title="Java中的Lambda表达式"></a>Java中的Lambda表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Java 中的 Lambda 表达式通常使用 (argument) -&gt; (body) 语法书写，例如：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(arg1, arg2...)</span> -&gt;</span> &#123; body &#125;</span><br><span class="line"><span class="function"><span class="params">(type1 arg1, type2 arg2...)</span> -&gt;</span> &#123; body &#125;</span><br></pre></td></tr></table></figure></p><p>在Lambda表达式中引用的自由变量，必须是final或者是实际上不会修改的变量</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li><li>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ol><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要参数，返回值为int的42</span></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，返回值为float的3.1415</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受两个int参数，返回值为它们的和</span></span><br><span class="line">(int a, int b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，没有返回值，输出一个字符串</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个String参数，没有返回值，打印该字符串</span></span><br><span class="line">(<span class="built_in">String</span> s) -&gt; &#123; System.out.println(s); &#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Java中只有一个方法声明的接口叫做函数式接口，例如java.lang.Runnable接口只声明了一个void run()方法<br>不指明函数式接口时，编译器可以进行自动转化<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable <span class="function"><span class="title">r</span> = <span class="params">()</span> -&gt;</span> System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br><span class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Hello Java!"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p><h1 id="C-中的Lambda表达式"><a href="#C-中的Lambda表达式" class="headerlink" title="C++中的Lambda表达式"></a>C++中的Lambda表达式</h1><p>在C++ 11中支持Lambda表达式</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>Lambda表达式的语法如下</p><ol><li>[]中可以以值或引用捕获变量，来实现闭包</li><li>捕获变量时需要注意，如果调用闭包时，引用了生存周期结束的变量，则发生未定义行为，C++的闭包不会延长被捕获引用的生存周期</li><li>Lambda表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型</li><li>this是一个特殊的捕获，必须定义在类的非静态成员函数中，该Lambda具有访问该类的保护和私有成员的权限，在Lambda中访问该类的成员，不需要显式使用this-&gt;，即this-&gt;a和a等价</li><li>不捕获变量的Lambda可以将函数赋值给对应的函数指针</li><li>Lambda表达式可以赋值给std::function</li></ol><p>Boost库提供了自己的Lambda表达式语法，参见<a href="https://www.boost.org/doc/libs/1_62_0/doc/html/lambda.html" target="_blank" rel="noopener">Boost.Lambda</a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) -&gt; return_type &#123; body &#125;</span><br><span class="line"><span class="comment">// 忽略返回值，返回值的类型使用自动推断</span></span><br><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) &#123; body &#125;</span><br><span class="line"><span class="comment">// 不接受任何参数</span></span><br><span class="line">[<span class="meta"> captures </span>] &#123; body &#125;</span><br></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受x，y参数，返回它们的和</span></span><br><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是捕获的例子</span></span><br><span class="line">[]        <span class="comment">//no variables defined. Attempting to use any external variables in the lambda is an error.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&amp;]       <span class="comment">//any external variable is implicitly captured by reference if used</span></span><br><span class="line">[=]       <span class="comment">//any external variable is implicitly captured by value if used</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Variables captured by value are constant by default. Adding mutable after the parameter list makes them non-constant.</span></span><br><span class="line"><span class="comment">// 按值捕获到的变量不能被改变，需要改变的话要在参数列表后加上mutalbe，按值捕获不会改变原值</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=] () <span class="keyword">mutable</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用捕获可以修改原值，a值会被改变成3</span></span><br><span class="line"><span class="keyword">auto</span> r = [&amp;] &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">r();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosureTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClosureTest() &#123; r = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获this</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClosureTest::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">this</span>-&gt;r, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给函数指针，不能捕获变量</span></span><br><span class="line"><span class="keyword">void</span> (*p)() = []&#123;<span class="built_in">printf</span>(<span class="string">"test\n"</span>);&#125;;</span><br><span class="line">p();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给std::function对象，可以进行捕获，void不能省略</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; <span class="built_in">print</span> = [](<span class="keyword">int</span> a)&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; <span class="built_in">print</span> = [&amp;]()&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h1 id="Python中的Lambda表达式"><a href="#Python中的Lambda表达式" class="headerlink" title="Python中的Lambda表达式"></a>Python中的Lambda表达式</h1><p>Python中可以使用lambda关键字定义匿名函数，它能用在任何需要函数的地方，在语法上它被限制只能有单个语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> parameter_list: expression</span><br><span class="line"></span><br><span class="line">// 例如参数x，返回x*x</span><br><span class="line"><span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line">// 以上等价于</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">// 参数x，y，返回它们的和</span><br><span class="line"><span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">// 可以使用自由变量</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> g  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assigning specific closures to variables.</span></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = h(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the closures stored in variables.</span></span><br><span class="line"><span class="keyword">assert</span> a(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> b(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using closures without binding them to variables first.</span></span><br><span class="line"><span class="keyword">assert</span> f(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># f(1) is the closure.</span></span><br><span class="line"><span class="keyword">assert</span> h(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># h(1) is the closure.</span></span><br><span class="line"></span><br><span class="line">// x是全局的</span><br><span class="line">// 修改x后，会修改函数f的结果</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">// [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">// [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br></pre></td></tr></table></figure></p><h1 id="Go的匿名函数"><a href="#Go的匿名函数" class="headerlink" title="Go的匿名函数"></a>Go的匿名函数</h1><p>Go的匿名函数是闭包，他们可以引用自由变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别打出11，102，111</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> num + x</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">num = <span class="number">101</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(test(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h1><p>闭包通常用一个包含函数代码的指针和创建闭包时函数词法环境（一系列可用的变量）的数据结构来实现<br>也就是说闭包引用的自由变量，需要在闭包调用的时候仍然能够访问</p><p>只在栈上分配变量的语言很难容易的实现完全的闭包，这些语言中，自动变量会在函数返回后自动的销毁<br>这也可以解释为什么通常支持闭包的语言也使用垃圾回收机制<br>替代方案是非局部变量的手动内存管理，不过这种方式可能会产生野指针的问题，C++ 11中的Lambda表达式和<a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html" target="_blank" rel="noopener">GNU C中的嵌套函数</a>都可能会产生这个问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">Anonymous_function</a><br>2) <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">Closure_(computer_programming)</a><br>3) <a href="https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/" target="_blank" rel="noopener">Java中的闭包之争</a><br>4) <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank" rel="noopener">Free_variables_and_bound_variables</a><br>5) <a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="noopener">深入浅出 Java 8 Lambda 表达式</a><br>6) <a href="https://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">Lambda expressions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，
      
    
    </summary>
    
    
      <category term="Java" scheme="https://gwq5210.com/tags/Java/"/>
    
      <category term="C++" scheme="https://gwq5210.com/tags/C/"/>
    
      <category term="Python" scheme="https://gwq5210.com/tags/Python/"/>
    
      <category term="Lambda表达式" scheme="https://gwq5210.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="匿名函数" scheme="https://gwq5210.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git简介及常用命令</title>
    <link href="https://gwq5210.com/2019/03/25/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://gwq5210.com/2019/03/25/Git简介及常用命令/</id>
    <published>2019-03-25T20:31:11.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想深入了解一下Git，阅读了一下<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a>的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅</p><h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。<br><a id="more"></a><br>本地版本控制系统无法实现协同工作，集中化的版本控制系统解决了协同工作的问题，但中央服务器的单点故障会影响所有人的工作，分布式版本控制系统采用快照的方式，每个开发者电脑上都有一份代码的完整拷贝，故障恢复起来就比较容易。</p><p>Git是Linux开源社区的杰作，他们开发Git之初就对其有以下目标：</p><ol><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全的分布式</li><li>有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）</li></ol><p>Git和其他版本控制系统（如Subversion）的主要差别在于对待数据的方法。不像其他版本控制系统保存基本文件和基于基本文件的差异，Git直接保存每个文件的快照。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/存储每个文件和基础版本的差异.png" alt="存储每个文件和基础版本的差异" title>                </div>                <div class="image-caption">存储每个文件和基础版本的差异</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/存储项目随时间变化的快照.png" alt="存储项目随时间变化的快照" title>                </div>                <div class="image-caption">存储项目随时间变化的快照</div>            </figure><p>正因为如此，Git中的大多数操作只需要访问本地资源，而不需要与服务器进行通信，保证了操作的速度。</p><h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h2><p>在Git中，你的文件处于以下三种状态之一：</p><ol><li>已提交（committed），表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified），表示已经修改了文件，但还没保存在数据库中。</li><li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>由此引入Git项目的三个工作区的概念：Git仓库，工作目录以及暂存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/工作目录，暂存区域以及Git仓库.png" alt="Git仓库，工作目录以及暂存区域" title>                </div>                <div class="image-caption">Git仓库，工作目录以及暂存区域</div>            </figure><p>基本的 Git 工作流程如下： </p><ol><li>在工作目录中修改文件。 </li><li>暂存文件，将文件的快照放入暂存区域。 </li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 </li></ol><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>有三种方式获取Git的帮助：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">help</span> <span class="symbol">&lt;verb&gt;</span></span><br><span class="line">git <span class="symbol">&lt;verb&gt;</span> --<span class="keyword">help</span></span><br><span class="line">man git-<span class="symbol">&lt;verb&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>Git的配置信息存放在三个不同的位置</p><ol><li>/etc/gitconfig文件，系统上每一个用户及他们仓库的配置，使用–system选项会读写此配置文件</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。使用–global选项会读写此配置文件</li><li>当前仓库中使用的配置（.git/config），需要在当前仓库进行修改，不需要加选项。</li></ol><p>每一个级别的配置会覆盖上一个级别的配置。</p><p>以下是常用的配置<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看用户配置</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局的用户名和邮箱</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"gwq5210"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"gwq5210@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用的编辑器</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> core<span class="variable">.editor</span> <span class="string">"vim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置常用的别名，以下命令会在稍候介绍</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.co</span> checkout</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.br</span> branch</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.st</span> status</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.unstage</span> reset HEAD --</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.last</span> log -l HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Git设置代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.http</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为不同的网址设置不同的代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> https<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免每次都输入账号密码，将账号密码保存在内存中几分钟</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> credential<span class="variable">.helper</span> cache</span><br></pre></td></tr></table></figure></p><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种方式获取Git仓库：从现有目录初始化仓库和从服务器克隆一个现有的Git仓库。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从现有目录初始化仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器克隆一个现有的仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">clone</span> <span class="selector-attr">[url]</span> <span class="selector-attr">[name]</span></span><br></pre></td></tr></table></figure></p><p>Git仓库里存在着.git目录，保存着Git仓库的必要信息。</p><h2 id="查看当前文件状态、跟踪新文件和暂存已修改的文件"><a href="#查看当前文件状态、跟踪新文件和暂存已修改的文件" class="headerlink" title="查看当前文件状态、跟踪新文件和暂存已修改的文件"></a>查看当前文件状态、跟踪新文件和暂存已修改的文件</h2><p>工作目录的文件状态不外乎：已跟踪和未跟踪。已跟踪是已纳入版本控制的文件，在上一次快照中有他们的记录，工作过一段时候后，他们的状态可能是未修改，已修改，已暂存状态。除此之外其他文件都属于未跟踪文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/文件状态变化生命周期.png" alt="文件状态变化生命周期" title>                </div>                <div class="image-caption">文件状态变化生命周期</div>            </figure></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 查看当前文件状态</span></span><br><span class="line"><span class="regexp">git status</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 之前设置的status别名为st</span></span><br><span class="line"><span class="regexp">git st</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 显式简介的状态</span></span><br><span class="line"><span class="regexp">git status -s</span></span><br><span class="line"><span class="regexp">git status --short</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第一列表示在暂存区域的状态，第二列表示在工作区域的状态</span></span><br><span class="line"><span class="regexp">-------------------</span></span><br><span class="line"><span class="regexp"> M README</span></span><br><span class="line"><span class="regexp">MM Rakefile</span></span><br><span class="line"><span class="regexp">A lib/git</span>.rb</span><br><span class="line">M <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">?? LICENSE.txt </span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 跟踪新文件或暂存已修改的文件</span></span><br><span class="line"><span class="regexp">git add [path]</span></span><br></pre></td></tr></table></figure><p>我们可以使用.gitignore文件来忽略我们不想跟踪的文件，这里有.gitignore文件的列表，可供查阅<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 查看未暂存的修改，即工作区域和已暂存区域的修改</span><br><span class="line">git diff</span><br><span class="line"><span class="string">//</span> 查看已提交和已暂存的修改</span><br><span class="line">git diff <span class="params">--cached</span></span><br><span class="line"><span class="string">//</span> Git 1.6.1及更高版本</span><br><span class="line">git diff <span class="params">--staged</span></span><br></pre></td></tr></table></figure><h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>使用如下命令将暂存区域的内容提交<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">// 命令行指定提交消息</span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line">// 跳过暂存，进行提交</span><br><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"commit message"</span></span><br><span class="line">// commit的别名</span><br><span class="line">git ci</span><br></pre></td></tr></table></figure></p><h2 id="移除或修改文件"><a href="#移除或修改文件" class="headerlink" title="移除或修改文件"></a>移除或修改文件</h2><p>要移除文件，需要从已跟踪清单中（确切的说是从暂存区域）移除，然后提交。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git rm [path]</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git rm类似如下命令</span></span><br><span class="line">rm [path]</span><br><span class="line">git add [path]</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从暂存区域移除，仍然保留在工作区域</span></span><br><span class="line">git rm --cached [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经修改了文件或者已经暂存了该文件，则需要使用-f进行删除，防止误操作删除了不可恢复的文件</span></span><br><span class="line">git rm -f [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名文件</span></span><br><span class="line">git mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git mv相当于下边的操作</span></span><br><span class="line">mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">git rm file<span class="emphasis">_from</span></span><br><span class="line"><span class="emphasis">git add file_</span>to</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>提交若干更新或者克隆一个仓库之后，我们可以查看提交历史<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 默认会列出所有的提交历史，最近的更新会排在最上边</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">// 显示最新的n条记录</span><br><span class="line">git <span class="built_in">log</span> -n</span><br><span class="line"></span><br><span class="line">// 显示每次提交的内容差异</span><br><span class="line">git <span class="built_in">log</span> -p</span><br><span class="line"></span><br><span class="line">// 查看每次提交的简略统计信息</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--stat</span></span><br><span class="line"></span><br><span class="line">// 单行显示提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--oneline</span></span><br><span class="line"></span><br><span class="line">// 使用图形提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure></p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 修改最后一次提交，使用这个选项会覆盖上一次的提交</span><br><span class="line">git ci <span class="params">--amend</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 取消暂存文件</span><br><span class="line">git reset HEAD &lt;file&gt;<span class="string">...</span></span><br><span class="line"><span class="string">//</span> 别名</span><br><span class="line">git unstage &lt;file&gt;<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 撤销对文件的修改，此操作会丢失对文件的修改，很危险</span><br><span class="line">git checkout -- &lt;file&gt;<span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="使用远程仓库"><a href="#使用远程仓库" class="headerlink" title="使用远程仓库"></a>使用远程仓库</h2><p>克隆一个仓库，会自动给远程仓库添加origin的名称<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote show <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加远程仓库</span></span><br><span class="line">git remote add <span class="params">&lt;shortname&gt;</span> <span class="params">&lt;url&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取远程仓库的信息，不会自动合并或修改你当前的工作</span></span><br><span class="line"><span class="comment">// 分支设置了跟踪一个远程分支的话git pull会自动抓取然后合并</span></span><br><span class="line">git fetch <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送到远程仓库</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;branch-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程仓库重命名和移除</span></span><br><span class="line">git remote rename <span class="params">&lt;old-name&gt;</span> <span class="params">&lt;new-name&gt;</span></span><br><span class="line">git remote rm <span class="params">&lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>Git可以给历史中的某一个提交打上标签，表示重要<br>Git标签有两种标签，轻量标签和附注标签<br>轻量标签很像一个不会改变的分支，它只是一个特定提交的引用<br>附注标签是存储在Git数据库中的完整对象，可以包含打标签者的名字，邮件，日期等信息<br>通常建议创建附注标签<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出标签</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l <span class="string">"v1.8*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建附注标签，指定存储在标签中的信息</span></span><br><span class="line">git tag -a v1<span class="number">.0</span> -m <span class="string">"create tag v1.0"</span></span><br><span class="line"><span class="comment">// 查看标签的信息和对应的提交信息，轻量标签只会显示提交信息</span></span><br><span class="line">git show v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轻量标签，只需要提供标签名字</span></span><br><span class="line">git tag v1<span class="number">.0</span>-lw</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对过去的提交打标签</span></span><br><span class="line">git tag -a v0<span class="number">.9</span> <span class="number">9f</span>ceb02</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享标签，将标签推送到远程仓库，类似共享远程分支</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有不在远程服务器的标签都推送过去</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --tags</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除标签，此命令不会删除远程服务器的标签</span></span><br><span class="line">git tag -d v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程服务器的标签</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> :refs<span class="meta-keyword">/tags/</span><span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --delete <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检出标签，此命令会使你的仓库处于分离头指针（detached HEAD）状态</span></span><br><span class="line"><span class="comment">// 在分离头指针状态你进行某些更改然后提交他们，标签不会发生变化，你的提交不属于任何分支，只能使用确切的哈希来访问</span></span><br><span class="line">git checkout <span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git co <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，需要修复旧版本的错误，通常需要创建一个新的分支，在新分支上进行修改，并提交，该分支就和此标签不同了</span></span><br><span class="line">git co -b <span class="params">&lt;branch-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>几乎所有的版本控制系统都支持分支，你可以把工作从开发主线上分离出来，以免影响开发主线<br>Git处理分支的方式十分轻量，创建和切换分支操作都十分便捷，因此Git鼓励使用分支</p><p>进行提交操作时，Git会保存一个提交对象，该提交对象包含一个指向暂存内容快照的指针，还包括作者的姓名，邮箱等信息，以及它的父对象信息（一个或多个）</p><p>Git的默认分支是master分支，master分支不是一个特殊的分支，与其他分支没有差别，git init命令会默认创建它</p><p>这些分支操作全部都保存在本地，没有与服务器发生交互<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支，会在当前所的提交对象上创建一个指针，Git有一个HEAD的特殊指针，指向当前分支，可以理解为当前分支的别名</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>切换分支，分支切换会改变工作目录的内容，如果Git不能干净利落的完成这个任务，它将禁止切换分支</span><br><span class="line"><span class="symbol">git</span> checkout &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>新建分支并切换</span><br><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>合并分支，将&lt;<span class="keyword">branch-name&gt;分支合并到当前分支</span></span><br><span class="line"><span class="keyword">// </span>合并两个分支时，如果顺着一个分支能够到达另外一个分支，那么就进行快进（fast-forward）</span><br><span class="line">// 有分叉的合并会产生一个合并提交，该提交使用三方（两个分支末端的快照和它们的公共祖先）合并的结果</span><br><span class="line">// 如果合并时遇到对同一个文件同一处的修改，则会发生冲突，等你解决冲突后，使用git <span class="keyword">add命令将冲突的文件标记为已解决冲突</span></span><br><span class="line"><span class="keyword">git </span>merge &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>删除分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支，*号代表当前所在分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支最后一个提交</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-v</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>-v</span><br><span class="line"></span><br><span class="line">// 显示列表中已经合并或尚未合并到当前分支的分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--merged</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>--no-merged</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/一个和并提交.png" alt="一个和并提交" title>                </div>                <div class="image-caption">一个和并提交</div>            </figure><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用，包括分支标签等。<br>我们经常利用远程跟踪分支，它是远程分支状态的引用，它们是你不能移动的本地引用，当你进行任何网络操作时，它们会自动移动<br>远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签，以<remote>/<branch>命名，如origin/master</branch></remote></p><p>origin和master没有特殊含义，origin是git clone创建的远程仓库的默认名字，master是git init时默认的起始分支的名字<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看完整远程引用列表</span></span><br><span class="line">git ls-remote</span><br><span class="line">git remote <span class="keyword">show</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/本地与远程的工作可以分叉.png" alt="本地与远程的工作可以分叉" title>                </div>                <div class="image-caption">本地与远程的工作可以分叉</div>            </figure><h3 id="推送到远程分支"><a href="#推送到远程分支" class="headerlink" title="推送到远程分支"></a>推送到远程分支</h3><p>你想分享一个分支，必须要将其推送到有写入权限的远程仓库，本地的分支不会自动与远程仓库同步，必须显式的推送<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分支推送到远程仓库</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地分支与远程分支采用不同的名字</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;:&lt;remote-branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他人可以获取到远程分支</span></span><br><span class="line">git fetch &lt;remote-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 合并远程分支到当前分支</span></span><br><span class="line">git merge &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git co -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程仓库检出一个本地分支会自动创建一个做跟踪分支（上游分支），跟踪分支是与远程分支有直接关系的本地分支<br>如果在跟踪分支上输入git pull，则Git能自动识别去哪个服务器抓取、合并到哪个分支<br>克隆仓库时，会自动创建一个跟踪origin/master的master分支<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git checkout -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git checkout --track &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 当前分支设置跟踪的远程分支</span></span><br><span class="line">git branch -u &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置好跟踪分支后，可以通过@&#123;u&#125;或@&#123;upstream&#125;快捷方式来引用它</span></span><br><span class="line">git merge origin/master</span><br><span class="line">git merge @<span class="comment">&#123;u&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看分支跟踪的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取远程分支，并不会修改本地工作目录中的内容，需要自己合并</span></span><br><span class="line">git fetch origin master</span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment">// git pull会查找当前分支的跟踪分支，从服务器抓取数据然后尝试合并入那个远程分支</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; --delete &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>Git中整合来自不同分支的修改主要有两种方法：merge和rebase<br>合并进行一次三方合并，产生一个新的快照并提交<br>变基首先找到两个分支的共同祖先，对比当前分支的历次提交，提取相应的修改，然后在新的分支上进行重新播放，最后进行一次快速合并<br>一般进行变基的目的是确保向远程分支推送时，保持提交历史的整洁<br>这两种方式整合的最终快照是一样的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将当前分支变基到<span class="literal">master</span>分支</span><br><span class="line">git rebase <span class="literal">master</span></span><br><span class="line">// 将在client分支里但不在server分支里的修改，在<span class="literal">master</span>分支里重放</span><br><span class="line">git rebase --onto <span class="keyword">master</span> <span class="title">server</span> client</span><br><span class="line">// 无需切换分支进行变基</span><br><span class="line">git rebase <span class="keyword">master</span> <span class="title">server</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/变基然后进行快进合并.png" alt="变基然后进行快进合并" title>                </div>                <div class="image-caption">变基然后进行快进合并</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/通过合并操作来整合分叉的历史.png" alt="通过合并操作来整合分叉的历史" title>                </div>                <div class="image-caption">通过合并操作来整合分叉的历史</div>            </figure><p>变基存在风险，使用变基的准则是不要对在你的仓库外有副本的分支执行变基<br>变基的操作实际上是丢弃一些现有的提交，然后相应的新建一些内容一样的但是实际上不同的提交<br>如果别人在该分支上进行了工作，你对此分支进行了变基，那么就会出现问题<br>出现类似的情况可以使用变基来解决变基<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上的命令和知识可以应付大部分Git的使用场景了<br>如果遇到其他的困难问题，可以后续再补充</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想深入了解一下Git，阅读了一下&lt;a href=&quot;https://git-scm.com/book/en/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pro Git&lt;/a&gt;的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅&lt;/p&gt;
&lt;h1 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h1&gt;&lt;p&gt;Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;p&gt;版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://gwq5210.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Cpp-Primer-Plus读书笔记（四）</title>
    <link href="https://gwq5210.com/2018/04/12/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://gwq5210.com/2018/04/12/Cpp-Primer-Plus读书笔记（四）/</id>
    <published>2018-04-12T22:26:26.000Z</published>
    <updated>2022-07-22T07:33:50.189Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-C-中的代码重用"><a href="#第十四章-C-中的代码重用" class="headerlink" title="第十四章 C++中的代码重用"></a>第十四章 C++中的代码重用</h1><p>C++的一个主要目标是促进代码重用。</p><h2 id="包含对象成员的类"><a href="#包含对象成员的类" class="headerlink" title="包含对象成员的类"></a>包含对象成员的类</h2><p>valarray是由头文件valarray定义，其用于处理数值<br>通常用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类<br>使用组合可以获得实现，但不获得接口，共有继承可以获得接口，可能还有实现</p><p>对于模板类我们可以使用typedef简化其描述</p><p>使用成员初始化列表来初始化包含的类对象。</p><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。这种关系是has-a关系。</p><p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象(subobject)来表示通过继承或包含添加的对象。</p><p>使用包含时使用对象名来调用方法，而使用私有继承时，将使用类名和作用域解析运算符来调用方法</p><p>私有继承如果希望访问基类对象，可以使用强制类型转换。同样，可以通过强制类型转换来使用基类的友元函数。</p><p>在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针。在多重继承情况下，不进行强制类型转换也无法确定应转换成哪个类。然而即使公有继承也必须进行强制类型抓换。</p><h3 id="使用包含还是私有继承"><a href="#使用包含还是私有继承" class="headerlink" title="使用包含还是私有继承"></a>使用包含还是私有继承</h3><p>使用包含更容易理解，继承会引起多个问题，尤其是使用多重继承的情况下，另外还可能需要包含类的多个子对象</p><p>通常应使用包含来实现has-a，如果新类要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承</p><h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护继承是私有继承的变体，其使用关键字protected<br>在使用保护继承时，基类的共有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的，当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别就呈现出来了，使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中将变成私有方法，使用保护继承时，基类的共有方法在第二代类中将变成受保护的，因此第三代类可以使用它们。隐式向上转换(implicit upcasting)意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。如下表<br>| 特征  | 共有继承 | 保护继承 | 私有继承 |<br>| —- | —- | —- | —- |<br>| 公有成员变成 | 派生类的公有成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 保护成员变成 | 派生类的保护成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 私有成员变成 | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |<br>| 能否隐式向上转换 | 是 | 是(但只能在派生类中) | 否 |</p><h4 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h4><p>使用保护派生或私有派生时，假设要使基类的方法在派生类外可用，方法之一是定义一个使用该基类方法的派生类方法，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用基类特定的基类成员，即使采用的是私有派生，注意，using声明只使用成员名，没有圆括号，函数特征标和返回值，这使得所有成员名的方法都可用，其只适用于继承，不适用于包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十四章-C-中的代码重用&quot;&gt;&lt;a href=&quot;#第十四章-C-中的代码重用&quot; class=&quot;headerlink&quot; title=&quot;第十四章 C++中的代码重用&quot;&gt;&lt;/a&gt;第十四章 C++中的代码重用&lt;/h1&gt;&lt;p&gt;C++的一个主要目标是促进代码重用。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
</feed>
