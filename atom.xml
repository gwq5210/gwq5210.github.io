<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gwq5210&#39;s Blog</title>
  
  <subtitle>凡是过往，皆为序章！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gwq5210.com/"/>
  <updated>2022-07-18T02:31:52.909Z</updated>
  <id>https://gwq5210.com/</id>
  
  <author>
    <name>gwq5210</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APUE笔记-二</title>
    <link href="https://gwq5210.com/2022/07/17/APUE%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://gwq5210.com/2022/07/17/APUE笔记-二/</id>
    <published>2022-07-17T23:58:29.000Z</published>
    <updated>2022-07-18T02:31:52.909Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-标准IO库"><a href="#第五章-标准IO库" class="headerlink" title="第五章 标准IO库"></a>第五章 标准IO库</h1><p>标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标准IO库</p><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>在第三章所有的文件IO都是围绕文件描述符的。对于标准IO库，其操作是围绕流（stream）进行的，打开或创建一个文件时，使一个流与一个文件相关联</p><p>标准IO文件流可用于单字节和多字节字符集。流的定向（stream’s orientation）决定了读、写字符是单字节还是多字节的。</p><p>当一个流最初被创建时，它并没有定向。若在流上使用一个单字节IO函数，则将流设置为字节定向的。若在流上使用一个多字节IO函数，则将流设置为字宽定向的。</p><p>只有freopen和fwide这两个函数可以改变流的定向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE* fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: &gt;<span class="number">0</span> : 宽定向；&lt;<span class="number">0</span> 字节定向；<span class="number">0</span> : 未定向</span><br></pre></td></tr></table></figure><p>fwide并不能改变已定向流的定向。fwide无法返回出错。需要在调用fwide前清除errno，返回时再检查errno的值</p><p>一个流的结构（FILE*，通常称为文件指针）通常包含一些必要的信息，如实际IO的文件描述符，缓存区指针和长度，当前在缓冲区中的字符数和出错标志等</p><p>一个进程预定义了3个流，标准输入流，标准输出流，标准出错流(分别是stdin, stdout, stderr)可以自动被进程使用。分别对应文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准IO库提供缓冲的目的是尽可能减少read、write系统调用的次数。它对每个IO流自动进行缓冲管理，避免应用程序考虑应使用多大的缓冲区。</p><p>标准IO提供3中类型的缓冲</p><ul><li>全缓冲。这种情况下，缓冲区满才进行实际的IO操作，磁盘文件通常是全缓冲的。当然我们可以通过fflush手动冲洗流的缓冲区</li><li>行缓冲。这种情况下，输入和输出遇到换行符执行IO操作。流涉及一个终端时通常使用行缓冲。行缓冲有以下两个限制<ul><li>缓冲区大小固定。缓冲区满时，即使没有换行符也进行IO操作</li><li>任何时候，只要通过标准IO库要求从a）不带缓冲的流或b)一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流</li></ul></li><li>不带缓冲。标准IO库不对字符进行缓冲存储。标准错误流通常是不带缓冲的，这使得出错信息可以尽快的显示出来</li></ul><p>ISO C要求</p><ul><li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的</li><li>标准错误绝不会是全缓冲的</li></ul><p>一般系统默认如下方案</p><ul><li>标准错误流是不带缓冲的</li><li>若是指向终端的流，则是行缓冲的；否则是全缓冲的</li></ul><p>我们可以通过如下函数修改系统默认的缓冲类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上函数应在流被打开后调用，且应在对流执行任何一个其他操作之前调用</p><p>可以使用setbuf打开或关闭缓冲机制。buf为NULL，则关闭缓冲；为了带缓冲进行IO，参数buf必须指向一个长度为BUFSIZ的缓冲区。一般在此之后流就是全缓冲的，但是如果一个流与一个终端设备相关，某些系统也可将其设置为行缓冲的</p><p>使用setvbuf可以通过mode精确的指定缓冲类型</p><ul><li>_IOFBF：全缓冲</li><li>_IOLBF：行缓冲<ul><li>以上可以通过buf和size设置缓冲区和长度；如果buf为NULL，则标准IO库将自动分配合适的缓冲区，适当长度一般由BUFSIZ指定（GNU C使用stat结构中的st_blksize来决定最佳缓冲区长度）</li></ul></li><li>_IONBF：不带缓冲，忽略buf和size参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/setbuf和setvbuf函数.png" alt="setbuf和setvbuf函数" title>                </div>                <div class="image-caption">setbuf和setvbuf函数</div>            </figure><p>一般而言我们应该由系统选择缓冲区的长度，并自动分配缓冲区，流关闭时，将自动释放缓冲区</p><p>任何时候我们可以强制冲洗一个流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>此函数使所有未写的数据都传送至内核。如果fp是NULL，则导致所有的输出流被冲洗</p><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>以下3个函数打开一个标准流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>说明如下</p><ul><li>fopen打开路径名为pathname的指定文件</li><li>freopen在一个指定流上打开一个指定文件，如若流已经被打开，则先关闭该流。若流已经定向，则使用freopen清除该定向。此函数一般用于将一个指定文件打开为一个预定义的流：标准输入、标准输出、标准错误</li><li>fdopen函数取一个已有的文件描述符（如从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到），并使一个标准的IO流与此文件描述符相结合</li></ul><p>参数type有如下组合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fopen的type.png" alt="fopen的type" title>                </div>                <div class="image-caption">fopen的type</div>            </figure><p>使用字符b可以使得标准IO系统区分二进制和文本文件。UNIX内核并不区分这两种文件，所以在UNIX系统下并无作用</p><p>对于fdopen，type参数的作用稍有区别。因为该描述符已被打开，所有fdopen为写打开并不截断文件。标准IO追加写方式也不能用于创建该文件（该文件一定存在，fd引用一个文件）</p><p>当以读和写类型（type中+号）打开一个文件时，有如下限制</p><ul><li>如果中间没有fflush、fseek、fsetpos或rewind，则在输出后边不能直接跟随输入</li><li>如果中间没有fseek、fsetpos或rewind或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/打开流的不同方式.png" alt="打开流的不同方式" title>                </div>                <div class="image-caption">打开流的不同方式</div>            </figure><p>在w和a类型创建一个文件时，我们无法指定文件的访问权限位，我们可以通过调整umask值来限制这些权限或创建之后修改权限</p><p>调用fclose可以关闭一个打开的流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>在该文件被关闭之前，冲洗缓冲区中的输出数据，缓冲区中的任何输入数据被丢弃。如果分配和缓冲区，则自动释放缓冲区</p><p>进程正常终止时（直接调用exit或从main函数返回），则所有带未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭</p><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>有三种不同的非格式化IO可以对流进行读写操作</p><ul><li>每次一个字符的IO。如果流带缓冲，则标准IO函数处理所有缓冲</li><li>每次一行的IO。</li><li>直接IO，或者称为二进制IO。fread和fwrite支持这种类型的IO</li></ul><h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><p>以下函数可以一次读取一个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 等同于fgetc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回下一个字符；若已到文件结尾或出错，返回EOF</span><br></pre></td></tr></table></figure><p>返回值会将unsigned char转换为int类型。无符号即使最高位为1也不会返回负值。要求int返回值是因为除了返回所有可能的字符，还要加上一个已出错或到达文件尾端的标记值。EOF被要求是一个负值，通常为-1</p><p>为了区分出错或到达文件尾端，需要使用以下函数进行区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若条件为真，返回非<span class="number">0</span>；否则，返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数实现在文件指针中维护了两个标志：出错标志和文件结束标志；调用clearerr可以清除这两个标志</p><p>从流中读取数据后，可以调用ungetc再将字符压入流中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>压送回流的字符又可以从流中读出，但读出字符的顺序与压送回流的顺序相反。回送的字符不一定必须是上次读到的字符，不能回送EOF。但是当已经达到文件尾端时，仍可以回送一个字符。调用ungetc只是将字符写入流缓冲区中</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>; <span class="comment">// 等同于fputc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><h2 id="每次一行IO"><a href="#每次一行IO" class="headerlink" title="每次一行IO"></a>每次一行IO</h2><p>由以下函数提供每次输入一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;  <span class="comment">// 可能造成缓冲区溢出，应使用fgets(buf, n, stdin)替换</span></span><br><span class="line"></span><br><span class="line">若成功，返回buf；若已到达文件末尾或出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>fgets读取不超过n-1个字符，buf总是以null字节结尾。gets不将换行符写入buf，而fgets则将换行符写入buf</p><p>fputs和puts提供每次输出一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;  <span class="comment">// 等价于fputs(str, stdout); fputs("\n", stdout);</span></span><br><span class="line"></span><br><span class="line">若成功，返回非负值；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>应尽量使用fget和fputs组合，以便记得在每行终止时必须处理换行符</p><h2 id="标准IO的效率"><a href="#标准IO的效率" class="headerlink" title="标准IO的效率"></a>标准IO的效率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/标准IO库的效率.png" alt="标准IO库的效率" title>                </div>                <div class="image-caption">标准IO库的效率</div>            </figure><h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><p>使用以下函数处理二进制IO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回读或写的对象数</span><br></pre></td></tr></table></figure><p>对于读，如果出错或到达文件尾端，则此数字可以小于nobj，这时应调用ferror或feof判断是哪种情况。对于写如果返回值小于nobj则出错</p><p>二进制IO需要对读写的数据有限制，否则可能产生兼容性的问题。如结构体对齐问题，导致数据错误</p><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有三种方法定位标准IO流</p><ul><li>ftell和fseek，用long进行定位</li><li>ftello和fseeko，用off_t进行定位</li><li>fgetpos和fsetpos，由ISO C引入，使用fpos_t进行定位；移植到非UNIX系统的应用程序应当使用这两个函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回当前文件位置指示；若出错，返回<span class="number">-1L</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;  <span class="comment">// whence与lseek的参数相同</span></span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用rewind将流设置到文件的起始位置</p><p>除了偏移类型是off_t外，ftello和fseeko函数与上述函数相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span>* <span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><p>格式化IO有scanf和printf函数族来实现，同时也提供了vscanf和vprintf函数族来处理可变参数</p><p>有关格式化IO的详细信息，这里不过多介绍，需要时可以参考手册或书籍</p><h2 id="标准IO库的文件描述符"><a href="#标准IO库的文件描述符" class="headerlink" title="标准IO库的文件描述符"></a>标准IO库的文件描述符</h2><p>fileno可以获取对应流关联的文件描述符，其不是ISO C标准，不可移植</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回与流相关联的文件描述符</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准库提供了两个函数来帮助创建临时文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向唯一路径名的指针</span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>tmpnam函数产生一个与现有文件名不通的有效路径名字符串，最多调动TMP_MAX次。若ptr是NULL，则所产生的路径名存放在静态存储区中，指向该静态区的指针作为返回值返回。若ptr不为空，则长度至少为L_tmpnam，并返回ptr</p><p>tmpfile创建一个临时二进制文件（wb+），在关闭该文件或程序结束时将自动删除这中文件。其原理一般是调用tmpnam函数产生一个唯一路径名，然后用该路径名创建一个文件，并立即unlink它</p><p>另外mkdtemp和mkstemp也可以创建临时目录或文件。</p><p>一般应使用mkstemp（文件不会自动删除）和tmpfile，因为使用tmpnam和tempnam至少有一个缺点：因为在调用其获取唯一文件名和创建文件之间，可能有其他进程使用相同名字创建文件，而mkstemp和tmpfile不存在这个问题</p><h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>内存流一般不会用到，不做介绍</p><h2 id="标准IO库的替代软件"><a href="#标准IO库的替代软件" class="headerlink" title="标准IO库的替代软件"></a>标准IO库的替代软件</h2><p>标准IO库有一些缺点。效率不高，通常需要复制两次数据：内核到标准IO库缓冲区、标准IO库缓冲区到用户程序缓冲区。</p><p>mmap函数也可以用来读写文件</p><h1 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h1><p>UNIX系统有很多与系统有关的数据文件，由于历史原因这些数据文件都是ASCII文本文件，本章简单介绍这些文件。除此之外还介绍系统标识函数、时间和日期函数</p><h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含如下字段，其定义在&lt;pwd.h&gt;中的passwd结构中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/passwd文件中的字段.png" alt="passwd文件中的字段" title>                </div>                <div class="image-caption">passwd文件中的字段</div>            </figure><p>可以通过getpwuid和getpwunam获取uid或name，同时也提供了函数来读取/etc/passwd文件，具体可查看文档</p><p>目前，加密口令一般存放在阴影口令文件中，一般为/etc/shadow，可以通过函数来读取加密口令</p><p>组文件一般为/etc/group。UNXI系统一般支持附属组，一个用户可以加入多个附属组中，用户附属组可以通过函数获取</p><h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX会提供utmp——记录当前登录到系统的各个用户，wtmp——跟踪各个登录和注销事件，其一般为二进制文件，存放相应的结构体</p><h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>可以通过uname获取系统标识，一般包括如下字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> sysname[];  <span class="comment">// name of the operating system</span></span><br><span class="line">  <span class="keyword">char</span> nodename[];  <span class="comment">// name of the node</span></span><br><span class="line">  <span class="keyword">char</span> release[];  <span class="comment">// current release of operating system</span></span><br><span class="line">  <span class="keyword">char</span> version[];  <span class="comment">// current version of release</span></span><br><span class="line">  <span class="keyword">char</span> machine[];  <span class="comment">// name of hardware type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>历史上，BSD派生的系统提供gethostname函数，它只返回主机名，改名字通常就是TCP/IP网络上主机的名字</p><h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>time函数返回自协调世界时公元1970年1月1日 00:00:00这一特定时间以来经过的秒数</p><p>clock_gettime函数可用于获取指定时钟时间，clock_getres用于获取指定时钟精度，clock_settime对特定的时钟设置时间</p><p>gettimeofday可以获取微秒级的时间</p><p>其余函数可以将秒数转换为tm结构体，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;                   <span class="comment">/* Seconds.     [0-60] (1 leap second) */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;                   <span class="comment">/* Minutes.     [0-59] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;                  <span class="comment">/* Hours.       [0-23] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;                  <span class="comment">/* Day.         [1-31] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;                   <span class="comment">/* Month.       [0-11] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;                  <span class="comment">/* Year - 1900.  */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;                  <span class="comment">/* Day of week. [0-6] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;                  <span class="comment">/* Days in year.[0-365] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;                 <span class="comment">/* DST.         [-1/0/1]*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/时间函数之间的关系.png" alt="时间函数之间的关系" title>                </div>                <div class="image-caption">时间函数之间的关系</div>            </figure><h1 id="进程环境"><a href="#进程环境" class="headerlink" title="进程环境"></a>进程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，其原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argc为命令行参数的个数</span></span><br><span class="line"><span class="comment">// argv是指向参数的各个指针构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>内核（使用exec函数，后续将会介绍）执行C程序时，在调用main函数前会先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地——这是由链接编辑器指定的，而链接编辑器由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按照上述方式调用main函数做好准备</p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有八种方式终止进程（termination），前5种为正常终止，后3种为异常终止</p><ul><li>从main函数返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit</li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出响应</li></ul><p>启动例程一般是从main函数返回后立即调用main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语义为如下C语言调用，但启动例程一般用汇编语言编写</span></span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv));</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>_exit和_Exit立即进入内核，exit则先执行一些清理，然后返回内核</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p>exit函数总是执行一个标准IO库的相关清理工作：对于所有打开流调用fclose函数</p><p>3个函数都带一个整型参数，称为终止状态（exit status）。大多数UNIX系统shell都提供检查进程终止状态的方法（echo $?）</p><p>main函数推荐声明为int，并且需要返回整型值，否则，可能终止状态是未定义的</p><p>main函数返回一个整型值与用该值调用exit是等价的，即exit(0)等价于return 0</p><h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>ISO C规定一个进程可以登记多至32个函数，这些函数将由exit自动调用，这些函数称为终止处理程序（exit handler），使用atexit来登记这些函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>其参数是一个函数地址，其无参数也无返回值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数若登记多次也会被调用多次</p><p>exit首先调用各种终止处理程序，然后关闭所有打开的流。若程序调用exec函数族的任一函数，则将清除所有已安装的终止处理程序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/程序的启动和终止.png" alt="程序的启动和终止" title>                </div>                <div class="image-caption">程序的启动和终止</div>            </figure><p>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式的（通过调用exit）调用_exit或_Exit。进程也可非自愿的由一个信号使其终止</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-标准IO库&quot;&gt;&lt;a href=&quot;#第五章-标准IO库&quot; class=&quot;headerlink&quot; title=&quot;第五章 标准IO库&quot;&gt;&lt;/a&gt;第五章 标准IO库&lt;/h1&gt;&lt;p&gt;标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>STL之string</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E4%B9%8Bstring/"/>
    <id>https://gwq5210.com/2021/11/14/STL之string/</id>
    <published>2021-11-14T20:20:57.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string概述"><a href="#string概述" class="headerlink" title="string概述"></a>string概述</h1><p>string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常使用string，否则就使用vector</p><p>string和vector自动管理动态数组，并自动扩充数组的大小，析构时自动释放内存</p><p>string提供了字符串查找，替换等成员函数，方便使用</p><h1 id="string实现"><a href="#string实现" class="headerlink" title="string实现"></a>string实现</h1><p>string在编程中十分常见，了解字符串的实现很有帮助</p><p>为了提高string的性能，一般有三种方式来实现string，有时会对这几种方法相结合</p><ul><li>eager copy，即每次都执行深拷贝</li><li>SSO，即Small String Optimization，较小的字符串在栈中分配内存</li><li>COW，即Copy On Write，写时复制</li></ul><h2 id="string的结构"><a href="#string的结构" class="headerlink" title="string的结构"></a>string的结构</h2><p>介绍三种实现前，先大致介绍下string的结构</p><p>如果按照我们自己的设计，字符串必定包含以下三个数据成员：字符串长度，字符串的容量和字符数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringStorage</span> &#123;</span></span><br><span class="line">  size_type size;</span><br><span class="line">  size_type capacity;</span><br><span class="line">  pointer data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eager-copy"><a href="#eager-copy" class="headerlink" title="eager copy"></a>eager copy</h2><p>直接深拷贝的方式很容易理解，因为string中保存的是指向堆内存的指针，在复制时，需要执行以下步骤执行深拷贝</p><ul><li>分配新的内存</li><li>将字符串的内容复制到新内存</li><li>设置字符串大小和容量</li></ul><p>这种字符串的实现方式，相对简单，比较容易理解，但带来的问题是每次复制都需要分配内存和执行复制的操作，当字符串很大时，会带来性能的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringStorage <span class="title">AllocateMediumStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = kMaxMediumSize;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(Allocate(kMaxMediumSize + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitMedium</span><span class="params">(const_pointer str, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  assert(len &lt;= kMaxMediumSize);</span><br><span class="line">  store_ = AllocateMediumStorage();</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kMedium;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>短字符串优化是一个很巧妙的优化方法，利用string本身结构的buffer来存储较小的字符串</p><p>上边给出的例子中，至少需要三个变量，因此string的结构本身需要24个字节</p><p>当字符串较小时，如果仍在堆上分配内存，但size和capacity本身的值则很小，高位bit都是0，浪费了许多空间</p><p>因此在SSO的实现，只用一个字节表示字符串大小，容量大小是固定的，不需要存储，则可以有24-1=23个字节存储字符串，除去尾部的’\0’，则实际的容量为22，这便是llvm/clang/libc++采用的实现</p><p>SSO的字符串，复制时只需简单的复制SmallString结构即可，无需在堆上分配内存</p><p>另外，他们的实现，会结合SSO、COW和eager copy的实现，因此需要标记字符串的类型，它用一个bit来区分是长字符还是短字符，然后用位操作和掩码 (mask) 来取重叠部分的数据，因此实现是最复杂的。</p><p>本文的实现，为了简单，使用一个字节来区分字符串类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallString</span> &#123;</span></span><br><span class="line">  SmallString() &#123; Init(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    data[size] = <span class="string">'\0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(const_pointer str, size_type len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">      assert(len &lt;= kMaxSmallSize);</span><br><span class="line">      size = len;</span><br><span class="line">      <span class="built_in">memcpy</span>(data, str, <span class="keyword">sizeof</span>(value_type) * len);</span><br><span class="line">      data[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint8_t</span> size;</span><br><span class="line">  value_type data[kMaxSmallSize + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/sso_string.png" alt="sso_string" title>                </div>                <div class="image-caption">sso_string</div>            </figure><h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>写时复制（Copy-on-write，简称COW）是一种很重要的优化手段。核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享资源，当需要修改时，才真正进行资源的分配</p><p>Linux内核在进程fork时对进程地址空间的处理就使用到了COW技术</p><h3 id="COW优点"><a href="#COW优点" class="headerlink" title="COW优点"></a>COW优点</h3><ul><li>减少了分配（和复制）大量资源带来的瞬间延迟（实际上该延迟被分摊到后续的操作中，其累积耗时很可能比一次统一处理的延迟要高，造成throughput下降是有可能的）</li><li>减少了不必要的资源分配。（例如只读的复制没有必要执行深拷贝）</li></ul><p>当然COW不是没有缺点，下文会进行介绍</p><h3 id="COW实现"><a href="#COW实现" class="headerlink" title="COW实现"></a>COW实现</h3><p>基于COW的思想，我们知道，在string复制时，只进行浅拷贝，而在需要修改对象时，则执行深拷贝的动作。</p><p>我们要在什么时候需要执行深拷贝？</p><ul><li>当前字符串没有被共享，则不需要拷贝</li><li>当前字符串被共享，当需要修改时，进行深拷贝的动作</li></ul><p>因此，为了区分是否被共享，我们引入一个引用计数来记录字符串被多少个string共享</p><p>引用计数一般是原子操作，保证线程安全，下文会详细介绍；引用计数需要在堆上分配，保证不同的string对象能够共享</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeString</span> &#123;</span></span><br><span class="line">  LargeString() : ref_count(<span class="number">1</span>) &#123; data[<span class="number">0</span>] = <span class="string">'\0'</span>; &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;size_type&gt; ref_count;</span><br><span class="line">  value_type data[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">StringStorage <span class="title">AllocateLargeStorage</span><span class="params">(size_type capacity)</span> </span>&#123;</span><br><span class="line">  assert(capacity &gt; kMaxMediumSize);</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = capacity;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(Allocate(LargeString::GetDataOffset() + capacity + <span class="number">1</span>)) + LargeString::GetDataOffset());</span><br><span class="line">  LargeString::ConstrctAt(store);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitLarge</span><span class="params">(const_pointer str, size_type len, size_type c = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  store_ = AllocateLargeStorage(c &gt; <span class="number">0</span> ? c : len);</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kLarge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">MutableData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 引用计数大于1，则执行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (type_ == StringType::kLarge &amp;&amp; LargeString::RefCount(store_) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    LargeString::DecRefCount(store_);</span><br><span class="line">    UnsafeInitLarge(store_.data, store_.size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> store_.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="COW在多线程中的问题"><a href="#COW在多线程中的问题" class="headerlink" title="COW在多线程中的问题"></a>COW在多线程中的问题</h1><p>像STL的其他容器一样，多线程操作共享的string不是线程安全的。但不同的线程操作不同的字符串是线程安全的。</p><p>聪明的同学立马会想到，在COW的string实现中，不同的string对象，可能共享同一块内存，那不同线程同时修改COW实现的string时，怎么保证线程安全呢？</p><p>这就要求COW的string必须能够正确的处理这种竞争条件：</p><ul><li>对引用计数进行原子操作</li><li>需要修改时，先分配和复制，再将引用计数减1（当引用计数为0时，负责释放内存）</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>比起mutex之类的同步手段，原子操作自然要轻上不少，但比起普通的算术指令，依然算得上完全的重量级</p><p>COW为了保证“线程安全”而使用了原子操作，而原子操作本身的效率并不十分高。而且在多线程环境下，多个CPU对同一个地址的原子操作开销更大。COW中”共享“的实现，反而影响了多线程环境下string”拷贝“的性能。</p><h2 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h2><p>COW中，需要修改时，先分配和复制，再将引用计数减1，这在多线程操作中，会导致不必要的分配和复制</p><p>两个线程同时操作两个string，这两个string共享同一片内存（即引用计数为2），当两个线程都需要对string修改时，他们都需要先分配和复制，再将引用计数减1（最终会有一个线程释放内存）</p><p>这时，COW一共进行了3次内存分配和复制（初始化时1次，修改时2次）和1次内存释放</p><p>但如果没有使用COW技术，从string的初始化到目前为止也只进行了2次内存分配和复制（都是在初始化时进行）</p><h1 id="COW的失效问题"><a href="#COW的失效问题" class="headerlink" title="COW的失效问题"></a>COW的失效问题</h1><p>这个问题其实是字符串接口导致的问题，string类提供了data、operator[]等接口，可以直接修改字符串本身，但由于他们返回的是指针和引用，只读操作也会导致分配和复制</p><p>这可能导致COW不能完全发挥作用，每次都是在深拷贝。</p><p>这当然可以通过重新设计接口，严格区分只读和修改造作来解决。但维护非标准接口，并非是一个简单的工作</p><h2 id="代理类区分读写操作"><a href="#代理类区分读写操作" class="headerlink" title="代理类区分读写操作"></a>代理类区分读写操作</h2><p>区分读写的另一种方式是，定义CharProxy类，operator[]返回CharProxy，在对CharProxy赋值时，才执行分配和复制</p><p>但这也会增加编码的复杂度</p><h1 id="fbstring"><a href="#fbstring" class="headerlink" title="fbstring"></a>fbstring</h1><p>Fackbook的开源库folly中提供了fbstring，它是std::string的替代。其对string类的设计进行了许多优化</p><ul><li>将字符串区分为small/medium/large，针对他们分别采用SSO、eager copy和COW的策略（使用capacity最高位的4个bits来判断string的种类）<ul><li>small：结构体长度为24字节，减去末尾的1字节（用来表示长度）和为结束符’\0’（data()和c_str()方法的需要）预留的1字节，可以放置22字节的有效长度</li><li>medium：不超过255字节</li><li>large：超过255字节</li></ul></li><li>word-wise copy（逐字拷贝）</li><li>直接使用malloc/free，并在使用jemalloc时，使用非标准扩展接口来提高性能</li><li>末尾’\0’的处理：平时预留空间，在调用data或c_str时，才添加’\0’，避免了每次修改字符串时的额外开销</li><li>find使用BM算法</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/1792179/" target="_blank" rel="noopener">Effective STL中文版</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html" target="_blank" rel="noopener">std::string的Copy-on-Write：不如想象中美好</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html" target="_blank" rel="noopener">漫步Facebook开源C++库folly：string类的设计</a></li><li><a href="https://www.cnblogs.com/cthon/p/9181979.html" target="_blank" rel="noopener">c++再探string之eager-copy、COW和SSO方案</a></li><li><a href="https://github.com/facebook/folly" target="_blank" rel="noopener">folly</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;string概述&quot;&gt;&lt;a href=&quot;#string概述&quot; class=&quot;headerlink&quot; title=&quot;string概述&quot;&gt;&lt;/a&gt;string概述&lt;/h1&gt;&lt;p&gt;string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="字符串" scheme="https://gwq5210.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://gwq5210.com/2021/11/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://gwq5210.com/2021/11/14/智能指针/</id>
    <published>2021-11-14T20:18:54.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>了解智能指针前，我们先了解下C++编程中常用的RAII的思想</p><p>RAII全称为Resource Acquisition is Initialization，直译就是资源获取即初始化。</p><p>它的思想是将必须在使用前获取的资源（堆内存，线程，文件，互斥锁等）与一个对象的声明周期绑定，常用做法是在构造函数中请求资源，在析构函数中释放资源</p><p>以上由C++的语言机制保证，当对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数</p><p>智能指针就是使用RAII思想的例子</p><h1 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h1><p>智能指针本质是模板类独享，其行为类似指针。其最主要的功能是帮助管理动态内存，防止发生内存泄漏</p><p>C++提供了四种智能指针</p><ul><li>auto_ptr(C++11废弃，C++17移除)</li><li>unique_ptr(C++11)：独占智能指针</li><li>shared_ptr(C++11)：引用计数智能指针</li><li>weak_ptr(C++11)：弱引用智能指针，解决shared_ptr的循环引用，不能访问直接访问对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="comment">// p析构时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto_ptr是C++98提供的，现已废弃，应使用unique_ptr或shared_ptr替代</p><p>考虑如下情况，将p赋值给p2会发生什么？</p><p>按照常规指针的做法，p2和p会指向同一个对象，但是如果这样，p2和p在析构时会释放两次内存，这当然是不可行的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">  p2 = p; <span class="comment">// 会发生什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上问题，有如下解决方案</p><ul><li>执行深拷贝，但这会造成两个指针指向不同对象</li><li>建立所有权（ownership）的概念，仅可以让一个智能指针拥有该对象，该智能指针析构时执行内存释放操作。赋值操作将所有权转移。<ul><li>auto_ptr和unique_ptr都采用此策略，unique_ptr的策略更加严格</li></ul></li><li>使用引用计数，记录有多少个智能指针指向该对象，当引用计数变为0时，执行内存释放操作<ul><li>shared_ptr采用此策略</li></ul></li></ul><h1 id="auto-ptr使用"><a href="#auto-ptr使用" class="headerlink" title="auto_ptr使用"></a>auto_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>auto_ptr对象的复制构造和赋值会转移所有权</li><li>作为参数不要按值传递</li><li>auto_ptr不支持数组</li><li>无法作为STL容器的元素，auto_ptr的复制构造和赋值要求参数左值引用</li><li>仅支持new分配的内存</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">p2 = p; <span class="comment">// p的所有权被转移给p2，p不再有效</span></span><br><span class="line">*p = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递，调用时会将所有权转移给临时对象p3，函数结束时将内存释放</span></span><br><span class="line"><span class="comment">// 这里应采用按引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, *p3);</span><br><span class="line">&#125;</span><br><span class="line">test(p2);</span><br><span class="line">*p2 = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line">auto_ptr&lt;double[]&gt; pa(new double[100]()); // bad</span><br></pre></td></tr></table></figure><h2 id="auto-ptr实现"><a href="#auto-ptr实现" class="headerlink" title="auto_ptr实现"></a>auto_ptr实现</h2><ul><li>auto_ptr的复制构造函数和赋值运算符要求左值引用</li><li>需要考虑右值的构造和赋值，通过AutoPtrRef的方式实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoPtrRef</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtrRef</span><span class="params">(T* p)</span> : <span class="title">ptr</span><span class="params">(p)</span> </span>&#123;&#125;</span><br><span class="line">  T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  AutoPtr(AutoPtr&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  <span class="comment">// 为了实现右值的初始化</span></span><br><span class="line">  AutoPtr(AutoPtrRef&lt;element_type&gt; ref) : data_(ref.ptr) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr(AutoPtr&lt;Y&gt;&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  ~AutoPtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;Y&gt;&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&lt;Y&gt;&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtrRef&lt;Y&gt; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtrRef&lt;Y&gt; other)\n"</span>);</span><br><span class="line">    reset(other.ptr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">element_type* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  element_type* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtrRef&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtrRef&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtr&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtr&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type* ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data_;</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  element_type* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr使用"><a href="#unique-ptr使用" class="headerlink" title="unique_ptr使用"></a>unique_ptr使用</h1><p>相比于auto_ptr，unique_ptr有如下优点</p><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>禁用拷贝构造函数和赋值运算符</li><li>使用移动语义std::move转移所有权</li><li>使用移动语义可以作为STL容器的元素，但某些需要拷贝和赋值的算法操作会受限</li><li>支持数组，并提供operator[]，使用delete[]释放内存</li><li>支持自定义deleter</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">"student1"</span>;</span><br><span class="line">  <span class="keyword">double</span> score = <span class="number">100.0</span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Student&gt; <span class="title">p</span><span class="params">(gtl::make_unique&lt;Student&gt;(name, score))</span></span>;</span><br><span class="line">  <span class="keyword">auto</span>* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(name, p-&gt;name());</span><br><span class="line">  EXPECT_EQ(score, p-&gt;score());</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p))</span></span>;</span><br><span class="line">  EXPECT_EQ(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line">  p2 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line"></span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; p3;</span><br><span class="line">  p3 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 支持数组指针即使用new[]/delete[]</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person[]&gt; p = gtl::make_unique&lt;Person[]&gt;(n);</span><br><span class="line">  Person* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line">  p = <span class="built_in">std</span>::move(p);</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    p[i].set_name(<span class="built_in">std</span>::to_string(i));</span><br><span class="line">    EXPECT_EQ(<span class="built_in">std</span>::to_string(i), p[i].name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h1><ul><li>unique_ptr存在针对对象和数组的两个版本<ul><li>分别使用new/delete和new[]/delete[]</li></ul></li><li>需要支持自定义deleter</li><li>禁用拷贝构造函数和赋值运算符</li><li>定义移动构造函数和移动复制运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = <span class="built_in">std</span>::default_delete&lt;T&gt;&gt;</span><br><span class="line">class UniquePtr &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  explicit UniquePtr(pointer data = nullptr, deleter_type deleter = deleter_type()) : data_(data), deleter_(deleter) &#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr(UniquePtr&lt;Y&gt;&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.get_deleter())) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span>&lt;T[], Deleter&gt; &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    Destroy();</span><br><span class="line">    data_ = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr使用"><a href="#shared-ptr和weak-ptr使用" class="headerlink" title="shared_ptr和weak_ptr使用"></a>shared_ptr和weak_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>shared_ptr是共享所有权的智能指针，使用上更像普通指针</li><li>支持数组（C++17）</li><li>注意循环引用——将任一shared_ptr替换为weak_ptr打破循环即可</li><li>weak_ptr无法访问其所管理的资源，其是为了解决循环引用的问题，weak_ptr不会增加引用计数<ul><li>weak_ptr可以通过expired函数判断对应的资源是否已经释放</li><li>访问所管理的对象必须通过lock函数返回一个shared_ptr对象（注意判断返回值是否为空，可能其所对应的资源已经释放）</li></ul></li><li>线程安全问题<ul><li>多个线程在不同shared_ptr的实例上调用所有成员函数（包含复制构造和赋值）是安全的，即使他们共享同一个对象的所有权</li><li>多个线程只读方式访问同一个shared_ptr的实例是安全的</li><li>多个线程访问同一个shared_ptr的实例的非const成员函数是不安全的，会出现数据竞争</li><li>所拥有资源的线程安全由资源本身决定</li></ul></li></ul><p>循环引用的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> score_;</span><br><span class="line">  SharedPtr&lt;Teacher&gt; teacher_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">  SharedPtr&lt;Student&gt; student_;</span><br><span class="line">  WeakPtr&lt;Student&gt; student_weak_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// teacher包含student，student包含teacher，会造成循环引用</span></span><br><span class="line">  <span class="comment">// 析构时引用数都不会变为0，造成内存泄漏</span></span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">1</span>);</span><br><span class="line">  teacher-&gt;set_student(student);</span><br><span class="line">  student-&gt;set_teacher(teacher);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  gtl::WeakPtr&lt;Student&gt; student_weak_bak;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher_weak</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher_weak"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student_weak</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student_weak"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    teacher_weak-&gt;set_student_weak(student_weak);</span><br><span class="line">    student_weak-&gt;set_teacher(teacher_weak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">2</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    student_weak_bak = student_weak;</span><br><span class="line">    EXPECT_EQ(student_weak_bak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak_bak.expired(), <span class="literal">false</span>);</span><br><span class="line">    EXPECT_EQ(<span class="keyword">bool</span>(student_weak_bak.lock()), <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, student_weak.get());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"weak test\n"</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.use_count(), <span class="number">0</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.expired(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">auto</span> stucent_shared_ptr = student_weak_bak.lock();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, stucent_shared_ptr.get());</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(stucent_shared_ptr), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr实现"><a href="#shared-ptr和weak-ptr实现" class="headerlink" title="shared_ptr和weak_ptr实现"></a>shared_ptr和weak_ptr实现</h1><ul><li>shared_ptr包含指向对象的指针和引用计数的指针<ul><li>包含对象指针是为了不同的对象共享所有权</li><li>包含引用计数的指针而不是对象，是为了共享所有权的shared_ptr得到的引用计数是相同的</li></ul></li><li>引用计数包含use_count和weak_count<ul><li>由于weak_ptr需要在所有的shared_ptr都释放时也能够判断引用计数的数量是否为0，因此shared_ptr释放时，如果weak_count&gt;1，则仅可以释放所管理对象的资源，引用计数的资源不能释放</li><li>当weak_ptr析构时，需要判断是否需要释放引用计数的资源</li></ul></li><li>shared_ptr的use_count和weak_count如何变化<ul><li>以空指针构造，两个指针都为空</li><li>以非空指针构造，use_count和weak_count都设置为1</li><li>复制构造，若非空则use_count加1</li><li>移动构造use_count不变，资源转移到新构造的shared_ptr，被移动的shared_ptr变为空</li><li>赋值操作，左侧操作数use_count减1，右侧操作数use_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数use_count减1，右侧操作数use_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>shared_ptr析构，use_count减1</li><li>use_count为0时，释放所管理对象的资源，weak_count减1（为0时释放引用计数的资源）</li></ul></li><li>weak_ptr的use_count和weak_count如何变化<ul><li>默认构造，weak_ptr不管理任何对象</li><li>weak_ptr不接受普通指针构造</li><li>复制构造，若非空则weak_count加1</li><li>以shared_ptr构造，若非空则weak_count加1</li><li>移动构造，weak_count不变，被移动weak_ptr变为空</li><li>赋值操作，左侧操作数weak_count减1，右侧操作数weak_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数weak_count减1，右侧操作数weak_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>weak_ptr析构，weak_count减1</li><li>weak_count为0时，释放引用计数的资源</li><li>调用lock函数构造shared_ptr，use_count加1</li></ul></li></ul><p>具体实现可参考<a href="https://github.com/gwq5210/gtl/blob/main/gtl/memory/smart_pointers.h" target="_blank" rel="noopener">smart_pointers.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RefCount</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; use_count; <span class="comment">// 有多少个shared_ptr指向这个对象</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; weak_count; <span class="comment">// 有多少个weak_ptr指向这个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  RefCount* ref_count_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">raii</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory" target="_blank" rel="noopener">memory</a></li><li><a href="https://item.jd.com/11017238.html" target="_blank" rel="noopener">C++ Primer Plus（第6版 中文版）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RAII&quot;&gt;&lt;a href=&quot;#RAII&quot; class=&quot;headerlink&quot; title=&quot;RAII&quot;&gt;&lt;/a&gt;RAII&lt;/h1&gt;&lt;p&gt;了解智能指针前，我们先了解下C++编程中常用的RAII的思想&lt;/p&gt;
&lt;p&gt;RAII全称为Resource Acquisit
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="智能指针" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    
      <category term="智能指针" scheme="https://gwq5210.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之无序关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之无序关联容器/</id>
    <published>2021-11-14T20:17:36.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><p>无序关联容器有以下几种</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><p>无序关联容器底层由哈希表实现，下文主要对哈希表进行介绍</p><h1 id="哈希表概述"><a href="#哈希表概述" class="headerlink" title="哈希表概述"></a>哈希表概述</h1><p>哈希表的基本原理是利用数组可以随机存取的特点，通过哈希函数（hasher）将键（key_type）均匀的映射到数组的下标，这样我们可以很快的通过数组下标快速找到对应的元素</p><p>数组中的每个元素称为桶（bucket）</p><p>这样会存在两个问题：</p><ul><li>不同的键映射到了相同的数组下标</li><li>数组大小是固定的，添加了更多元素之后，如何对数组进行扩容</li></ul><h2 id="解决哈希表碰撞"><a href="#解决哈希表碰撞" class="headerlink" title="解决哈希表碰撞"></a>解决哈希表碰撞</h2><p>不同的的元素被映射到相同的数组下标，被称为碰撞。解决碰撞有许多种方法</p><ul><li>开放定址法：哈希冲突时，从冲突的位置按照一定的次序寻找一个空闲的桶。删除元素时需要进行标记，否则会导致查找错误<ul><li>线性探测：依次判断位置为i+1,i+2,i+3,到达最后一个桶时从头开始判断</li><li>二次探测：依次判断位置为i+1^2,i+2^2,i+3^2</li></ul></li><li>链地址法：哈希冲突时，冲突的元素放在链表中。可以理解为数组的每个桶都是一个链表，只是大部分的链表仅包含一个元素</li></ul><p>大部分的实现采用链地址法处理冲突</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/hashtable.png" alt="hashtable" title>                </div>                <div class="image-caption">hashtable</div>            </figure><h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>在一般的实现中，哈希桶的数量为2的次幂，这样可以通过位运算得到元素哈希桶的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type bucket_idx = hasher()(key) % bucket_count();</span><br><span class="line">size_type bucket_idx = hasher()(key) &amp; (bucket_count() - <span class="number">1</span>); <span class="comment">// 当bucket_count为2的幂时</span></span><br></pre></td></tr></table></figure><h3 id="负载因子和初始容量"><a href="#负载因子和初始容量" class="headerlink" title="负载因子和初始容量"></a>负载因子和初始容量</h3><p>首先介绍一个负载因子（load factor）的概念：即元素个数除以桶个数。</p><p>哈希表一般通过负载因子来指定扩容的临界值。例如负载因子可以设置为0.75。当元素的数量超过bucket_count*load_factor时，会触发扩容操作</p><p>哈希表另一个比较重要的概念是初始容量，即初始哈希桶的数量，插入元素较多的情况下可以指定较大的初始容量减少扩容的次数。默认初始容量可以设置为16</p><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p>哈希表的扩容也称为重新哈希（rehash），大致步骤如下</p><ul><li>以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组</li><li>遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中<ul><li>在同数量为2的次幂时，可以将桶中元素分为两部分，这两部分元素在新桶数组中的位置分别是：i和i+old_bucket_count（按照位运算很好理解）</li></ul></li><li>所有元素迁移完成之后，释放原桶数组</li></ul><p>以下例子是数组+单链表（下文介绍）的重新哈希的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_rehash</span><span class="params">(size_type new_bucket_count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 新分配桶数组</span></span><br><span class="line">  BucketStorage new_buckets = alloc_buckets(new_bucket_count);</span><br><span class="line">  SListNode old_head = head_;</span><br><span class="line">  buckets_.swap(new_buckets); <span class="comment">// 与旧桶数组交换</span></span><br><span class="line">  head_.next = <span class="literal">nullptr</span>;</span><br><span class="line">  get_size() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash new bucket count %zu %zu\n"</span>, bucket_count(), new_bucket_count);</span><br><span class="line">  SListNode* prev = &amp;old_head; <span class="comment">// 旧链表的伪头节点，便于实现</span></span><br><span class="line">  SListNode* first = prev-&gt;next;</span><br><span class="line">  <span class="comment">// 2. 遍历所有元素的链表</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    <span class="comment">// 计算链表头节点在新桶数组中的位置</span></span><br><span class="line">    <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(first));</span><br><span class="line">    size_type new_bucket_idx = bucket(key);</span><br><span class="line">    <span class="comment">// 找到相同key的元素</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, prev);</span><br><span class="line">    <span class="comment">// 将(range_res.first.before, range_res.first.node]这些元素从链表中移除</span></span><br><span class="line">    RemoveAfter(range_res.first.before, range_res.first.node);</span><br><span class="line">    <span class="comment">// 插入到新链表中并设置桶的所在元素的范围</span></span><br><span class="line">    insert_node(new_bucket_idx, buckets_[new_bucket_idx].node_before_begin ? buckets_[new_bucket_idx].node_before_begin : &amp;head_, first, range_res.first.node, range_res.second);</span><br><span class="line">    <span class="comment">// 旧链表的新头节点</span></span><br><span class="line">    first = prev-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash done. new bucket count %zu\n"</span>, bucket_count());</span><br><span class="line">  <span class="comment">// 3. 旧桶数组在作用域结束时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表的具体实现"><a href="#哈希表的具体实现" class="headerlink" title="哈希表的具体实现"></a>哈希表的具体实现</h1><p>哈希表一般有以下几种实现</p><ul><li>仅数组<ul><li>迭代元素需要遍历整个桶数组</li><li>元素迭代的顺序与插入顺序无关，与在桶中的位置有关</li><li>同一个桶内的元素以相反的顺序遍历（在头部插入）</li></ul></li><li>数组+单链表：所有的元素用单链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相反（找不到元素时在头部插入）</li><li>桶的结构中保存链表节点的指针或迭代器(before, node]</li><li>插入元素时如果更改了某个桶的尾元素node，则需要更新node-&gt;next元素所在桶的before指针</li><li>单链表包含一个伪头结点head_利于实现</li><li>swap时要更新链表头结点的before指针</li></ul></li><li>数组+双链表：所有的元素用双链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相同（找不到元素时在尾部插入）</li><li>桶的结构中保存链表节点的指针或迭代器[begin, node]</li><li>实现相较数组+单链表简单</li></ul></li></ul><p>说明</p><ul><li>以上只说明大致思路，具体的实现可能略有不同</li><li>以上针对元素key唯一的情况，key相同的情况下，相同的key元素在链表中紧邻存放(相同key的元素的迭代顺序由实现决定，可以不做保证)</li><li>哈希表是无序的，不对key进行排序</li><li>哈希表重新哈希之后元素迭代顺序会发生变化</li><li>哈希表的实现中，会提供两个函数insert_unique和insert_equal分别来实现unordered_set/unordered_map和unordered_multiset/unordered_multimap（也可通过模板特化来针对唯一key或相同key实现不同的逻辑，提升性能）</li></ul><h2 id="数组-单链表的实现介绍"><a href="#数组-单链表的实现介绍" class="headerlink" title="数组+单链表的实现介绍"></a>数组+单链表的实现介绍</h2><h3 id="数据结构结构"><a href="#数据结构结构" class="headerlink" title="数据结构结构"></a>数据结构结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span> &#123;</span></span><br><span class="line">  SListNode* next;</span><br><span class="line">  SListNode() : next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">typename</span> KeyEquel = <span class="built_in">std</span>::equal_to&lt;Key&gt;&gt;</span><br><span class="line">class HashTable &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 哈希桶的结构，链表中范围(node_before_begin, node_finish]内的节点在该桶内</span></span><br><span class="line">  struct HashNode &#123;</span><br><span class="line">    HashNode(): node_before_begin(<span class="literal">nullptr</span>), node_finish(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    HashNode(SListNode* b, SListNode* f): node_before_begin(b), node_finish(f) &#123;&#125;</span><br><span class="line">    SListNode* node_before_begin;</span><br><span class="line">    SListNode* node_finish;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ExtractKey get_key_func_;</span><br><span class="line">  key_equal key_equal_;</span><br><span class="line">  hasher hasher_;</span><br><span class="line">  SListNode head_;</span><br><span class="line">  <span class="keyword">float</span> max_load_factor_;</span><br><span class="line">  BucketStorage buckets_;</span><br><span class="line">  CompressedPair&lt;size_type, NodeAllocator&gt; size_alloc_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* first, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将新的[first, last]内的元素插入到before节点后</span></span><br><span class="line">  InsertAfter(before, first, last);</span><br><span class="line">  <span class="comment">// 更新该桶内的元素范围</span></span><br><span class="line">  buckets_[bucket_idx].insert_node(before, first, last);</span><br><span class="line">  incr_size(count);</span><br><span class="line">  <span class="comment">// 更新下一个bucket的前一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; insert_node(bool unique, const_iterator hint, Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="comment">// 原位构造元素</span></span><br><span class="line">  Node* node = NewNode(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  SListNode* prev = hint.node;</span><br><span class="line">  <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(node));</span><br><span class="line">  size_type bucket_idx = bucket(key);</span><br><span class="line">  <span class="comment">// 元素唯一的情况下，已找到元素直接结束插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev &amp;&amp; (key_equal_(get_key(Node::Value(prev)), key) || (prev-&gt;next &amp;&amp; key_equal_(get_key(Node::Value(prev-&gt;next)), key)))) &#123;</span><br><span class="line">    <span class="comment">// hint或hint-&gt;next对应元素的key与新元素的key相同，使用hint作为插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到对应元素的插入位置</span></span><br><span class="line">    FindNodeResult result = find_node(key, bucket_idx);</span><br><span class="line">    <span class="keyword">if</span> (unique &amp;&amp; result.node) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = result.before;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  insert_node(bucket_idx, prev, node);</span><br><span class="line">  <span class="comment">// 可以先添加，然后再rehash</span></span><br><span class="line">  check_for_rehash(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(node), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><h4 id="查找单节点"><a href="#查找单节点" class="headerlink" title="查找单节点"></a>查找单节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定位到哈希桶</span></span><br><span class="line">  <span class="keyword">return</span> find_node(key, bucket(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key, size_type bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">  <span class="comment">// 该桶为空直接返回未找到</span></span><br><span class="line">  <span class="keyword">if</span> (hnode.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">const_cast</span>&lt;SListNode*&gt;(&amp;head_), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依次查找该桶的元素，找到相同的key则返回</span></span><br><span class="line">  <span class="keyword">for</span> (SListNode* prev = hnode.node_before_begin; prev-&gt;next != hnode.node_finish-&gt;next; prev = prev-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key_equal_(key, get_key(Node::Value(prev-&gt;next)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;prev, prev-&gt;next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 到这里说明没找到</span></span><br><span class="line">  <span class="keyword">return</span> &#123;hnode.node_before_begin, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找范围"><a href="#查找范围" class="headerlink" title="查找范围"></a>查找范围</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;iterator, iterator&gt; equal_range(bool unique, const key_type&amp; key) &#123;</span><br><span class="line">  <span class="comment">// 先查找单个元素，未找到则直接返回</span></span><br><span class="line">  <span class="keyword">auto</span> res = find_node(key);</span><br><span class="line">  <span class="keyword">if</span> (!res.node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), iterator());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果键唯一，则找到后直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(res.node-&gt;next));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 键不唯一，从before开始查找相同key的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, res.before);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(range_res.first.node-&gt;next));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::pair&lt;FindNodeResult, size_type&gt; find_range(const key_type&amp; key, const SListNode* before) const &#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;FindNodeResult, size_type&gt; res = <span class="built_in">std</span>::make_pair(FindNodeResult(), <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 从before-&gt;next开始，直到key不相同</span></span><br><span class="line">  res.first.before = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">while</span> (before-&gt;next &amp;&amp; key_equal_(key, get_key(Node::Value(before-&gt;next)))) &#123;</span><br><span class="line">    before = before-&gt;next;</span><br><span class="line">    ++res.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时before为key的最后一个元素</span></span><br><span class="line">  res.first.node = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除单个元素的操作相对简单，这里是删除范围的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 范围为空，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到first的前一个节点before</span></span><br><span class="line">  <span class="keyword">const</span> value_type&amp; value = Node::Value(first.node);</span><br><span class="line">  size_type bucket_idx = bucket(get_key(value));</span><br><span class="line">  SListNode* before = PrevNode(buckets_[bucket_idx].node_before_begin, first.node);</span><br><span class="line">  SListNode* prev = before;</span><br><span class="line">  <span class="comment">// printf("erase range before key: %d\n", get_key(Node::Value(before)));</span></span><br><span class="line">  <span class="comment">// 遍历[first, last)的节点并删除</span></span><br><span class="line">  <span class="keyword">while</span> (prev-&gt;next != last.node) &#123;</span><br><span class="line">    HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">    SListNode* node_end = hnode.node_finish-&gt;next;</span><br><span class="line">    <span class="comment">// printf("erase begin\n");</span></span><br><span class="line">    size_type count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断该桶内元素删除的范围</span></span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != node_end &amp;&amp; prev-&gt;next != last.node) &#123;</span><br><span class="line">      <span class="comment">// printf("erase range key: %d\n", Node::Value(prev-&gt;next));</span></span><br><span class="line">      prev = prev-&gt;next;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行元素的删除</span></span><br><span class="line">    erase_node(bucket_idx, before, prev, count);</span><br><span class="line">    prev = before;</span><br><span class="line">    <span class="comment">// printf("bucket %zu size %zu\n", bucket_idx, hnode.size());</span></span><br><span class="line">    <span class="comment">// 已经删除完毕，break</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == last.node) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个删除元素的桶位置</span></span><br><span class="line">    bucket_idx = bucket(get_key(Node::Value(prev-&gt;next)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是最后一个元素，则下一个bucket的前一个节点需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = before;</span><br><span class="line">  &#125;</span><br><span class="line">  SListNode* first = before-&gt;next;</span><br><span class="line">  SListNode* next = first-&gt;next;</span><br><span class="line">  <span class="comment">// 更新该桶节点的范围</span></span><br><span class="line">  buckets_[bucket_idx].erase_node(before, last);</span><br><span class="line">  <span class="comment">// 将元素从链表中删除</span></span><br><span class="line">  RemoveAfter(before, last);</span><br><span class="line">  <span class="comment">// 更新size</span></span><br><span class="line">  incr_size(-count);</span><br><span class="line">  <span class="comment">// 析构节点并释放内存</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    next = first-&gt;next;</span><br><span class="line">    DeleteNode(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作</h3><p>上文已介绍</p><h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>可直接使用单链表的迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = SListIteratorBase;</span><br><span class="line">  SListNode* node;</span><br><span class="line">  SListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  SListIteratorBase(SListNode* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    SListNode* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Difference = <span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">struct SListConstIterator : <span class="keyword">public</span> SListIteratorBase &#123;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">const</span> T&amp;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">const</span> T*;</span><br><span class="line">  <span class="keyword">using</span> difference_type = Difference;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> Node = singly_list::SListNodeT&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> Base = SListIteratorBase;</span><br><span class="line">  <span class="keyword">using</span> Self = SListConstIterator;</span><br><span class="line">  SListConstIterator(): Base() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SListConstIterator</span><span class="params">(<span class="keyword">const</span> SListNode* node)</span> : <span class="title">Base</span><span class="params">(<span class="keyword">const_cast</span>&lt;SListNode*&gt;(node))</span> </span>&#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Node::Value(node); &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><ul><li>无重新哈希：无序关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</li><li>插入元素导致重新哈希：迭代器（包括end迭代器）非法化，引用有效</li></ul><h1 id="无序关联式容器的注意事项"><a href="#无序关联式容器的注意事项" class="headerlink" title="无序关联式容器的注意事项"></a>无序关联式容器的注意事项</h1><ul><li>unordered_map的operator[]可能会新增元素</li><li>无序关联式容器的元素没有顺序</li><li>删除元素时注意迭代器失效的问题；代码<code>unordered_map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改unordered_map/unordered_multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" target="_blank" rel="noopener">HashMap&amp;HashSet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h1&gt;&lt;p&gt;无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="无序关联容器" scheme="https://gwq5210.com/tags/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之关联容器/</id>
    <published>2021-11-14T20:16:41.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><p>关联容器有以下几种</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h1><p>关联容器的内部由红黑树实现，红黑树是一颗平衡的二叉搜索树（BST，Binary Search Tree）</p><p>在二叉搜索树中，任何节点的值一定大于左子树每一个节点的键值，小于右子树中每一个节点的键值</p><p>但是在极端的情况下，二叉搜索树可能失去平衡，退化为一个链表，造成查找效率低下。因此出现了平衡二叉搜索树，如AVL-tree，红黑树等</p><p>STL的红黑树实现中，会提供两个函数insert_unique和insert_equal分别来实现set/map和multiset/multimap</p><p>由于实现的特性，关联式容器是根据键值有序的，默认从小到大排序（使用std::less<t>进行比较）</t></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/rbtree.png" alt="rbtree" title>                </div>                <div class="image-caption">rbtree</div>            </figure><h2 id="为什么选择红黑树"><a href="#为什么选择红黑树" class="headerlink" title="为什么选择红黑树"></a>为什么选择红黑树</h2><p>AVL树要求每个节点的左右子树高度差不超过1，因此其最坏的查找时间为O(logn)</p><p>但为了严格满足AVL树的高度要求，在每次插入或删除节点时，几乎都会破坏AVL树的平衡，进而我们需要通过旋转来使之平衡</p><p>显然这对插入，删除频繁的场景很不友好，性能大大降低</p><p>而红黑树的高度要求不像AVL树那样严格，频繁插入删除不会频繁破坏平衡，也就不需要频繁调整，这其实是一种折中的方案</p><p>但仅从查找效率来说，AVL树要由于红黑树</p><p>总的来说：平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况</p><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><p>关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</p><h1 id="关联式容器的注意事项"><a href="#关联式容器的注意事项" class="headerlink" title="关联式容器的注意事项"></a>关联式容器的注意事项</h1><ul><li>map的operator[]可能会新增元素</li><li>关联式容器实现了lower_bound，upper_bound和equal_range的成员函数<ul><li>使用通用的lower_bound，upper_bound和equal_range函数会导致查找效率变低（用在非随机存取迭代器上都会导致效率变低）</li></ul></li><li>删除元素时注意迭代器失效的问题；代码<code>map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改map/multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">平衡树和红黑树</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联容器&quot;&gt;&lt;a href=&quot;#关联容器&quot; class=&quot;headerlink&quot; title=&quot;关联容器&quot;&gt;&lt;/a&gt;关联容器&lt;/h1&gt;&lt;p&gt;关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。&lt;/p&gt;
&lt;p&gt;关联容器有以下几种&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="关联容器" scheme="https://gwq5210.com/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之priority_queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bpriority-queue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之priority-queue/</id>
    <published>2021-10-26T00:15:50.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元素</p><p>可以通过模板参数Compare更改顺序，默认使用std::less<t>进行比较，返回最大元素</t></p><p>priority_queue的底层用堆实现</p><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>堆并不属于容器组件，是一个数据结构，堆实际上是一个完全二叉树（整个二叉树除了最底层的叶节点外，是填满的），并且每个节点的键值都大于等于/小于等于其父节点的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/heap.png" alt="heap" title>                </div>                <div class="image-caption">heap</div>            </figure><p>由于二叉树的性质，我们可以使用数组来表示一个二叉堆(假设下标从0开始)</p><ul><li>下标为i的节点的子节点为<code>2*i+1</code>和<code>2*i+2</code></li><li>下标为i的节点的父节点为<code>(i-1)/2</code></li></ul><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>在已有的堆中插入元素，一般在堆最下层最右边的叶子之后插入一个元素（或者新增一层）</p><p>插入新元素之后，可能不满足堆的性质，这时候需要进行向上调整（sift_up）的操作</p><ul><li>如果这个节点的值大于父节点的值，则与父节点进行交换，重复次过程直到满足堆的条件或者到达根</li></ul><p>向上调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span> &amp;&amp; arr[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[i]; i = (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作是删除堆的最大元素，一般将最大元素即根节点与最后一个节点交换，再将新的根节点进行向下调整（sift_down）的操作</p><ul><li>在该节点的儿子中选择较大节点与该节点进行交换，重复此操作直到底层或已满足堆的条件</li></ul><p>向下调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; n / <span class="number">2</span>; i = <span class="number">2</span> * x + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= arr[j]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h2><h3 id="向上调整建堆"><a href="#向上调整建堆" class="headerlink" title="向上调整建堆"></a>向上调整建堆</h3><p>即相当于每次在堆的结尾添加一个元素，比较好理解</p><p>复杂度为log1+log2+…+logn=O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    sift_up(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下调整建堆"><a href="#向下调整建堆" class="headerlink" title="向下调整建堆"></a>向下调整建堆</h3><p>从叶子开始建堆，逐个向下调整，相当于每次”合并”两个已经调整好的堆</p><p>复杂度为O(n)，每个节点最多向下调整一次，只需要从最后一个非叶子结点进行调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    sift_down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆操作算法"><a href="#堆操作算法" class="headerlink" title="堆操作算法"></a>堆操作算法</h1><p>STL提供了以下几个算法，可以方便的实现优先队列</p><h2 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h2><p>将位置<code>last-1</code>的元素插入到<code>[first, last - 1)</code>定义的堆中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    gtl::sift_up(first, last, gtl::distance(first, last) - <span class="number">1</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::push_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h2><p>交换在位置<code>first</code>的值和位置<code>last-1</code>的值，并将范围<code>[first, last-1)</code>调整为堆</p><p>这达到将范围<code>[first, last)</code>所定义的堆移除首个元素的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    --last;</span><br><span class="line">    gtl::iter_swap(first, last);</span><br><span class="line">    gtl::sift_down(first, last, <span class="number">0</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::pop_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>将最大堆<code>[first, last)</code>转换为为以升序排序的序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; --last) &#123;</span><br><span class="line">    gtl::pop_heap(first, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::sort_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>在范围<code>[first, last)</code>中构造最大堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = gtl::distance(first, last) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      gtl::sift_down(first, last, i, comp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::make_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap-until"><a href="#is-heap-until" class="headerlink" title="is_heap_until"></a>is_heap_until</h2><p>检验范围<code>[first, last)</code>并寻找始于<code>first</code>且为最大堆的最大范围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> n = gtl::distance(first, last);</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::difference_type i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> it = first;</span><br><span class="line">  <span class="keyword">auto</span> left_it = first + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n / <span class="number">2</span>; ++i, ++it, ++left_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">    ++left_it;</span><br><span class="line">    <span class="keyword">if</span> (left_it &lt; last &amp;&amp; comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap"><a href="#is-heap" class="headerlink" title="is_heap"></a>is_heap</h2><p>检查范围 [first, last) 中的元素是否为最大堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, comp) == last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h1><p>有了堆的操作算法，很容易通过这些算法实现优先队列</p><p>具体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = <span class="built_in">std</span>::less&lt;T&gt;, <span class="keyword">typename</span> Container = Vector&lt;T&gt;&gt;</span><br><span class="line">class PriorityQueue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                        <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  PriorityQueue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  PriorityQueue(InputIt first, InputIt last) : c_(first, last) &#123;</span><br><span class="line">    gtl::make_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(v);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(<span class="built_in">std</span>::move(v));</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gtl::pop_heap(c_.begin(), c_.end());</span><br><span class="line">    c_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(PriorityQueue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">  Compare compare_;</span><br><span class="line">&#125;;  <span class="comment">// class PriorityQueue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">算法库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://oi-wiki.org/ds/binary-heap/" target="_blank" rel="noopener">二叉堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先队列&quot;&gt;&lt;a href=&quot;#优先队列&quot; class=&quot;headerlink&quot; title=&quot;优先队列&quot;&gt;&lt;/a&gt;优先队列&lt;/h1&gt;&lt;p&gt;与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="优先队列" scheme="https://gwq5210.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bqueue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之queue/</id>
    <published>2021-10-26T00:15:39.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h1><p>queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许在一个入口(队尾)添加元素，在另一个入口(队头)获取和删除元素</p><p>queue不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/queue.png" alt="queue" title>                </div>                <div class="image-caption">queue</div>            </figure><p>通常使用deque来作为queue的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此queue往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改queue的底层容器</p><h1 id="queue实现"><a href="#queue实现" class="headerlink" title="queue实现"></a>queue实现</h1><p>queue的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Queue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Queue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Queue(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line">  ~Queue() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_front(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Queue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Queue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;queue概述&quot;&gt;&lt;a href=&quot;#queue概述&quot; class=&quot;headerlink&quot; title=&quot;queue概述&quot;&gt;&lt;/a&gt;queue概述&lt;/h1&gt;&lt;p&gt;queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="队列" scheme="https://gwq5210.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之stack</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bstack/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之stack/</id>
    <published>2021-10-26T00:15:34.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stack概述"><a href="#stack概述" class="headerlink" title="stack概述"></a>stack概述</h1><p>stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出口。</p><p>stack不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/stack.png" alt="stack" title>                </div>                <div class="image-caption">stack</div>            </figure><p>stack是一种很简单的数据接口，只允许在栈顶新增，删除，获取元素</p><p>通常使用deque来作为stack的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此stack往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改stack的底层容器</p><h1 id="stack实现"><a href="#stack实现" class="headerlink" title="stack实现"></a>stack实现</h1><p>stack的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Stack() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Stack(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  reference top() &#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_back(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Stack&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Stack</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stack概述&quot;&gt;&lt;a href=&quot;#stack概述&quot; class=&quot;headerlink&quot; title=&quot;stack概述&quot;&gt;&lt;/a&gt;stack概述&lt;/h1&gt;&lt;p&gt;stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="栈" scheme="https://gwq5210.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之deque</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之deque/</id>
    <published>2021-10-26T00:15:29.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快速插入或删除数据。与vector的连续空间存储不同，deque的元素可能不是相邻存储的</p><p>vecotr也允许在头尾两端添加或删除数据，但可能会涉及到元素的移动和扩容，导致效率不高</p><p>deque的迭代器也提供随机存储功能，但与vector的迭代器是普通指针不同，为了实现随机存取，deque的迭代器实现比较复杂</p><p>deque的存储按需自动扩展及收缩。deque的扩容相比vector更优，它既不会涉及到元素的移动，也不会过多的浪费存储空间</p><h2 id="deque常见操作的复杂度"><a href="#deque常见操作的复杂度" class="headerlink" title="deque常见操作的复杂度"></a>deque常见操作的复杂度</h2><ul><li>随机访问——常数 O(1)</li><li>在结尾或起始插入或移除元素——常数 O(1)</li><li>插入或移除元素——线性 O(n)</li></ul><h1 id="deque的实现"><a href="#deque的实现" class="headerlink" title="deque的实现"></a>deque的实现</h1><p>deque由一段一段固定大小的连续空间组成，扩容时，便在deque的首或尾新增一个固定大小的连续空间，这就需要额外的结构来串联起这一段段的固定大小空间</p><p>同时为了实现随机存取的接口，则实现了复杂的迭代器架构</p><p>deque采用的是两层架构，采用map（与STL的map不同），记录有多少个固定的连续空间，其中的每个元素称为节点缓冲区，存储实际的元素。</p><p>有的实现我们可以指定固定缓冲区的大小</p><p>这就意味着为了访问真实的元素，必须先定为到节点缓冲区，然后再定位到元素本身，需要进行两次指针访问，而vector只需要一次指针访问</p><p>map中的节点缓冲区满时，需要重新分配map本身的区域，移动原有的节点缓冲区到新的map区域，但这代价很小，仅仅是移动指针而已</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/deque.png" alt="deque" title>                </div>                <div class="image-caption">deque</div>            </figure><p>deque的数据结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  map_pointer <span class="built_in">map</span>; <span class="comment">// 记录节点缓冲区</span></span><br><span class="line">  size_type map_size; <span class="comment">// map可以容纳多少个缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>通过deque的结构可以知道，deque的迭代器至少需要保存两个信息：当前元素在哪个节点缓冲区；当前元素在这个缓冲区的哪个位置</p><p>如可能的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      ++cur;</span><br><span class="line">      <span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 到达该节点缓冲区的尾部就切换到下一个缓冲区</span></span><br><span class="line">        set_node(node + <span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* cur; <span class="comment">// 当前元素</span></span><br><span class="line">  T* first; <span class="comment">// 当前节点缓冲区的第一个元素</span></span><br><span class="line">  T* last; <span class="comment">// 当前节点缓冲区的尾，包含备用空间</span></span><br><span class="line">  map_pointer node; <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代器的失效"><a href="#迭代器的失效" class="headerlink" title="迭代器的失效"></a>迭代器的失效</h2><ul><li>在队列中间的插入操作导致所有迭代器和引用失效——可能涉及到元素移动或map中控器扩容</li><li>在队列头尾插入操作会导致迭代器失效——可能涉及map中控器扩容，但不会非法化引用</li><li>在队列中间擦除操作导致所有迭代器和引用失效——涉及元素移动</li><li>在队列头尾擦除操作导致擦除元素的迭代器失效（在尾部删除还会导致end迭代器失效），但不会非法化未擦除元素的引用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/deque" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deque概述&quot;&gt;&lt;a href=&quot;#deque概述&quot; class=&quot;headerlink&quot; title=&quot;deque概述&quot;&gt;&lt;/a&gt;deque概述&lt;/h1&gt;&lt;p&gt;deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="双端队列" scheme="https://gwq5210.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之list</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Blist/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之list/</id>
    <published>2021-10-26T00:15:25.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h1><p>不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针进行关联</p><p>同时list也不会浪费空间(实际上会多占用前后指针的空间)，有多少个元素就占用多少空间</p><p>list的元素插入是常数级别，但无法想vector一样实现随机元素访问</p><p>在list内添加，删除或移动元素不会导致已有迭代器失效或引用非法，对应元素被删除时该迭代器失效或引用非法</p><h1 id="list的实现"><a href="#list的实现" class="headerlink" title="list的实现"></a>list的实现</h1><h2 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h2><p>list本身和list的节点是不同的结构，常见的list节点如下，包含前后指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要实现一个通用的链表需要使用模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  ListNode* prev;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h2><p>在STL的list实现中，list不仅是一个双向链表，还是一个环形双向链表</p><p>实现list的一个技巧是添加一个虚拟的空白节点，让list的end迭代器指向该空白节点，既符合STL迭代器前闭后开的要求，也方便了编程的实现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/list.png" alt="list" title>                </div>                <div class="image-caption">list</div>            </figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  List() &#123;</span><br><span class="line">    dummy_head_ = node_allocator::allocate(); <span class="comment">// 分配一个空间，不设置值</span></span><br><span class="line">    dummy_head_-&gt;prev = dummy_head_; <span class="comment">// 头尾都指向自己</span></span><br><span class="line">    dummy_head_-&gt;next = dummy_head_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_-&gt;next; &#125; <span class="comment">// begin是next节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_; &#125; <span class="comment">// end是虚拟节点自身</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ListNode&lt;T&gt;* dummy_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>由于list的特殊实现方式，因此我们需要实现一个list的迭代器，允许用户遍历list中保存的元素</p><p>迭代器的表现类似指针，list的迭代器是双向迭代器，支持++和–操作，同时要实现*和-&gt;运算符</p><p>典型的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::bidirectional_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = ListIteratorBase;</span><br><span class="line">  ListNode&lt;T&gt;* node;</span><br><span class="line">  ListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  ListIteratorBase(ListNode&lt;T&gt;* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ++it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// --it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> node-&gt;data; &#125;</span><br><span class="line">  <span class="comment">// *(*this) *this即为迭代器本身，则第一个*为调用迭代器的operator*，返回数据的引用</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/list" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list概述&quot;&gt;&lt;a href=&quot;#list概述&quot; class=&quot;headerlink&quot; title=&quot;list概述&quot;&gt;&lt;/a&gt;list概述&lt;/h1&gt;&lt;p&gt;不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="链表" scheme="https://gwq5210.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之空间配置器</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之空间配置器/</id>
    <published>2021-10-26T00:12:46.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了</p><p>allocator为什么叫做空间配置器，不叫内存配置器？因为allocator的实现不仅可以从内存分配空间，也可以从磁盘分配空间</p><p>在STL容器的实现中，每个容器都有一个模板参数，可以指定使用的空间配置器</p><p>allocator包含以下类型</p><ul><li>value_type：T</li><li>pointer (C++17 中弃用)(C++20 中移除)：T*</li><li>const_pointer (C++17 中弃用)(C++20 中移除)：const T*</li><li>reference (C++17 中弃用)(C++20 中移除)：T&amp;</li><li>const_reference (C++17 中弃用)(C++20 中移除)：const T&amp;</li><li>size_type：std::size_t</li><li>difference_type：std::ptrdiff_t</li></ul><p>allocator主要包含以下成员函数</p><ul><li>allocate：分配未初始化的存储</li><li>deallocate：解分配存储</li><li>construct(C++17 中弃用)(C++20 中移除)：在分配的存储构造对象</li><li>destroy (C++17 中弃用)(C++20 中移除)：析构在已分配存储中的对象</li></ul><p>在C++的头文件<code>&lt;memory&gt;</code>中定义了一些与未初始化内存相关的函数，在STL容器的实现中，起到了很大的作用，如construct_at(C++20)，uninitialized_copy，uninitialized_fill等</p><h1 id="空间配置器在STL容器中的应用"><a href="#空间配置器在STL容器中的应用" class="headerlink" title="空间配置器在STL容器中的应用"></a>空间配置器在STL容器中的应用</h1><p>STL容器的实现思想中，实际上将空间的分配/释放和对象的构造/析构进行了拆分：空间配置器负责空间的分配/释放；<code>&lt;memory&gt;</code>中的未初始化内存相关的函数负责对象构造/析构，移动等</p><p>能够实现上述拆分，主要由于C++的以下特性</p><ul><li>operator new只进行内存分配，不进行对象构造</li><li>placement new是operator new的一个特殊版本，在已分配的内存上构造对象</li><li>new关键字的作用是：调用operator new，并调用对象的构造函数</li></ul><p>以下两种代码实际上是等价的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name): name_(name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  ~Test() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destroy %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码1</span></span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">new</span> Test(<span class="string">"new_test"</span>);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码2</span></span><br><span class="line">    <span class="keyword">void</span>* p = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">reinterpret_cast</span>&lt;Test*&gt;(p);</span><br><span class="line">    t-&gt;Test::Test(<span class="string">"allocator_test"</span>);</span><br><span class="line">    <span class="comment">// auto* t = new (p) Test("allocator_test"); // placement new</span></span><br><span class="line">    t-&gt;~Test();</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">construct new_test</span></span><br><span class="line"><span class="comment">destroy new_test</span></span><br><span class="line"><span class="comment">construct allocator_test</span></span><br><span class="line"><span class="comment">destroy allocator_test</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="未初始化内存算法的实现"><a href="#未初始化内存算法的实现" class="headerlink" title="未初始化内存算法的实现"></a>未初始化内存算法的实现</h1><p>有了上述基础，可以实现简单的未初始化内存的算法，更多实现参见<a href="https://github.com/gwq5210/gtl/blob/main/gtl/algorithm/gtl_memory.h" target="_blank" rel="noopener">gtl_memory.h</a></p><p>construct_at用到了std::forward的完美转发（C++11），两次强制转换是为了除去cv限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在给定地址 p 创建以参数 args... 初始化的 T 对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T* <span class="title">construct_at</span><span class="params">(T* p, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  ::<span class="keyword">new</span> (<span class="keyword">const_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>*&gt;(p))) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁指针p指向的对象</span></span><br><span class="line"><span class="comment"> * 若 T 不是数组类型，则调用 p 所指向对象的析构函数，如同用 p-&gt;~T()</span></span><br><span class="line"><span class="comment"> * 若 T 是数组类型，则按顺序递归地销毁 *p 的元素，如同通过调用 std::destroy(std::begin(*p), std::end(*p))</span></span><br><span class="line"><span class="comment"> * C++17 version:</span></span><br><span class="line"><span class="comment"> * template&lt;class T&gt; void destroy_at(T* p) &#123; p-&gt;~T(); &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 指向要被销毁的对象的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_at</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_array_v&lt;T&gt;)</span> </span>&#123;  <span class="comment">// C++ 20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : *p) &#123;</span><br><span class="line">      gtl::destroy_at(gtl::addressof(v));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;~T();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first, ++d_first) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range_n</span><span class="params">(InputIt first, SizeType count, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; ++first, ++d_first, --count) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制来自范围 [first, last) 的元素到始于 d_first 的未初始化内存</span></span><br><span class="line"><span class="comment"> * 若初始化中抛异常，则以未指定顺序销毁已构造的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return ForwardIt 指向最后复制的元素后一元素的迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 处理异常的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> input_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> forward_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">return</span> gtl::uninitialized_copy_range(first, last, d_first, input_iterator_category(), forward_iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">std::allocator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;空间配置器&quot;&gt;&lt;a href=&quot;#空间配置器&quot; class=&quot;headerlink&quot; title=&quot;空间配置器&quot;&gt;&lt;/a&gt;空间配置器&lt;/h1&gt;&lt;p&gt;从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了
      
    
    </summary>
    
      <category term="STL" scheme="https://gwq5210.com/categories/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/categories/STL/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://gwq5210.com/2021/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/26/设计模式之适配器模式/</id>
    <published>2021-10-26T00:08:42.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器</p><p>适配器模式的定义为：将一个类的接口转换为另一个类的接口，使原本因接口不兼容而不能工作的类可以一起工作</p><p>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>在很多业务场景中符合开闭原则。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h1 id="适配器的实现"><a href="#适配器的实现" class="headerlink" title="适配器的实现"></a>适配器的实现</h1><p>适配器模式（Adapter）包含以下主要角色。</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h2 id="类适配器实现"><a href="#类适配器实现" class="headerlink" title="类适配器实现"></a>类适配器实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口。</p><p>Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/class_adapter.gif" alt="class_adapter" title>                </div>                <div class="image-caption">class_adapter</div>            </figure><h2 id="对象适配器实现"><a href="#对象适配器实现" class="headerlink" title="对象适配器实现"></a>对象适配器实现</h2><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/object_adapter.gif" alt="object_adapter" title>                </div>                <div class="image-caption">object_adapter</div>            </figure><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>在STL中有三种容器适配器，这里不过多介绍</p><ul><li><a href="/2021/10/26/STL容器之queue/">stack</a></li><li><a href="/2021/10/26/STL容器之stack/">queue</a></li><li><a href="/2021/10/26/STL容器之priority-queue/">priority_queue</a></li></ul><h1 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h1><ul><li>reverse_iterator: 逆序遍历的迭代器适配器(类模板)</li><li>make_reverse_iterator(C++14): 创建拥有从实参推出的类型的 std::reverse_iterator(函数模板)</li><li>move_iterator(C++11): 解引用结果为右值引用的迭代器适配器(类模板)</li><li>make_move_iterator(C++11): 创建拥有从实参推出的类型的 std::move_iterator(函数模板)</li><li>back_insert_iterator: 用于在容器尾部插入的迭代器适配器(类模板)</li><li>back_inserter: 创建拥有从实参推出的类型的 std::back_insert_iterator(函数模板)</li><li>front_insert_iterator: 用于在容器头部插入的迭代器适配器(类模板)</li><li>front_inserter: 创建拥有从实参推出的类型的 std::front_insert_iterator(函数模板)</li><li>insert_iterator: 用于插入容器的迭代器适配器(类模板)</li><li>inserter: 创建拥有从实参推出的类型的 std::insert_iterator(函数模板)</li></ul><p>如ReverseIterator的实现，将++操作换成迭代器的–操作，实现逆向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator_type = Iterator;</span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::reference;</span><br><span class="line"></span><br><span class="line">  ReverseIterator() : it_() &#123;&#125;</span><br><span class="line">  ReverseIterator(iterator_type it) : it_(it) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) : it_(other.it_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) &#123;</span><br><span class="line">    it_ = other.it_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> it_; &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">return</span> *gtl::prev(it_);</span><br><span class="line">  &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> gtl::addressof(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) &#123; <span class="keyword">return</span> *gtl::prev(n + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    it_ -= n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">    it_ += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ - n); &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ + n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  iterator_type it_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h1><p>早期的C++提供了一些函数适配器，如bind1st和bind2nd（C++11后可用bind替代）</p><p>早期提供功能支持的几个工具在C++11中弃用，并于 C++17 中移除（旧否定器于 C++17 中弃用并于 C++20 中移除），这里不再过多介绍</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1361.html" target="_blank" rel="noopener">适配器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">迭代器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/utility/functional" target="_blank" rel="noopener">函数对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器&lt;/p&gt;
&lt;p&gt;适配器模式的定义为：将一
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之迭代器模式/</id>
    <published>2021-10-22T12:12:43.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素<br>通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p><p>既然将遍历方法封装在容器类中不可取，那么容器类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ul><li>暴露了容器类的内部表示，使其数据不安全</li><li>增加了客户的负担</li></ul><p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与容器类之间插入一个迭代器，这分离了容器对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</p><p>迭代器模式定义：提供一种方法，使之能够依次访问某个容器所含的各个元素，而又无需暴露该容器的内部实现。</p><p>迭代器模式是一种对象行为型模式，其主要优点如下</p><ul><li>访问一个容器对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了容器类。</li><li>它支持以不同方式遍历一个容器，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的容器类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的容器结构提供一个统一的接口。</li></ul><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><p>在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。</p><p>一般来说，迭代器需要了解容器类的内部实现，才能正确的遍历容器中的元素</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>迭代器模式主要包含以下角色。</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/iterator.gif" alt="迭代器模式结构" title>                </div>                <div class="image-caption">迭代器模式结构</div>            </figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>迭代器模式通常在以下几种情况使用。</p><ul><li>当需要为容器对象提供多种遍历方式时。</li><li>当需要为遍历不同的容器结构提供一个统一的接口时。</li><li>当访问一个容器对象的内容而无须暴露其内部细节的表示时。</li></ul><p>由于容器与迭代器的关系非常密切，所以大多数语言在实现容器类时都提供了迭代器类，因此大数情况下使用语言中已有的容器类的迭代器就已经够了。</p><h1 id="STL中的迭代器"><a href="#STL中的迭代器" class="headerlink" title="STL中的迭代器"></a>STL中的迭代器</h1><p>在STL中的vector、list、set、map等容器都包含了迭代器，迭代器的行为与指针类似，迭代器可以是原生指针，也可以是重载operator*和operator-&gt;的对象。</p><p>与容器相似，该容器对应的迭代器可以获取特定类型的值，我们需要通过特性萃取技术（traits）来获取迭代器对应的类型。c++提供了iterator_traits来实现该功能。</p><p>一般来说，迭代器需要提供以下几种类型，针对原生指针，可以通过对iterator_traits进行模板特化来获取对应的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value_type</span><br><span class="line">difference_type</span><br><span class="line">pointer</span><br><span class="line">reference</span><br><span class="line">iterator_category</span><br></pre></td></tr></table></figure><h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输入迭代器，只读，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输出迭代器，可写，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;; <span class="comment">// 前向迭代器，只能向前移动，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;; <span class="comment">// 可双向移动，可++，--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;; <span class="comment">// 可随机访问，与原生指针类似</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">contiguous_iterator_tag</span>:</span> <span class="keyword">public</span> random_access_iterator_tag &#123; &#125;; <span class="comment">//  (C++20) 要求逻辑相邻元素在内存中物理上也相邻</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1395.html" target="_blank" rel="noopener">迭代器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h1&gt;&lt;p&gt;实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素&lt;br&gt;通常的做法是将链表的创建和遍历都放在同
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之状态模式/</id>
    <published>2021-10-22T12:04:33.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式概述"><a href="#状态模式概述" class="headerlink" title="状态模式概述"></a>状态模式概述</h1><p>在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理</p><p>但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展</p><p>以上问题如果采用“状态模式”就能很好地得到解决。</p><p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><h1 id="状态模式定义与特点"><a href="#状态模式定义与特点" class="headerlink" title="状态模式定义与特点"></a>状态模式定义与特点</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li><li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h1 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h1><p>状态模式涉及的角色如下</p><ul><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https/gwq5210.com/images/state.gif" alt="状态模式结构图" title>                </div>                <div class="image-caption">状态模式结构图</div>            </figure><h1 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h1><p>本例子实现了一个投票的简单例子</p><ul><li>同一个用户可以投一次票，初始状态为正常状态(NormalVoteState)</li><li>成功投票之后，状态转换为重复投票状态(RepeatVoteState)，不能再进行投票</li></ul><p>例子十分简单，具体工程上，可以实现很复杂的状态转换</p><p>核心代码如下，具体可参见代码<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.cc" target="_blank" rel="noopener">state.cc</a>和<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.h" target="_blank" rel="noopener">state.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NormalVoteState::vote</span><span class="params">(VoteManager* manager, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; username)</span> </span>&#123;</span><br><span class="line">  manager-&gt;inc_vote(username);</span><br><span class="line">  manager-&gt;set_state(&amp;VoteManager::repeat_vote_state);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s, 投票成功!\n"</span>, username.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  VoteManager manager;</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境和状态处理对象"><a href="#环境和状态处理对象" class="headerlink" title="环境和状态处理对象"></a>环境和状态处理对象</h2><p>在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。</p><p>在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。</p><p>客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1388.html" target="_blank" rel="noopener">状态模式（详解版）</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html" target="_blank" rel="noopener">《JAVA与模式》之状态模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式概述&quot;&gt;&lt;a href=&quot;#状态模式概述&quot; class=&quot;headerlink&quot; title=&quot;状态模式概述&quot;&gt;&lt;/a&gt;状态模式概述&lt;/h1&gt;&lt;p&gt;在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之vector</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器之vector/</id>
    <published>2021-10-22T12:02:02.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在物理上也是相邻的</p><p>vector的底层是数组，这也说明必要的时候，vector的元素指针可以当做数组指针来使用</p><p>一般的实现中，vector的迭代器就是指针本身</p><p>vector元素访问复杂度</p><ul><li>随机访问——常数 O(1)</li><li>在末尾插入或移除元素——均摊常数 O(1)</li><li>插入或移除元素——与到 vector 结尾的距离成线性 O(n)</li></ul><p>vector有两个特点</p><ul><li>数据连续存储</li><li>空间动态分配</li></ul><p>下边主要针对空间动态分配进行介绍</p><h1 id="vector的实现"><a href="#vector的实现" class="headerlink" title="vector的实现"></a>vector的实现</h1><p>vector的空间是动态分配的，随着元素的增加，vector会自动扩充空间以容纳新元素</p><p>当需要扩充空间时，vector内部会进行如下操作</p><ul><li>分配一块更大的空间</li><li>将原有的数据移动到新的位置</li><li>释放原有空间</li></ul><p>可以看到自动扩充空间涉及到内存分配和元素移动，时间成本很高，需要设计一个合理的数据结构和空间配置策略</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>vector需要表示一块连续存储空间，因此我们需要知道内存的位置，内存的大小和已存储元素的个数</p><p>一个简单的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* start_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了降低内存分配的时间成本，vector的实际空间要比使用的空间要大一些，为将来的元素增加做好准备，为此就需要一个容量来表示当前内存的最大大小</p><h2 id="空间配置策略"><a href="#空间配置策略" class="headerlink" title="空间配置策略"></a>空间配置策略</h2><p>当vector空间满时，新添加元素，会触发自动空间分配，这个时候再分配多少合适呢</p><p>选的扩容太小比如新的大小是当前大小的1.1倍，可能会频繁导致空间分配，如果新的大小是当前大小的3或4倍，可能会导致内存的浪费</p><p>我们先看下主流的实现，gcc新的大小是当前空间大小的2倍，vs是新大小是当前空间大小的1.5倍</p><p>如果选择增长因子为2，可能是最坏的可能，因为它不允许vector重用先前分配好的任何内存，因此选择1.5是一个更好的选择</p><p>如果增长因子为k，则每次分配的内存为，当为2的时候每次分配的内存都比先前分配的所有内存和都大，选择1.5时，则可以在4次分配后重用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C, C*k,  C*k^2, C*k^3, ...</span><br><span class="line">1 + 2^1 + 2^2 + 2^3... + 2^n = 2^(n+1) - 1</span><br></pre></td></tr></table></figure><h2 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h2><p>vector删除元素并不会删除已经申请好的内存，即使vector里已经不包含任何元素</p><p>C++11增加公共成员函数shrink_to_fit，允许释放未使用的内存</p><p>或者通过swap临时变量的方式释放内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v);</span><br></pre></td></tr></table></figure><h1 id="vector的迭代器失效"><a href="#vector的迭代器失效" class="headerlink" title="vector的迭代器失效"></a>vector的迭代器失效</h1><p>对容器的操作影响了元素的存放位置，称为迭代器失效</p><p>由于vector的实现特点，在发生以下情况时，迭代器和引用都会失效</p><ul><li>容量发生改变</li><li>插入或移除元素后的迭代器(插入或移除元素前的迭代器和引用不会失效)</li></ul><h1 id="vector原位构造元素"><a href="#vector原位构造元素" class="headerlink" title="vector原位构造元素"></a>vector原位构造元素</h1><p>C++11提供以下两个函数来原位构造元素</p><ul><li>emplace</li><li>emplace_back</li></ul><p>这两个函数通过完美转发实现原位构造，相比push_back这一类函数，少了一次拷贝的动作</p><p>实际上，当前的push_back实现会使用move语义，不会进行拷贝</p><h1 id="vector的特化"><a href="#vector的特化" class="headerlink" title="vector的特化"></a>vector的特化</h1><p>STL针对vector<bool>进行了特化，可以提供更优的存储空间，实际上它实现了一个动态bitmap</bool></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://github.com/facebook/folly/blob/main/folly/docs/FBVector.md" target="_blank" rel="noopener">fbvector</a></li><li><a href="https://segmentfault.com/a/1190000040103598" target="_blank" rel="noopener">vector实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector概述&quot;&gt;&lt;a href=&quot;#vector概述&quot; class=&quot;headerlink&quot; title=&quot;vector概述&quot;&gt;&lt;/a&gt;vector概述&lt;/h1&gt;&lt;p&gt;vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="顺序容器" scheme="https://gwq5210.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器概述</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器概述/</id>
    <published>2021-10-22T11:59:54.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL容器概述"><a href="#STL容器概述" class="headerlink" title="STL容器概述"></a>STL容器概述</h1><p>容器被设计来存储数据，可以使程序员简单的访问常见的数据结构</p><p>每种不同的容器底层使用不同的数据结构，并拥有不同的特征，可在特定场景提供高效的数据存储和访问的方式</p><p>每种容器提供<a href="/2021/10/22/设计模式之迭代器模式/">迭代器</a>来访问存储在其中的元素</p><p>容器一般分为以下几种类别</p><h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>顺序容器实现能按顺序访问的数据结构</p><ul><li>array：静态连续数组</li><li>vector：动态连续数组</li><li>deque：双端队列</li><li>forward_list：单链表</li><li>list：双链表</li></ul><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器提供顺序容器的不同接口</p><ul><li>stack：栈</li><li>queue：队列</li><li>priority_queue：优先队列</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL容器概述&quot;&gt;&lt;a href=&quot;#STL容器概述&quot; class=&quot;headerlink&quot; title=&quot;STL容器概述&quot;&gt;&lt;/a&gt;STL容器概述&lt;/h1&gt;&lt;p&gt;容器被设计来存储数据，可以使程序员简单的访问常见的数据结构&lt;/p&gt;
&lt;p&gt;每种不同的容器底层使用不同
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Lambda表达式</title>
    <link href="https://gwq5210.com/2019/03/28/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F(%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0)/"/>
    <id>https://gwq5210.com/2019/03/28/Lambda表达式(匿名函数)/</id>
    <published>2019-03-28T11:35:53.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，C++，Python中的Lambda表达式</p><h1 id="什么是Lambda表达式"><a href="#什么是Lambda表达式" class="headerlink" title="什么是Lambda表达式"></a>什么是Lambda表达式</h1><p>在编程中，Lambda表达式就是指匿名函数（anonymous function），它是一类无需定义标识符（函数名）的函数<br>匿名函数通常作为参数传递给高阶函数或者作为高阶函数的返回值<br>如果函数只使用一次或者有限的次数，则使用匿名函数会比较方便<br>现在越来越多的编程语言支持匿名函数</p><p>闭包常常被用作匿名函数的同义词，严格来说，匿名函数仅仅是没有名字的函数，闭包是任何能够访问自由变量（free variable or non-local variable，不在局部和参数列表里定义的变量）的函数实例</p><h1 id="Java中的Lambda表达式"><a href="#Java中的Lambda表达式" class="headerlink" title="Java中的Lambda表达式"></a>Java中的Lambda表达式</h1><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>Java 中的 Lambda 表达式通常使用 (argument) -&gt; (body) 语法书写，例如：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">(arg1, arg2...)</span> -&gt;</span> &#123; body &#125;</span><br><span class="line"><span class="function"><span class="params">(type1 arg1, type2 arg2...)</span> -&gt;</span> &#123; body &#125;</span><br></pre></td></tr></table></figure></p><p>在Lambda表达式中引用的自由变量，必须是final或者是实际上不会修改的变量</p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><ol><li>一个 Lambda 表达式可以有零个或多个参数</li><li>参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同</li><li>所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c)</li><li>空圆括号代表参数集为空。例如：() -&gt; 42</li><li>当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a</li><li>Lambda 表达式的主体可包含零条或多条语句</li><li>如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致</li><li>如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空</li></ol><h2 id="一些例子"><a href="#一些例子" class="headerlink" title="一些例子"></a>一些例子</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要参数，返回值为int的42</span></span><br><span class="line">() -&gt; <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，返回值为float的3.1415</span></span><br><span class="line">() -&gt; &#123; <span class="keyword">return</span> <span class="number">3.1415</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受两个int参数，返回值为它们的和</span></span><br><span class="line">(int a, int b) -&gt; &#123;  <span class="keyword">return</span> a + b; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不需要参数，没有返回值，输出一个字符串</span></span><br><span class="line">() -&gt; System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受一个String参数，没有返回值，打印该字符串</span></span><br><span class="line">(<span class="built_in">String</span> s) -&gt; &#123; System.out.println(s); &#125;</span><br></pre></td></tr></table></figure><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>Java中只有一个方法声明的接口叫做函数式接口，例如java.lang.Runnable接口只声明了一个void run()方法<br>不指明函数式接口时，编译器可以进行自动转化<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable <span class="function"><span class="title">r</span> = <span class="params">()</span> -&gt;</span> System.out.println(<span class="string">"Hello Java!"</span>);</span><br><span class="line"><span class="keyword">new</span> Thread(r).start();</span><br><span class="line"><span class="keyword">new</span> Thread<span class="function"><span class="params">(() -&gt; System.out.println(<span class="string">"Hello Java!"</span>))</span>.<span class="title">start</span><span class="params">()</span>;</span></span><br></pre></td></tr></table></figure></p><h1 id="C-中的Lambda表达式"><a href="#C-中的Lambda表达式" class="headerlink" title="C++中的Lambda表达式"></a>C++中的Lambda表达式</h1><p>在C++ 11中支持Lambda表达式</p><h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>Lambda表达式的语法如下</p><ol><li>[]中可以以值或引用捕获变量，来实现闭包</li><li>捕获变量时需要注意，如果调用闭包时，引用了生存周期结束的变量，则发生未定义行为，C++的闭包不会延长被捕获引用的生存周期</li><li>Lambda表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型</li><li>this是一个特殊的捕获，必须定义在类的非静态成员函数中，该Lambda具有访问该类的保护和私有成员的权限，在Lambda中访问该类的成员，不需要显式使用this-&gt;，即this-&gt;a和a等价</li><li>不捕获变量的Lambda可以将函数赋值给对应的函数指针</li><li>Lambda表达式可以赋值给std::function</li></ol><p>Boost库提供了自己的Lambda表达式语法，参见<a href="https://www.boost.org/doc/libs/1_62_0/doc/html/lambda.html" target="_blank" rel="noopener">Boost.Lambda</a><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) -&gt; return_type &#123; body &#125;</span><br><span class="line"><span class="comment">// 忽略返回值，返回值的类型使用自动推断</span></span><br><span class="line">[<span class="meta"> captures </span>] ( <span class="keyword">params</span> ) &#123; body &#125;</span><br><span class="line"><span class="comment">// 不接受任何参数</span></span><br><span class="line">[<span class="meta"> captures </span>] &#123; body &#125;</span><br></pre></td></tr></table></figure></p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接受x，y参数，返回它们的和</span></span><br><span class="line">[](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是捕获的例子</span></span><br><span class="line">[]        <span class="comment">//no variables defined. Attempting to use any external variables in the lambda is an error.</span></span><br><span class="line">[x, &amp;y]   <span class="comment">//x is captured by value, y is captured by reference</span></span><br><span class="line">[&amp;]       <span class="comment">//any external variable is implicitly captured by reference if used</span></span><br><span class="line">[=]       <span class="comment">//any external variable is implicitly captured by value if used</span></span><br><span class="line">[&amp;, x]    <span class="comment">//x is explicitly captured by value. Other variables will be captured by reference</span></span><br><span class="line">[=, &amp;z]   <span class="comment">//z is explicitly captured by reference. Other variables will be captured by value</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Variables captured by value are constant by default. Adding mutable after the parameter list makes them non-constant.</span></span><br><span class="line"><span class="comment">// 按值捕获到的变量不能被改变，需要改变的话要在参数列表后加上mutalbe，按值捕获不会改变原值</span></span><br><span class="line">a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> f = [=] () <span class="keyword">mutable</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">f();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 按引用捕获可以修改原值，a值会被改变成3</span></span><br><span class="line"><span class="keyword">auto</span> r = [&amp;] &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">r();</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosureTest</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ClosureTest() &#123; r = <span class="number">0</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">test</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">result</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 捕获this</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ClosureTest::test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d, %d\n"</span>, <span class="keyword">this</span>-&gt;r, r);</span><br><span class="line">    &#125;;</span><br><span class="line">    f();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给函数指针，不能捕获变量</span></span><br><span class="line"><span class="keyword">void</span> (*p)() = []&#123;<span class="built_in">printf</span>(<span class="string">"test\n"</span>);&#125;;</span><br><span class="line">p();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将Lambda赋值给std::function对象，可以进行捕获，void不能省略</span></span><br><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; add = [](<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;<span class="keyword">return</span> a+b;&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">int</span>)&gt; <span class="built_in">print</span> = [](<span class="keyword">int</span> a)&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; <span class="built_in">print</span> = [&amp;]()&#123;<span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);&#125;;</span><br><span class="line"><span class="built_in">print</span>(add(<span class="number">1</span>, <span class="number">2</span>));</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><h1 id="Python中的Lambda表达式"><a href="#Python中的Lambda表达式" class="headerlink" title="Python中的Lambda表达式"></a>Python中的Lambda表达式</h1><p>Python中可以使用lambda关键字定义匿名函数，它能用在任何需要函数的地方，在语法上它被限制只能有单个语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> parameter_list: expression</span><br><span class="line"></span><br><span class="line">// 例如参数x，返回x*x</span><br><span class="line"><span class="keyword">lambda</span> x: x * x</span><br><span class="line"></span><br><span class="line">// 以上等价于</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line"></span><br><span class="line">// 参数x，y，返回它们的和</span><br><span class="line"><span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">// 可以使用自由变量</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(y)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> x + y</span><br><span class="line">    <span class="keyword">return</span> g  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">h</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y: x + y  <span class="comment"># Return a closure.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Assigning specific closures to variables.</span></span><br><span class="line">a = f(<span class="number">1</span>)</span><br><span class="line">b = h(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Using the closures stored in variables.</span></span><br><span class="line"><span class="keyword">assert</span> a(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"><span class="keyword">assert</span> b(<span class="number">5</span>) == <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Using closures without binding them to variables first.</span></span><br><span class="line"><span class="keyword">assert</span> f(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># f(1) is the closure.</span></span><br><span class="line"><span class="keyword">assert</span> h(<span class="number">1</span>)(<span class="number">5</span>) == <span class="number">6</span>  <span class="comment"># h(1) is the closure.</span></span><br><span class="line"></span><br><span class="line">// x是全局的</span><br><span class="line">// 修改x后，会修改函数f的结果</span><br><span class="line">x = <span class="number">1</span></span><br><span class="line">nums = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line">// [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br><span class="line"></span><br><span class="line">x = <span class="number">3</span></span><br><span class="line">// [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line">map(f, nums)</span><br><span class="line">map(<span class="keyword">lambda</span> y: x + y, nums)</span><br></pre></td></tr></table></figure></p><h1 id="Go的匿名函数"><a href="#Go的匿名函数" class="headerlink" title="Go的匿名函数"></a>Go的匿名函数</h1><p>Go的匿名函数是闭包，他们可以引用自由变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 分别打出11，102，111</span></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">num := <span class="number">10</span></span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> num + x</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line">num = <span class="number">101</span></span><br><span class="line">fmt.Println(f(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">fmt.Println(test(f))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">(f <span class="keyword">func</span>(<span class="keyword">int</span>)</span> <span class="title">int</span>) <span class="title">int</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> f(<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="闭包的实现"><a href="#闭包的实现" class="headerlink" title="闭包的实现"></a>闭包的实现</h1><p>闭包通常用一个包含函数代码的指针和创建闭包时函数词法环境（一系列可用的变量）的数据结构来实现<br>也就是说闭包引用的自由变量，需要在闭包调用的时候仍然能够访问</p><p>只在栈上分配变量的语言很难容易的实现完全的闭包，这些语言中，自动变量会在函数返回后自动的销毁<br>这也可以解释为什么通常支持闭包的语言也使用垃圾回收机制<br>替代方案是非局部变量的手动内存管理，不过这种方式可能会产生野指针的问题，C++ 11中的Lambda表达式和<a href="https://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html" target="_blank" rel="noopener">GNU C中的嵌套函数</a>都可能会产生这个问题</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://en.wikipedia.org/wiki/Anonymous_function" target="_blank" rel="noopener">Anonymous_function</a><br>2) <a href="https://en.wikipedia.org/wiki/Closure_(computer_programming)" target="_blank" rel="noopener">Closure_(computer_programming)</a><br>3) <a href="https://sylvanassun.github.io/2017/07/30/2017-07-30-JavaClosure/" target="_blank" rel="noopener">Java中的闭包之争</a><br>4) <a href="https://en.wikipedia.org/wiki/Free_variables_and_bound_variables" target="_blank" rel="noopener">Free_variables_and_bound_variables</a><br>5) <a href="http://blog.oneapm.com/apm-tech/226.html" target="_blank" rel="noopener">深入浅出 Java 8 Lambda 表达式</a><br>6) <a href="https://en.cppreference.com/w/cpp/language/lambda" target="_blank" rel="noopener">Lambda expressions</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，
      
    
    </summary>
    
    
      <category term="Java" scheme="https://gwq5210.com/tags/Java/"/>
    
      <category term="C++" scheme="https://gwq5210.com/tags/C/"/>
    
      <category term="Python" scheme="https://gwq5210.com/tags/Python/"/>
    
      <category term="Lambda表达式" scheme="https://gwq5210.com/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="匿名函数" scheme="https://gwq5210.com/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Git简介及常用命令</title>
    <link href="https://gwq5210.com/2019/03/25/Git%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>https://gwq5210.com/2019/03/25/Git简介及常用命令/</id>
    <published>2019-03-25T20:31:11.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近想深入了解一下Git，阅读了一下<a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a>的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅</p><h1 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h1><p>Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><p>版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。<br><a id="more"></a><br>本地版本控制系统无法实现协同工作，集中化的版本控制系统解决了协同工作的问题，但中央服务器的单点故障会影响所有人的工作，分布式版本控制系统采用快照的方式，每个开发者电脑上都有一份代码的完整拷贝，故障恢复起来就比较容易。</p><p>Git是Linux开源社区的杰作，他们开发Git之初就对其有以下目标：</p><ol><li>速度</li><li>简单的设计</li><li>对非线性开发模式的强力支持（允许成千上万个并行开发的分支）</li><li>完全的分布式</li><li>有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量）</li></ol><p>Git和其他版本控制系统（如Subversion）的主要差别在于对待数据的方法。不像其他版本控制系统保存基本文件和基于基本文件的差异，Git直接保存每个文件的快照。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/存储每个文件和基础版本的差异.png" alt="存储每个文件和基础版本的差异" title>                </div>                <div class="image-caption">存储每个文件和基础版本的差异</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/存储项目随时间变化的快照.png" alt="存储项目随时间变化的快照" title>                </div>                <div class="image-caption">存储项目随时间变化的快照</div>            </figure><p>正因为如此，Git中的大多数操作只需要访问本地资源，而不需要与服务器进行通信，保证了操作的速度。</p><h1 id="Git基础"><a href="#Git基础" class="headerlink" title="Git基础"></a>Git基础</h1><h2 id="Git的三种状态"><a href="#Git的三种状态" class="headerlink" title="Git的三种状态"></a>Git的三种状态</h2><p>在Git中，你的文件处于以下三种状态之一：</p><ol><li>已提交（committed），表示数据已经安全的保存在本地数据库中。</li><li>已修改（modified），表示已经修改了文件，但还没保存在数据库中。</li><li>已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ol><p>由此引入Git项目的三个工作区的概念：Git仓库，工作目录以及暂存区域。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/工作目录，暂存区域以及Git仓库.png" alt="Git仓库，工作目录以及暂存区域" title>                </div>                <div class="image-caption">Git仓库，工作目录以及暂存区域</div>            </figure><p>基本的 Git 工作流程如下： </p><ol><li>在工作目录中修改文件。 </li><li>暂存文件，将文件的快照放入暂存区域。 </li><li>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 </li></ol><h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="Git帮助"><a href="#Git帮助" class="headerlink" title="Git帮助"></a>Git帮助</h2><p>有三种方式获取Git的帮助：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">help</span> <span class="symbol">&lt;verb&gt;</span></span><br><span class="line">git <span class="symbol">&lt;verb&gt;</span> --<span class="keyword">help</span></span><br><span class="line">man git-<span class="symbol">&lt;verb&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h2><p>Git的配置信息存放在三个不同的位置</p><ol><li>/etc/gitconfig文件，系统上每一个用户及他们仓库的配置，使用–system选项会读写此配置文件</li><li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。使用–global选项会读写此配置文件</li><li>当前仓库中使用的配置（.git/config），需要在当前仓库进行修改，不需要加选项。</li></ol><p>每一个级别的配置会覆盖上一个级别的配置。</p><p>以下是常用的配置<br><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看用户配置</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> -l</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置全局的用户名和邮箱</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">"gwq5210"</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">"gwq5210@qq.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置使用的编辑器</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> core<span class="variable">.editor</span> <span class="string">"vim"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置常用的别名，以下命令会在稍候介绍</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.co</span> checkout</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.ci</span> commit</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.br</span> branch</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.st</span> status</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.unstage</span> reset HEAD --</span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> <span class="keyword">alias</span><span class="variable">.last</span> log -l HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为Git设置代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.http</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span> http:<span class="comment">//127.0.0.1:8080</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 为不同的网址设置不同的代理</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> http<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> https<span class="variable">.https</span>:<span class="comment">//github.com.proxy http://127.0.0.1:8081</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 避免每次都输入账号密码，将账号密码保存在内存中几分钟</span></span><br><span class="line">git <span class="keyword">config</span> --<span class="keyword">global</span> credential<span class="variable">.helper</span> cache</span><br></pre></td></tr></table></figure></p><h2 id="获取Git仓库"><a href="#获取Git仓库" class="headerlink" title="获取Git仓库"></a>获取Git仓库</h2><p>有两种方式获取Git仓库：从现有目录初始化仓库和从服务器克隆一个现有的Git仓库。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从现有目录初始化仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">init</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从服务器克隆一个现有的仓库</span></span><br><span class="line"><span class="selector-tag">git</span> <span class="selector-tag">clone</span> <span class="selector-attr">[url]</span> <span class="selector-attr">[name]</span></span><br></pre></td></tr></table></figure></p><p>Git仓库里存在着.git目录，保存着Git仓库的必要信息。</p><h2 id="查看当前文件状态、跟踪新文件和暂存已修改的文件"><a href="#查看当前文件状态、跟踪新文件和暂存已修改的文件" class="headerlink" title="查看当前文件状态、跟踪新文件和暂存已修改的文件"></a>查看当前文件状态、跟踪新文件和暂存已修改的文件</h2><p>工作目录的文件状态不外乎：已跟踪和未跟踪。已跟踪是已纳入版本控制的文件，在上一次快照中有他们的记录，工作过一段时候后，他们的状态可能是未修改，已修改，已暂存状态。除此之外其他文件都属于未跟踪文件<br><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/文件状态变化生命周期.png" alt="文件状态变化生命周期" title>                </div>                <div class="image-caption">文件状态变化生命周期</div>            </figure></p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/<span class="regexp">/ 查看当前文件状态</span></span><br><span class="line"><span class="regexp">git status</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 之前设置的status别名为st</span></span><br><span class="line"><span class="regexp">git st</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 显式简介的状态</span></span><br><span class="line"><span class="regexp">git status -s</span></span><br><span class="line"><span class="regexp">git status --short</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 第一列表示在暂存区域的状态，第二列表示在工作区域的状态</span></span><br><span class="line"><span class="regexp">-------------------</span></span><br><span class="line"><span class="regexp"> M README</span></span><br><span class="line"><span class="regexp">MM Rakefile</span></span><br><span class="line"><span class="regexp">A lib/git</span>.rb</span><br><span class="line">M <span class="class"><span class="keyword">lib</span>/<span class="title">simplegit</span>.<span class="title">rb</span></span></span><br><span class="line">?? LICENSE.txt </span><br><span class="line">-------------------</span><br><span class="line"></span><br><span class="line">/<span class="regexp">/ 跟踪新文件或暂存已修改的文件</span></span><br><span class="line"><span class="regexp">git add [path]</span></span><br></pre></td></tr></table></figure><p>我们可以使用.gitignore文件来忽略我们不想跟踪的文件，这里有.gitignore文件的列表，可供查阅<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p><h2 id="查看已暂存和未暂存的修改"><a href="#查看已暂存和未暂存的修改" class="headerlink" title="查看已暂存和未暂存的修改"></a>查看已暂存和未暂存的修改</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 查看未暂存的修改，即工作区域和已暂存区域的修改</span><br><span class="line">git diff</span><br><span class="line"><span class="string">//</span> 查看已提交和已暂存的修改</span><br><span class="line">git diff <span class="params">--cached</span></span><br><span class="line"><span class="string">//</span> Git 1.6.1及更高版本</span><br><span class="line">git diff <span class="params">--staged</span></span><br></pre></td></tr></table></figure><h2 id="提交更新"><a href="#提交更新" class="headerlink" title="提交更新"></a>提交更新</h2><p>使用如下命令将暂存区域的内容提交<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git commit</span><br><span class="line">// 命令行指定提交消息</span><br><span class="line">git commit -m <span class="string">"commit message"</span></span><br><span class="line">// 跳过暂存，进行提交</span><br><span class="line">git commit -<span class="keyword">a</span> -m <span class="string">"commit message"</span></span><br><span class="line">// commit的别名</span><br><span class="line">git ci</span><br></pre></td></tr></table></figure></p><h2 id="移除或修改文件"><a href="#移除或修改文件" class="headerlink" title="移除或修改文件"></a>移除或修改文件</h2><p>要移除文件，需要从已跟踪清单中（确切的说是从暂存区域）移除，然后提交。<br><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">git rm [path]</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git rm类似如下命令</span></span><br><span class="line">rm [path]</span><br><span class="line">git add [path]</span><br><span class="line">-------------</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从暂存区域移除，仍然保留在工作区域</span></span><br><span class="line">git rm --cached [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果已经修改了文件或者已经暂存了该文件，则需要使用-f进行删除，防止误操作删除了不可恢复的文件</span></span><br><span class="line">git rm -f [path]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重命名文件</span></span><br><span class="line">git mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">-------------</span><br><span class="line"><span class="comment">// git mv相当于下边的操作</span></span><br><span class="line">mv file<span class="emphasis">_from file_</span>to</span><br><span class="line">git rm file<span class="emphasis">_from</span></span><br><span class="line"><span class="emphasis">git add file_</span>to</span><br><span class="line">-------------</span><br></pre></td></tr></table></figure></p><h2 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h2><p>提交若干更新或者克隆一个仓库之后，我们可以查看提交历史<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 默认会列出所有的提交历史，最近的更新会排在最上边</span><br><span class="line">git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line">// 显示最新的n条记录</span><br><span class="line">git <span class="built_in">log</span> -n</span><br><span class="line"></span><br><span class="line">// 显示每次提交的内容差异</span><br><span class="line">git <span class="built_in">log</span> -p</span><br><span class="line"></span><br><span class="line">// 查看每次提交的简略统计信息</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--stat</span></span><br><span class="line"></span><br><span class="line">// 单行显示提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--oneline</span></span><br><span class="line"></span><br><span class="line">// 使用图形提交历史</span><br><span class="line">git <span class="built_in">log</span> <span class="comment">--graph</span></span><br></pre></td></tr></table></figure></p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> 修改最后一次提交，使用这个选项会覆盖上一次的提交</span><br><span class="line">git ci <span class="params">--amend</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 取消暂存文件</span><br><span class="line">git reset HEAD &lt;file&gt;<span class="string">...</span></span><br><span class="line"><span class="string">//</span> 别名</span><br><span class="line">git unstage &lt;file&gt;<span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="string">//</span> 撤销对文件的修改，此操作会丢失对文件的修改，很危险</span><br><span class="line">git checkout -- &lt;file&gt;<span class="string">...</span></span><br></pre></td></tr></table></figure><h2 id="使用远程仓库"><a href="#使用远程仓库" class="headerlink" title="使用远程仓库"></a>使用远程仓库</h2><p>克隆一个仓库，会自动给远程仓库添加origin的名称<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 显示远程仓库</span></span><br><span class="line">git remote -v</span><br><span class="line">git remote show <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加远程仓库</span></span><br><span class="line">git remote add <span class="params">&lt;shortname&gt;</span> <span class="params">&lt;url&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拉取远程仓库的信息，不会自动合并或修改你当前的工作</span></span><br><span class="line"><span class="comment">// 分支设置了跟踪一个远程分支的话git pull会自动抓取然后合并</span></span><br><span class="line">git fetch <span class="params">&lt;remote-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 推送到远程仓库</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;branch-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程仓库重命名和移除</span></span><br><span class="line">git remote rename <span class="params">&lt;old-name&gt;</span> <span class="params">&lt;new-name&gt;</span></span><br><span class="line">git remote rm <span class="params">&lt;remote-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="使用标签"><a href="#使用标签" class="headerlink" title="使用标签"></a>使用标签</h2><p>Git可以给历史中的某一个提交打上标签，表示重要<br>Git标签有两种标签，轻量标签和附注标签<br>轻量标签很像一个不会改变的分支，它只是一个特定提交的引用<br>附注标签是存储在Git数据库中的完整对象，可以包含打标签者的名字，邮件，日期等信息<br>通常建议创建附注标签<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 列出标签</span></span><br><span class="line">git tag</span><br><span class="line">git tag -l <span class="string">"v1.8*"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建附注标签，指定存储在标签中的信息</span></span><br><span class="line">git tag -a v1<span class="number">.0</span> -m <span class="string">"create tag v1.0"</span></span><br><span class="line"><span class="comment">// 查看标签的信息和对应的提交信息，轻量标签只会显示提交信息</span></span><br><span class="line">git show v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建轻量标签，只需要提供标签名字</span></span><br><span class="line">git tag v1<span class="number">.0</span>-lw</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对过去的提交打标签</span></span><br><span class="line">git tag -a v0<span class="number">.9</span> <span class="number">9f</span>ceb02</span><br><span class="line"></span><br><span class="line"><span class="comment">// 共享标签，将标签推送到远程仓库，类似共享远程分支</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有不在远程服务器的标签都推送过去</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --tags</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除标签，此命令不会删除远程服务器的标签</span></span><br><span class="line">git tag -d v1<span class="number">.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程服务器的标签</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> :refs<span class="meta-keyword">/tags/</span><span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git push <span class="params">&lt;remote-name&gt;</span> --delete <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检出标签，此命令会使你的仓库处于分离头指针（detached HEAD）状态</span></span><br><span class="line"><span class="comment">// 在分离头指针状态你进行某些更改然后提交他们，标签不会发生变化，你的提交不属于任何分支，只能使用确切的哈希来访问</span></span><br><span class="line">git checkout <span class="params">&lt;tag-name&gt;</span></span><br><span class="line">git co <span class="params">&lt;tag-name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 因此，需要修复旧版本的错误，通常需要创建一个新的分支，在新分支上进行修改，并提交，该分支就和此标签不同了</span></span><br><span class="line">git co -b <span class="params">&lt;branch-name&gt;</span> <span class="params">&lt;tag-name&gt;</span></span><br></pre></td></tr></table></figure></p><h2 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h2><p>几乎所有的版本控制系统都支持分支，你可以把工作从开发主线上分离出来，以免影响开发主线<br>Git处理分支的方式十分轻量，创建和切换分支操作都十分便捷，因此Git鼓励使用分支</p><p>进行提交操作时，Git会保存一个提交对象，该提交对象包含一个指向暂存内容快照的指针，还包括作者的姓名，邮箱等信息，以及它的父对象信息（一个或多个）</p><p>Git的默认分支是master分支，master分支不是一个特殊的分支，与其他分支没有差别，git init命令会默认创建它</p><p>这些分支操作全部都保存在本地，没有与服务器发生交互<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 创建分支，会在当前所的提交对象上创建一个指针，Git有一个HEAD的特殊指针，指向当前分支，可以理解为当前分支的别名</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>切换分支，分支切换会改变工作目录的内容，如果Git不能干净利落的完成这个任务，它将禁止切换分支</span><br><span class="line"><span class="symbol">git</span> checkout &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>新建分支并切换</span><br><span class="line"><span class="symbol">git</span> checkout -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span>co -<span class="keyword">b </span>&lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>合并分支，将&lt;<span class="keyword">branch-name&gt;分支合并到当前分支</span></span><br><span class="line"><span class="keyword">// </span>合并两个分支时，如果顺着一个分支能够到达另外一个分支，那么就进行快进（fast-forward）</span><br><span class="line">// 有分叉的合并会产生一个合并提交，该提交使用三方（两个分支末端的快照和它们的公共祖先）合并的结果</span><br><span class="line">// 如果合并时遇到对同一个文件同一处的修改，则会发生冲突，等你解决冲突后，使用git <span class="keyword">add命令将冲突的文件标记为已解决冲突</span></span><br><span class="line"><span class="keyword">git </span>merge &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>删除分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br </span>-d &lt;<span class="keyword">branch-name&gt;</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支，*号代表当前所在分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch</span></span><br><span class="line"><span class="keyword">git </span><span class="keyword">br</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">// </span>查看分支最后一个提交</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>-v</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>-v</span><br><span class="line"></span><br><span class="line">// 显示列表中已经合并或尚未合并到当前分支的分支</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">branch </span>--merged</span><br><span class="line"><span class="symbol">git</span> <span class="keyword">br </span>--no-merged</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/一个和并提交.png" alt="一个和并提交" title>                </div>                <div class="image-caption">一个和并提交</div>            </figure><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程引用是对远程仓库的引用，包括分支标签等。<br>我们经常利用远程跟踪分支，它是远程分支状态的引用，它们是你不能移动的本地引用，当你进行任何网络操作时，它们会自动移动<br>远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签，以<remote>/<branch>命名，如origin/master</branch></remote></p><p>origin和master没有特殊含义，origin是git clone创建的远程仓库的默认名字，master是git init时默认的起始分支的名字<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查看完整远程引用列表</span></span><br><span class="line">git ls-remote</span><br><span class="line">git remote <span class="keyword">show</span> &lt;remote-name&gt;</span><br></pre></td></tr></table></figure></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/本地与远程的工作可以分叉.png" alt="本地与远程的工作可以分叉" title>                </div>                <div class="image-caption">本地与远程的工作可以分叉</div>            </figure><h3 id="推送到远程分支"><a href="#推送到远程分支" class="headerlink" title="推送到远程分支"></a>推送到远程分支</h3><p>你想分享一个分支，必须要将其推送到有写入权限的远程仓库，本地的分支不会自动与远程仓库同步，必须显式的推送<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将分支推送到远程仓库</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地分支与远程分支采用不同的名字</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; &lt;branch-<span class="keyword">name</span>&gt;:&lt;remote-branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他人可以获取到远程分支</span></span><br><span class="line">git fetch &lt;remote-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 合并远程分支到当前分支</span></span><br><span class="line">git merge &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git co -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="跟踪分支"><a href="#跟踪分支" class="headerlink" title="跟踪分支"></a>跟踪分支</h3><p>从一个远程仓库检出一个本地分支会自动创建一个做跟踪分支（上游分支），跟踪分支是与远程分支有直接关系的本地分支<br>如果在跟踪分支上输入git pull，则Git能自动识别去哪个服务器抓取、合并到哪个分支<br>克隆仓库时，会自动创建一个跟踪origin/master的master分支<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支</span></span><br><span class="line">git checkout -b &lt;branch-<span class="keyword">name</span>&gt; &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git checkout --track &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"><span class="comment">// 当前分支设置跟踪的远程分支</span></span><br><span class="line">git branch -u &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line">git branch --<span class="keyword">set</span>-upstream-<span class="keyword">to</span> &lt;remote-<span class="keyword">name</span>&gt;/&lt;branch-<span class="keyword">name</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置好跟踪分支后，可以通过@&#123;u&#125;或@&#123;upstream&#125;快捷方式来引用它</span></span><br><span class="line">git merge origin/master</span><br><span class="line">git merge @<span class="comment">&#123;u&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看分支跟踪的远程分支</span></span><br><span class="line">git branch -vv</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取远程分支，并不会修改本地工作目录中的内容，需要自己合并</span></span><br><span class="line">git fetch origin master</span><br><span class="line">git merge origin/master</span><br><span class="line"></span><br><span class="line"><span class="comment">// git pull会查找当前分支的跟踪分支，从服务器抓取数据然后尝试合并入那个远程分支</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除远程分支</span></span><br><span class="line">git push &lt;remote-<span class="keyword">name</span>&gt; --delete &lt;branch-<span class="keyword">name</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><p>Git中整合来自不同分支的修改主要有两种方法：merge和rebase<br>合并进行一次三方合并，产生一个新的快照并提交<br>变基首先找到两个分支的共同祖先，对比当前分支的历次提交，提取相应的修改，然后在新的分支上进行重新播放，最后进行一次快速合并<br>一般进行变基的目的是确保向远程分支推送时，保持提交历史的整洁<br>这两种方式整合的最终快照是一样的</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 将当前分支变基到<span class="literal">master</span>分支</span><br><span class="line">git rebase <span class="literal">master</span></span><br><span class="line">// 将在client分支里但不在server分支里的修改，在<span class="literal">master</span>分支里重放</span><br><span class="line">git rebase --onto <span class="keyword">master</span> <span class="title">server</span> client</span><br><span class="line">// 无需切换分支进行变基</span><br><span class="line">git rebase <span class="keyword">master</span> <span class="title">server</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/变基然后进行快进合并.png" alt="变基然后进行快进合并" title>                </div>                <div class="image-caption">变基然后进行快进合并</div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/通过合并操作来整合分叉的历史.png" alt="通过合并操作来整合分叉的历史" title>                </div>                <div class="image-caption">通过合并操作来整合分叉的历史</div>            </figure><p>变基存在风险，使用变基的准则是不要对在你的仓库外有副本的分支执行变基<br>变基的操作实际上是丢弃一些现有的提交，然后相应的新建一些内容一样的但是实际上不同的提交<br>如果别人在该分支上进行了工作，你对此分支进行了变基，那么就会出现问题<br>出现类似的情况可以使用变基来解决变基<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull <span class="comment">--rebase</span></span><br></pre></td></tr></table></figure></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上的命令和知识可以应付大部分Git的使用场景了<br>如果遇到其他的困难问题，可以后续再补充</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>1) <a href="https://git-scm.com/book/en/v2" target="_blank" rel="noopener">Pro Git</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;最近想深入了解一下Git，阅读了一下&lt;a href=&quot;https://git-scm.com/book/en/v2&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Pro Git&lt;/a&gt;的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅&lt;/p&gt;
&lt;h1 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h1&gt;&lt;p&gt;Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/p&gt;
&lt;p&gt;版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。&lt;br&gt;
    
    </summary>
    
    
      <category term="Git" scheme="https://gwq5210.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Cpp-Primer-Plus读书笔记（四）</title>
    <link href="https://gwq5210.com/2018/04/12/Cpp-Primer-Plus%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>https://gwq5210.com/2018/04/12/Cpp-Primer-Plus读书笔记（四）/</id>
    <published>2018-04-12T22:26:26.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-C-中的代码重用"><a href="#第十四章-C-中的代码重用" class="headerlink" title="第十四章 C++中的代码重用"></a>第十四章 C++中的代码重用</h1><p>C++的一个主要目标是促进代码重用。</p><h2 id="包含对象成员的类"><a href="#包含对象成员的类" class="headerlink" title="包含对象成员的类"></a>包含对象成员的类</h2><p>valarray是由头文件valarray定义，其用于处理数值<br>通常用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类<br>使用组合可以获得实现，但不获得接口，共有继承可以获得接口，可能还有实现</p><p>对于模板类我们可以使用typedef简化其描述</p><p>使用成员初始化列表来初始化包含的类对象。</p><h2 id="私有继承"><a href="#私有继承" class="headerlink" title="私有继承"></a>私有继承</h2><p>C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。这种关系是has-a关系。</p><p>包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象(subobject)来表示通过继承或包含添加的对象。</p><p>使用包含时使用对象名来调用方法，而使用私有继承时，将使用类名和作用域解析运算符来调用方法</p><p>私有继承如果希望访问基类对象，可以使用强制类型转换。同样，可以通过强制类型转换来使用基类的友元函数。</p><p>在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针。在多重继承情况下，不进行强制类型转换也无法确定应转换成哪个类。然而即使公有继承也必须进行强制类型抓换。</p><h3 id="使用包含还是私有继承"><a href="#使用包含还是私有继承" class="headerlink" title="使用包含还是私有继承"></a>使用包含还是私有继承</h3><p>使用包含更容易理解，继承会引起多个问题，尤其是使用多重继承的情况下，另外还可能需要包含类的多个子对象</p><p>通常应使用包含来实现has-a，如果新类要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承</p><h3 id="保护继承"><a href="#保护继承" class="headerlink" title="保护继承"></a>保护继承</h3><p>保护继承是私有继承的变体，其使用关键字protected<br>在使用保护继承时，基类的共有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的，当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别就呈现出来了，使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中将变成私有方法，使用保护继承时，基类的共有方法在第二代类中将变成受保护的，因此第三代类可以使用它们。隐式向上转换(implicit upcasting)意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。如下表<br>| 特征  | 共有继承 | 保护继承 | 私有继承 |<br>| —- | —- | —- | —- |<br>| 公有成员变成 | 派生类的公有成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 保护成员变成 | 派生类的保护成员 | 派生类的保护成员 | 派生类的私有成员 |<br>| 私有成员变成 | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 |<br>| 能否隐式向上转换 | 是 | 是(但只能在派生类中) | 否 |</p><h4 id="使用using重新定义访问权限"><a href="#使用using重新定义访问权限" class="headerlink" title="使用using重新定义访问权限"></a>使用using重新定义访问权限</h4><p>使用保护派生或私有派生时，假设要使基类的方法在派生类外可用，方法之一是定义一个使用该基类方法的派生类方法，如</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Student::sum</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::sum();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用基类特定的基类成员，即使采用的是私有派生，注意，using声明只使用成员名，没有圆括号，函数特征标和返回值，这使得所有成员名的方法都可用，其只适用于继承，不适用于包含。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>:</span> <span class="keyword">private</span> <span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">private</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::min;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::valarray&lt;<span class="keyword">double</span>&gt;::max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十四章-C-中的代码重用&quot;&gt;&lt;a href=&quot;#第十四章-C-中的代码重用&quot; class=&quot;headerlink&quot; title=&quot;第十四章 C++中的代码重用&quot;&gt;&lt;/a&gt;第十四章 C++中的代码重用&lt;/h1&gt;&lt;p&gt;C++的一个主要目标是促进代码重用。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="c++" scheme="https://gwq5210.com/tags/c/"/>
    
      <category term="Cpp Primer Plus" scheme="https://gwq5210.com/tags/Cpp-Primer-Plus/"/>
    
  </entry>
  
  <entry>
    <title>mathjax简单教程（翻译）</title>
    <link href="https://gwq5210.com/2018/02/04/mathjax%E7%AE%80%E5%8D%95%E6%95%99%E7%A8%8B%EF%BC%88%E7%BF%BB%E8%AF%91%EF%BC%89/"/>
    <id>https://gwq5210.com/2018/02/04/mathjax简单教程（翻译）/</id>
    <published>2018-02-04T00:36:22.000Z</published>
    <updated>2022-07-18T02:31:52.913Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mathjax简单教程（翻译）"><a href="#mathjax简单教程（翻译）" class="headerlink" title="mathjax简单教程（翻译）"></a>mathjax简单教程（翻译）</h1><p>原文地址：<a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="noopener">mathjax basic tutorial and quick reference</a></p><ol><li>在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。</li><li>使用\$…\$来产生行内公式，使用\$\$…\$\$来产生多行公式。公式$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\tag{displayed}$是不一样的。</li><li>使用\alpha,\beta,…,\omega来产生希腊字母：$\alpha$,$\beta$,$\omega$。使用\Gamma,\Delta,…,\Omega来产生大写的：$\Gamma$,$\Delta$,…,$\Omega$。</li><li>使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。</li></ol><a id="more"></a><ol start="5"><li>组。下标，上标和其他运算符只能应用到下一个”组”。单个符号或者被大括号{…}包含起来的公式被视为一个组。如10^10产生$10^10$，而不是$10^{10}$，这样写可以得到预期的结果：10^{10}。使用大括号可以界定公式中那些是上标或者下标：x^5^6是错误的，{x^y}^z是${x^y}^z$，x^{y^z}是$x^{y^z}$。显然x_i^2：$x_i^2$和x_{i^2}：$x_{i^2}$是不同的。</li><li>符号()[]产生对应的符号，如(3+4)[4+4]产生：$(3+4)[4+4]$。但使用{和}来产生大括号：${}$。<br>但上边的不会自动适应公式的大小，所以如果你写下(\frac12)，那么括号会很小：$(\frac12)$，使用\left(…\right)来使括号自动适应公式的大小：\left(\frac12\right)产生$\left(\frac12\right)$。<br>\left和\right可以作用于下边种类的括号：(和)：$\left(x\right)$，[和]：$\left[x\right]$，{和} ：$\left{x\right}$，|：$\left|x\right|$，\langle和\ rangle：$\left\langle{x}\right\rangle$，\lceil和\rceil：$\left\lceil{x}\right\rceil$，\lfloor和\rfloor：$\left\lfloor{x}\right\rfloor$。还有一种不可见的括号，用.来指代：\left.\frac12\right}表示$\left.\frac12\right}$。</li><li>使用\sum和\int来代表求和，积分。下标表示下限，上标表示上限，所以\sum_1^n表示$\sum_1^n$。上限和下限超过一个符号不要忘记加上{…}。如\sum_{i=0}^\infty i^2表示$\sum_{i=0}^\infty{i^2}$。类似的还有：\prod$表示\prod$，\int表示$\int$，\bigcup表示$\bigcup$，\bigcap表示$\bigcap$，\iint表示$\iint$。</li><li>分数有两种产生方式。\frac作用于下边紧邻的两个组；如\frac ab产生$\frac ab$。可以使用{…}来产生更复杂的表达式；如\frac{a+1}{b+1}产生$\frac{a+1}{b+1}$。如果分子和分母很复杂，你可能更喜欢\over，它分割一个组内的两部分产生分数；如{a+1 \over b+1}产生${a+1 \over b+1}$。</li><li>字体。<ul><li>使用\mathbb或\Bbb产生”blackboard bold”：$\mathbb{CHNQRZ}$</li><li>使用\mathface产生blodface：$\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathbf{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathtt产生”typewriter”字体：$\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathtt{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mattrm产生roman字体：$\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathrm{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathcal产生”calligraphic”字母：<br>$\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathcal{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathsrc产生script字母：<br>$\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathscr{abcdefghijklmnopqrstuvwxyz}$</li><li>使用\mathfrak产生”Fraktur”(老式德国风格)字母：<br>$\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\mathfrak{abcdefghijklmnopqrstuvwxyz}$</li></ul></li><li>使用\sqrt产生根号，它会自动适应公式的大小。如\sqrt{x^3}产生$\sqrt{x^3}$；\sqrt[3]{\frac xy}产生$\sqrt[3]{\frac xy}$。对于复杂的表达式可以使用{…}^{1/2}。</li><li>一些如lim，sin，max，ln的特殊函数可以使用\lim，\sin等产生。如\sin x产生$\sin x$，而不是sin x产生$sin x$。\lim使用下标产生趋近符号：\lim_{x\to 0}产生$\lim_{x\to 0}$。</li><li>有大量的特殊符号和记号，可以参考<a href="http://pic.plover.com/MISC/symbols.pdf" target="_blank" rel="noopener">this shorter listing</a>或<a href="http://mirror.math.ku.edu/tex-archive/info/symbols/comprehensive/symbols-a4.pdf" target="_blank" rel="noopener">this exhaustive listing</a>。一些常用的列在下边：<ul><li>\lt,\gt,\le,\ge,\neq分别表示$\lt$,$\gt$,$\le$,$\ge$,$\neq$。你可以使用\not来在大多数符号上画上斜线，但通常看起来很差劲，如\not\lt表示$\not\lt$。</li><li>\times,\div,\pm,\mp分别表示$\times$,$\div$,$\pm$,$\mp$。\cdot表示一个居中的点：$x\cdot y$。</li><li>\cup,\cap,\setminus,\subset,\subseteq,\subsetneq,\supset,\in,\notin,\emptyset,\varnothing分别表示$\cup\, \cap\, \setminus\, \subset\, \subseteq \,\subsetneq \,\supset\, \in\, \notin\, \emptyset\, \varnothing$。</li><li>{n+1 \choose 2k}或者\binom{n+1}{2k}表示${n+1 \choose 2k}$。</li><li>\to,\rightarrow,\leftarrow,\Rightarrow,\Leftarrow,\mapsto分别表示$\to\, \rightarrow\, \leftarrow\, \Rightarrow\, \Leftarrow\, \mapsto$。</li><li>\land,\lor,\lnot,\forall,\exists,\top,\bot,\vdash,\vDash分别表示$\land\, \lor\, \lnot\, \forall\, \exists\, \top\, \bot\, \vdash\, \vDash$。</li><li>\star\, \ast\, \oplus\, \circ\, \bullet分别表示$\star\, \ast\, \oplus\, \circ\, \bullet$。</li><li>\approx\, \sim \, \simeq\, \cong\, \equiv\, \prec分别表示$\approx\, \sim \, \simeq\, \cong\, \equiv\, \prec$。</li><li>\infty\, \aleph_0, \nabla\, \partial, \Im\, \Re分别表示$\infty\, \aleph_0, \nabla\, \partial, \Im\, \Re$。</li><li>可以使用\pmod来产生同余式，如a\equiv b\pmod n产生$a\equiv b\pmod n$。</li><li>\ldots可以产生这里的点：$a_1, a_2, \ldots ,a_n$；\cdots产生这里的点：$a_1+a_2+\cdots+a_n$。</li><li>一些希腊字母具有不同的形式：\epsilon\, \varepsilon分别表示$\epsilon\, \varepsilon$，\phi\, \varphi分别表示$\phi\, \varphi$，\ell表示$\ell$等。</li></ul></li><li>在mathjax的公式中加入空格，不会改变公式中空格的数量。如a␣b和a␣␣␣␣b都产生$a b$。可以使用\,加入一个空格$a\,b$，使用\;加入一个宽空格$a\;b$，使用\quad和\qquad产生大量的空格$a\quad b,a\qquad b$。<br>可以使用\text{…}在公式中加入普通文本：${x\in s\mid x\text{ is extra large}}$。还可以在\text{…}中嵌套\$…\$。</li><li>强调和区别标志。\hat用于单个符号：$\hat x$,\widehat用于一个公式：$\widehat{xy}$。如果将它弄的特别宽，看起来就十分丑。类似的，\bar产生$\bar x$，\overline产生$\overline{xyz}$，\vec产生$\vec x$，\overrightarrow产生$\overrightarrow{xy}$。可以使用\dot和\ddot产生点和双点，如\frac d{dx}x\dot x =  \dot x^2 +  x\ddot x产生$\frac d{dx}x\dot x =  \dot x^2 +  x\ddot x$。</li><li>使用\来转义mathjax中使用的特殊字符，如\$表示$\$$，{表示${$，_表示$_$等等。<br>教程到此结束。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;mathjax简单教程（翻译）&quot;&gt;&lt;a href=&quot;#mathjax简单教程（翻译）&quot; class=&quot;headerlink&quot; title=&quot;mathjax简单教程（翻译）&quot;&gt;&lt;/a&gt;mathjax简单教程（翻译）&lt;/h1&gt;&lt;p&gt;原文地址：&lt;a href=&quot;http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;mathjax basic tutorial and quick reference&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &amp;gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。&lt;/li&gt;
&lt;li&gt;使用\$…\$来产生行内公式，使用\$\$…\$\$来产生多行公式。公式$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}\tag{displayed}$是不一样的。&lt;/li&gt;
&lt;li&gt;使用\alpha,\beta,…,\omega来产生希腊字母：$\alpha$,$\beta$,$\omega$。使用\Gamma,\Delta,…,\Omega来产生大写的：$\Gamma$,$\Delta$,…,$\Omega$。&lt;/li&gt;
&lt;li&gt;使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
      <category term="mathjax教程" scheme="https://gwq5210.com/tags/mathjax%E6%95%99%E7%A8%8B/"/>
    
      <category term="LaTeX" scheme="https://gwq5210.com/tags/LaTeX/"/>
    
  </entry>
  
</feed>
