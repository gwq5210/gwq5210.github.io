<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>gwq5210&#39;s Blog</title>
  
  <subtitle>凡是过往，皆为序章！</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gwq5210.com/"/>
  <updated>2022-08-03T12:56:33.264Z</updated>
  <id>https://gwq5210.com/</id>
  
  <author>
    <name>gwq5210</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>APUE笔记-六</title>
    <link href="https://gwq5210.com/2022/08/03/APUE%E7%AC%94%E8%AE%B0-%E5%85%AD/"/>
    <id>https://gwq5210.com/2022/08/03/APUE笔记-六/</id>
    <published>2022-08-03T20:54:10.000Z</published>
    <updated>2022-08-03T12:56:33.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十六章-网络IPC：套接字"><a href="#第十六章-网络IPC：套接字" class="headerlink" title="第十六章 网络IPC：套接字"></a>第十六章 网络IPC：套接字</h1><p>UNIX系统所提供的的经典进程间通信机制（IPC）：管道、FIFO、消息队列、信号量以及共享存储。这些机制允许在同一台计算机上运行的进程可以相互通信。网络进程间通信（network IPC）可以让在不同计算机（通过网络相连）上的进程相互通信</p><p>套接字网络进程间通信接口，进程用该接口能够和其他进程通信，无论它们是在同一台计算机上还是在不同的计算机上。实际上，这正是套接字接口的设计目标之一：同样的接口既可以用于计算机间通信，也可以用于计算机内通信。</p><h2 id="套接字描述符"><a href="#套接字描述符" class="headerlink" title="套接字描述符"></a>套接字描述符</h2><p>套接字是通信端点的抽象。正如使用文件描述符访问文件，应用程序使用套接字描述符访问套接字。套接字描述符在UNIX系统中被当作是一种文件描述符。事实上，许多处理文件描述符的函数（如read和write）可以用于处理套接字描述符。使用socket函数创建一个套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件（套接字）描述符；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参数domain（域）确定通信的特性，包括地址格式。各个域都有自己表示地址的格式，而表示各个域的常数都以AF_开头，表示地址族（address family）。</p><p>大多数系统还定义了AF_LOCAL域，这是AF_UNIX的别名。AF_UNSPEC域可以代表“任何”域。套接字通信域如下</p><table><thead><tr><th>域</th><th>描述</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4因特网域</td></tr><tr><td>AF_INET6</td><td>IPv6因特网域</td></tr><tr><td>AF_UNIX</td><td>UNIX域</td></tr><tr><td>AF_UNSPEC</td><td>未执行</td></tr></tbody></table><p>参数type确定套接字的类型，进一步确定通信特征。</p><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>SOCK_DGRAM</td><td>固定长度的、无连接的、不可靠的报文传递</td></tr><tr><td>SOCK_RAW</td><td>IP协议的数据报接口</td></tr><tr><td>SOCK_SEQPACKET</td><td>固定长度的、有序的、可靠的、面向连接的报文传递</td></tr><tr><td>SOCK_STREAM</td><td>有序的、可靠的、双向的、面向连接的字节流</td></tr></tbody></table><p>参数protocol通常是0，表示为给定的域和套接字类型选择默认协议。当对同一域和套接字类型支持多个协议时，可以使用protocol选择一个特定协议。在AF_INET通信域中，套接字类型SOCK_STREAM的默认协议是传输控制协议（Transmission Control Protocol，TCP）。在AF_INET通信域中，套接字类型SOCK_DGRAM的默认协议是UDP。</p><table><thead><tr><th>协议</th><th>描述</th></tr></thead><tbody><tr><td>IPPROTO_IP</td><td>IPv4网际协议</td></tr><tr><td>IPPROTO_IPV6</td><td>IPv6网际协议</td></tr><tr><td>IPPROTO_ICMP</td><td>因特网控制报文协议（Internet Control Message Protocol）</td></tr><tr><td>IPPROTO_RAW</td><td>原始IP数据包协议</td></tr><tr><td>IPPROTO_TCP</td><td>传输控制协议</td></tr><tr><td>IPPROTO_UDP</td><td>用户数据报协议（User Datagram Protocol）</td></tr></tbody></table><p>对于数据报（SOCK_DGRAM）接口，两个对等进程之间通信时不需要逻辑连接。只需要向对等进程所使用的套接字送出一个报文</p><p>因此数据报提供了一个无连接的服务。另一方面，字节流（SOCK_STREAM）要求在交换数据之前，在本地套接字和通信的对等进程的套接字之间建立一个逻辑连接</p><p>数据报值自包含报文。发送数据报近似于给某人邮寄信件。你能邮寄很多信，但不能保证传递的次序，并且可能有些信件会丢失在路上。每封信件包含接收者地址，使这封信件独立于所有其他信件。每封信件可能送达不同的接收者</p><p>相反，使用面向连接的协议通信就像与对方打电话。首先需要通过电话建立一个连接，连接建立好之后，彼此能双向的通信。每个连接是端到端的通信链路。对话中不包含地址信息，就像呼叫两端存在一个点对点虚拟连接，并且连接本身暗示特定的源和目的地</p><p>SOCK_STREAM套接字提供字节流服务，所以应用程序分辨不出报文的界限。这意味着从SOCK_STREAM套接字读数据时，它也许不会返回所有由发送进程所写的字节数。最终可以获得发送过来的所有数据，但也许要通过若干次函数调用才能得到。</p><p>SOCK_SEQPACKET套接字和SOCK_STREAM套接字很类似，只是从该套接字得到的是基于报文的服务而不是字节流服务。这意味着从SOCK_SEQPACKET套接字接收的数据量与对方发送的一致。流控制传输协议（Stream Control Transmission Protocol，SCTP）提供了因特网域上的顺序数据包服务</p><p>SOCK_RAW套接字提供一个数据报接口，用于直接访问下面的网络层（即因特网域中的IP层）。使用这个接口时，应用程序负责构造自己的协议头部，这是因为传输协议（如TCP和UDP）被绕过了。当创建一个原始套接字时，需要有超级用户特权，这样可以防止恶意应用程序绕过内建安全机制来创建报文</p><p>调用socket与调用open类似。在两种情况下，均可获得用于IO的文件描述符。当不再需要该文件描述符时，调用close来关闭对文件或套接字的访问，并且释放该描述符以便重新使用</p><p>虽然套接字描述符本质上是一个文件描述符，但不是所有参数为文件描述符的函数都可以接受套接字描述符。未指定和由实现定义的行为通常意味着该函数对套接字描述符无效。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/文件描述符函数使用套接字时的行为.png" alt="文件描述符函数使用套接字时的行为" title>                </div>                <div class="image-caption">文件描述符函数使用套接字时的行为</div>            </figure><p>套接字通信是双向的。可以采用shutdown函数来禁止一个套接字的IO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> how)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果how是SHUT_RD（关闭读端），那么无法从套接字读取数据。如果how是SHUT_WR（关闭写端），那么无法使用套接字发送数据。如果how是SHUT_RDWR，则既无法读取数据，又无法发送数据。</p><p>能够关闭（close）一个套接字，为何还使用shutdown呢？这里有若干理由。首先，只有最后一个活动引用关闭时，close才释放网络断点。这意味着如果复制一个套接字（如采用dup），要直到关闭了最后一个引用它的文件描述符才会释放这个套接字。而shutdown允许使一个套接字处于不活动状态，和引用它的文件描述符数目无关。其次，有时可以很方便的关闭套接字双向传输中的一个方向。例如，如果想让所通信的进程能够确定数据传输何时结束，可以关闭该套接字的写端，然而通过该套接字读端仍可以继续接收数据</p><h2 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h2><p>需要知道如何标识一个目标通信进程。进程标识由两部分组成。一部分是计算机的网络地址，它可以帮助标识网络上我们想与之通信的计算机；另一部分是该计算机上用端口号表示的服务，它可以帮助标识特定的进程</p><h3 id="字节序"><a href="#字节序" class="headerlink" title="字节序"></a>字节序</h3><p>与同一台计算机上的进程通信时，一般不用考虑字节序。字节序是一个处理器架构特性，用于指示像整数这样的大数据类型内部的字节如何排序。</p><p>如果处理器架构支持大端（bit-endian）字节序，那么最大字节地址出现在最低有效字节（Least Significant Byte，LSB）上。小端（little-endian）字节序则相反：最低有效字节包含最小字节地址。<br>注意不管字节如何排序，最高有效字节（Most Significant Byte，MSB）总是在左边，最低有效字节总是在右边。因此如果想给一个32位证书赋值0x04030201，不管字节序如何，最高有效字节都将包含4，最低有效字节都将包含1.如果接下来想将一个字符指针（cp）强制转换到这个整数地址，就会看到字节序带来的不同。在小端字节序的处理器上，cp[0]指向最低有效字节因而包含1，cp[3]指向最高有效字节因而包含4。大端序则相反。</p><p>网络协议指定了字节序，因此异构计算机系统能够交换协议信息而不会被字节序所混淆。TCP/IP协议栈使用大端字节序。应用程序交换格式化数据时，字节序问题就会出现。对于TCP/IP，地址用网络字节序来表示，所以应用程序有时需要在处理器的字节序和网络字节序之间转换。</p><p>对于TCP/IP应用程序，有4个用来在处理器字节序和网络字节序之间实施转换的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">htonl</span><span class="params">(<span class="keyword">uint32_t</span> hostint32)</span></span>;</span><br><span class="line"></span><br><span class="line">返回以网络字节序表示的<span class="number">32</span>位整数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">htons</span><span class="params">(<span class="keyword">uint16_t</span> hostint16)</span></span>;</span><br><span class="line"></span><br><span class="line">返回以网络字节序表示的<span class="number">16</span>位整数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">uint32_t</span> netint32)</span></span>;</span><br><span class="line"></span><br><span class="line">返回以主机字节序表示的<span class="number">32</span>位整数</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint16_t</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">uint16_t</span> netint16)</span></span>;</span><br><span class="line"></span><br><span class="line">返回以主机字节序表示的<span class="number">16</span>位整数</span><br></pre></td></tr></table></figure><p>h表示主机字节序，n表示网络字节序。l表示长（4字节）整数，s表示短（2字节）整数。这些函数常常实现为宏</p><h2 id="地址格式"><a href="#地址格式" class="headerlink" title="地址格式"></a>地址格式</h2><p>一个地址标识一个特定通信域的套接字端点，地址格式与这个特定的通信域相关。为何不同格式地址能够传入到套接字函数，地址会被强制转换成一个通用的地址结构sockaddr。套接字实现可以自由地添加额外的成员并且定义sa_data成员的大小。例如在Linux中和FreeBSD中，其结构定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">as_family_t</span> sa_family;  <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">char</span> sa_data[];  <span class="comment">// variable-length address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Linux结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>];  <span class="comment">// variable-length address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// FreeBSD结构定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_len;  <span class="comment">// total length</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// variable-length address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因特网地址定义在&lt;netinet/in.h&gt;头文件中。在IPv4因特网域（AF_INET）中，套接字地址用结构sockaddr_in表示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">  <span class="keyword">in_addr_t</span> s_addr; <span class="comment">// IPv4 address（定义为uint32_t）</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sin_family; <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">in_port_t</span> sin_port; <span class="comment">// port number (in_port_t定义为uint16_t)</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4 address</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与AF_INET域相比较，IPv6因特网域（AF_INET6）套接字地址用结构sockaddr_in6表示</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint8_t</span> s6_addr[<span class="number">16</span>];  <span class="comment">// IPv6 address</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sin6_family; <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">in_port_t</span> sin6_port; <span class="comment">// port number</span></span><br><span class="line">  <span class="keyword">uint32_t</span> sin6_flowinfo;  <span class="comment">// traffic class and flow info</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span> <span class="comment">// IPv6 address</span></span><br><span class="line">  <span class="keyword">uint32_t</span> sin6_scope_id;  <span class="comment">// set of interfaces for scope</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这些都是Single UNIX Specification要求的定义。每个实现可以自由添加更多的字段。例如，在Linux中，sockaddr_in定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">  <span class="keyword">sa_family_t</span> sin_family;  <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">in_port_t</span> sin_port;  <span class="comment">// port number</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>  <span class="comment">// IPv4 address</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];  <span class="comment">// filler，填充字段，应该全部被置为0</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，尽管sockaddr_in和sockaddr_in6的结构相差比较大，但它们均被强制转换成sockaddr结构输入到套接字例程中。UNIX域套接字地址的结构与上述两个因特网域套接字地址格式稍有不同</p><p>有时，需要打印出能被人理解而不是计算机所理解的地址格式。BSD网络软件包含函数inet_addr和inet_ntoa，用于二进制地址格式与点分十进制字符表示（a.b.c.d）之间的相互转换。但是这个函数仅适用于IPv4地址。有两个新函数inet_ntop和inet_pton具有相似的功能，而且同时支持IPv4和IPv6地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">restrict</span> addr, <span class="keyword">char</span>* <span class="keyword">restrict</span> str, <span class="keyword">socklen_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回地址字符串指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, <span class="keyword">void</span>* <span class="keyword">restrict</span> addr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">1</span>；若格式无效，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数inet_ntop将网络字节序的二进制地址转换成文本字符串格式。inet_pton将文本字符串格式转换成网络字节序的二进制地址。参数domain仅支持两个值：AF_INET和AF_INET6。对于inet_ntop，参数size指定了保存文本字符串的缓冲区（str）的大小。两个常数用于简化工作：INET_ADDDRSTRLEN定义了足够大的空间来存放一个标识IPv4地址的文本字符串；INET6_ADDDRSTRLEN定义了足够大的空间来存放一个表示IPv6地址的文本字符串。对于inet_pton，如果domain是AF_INET，则缓冲区addr需要足够大的空间来存放一个32位地址，如果domain是AF_INET6，则需要足够大的空间来存放一个128位地址</p><h2 id="地址查询"><a href="#地址查询" class="headerlink" title="地址查询"></a>地址查询</h2><p>理想情况下，应用程序不需要了解一个套接字地址的内部结构。如果一个程序简单的传递一个类似于sockaddr结构的套接字地址，并且不依赖于任何协议相关的特性，那么可以与提供相同类型服务的许多不同协议协作</p><p>历史上，BSD网络软件提供了访问各种网络配置信息的接口。我们需要深入了解一些细节，并引入新的函数来查询寻址信息</p><p>这些函数返回的网络配置信息被存放在许多地方。这个信息可以存放在静态文件（如/etc/hosts和/etc/services）中，也可以由名字服务管理，如域名系统（Domain Name System，DNS）或者网络信息服务（Network Infomation Service，NIS）。无论这个信息放在何处，都可以用同样的函数访问它</p><p>通过调用gethostent，可以找到给定计算机系统的主机信息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sethostent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endhostent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>如果主机数据库文件没有打开，gethostent会打开它。函数gethostent返回文件中的下一个条目。函数sethostent会打开文件，如果文件已经被打开，那么将其回绕。当stayopen参数设置成非0值时，调用gethostent之后，文件将亦然是打开的。函数endhostent可以关闭文件。</p><p>当gethostent返回时，会得到一个指向hostent结构的指针，该结构可能包含一个静态的数据缓冲区，每次调用gethostent，缓冲区都会被覆盖。hostent结构至少包含以下成员，返回的地址采用网络字节序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* h_name;  <span class="comment">// name of host</span></span><br><span class="line">  <span class="keyword">char</span>** h_aliases;  <span class="comment">// pointer to alternate host name array</span></span><br><span class="line">  <span class="keyword">int</span> h_addrtype;  <span class="comment">// address type</span></span><br><span class="line">  <span class="keyword">int</span> h_length;  <span class="comment">// length in bytes of address</span></span><br><span class="line">  <span class="keyword">char</span>** h_addr_list;  <span class="comment">// pointer to array of network addresses</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用一套相似的接口来获得网络名字和网络编号</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct netent* <span class="title">getnetbyaddr</span><span class="params">(<span class="keyword">uint32_t</span> net, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="function">struct netent* <span class="title">getnetbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function">struct netent* <span class="title">getnetent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnetent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endnetent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>netent结构至少包含以下字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">netent</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* n_name;  <span class="comment">// network name</span></span><br><span class="line">  <span class="keyword">char</span>** n_aliases; <span class="comment">// alternate network name array pointer</span></span><br><span class="line">  <span class="keyword">int</span> n_addrtype;  <span class="comment">// address type</span></span><br><span class="line">  <span class="keyword">uint32_t</span> n_net;  <span class="comment">// network number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>网络编号按照网络字节序返回。地址类型是地址族常量之一（如AF_INET）</p><p>我们可以用以下函数在协议名字和协议编号之间进行映射</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct protoent* <span class="title">getprotobyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"><span class="function">struct protoent* <span class="title">getprotobynumber</span><span class="params">(<span class="keyword">int</span> proto)</span></span>;</span><br><span class="line"><span class="function">struct protoent* <span class="title">getprotoent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setprotoent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endprotoent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>POSIX.1定义的protoent结构至少包含以下成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">protoent</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* p_name;  <span class="comment">// protocol name</span></span><br><span class="line">  <span class="keyword">char</span>** p_aliases;  <span class="comment">// pointer to alternate protocol name array</span></span><br><span class="line">  <span class="keyword">int</span> p_proto;  <span class="comment">// protocol number</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>服务是由地址的端口号部分表示的。每个服务由一个唯一的众所周知的端口号来支持。可以使用函数getservbyname将一个服务名映射到一个端口号，使用函数getservbyport将一个端口号映射到一个服务名，使用函数getservent顺序扫描服务数据库</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setservent</span><span class="params">(<span class="keyword">int</span> stayopen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">endservent</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>servent结构至少包含以下成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span>* s_name;  <span class="comment">// service name</span></span><br><span class="line">  <span class="keyword">char</span>** s_aliases;  <span class="comment">// pointer to alternate service name array</span></span><br><span class="line">  <span class="keyword">int</span> s_port;  <span class="comment">// port number</span></span><br><span class="line">  <span class="keyword">char</span>* s_proto;  <span class="comment">// name of protocol</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>POSIX.1定义了若干新函数，允许一个应用程序将一个主机名和一个服务名映射到一个地址，或者反之。这些函数替代了较老的函数gethostbyname和gethostbyaddr</p><p>getaddrinfo函数允许将一个主机名和一个服务名映射到一个地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> host, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> service, <span class="keyword">const</span> struct addrinfo* <span class="keyword">restrict</span> hint, struct addrinfo** <span class="keyword">restrict</span> res)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span>错误码</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* ai)</span></span>;</span><br></pre></td></tr></table></figure><p>需要提供主机名、服务名，或者两者都提供。如果仅仅提供一个名字，另外一个应该是一个空指针。主机名可以是一个节点名或点分格式的主机地址</p><p>getaddrinfo函数返回一个链表结构addrinfo。可以用freeaddrinfo来释放一个或多个这种结构，这取决于用ai_next字段链接起来的结构有多少</p><p>addrinfo结构的定义至少包含以下成员</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> ai_flags;  <span class="comment">// customize behavior</span></span><br><span class="line">  <span class="keyword">int</span> ai_family;  <span class="comment">// address family</span></span><br><span class="line">  <span class="keyword">int</span> ai_socktype;  <span class="comment">// socket type</span></span><br><span class="line">  <span class="keyword">int</span> ai_protocol; <span class="comment">// protocol</span></span><br><span class="line">  <span class="keyword">socklen_t</span> ai_addrlen;  <span class="comment">// length in bytes of address</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span>  <span class="comment">// address</span></span><br><span class="line">  <span class="keyword">char</span>* ai_canonname;  <span class="comment">// canonical name of host</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span>  <span class="comment">// next in list</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以提供一个可选的hint来选择符合特定条件的地址。hint是一个用于过滤地址的模板，包括ai_family、ai_flags、ai_protocol和ai_socktype字段。剩余的整数字段必须设置为0，指针字段必须为空。</p><p>ai_flags字段中的标志，可以用这些标志来自定义如何处理地址和名字</p><table><thead><tr><th>标志</th><th>描述</th></tr></thead><tbody><tr><td>AI_ADDRCONFIG</td><td>查询配置的地址类型（IPv4或IPv6）</td></tr><tr><td>AI_ALL</td><td>查询IPv4和IPv6地址（仅用于AI_V4MAPPED）</td></tr><tr><td>AI_CANONNAME</td><td>需要一个规范的名字（与别名相对）</td></tr><tr><td>AI_NUMERICHOST</td><td>以数字格式指定主机地址，不翻译</td></tr><tr><td>AI_NUMERICSERV</td><td>将服务指定为数字端口号，不翻译</td></tr><tr><td>AI_PASSIVE</td><td>套接字地址用于监听绑定</td></tr><tr><td>AI_V4MAPPED</td><td>如果没有找到IPv6地址，返回映射到IPv6格式的IPv4地址</td></tr></tbody></table><p>如果getaddrinfo失败，不能使用perror或strerror来生成错误消息，而是要调用gai_strerror将返回的错误码转换成错误消息</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> error)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向描述错误的字符串的指针</span><br></pre></td></tr></table></figure><p>getnameinfo函数将一个地址转换成一个主机名和一个服务名</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* <span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span> alen, <span class="keyword">char</span>* <span class="keyword">restrict</span> host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* <span class="keyword">restrict</span> service, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span>值</span><br></pre></td></tr></table></figure><p>套接字地址（addr）被翻译成一个主机名和一个服务名。如果host非空，则指向一个长度为hostlen字节的缓冲区用于存放返回的主机名。同样如果service非空，则指向一个长度为servlen字节的缓冲区用于存放返回的主机名</p><p>flags参数提供了一些控制翻译的方式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/getnameinfo函数的标志.png" alt="getnameinfo函数的标志" title>                </div>                <div class="image-caption">getnameinfo函数的标志</div>            </figure><h2 id="将套接字与地址关联"><a href="#将套接字与地址关联" class="headerlink" title="将套接字与地址关联"></a>将套接字与地址关联</h2><p>将一个客户端的套接字关联上一个地址没有多少新意，可以让系统选一个默认的地址。然而，对于服务器，需要给一个接收客户端请求的服务器套接字关联上一个众所周知的地址。客户端应有一种方法来发现连接服务器所需要的地址，最简单的方法就是服务器保留一个地址并且注册在/etc/services或者某个名字服务中</p><p>使用bind函数来关联地址和套接字</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>对于使用的地址有以下一些限制</p><ul><li>在进程正在运行的计算机上，指定的地址必须有效；不能指定一个其他机器的地址</li><li>地址必须和创建套接字时的地址族所支持的格式相匹配</li><li>地址中的端口号必须不小于1024，除非该进程具有相应的特权（即超级用户）</li><li>一般只能将一个套接字端点绑定到一个给定的地址上，尽管有些协议允许多重绑定</li></ul><p>对于因特网域，如果指定IP地址为INADDR_ANY（&lt;netinet/in.h&gt;中定义的），套接字端点可以被绑定到所有的系统网络接口上。这意味着可以接收这个系统所安装的任何一个网卡的数据包。如果调用connect或listen，但没有将地址绑定到套接字上，系统会选一个地址绑定到套接字上</p><p>可以调用getsockname函数来发现绑定到套接字上的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* <span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> alenp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>调用getsockname之前，将alenp设置为一个指向整数的指针，该整数指定缓冲区sockaddr的长度。返回时，该整数会被设置成返回地址的大小。如果地址和提供的缓冲区长度不匹配，地址会被自动截断而不报错。如果当前没有地址绑定到该套接字，则其结果是未定义的。</p><p>如果套接字已和对等方连接，可以调用getpeername函数来找到对方的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* <span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> alenp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>除了返回对等方的地址，函数getpeername和getsockname一样</p><h2 id="建立连接"><a href="#建立连接" class="headerlink" title="建立连接"></a>建立连接</h2><p>如果要处理一个面向连接的网络服务（SOCK_STREAM或SOCK_SEQPACKET），那么在开始交换数据以前，需要在请求服务的进程套接字（客户端）和提供服务的进程套接字（服务器）之间简历一个连接。使用connect函数来建立连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>在connect中指定的地址是我们想与之通信的服务器地址。如果sockfd没有绑定到一个地址，connect会给调用者绑定一个默认地址</p><p>当尝试连接服务器时，出于一些原因，连接可能会失败。要想一个连接请求成功，要连接的计算机必须是开启的，并且正在运行，服务器必须绑定到一个想与之连接的地址上，并且服务器的等待连接队列要有足够的空间。因此应用程序必须能够处理connect返回的错误，这些错误可能是由一些瞬时条件引起的。因此可以对connect进行重试connect来处理瞬时错误，可以使用指数补偿算法，每次休眠时间指数级增加</p><p>如果套接字描述符处于非阻塞模式，那么在连接不能马上建立时，connect将会返回-1并且将errno设置为特殊的错误码EINPROGRESS。应用程序可以使用poll或者select来判断文件描述符何时可写。如果可写，连接完成。</p><p>connect函数还可以用于无连接的网络服务（SOCK_DGRAM）。这看起来有点矛盾，实际上却是一个不错的选择。如果用SOCK_DGRAM套接字调用connect，传送的报文的目标地址会设置成connect调用中所指定的地址，这样每次传送报文时就不需要再提供地址。另外，仅能接收来自指定地址的报文</p><p>服务器调用listen函数来宣告它愿意接受连接请求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参数backlog提供了一个提示，提示系统该进程所要入队列的未完成连接请求数量。其实际值由系统决定，但上限由&lt;sys/socket.h&gt;中的SOMAXCONN指定</p><p>一旦队列满，系统就会拒绝对于的连接请求，所以backlog的值应该基于服务器期望负载和处理量来选择，其中处理量是指接受连接请求与启动服务的数量</p><p>一旦服务器调用了listen，所用的套接字就能接收连接请求。使用accept函数获得连接请求并建立连接</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* <span class="keyword">restrict</span> addr, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件（套接字）描述符；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数accept所返回的文件描述符是套接字描述符，该描述符连接到调用connect的客户端。这个新的套接字描述符和原始套接字（sockfd）具有相同的套接字类型和地址族。传给accept的原始套接字没有关联到这个连接，而是继续保持可用状态并接收其他连接请求</p><p>如果不关心客户端标识，可以将参数addr和len设置为NULL。否则，在调用accept之前，将addr参数设为足够大的缓冲区来存放地址，并且将len指向的整数设置为这个缓冲区的字节大小。返回时，accept会在缓冲区填充客户端的地址，并且更新指向len的整数来反映改地址的大小</p><p>如果没有连接请求在等待，accept会阻塞直到一个请求到来。如果sockfd处于非阻塞模式，accept会返回-1，并将errno设置为EAGAIN或EWOULDBLOCK。</p><p>如果服务器调用accept，并且当前没有连接请求，服务器会阻塞直到一个请求到来。另外，服务器可以使用poll或select来等待一个请求的到来。在这种情况下，一个带有等待连接请求的套接字会以可读的方式出现</p><h2 id="数据传输"><a href="#数据传输" class="headerlink" title="数据传输"></a>数据传输</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十六章-网络IPC：套接字&quot;&gt;&lt;a href=&quot;#第十六章-网络IPC：套接字&quot; class=&quot;headerlink&quot; title=&quot;第十六章 网络IPC：套接字&quot;&gt;&lt;/a&gt;第十六章 网络IPC：套接字&lt;/h1&gt;&lt;p&gt;UNIX系统所提供的的经典进程间通信机制（I
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记-五</title>
    <link href="https://gwq5210.com/2022/07/29/APUE%E7%AC%94%E8%AE%B0-%E4%BA%94/"/>
    <id>https://gwq5210.com/2022/07/29/APUE笔记-五/</id>
    <published>2022-07-29T15:08:47.000Z</published>
    <updated>2022-08-03T12:56:33.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四章-高级IO"><a href="#第十四章-高级IO" class="headerlink" title="第十四章 高级IO"></a>第十四章 高级IO</h1><h2 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h2><p>系统调用可分成两类：“低速”系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用，包括</p><ul><li>如果某些文件类型（如读管道、终端设备和网络设备）的数据并不存在，读操作可能会使调用者永远阻塞</li><li>如果数据不能被相同的文件类型立即接受（如管道中无空间，网络流控制），写操作可能会使调用者永远阻塞</li><li>在某种条件发生之前打开某些文件类型可能会发生阻塞（如要打开一个终端设备，需要先等待与之连接的调制解调器应答，又如若以只读模式打开FIFO，那么在没有其他进程已用读模式打开该FIFO时也要等待）</li><li>对已经加上强制性记录锁的文件进行读写</li><li>某些ioctl操作</li><li>某些进程间通信函数</li></ul><p>虽然读写磁盘文件会暂时阻塞调用者，但并不能将与磁盘IO有关的系统调用视为“低速”</p><p>非阻塞IO使我们可以发出open、read和write这样的IO操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。设置阻塞方法如下</p><ul><li>如果调用open获得描述符，则可指定O_NONBLOCK标志</li><li>对于已经打开的一个描述符，则可调用fcntl，由该函数打开O_NONBLOCK文件状态标志。</li></ul><h2 id="记录锁"><a href="#记录锁" class="headerlink" title="记录锁"></a>记录锁</h2><p>记录锁（record locking）的功能是：当一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言，“记录”这个词是一个误用，因为UNIX系统内核根本没有使用文件记录这个概念。一个更适合的术语可能是字节范围锁（byte-range locking），因为它锁定的只是文件中的一个区域（也可能是整个文件）</p><p>POSIX.1使用fcntl来创建记录锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ...<span class="comment">/* struct flock* flockptr */</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回值依赖于cmd；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数（我们将调用flockptr）是一个指向flock结构的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">flock</span> &#123;</span></span><br><span class="line">  short l_type;  <span class="comment">// F_RDLCK, F_WRLCK or F_UNLCK</span></span><br><span class="line">  short l_whence;  <span class="comment">// SEEK_SET, SEEK_CUR or SEEK_END</span></span><br><span class="line">  <span class="keyword">off_t</span> l_start;  <span class="comment">// offset in bytes, relative to l_whence</span></span><br><span class="line">  <span class="keyword">off_t</span> l_len;  <span class="comment">// length, in bytes; 0 means lock to EOF</span></span><br><span class="line">  <span class="keyword">pid_t</span> l_pid;  <span class="comment">// returned with F_GETLK</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>进程的ID（l_pid）持有的锁能阻塞当前进程（仅有F_GETLK返回）</li><li>锁可以在当前文件尾端处开始或者越过尾端处开始，但是不能在文件起始位置之前开始</li><li>如若l_len为0，则表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件中追加写了多少数据，它们都可以处于锁的范围内（不必猜测会有多少字节被追加写到了文件之后），而且起始位置可以是文件中的任意一个位置</li><li>为了对整个文件加锁，我们设置l_start和l_whence指向文件的起始位置，并且指定长度（l_len）为0</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/不同类型锁彼此之间的兼容性.png" alt="不同类型锁彼此之间的兼容性" title>                </div>                <div class="image-caption">不同类型锁彼此之间的兼容性</div>            </figure><p>上述兼容性规则适用于不同进程提出的锁请求，并不适用于单个进程提出的多个锁请求。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有锁。加读锁时，该描述符必须是读打开的。加写锁时，该描述符必须是写打开的</p><p>fcntl的三个命令如下</p><ul><li>F_GETLK：判断由flockptr所描述的锁是否会被另外一把锁所排斥（阻塞）。如果存在一把锁，它阻止创建由flockptr所描述的锁，则该现有锁的信息将重写flockptr指向的信息。如果不存在这种情况，则除了将l_type设置为F_UNLCK之外，flockptr所指向结构中的其他信息保持不变</li><li>F_SETLK：设置由flockptr所描述的锁。如果我们试图获得一把读锁（l_type为F_RDLCK）或写锁（l_type为F_WRLCK），而兼容性规则阻止系统给我们这把锁，那么fcntl会立即出错返回，此时errno设置为EACCES或EAGAIN。此命令也用来清除由flockptr指定的锁（l_type为F_UNLCK）</li><li>F_SETLKW：这个命令是F_SETLK的阻塞版本，W表示wait。如果锁请求的读锁或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁而不能被授予，那么调用进程会被设置为休眠。如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒</li></ul><p>应当了解，用F_GETLK测试能否建立一把锁，然后用F_SETLK或F_SETLKW企图建立那把锁，这两者不是一个原子操作。因此不能保证在这两次fcntl调用之间会不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由F_SETLK返回的可能的出错</p><p>在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/文件字节范围锁.png" alt="文件字节范围锁" title>                </div>                <div class="image-caption">文件字节范围锁</div>            </figure><p>由于F_GETLK命令返回是否有现有的锁阻止调用进程设置它自己的锁。因为F_SETLK和F_SETLKW命令总是替换调用进程现有的锁（若已存在），所以调用进程决不会阻塞在自己持有的锁上，于是，F_GETLK命令决不会报告调用进程自己持有的锁</p><p>如果两个进程互相等待对方持有并且不释放（锁定）的资源时，则这两个进程就处于死锁状态。检测到死锁时，内核必须选择一个进程接收出错返回。</p><h3 id="锁的隐含继承和释放"><a href="#锁的隐含继承和释放" class="headerlink" title="锁的隐含继承和释放"></a>锁的隐含继承和释放</h3><ul><li>锁与进程和文件两者相关联。第一，当一个进程终止时，它所建立的锁全部释放；第二，无论一个描述符何时关闭，该进程通过这一描述符所引用的文件上的任何一把锁都会释放（这些锁都是该进程设置的）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// close(fd2)之后，在fd1上设置的锁被释放</span></span><br><span class="line">fd1 = open(pathname, ...);</span><br><span class="line">read_lock(fd1, ...);</span><br><span class="line">fd2 = dup(fd1);</span><br><span class="line">close(fd2);</span><br><span class="line"></span><br><span class="line">fd1 = open(pathname, ...)</span><br><span class="line">read_lock(fd1, ...);</span><br><span class="line">fd2 = open(pathname, ...)</span><br><span class="line">close(fd2)</span><br></pre></td></tr></table></figure><ul><li>由fork产生的子进程不继承父进程锁设置的锁。这意味着，若一个进程得到一把锁，然后调用fork，那么对于父进程获得的锁而言，子进程被视为另一个进程。对于通过fork从父进程处继承过来的描述符，子进程需要调用fcntl才能获取它自己的锁。这个约束是有道理的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过fork继承父进程的锁，则父进程和子进程就可以同时写同一个文件</li><li>在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置执行时关闭标志，那么当作为exec的一部分关闭该文件描述符时，将释放相应文件的所有锁</li></ul><h3 id="记录锁的实现"><a href="#记录锁的实现" class="headerlink" title="记录锁的实现"></a>记录锁的实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fd1 = open(pathname, ...);</span><br><span class="line">write_lock(fd1, <span class="number">0</span>, SEEK_SET, <span class="number">1</span>);  <span class="comment">// parent write locks byte 0</span></span><br><span class="line"><span class="keyword">if</span> ((pid = fork()) &gt; <span class="number">0</span>) &#123;  <span class="comment">// parent</span></span><br><span class="line">  fd2 = dup(fd1);</span><br><span class="line">  fd3 = open(pathname, ...);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">  read_lock(fd1, <span class="number">1</span>, SEEK_SET, <span class="number">1</span>);  <span class="comment">// child read locks byte 1</span></span><br><span class="line">&#125;</span><br><span class="line">pause();</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/记录锁的数据结构.png" alt="记录锁的数据结构" title>                </div>                <div class="image-caption">记录锁的数据结构</div>            </figure><p>在v节点上有lockf结构，lockf结构描述了一个给定进程的一个加锁区域。关闭描述符时，内核会从该描述符所关联的i节点开始，逐个检查lockf链表中的各项，并释放由调用进程持有的各把锁。内核并不清楚（也不关心）是又哪一个描述符来设置的这把锁</p><h3 id="在文件尾端加锁"><a href="#在文件尾端加锁" class="headerlink" title="在文件尾端加锁"></a>在文件尾端加锁</h3><p>在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。因为内核必须独立于当前文件偏移量或文件尾端而记住锁。</p><h3 id="建议性锁和强制性锁"><a href="#建议性锁和强制性锁" class="headerlink" title="建议性锁和强制性锁"></a>建议性锁和强制性锁</h3><p>强制性锁会让内核检查每一个open、read和write，验证调用进程是否违背了正在访问的文件上的某一把锁。对一个特定文件打开其设置组ID位，关闭其组执行位便开启了对该文件的强制性锁机制。因为当组执行位关闭时，设置组ID位不再有意义。</p><p>强制性锁对unlink函数没有影响。因此可以删除原文件（已加强制性记录锁），然后将临时文件名改为原文件名。</p><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p>IO多路复用，一般是需要构造一张我们感兴趣的描述符（通常都不止一个）的列表，然后调用一个函数，直到这些描述符中的一个已准备好几下IO时，该函数才返回。poll、pselect和select来完成这个工作，从这些函数返回时，进程会被告知哪些描述符已经准备好可以进行IO</p><h3 id="函数select和pselect"><a href="#函数select和pselect" class="headerlink" title="函数select和pselect"></a>函数select和pselect</h3><p>传给select的参数告诉内核</p><ul><li>我们所关心的描述符</li><li>对于每个描述符我们所关心的条件（读、写和异常条件）</li><li>愿意等待多长时间（可以永远等待、等待一个固定的时间或根本不等待）</li></ul><p>从select返回时，内核告诉我们</p><ul><li>已准备好描述符的数量</li><li>对于读、写或异常这3个条件中的每一个，哪些描述符已准备好</li></ul><p>使用这种返回信息，就可以调用相应的IO函数（read或write），并且确知该函数不会阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> maxfdp1, fd_set* <span class="keyword">restrict</span> readfds, fd_set* <span class="keyword">restrict</span> writefds, fd_set* <span class="keyword">restrict</span> exceptfds, struct timeval* <span class="keyword">restrict</span> tvptr)</span></span>;</span><br><span class="line"></span><br><span class="line">返回准备就绪的描述符数目；若超时，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>tvptr指定愿意等待的时间长度，单位是秒和微秒。可以指定永远等待、不等待或等待指定的时间</p><p>中间3个参数是指向描述符集的指针。分别指明读、写或异常条件的描述符集合。如果不关心相应条件，可以将参数设置为NULL，如果3个指针都为NULL，则select提供了精度更高的定时器</p><p>fd_set可以认为是一个bitmap。需要通过以下函数来进行操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"></span><br><span class="line">若fd在描述符集中，返回非<span class="number">0</span>值；否则，返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_CLR</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_SET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FD_ZERO</span><span class="params">(fd_set* fdset)</span></span>;</span><br></pre></td></tr></table></figure><p>这些接口可以实现为宏或函数</p><p>maxfdp1的意思是最大文件描述符编号值加1。考虑所有3个描述符集，在3个描述符集中找出最大描述符编号值，然后加1，这就是第一个参数值。也可以将其设置为FD_SETSIZE，这是一个常量，指定最大描述符数，通常是1024。</p><p>返回值</p><ul><li>返回-1表示出错</li><li>返回0表示没有描述符准备好。此时，所有的描述符集都会置0</li><li>一个正返回值说明了已经准备好的描述符数。该值是3个描述符中已准备好的描述符数之和，所以如果同一描述符已准备好读和写，那么在返回值中会对其计数两次。在这种情况下，3个描述符集中仍旧打开的位对应于已准备好的描述符</li></ul><p>准备好含义如下</p><ul><li>对于读，是进行read操作不会阻塞</li><li>对于写，是进行write操作不会阻塞</li><li>对于异常条件，是描述符有一个未决异常条件。包括：在网络连接上到达带外数据，或者在处于数据包模式的伪终端上发生了某些条件</li><li>对于读、写和异常条件，普通文件的文件描述符总是返回准备好</li></ul><p>一个描述符阻塞与否并不影响select是否阻塞。如果在一个描述符上碰到了文件尾端，则select会认为该描述符是可读的。然后调用read，它返回0，这是UNIX系统指示到达文件尾端的方法（很多人错误的认为，到达文件尾端时，select会指示一个异常条件）</p><p>除以下几点外，pselect与select相同</p><ul><li>select的超时值用timeval结构指定，但pselect使用timespec结构</li><li>pselect的超时值被声明为const，这就保证调用pselect不会改变此值，而select可能改变此值（取决于实现，如Linux 3.2.0将用剩余时间值更新该结构）</li><li>pselect可使用可选的信号屏蔽字。若sigmask为NULL，则在信号有关的方面，pselect与select相同。否则sigmask指定信号屏蔽字，在调用pselect时，以原子操作的方式安装该信号屏蔽字。在返回时，恢复以前的信号屏蔽字</li></ul><h2 id="函数poll"><a href="#函数poll" class="headerlink" title="函数poll"></a>函数poll</h2><p>poll函数类似select，但是程序员接口有所不同。poll函数可用于任何类型的文件描述符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd fdarray[], <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line">返回准备就绪的描述符数目；若超时，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> fd;  <span class="comment">// file descriptor to check, or &lt; 0 to ignore</span></span><br><span class="line">  short events;  <span class="comment">// events of interest on fd</span></span><br><span class="line">  short revents;  <span class="comment">// events that occurred on fd</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>应将每个数组元素的events成员设置为以下值的一个或几个，通过这些值告诉内核我们关心的是每个描述符的哪些事件。返回值revents成员由内核设置，用于说明每个描述符发生了哪些事件。poll不更改events成员</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/poll的标志.png" alt="poll的标志" title>                </div>                <div class="image-caption">poll的标志</div>            </figure><p>当一个描述符被挂断（POLLHUP）后，就不能再写该描述符，但是有可能仍然可以从该描述符读取到数据</p><p>timeout参数指定我们愿意等待多长时间。</p><p>理解文件尾端与挂断之间的区别是很重要的。如果我们正从终端输入数据，并键入文件结束符，那么就会打开POLLIN，于是我们就可以读文件结束指示（read返回0）。revents中的POLLHUP没有打开。如果正在调制解调器，并且电话线已挂断，我们将街道POLLHUP通知</p><p>与select一样，一个描述符是否阻塞不会影响poll是否阻塞</p><h2 id="函数readv和writev"><a href="#函数readv和writev" class="headerlink" title="函数readv和writev"></a>函数readv和writev</h2><p>readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* iov, <span class="keyword">int</span> iovcnt)</span></span>;</span><br><span class="line"></span><br><span class="line">返回已读或已写的字节数；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>iovec结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">  <span class="keyword">void</span>* iov_base;  <span class="comment">// starting address of buffer</span></span><br><span class="line">  <span class="keyword">size_t</span> iov_len;  <span class="comment">// size of buffer</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>iov数组中的元素数由iovcnt指定，其最大值受限于IOV_MAX。writev函数从缓冲区中聚集输出数据的顺序是：iov[0]、iov[1]直至iov[iovcnt-1]。writev返回输出的总字节数，通常应等于所有缓冲区长度之和</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/iovec的结构.png" alt="iovec的结构" title>                </div>                <div class="image-caption">iovec的结构</div>            </figure><p>readv函数则将读入的数据按上述同样顺序散布到缓冲区中。readv总是先填满一个缓冲区，然后再填写下一个。readv返回读到的字节总数。如果遇到文件尾端，已无数据可读，则返回0</p><p>应当用尽量少的系统调用次数来完成任务。如果我们只写少量的数据，将会发现自己复制数据然后使用一次write会比用writev更合算。但也可能发现，我们管理自己的分段缓冲区会增加程序额外的复杂性成本，所以从性能成本的角度来看不合算</p><h2 id="存储映射IO"><a href="#存储映射IO" class="headerlink" title="存储映射IO"></a>存储映射IO</h2><p>存储映射IO（memory-mapped IO）能将一个磁盘文件映射到存储空间中的一个缓冲区上，于是，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。这样就可以在不使用read和write的情况下执行IO</p><p>为了使用这一功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mmap.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot, <span class="keyword">int</span> flag, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> off)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回映射区的起始地址；若出错，返回MAP_FAILED</span><br></pre></td></tr></table></figure><p>addr参数用于指定映射存储区的起始位置。通常将其设置为0，这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址</p><p>fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。len参数是映射的字节数，off是要映射字节在文件中的起始偏移量</p><p>prot参数指定了映射存储区的保护要求</p><ul><li>PROT_READ：映射区可读</li><li>PROT_WRITE：映射区可写</li><li>PROT_EXEC：映射区可执行</li><li>PROT_NONE：映射区不可访问</li></ul><p>可将参数prot指定为PROT_NONE，也可以指定为PROT_READ、PROT_WRITE和PROT_EXEC的任意组合的按位或。对指定映射存储区的保护要求不能超过文件open模式访问权限。例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE</p><p>映射存储区一般位于堆和栈之间：这属于实现细节，各种实现之间可能不同</p><p>flag参数如下</p><ul><li>MAP_FIXED：返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且addr非0，则内核只把addr视为在何处设置映射区的一种建议，但是不保证会使用所要求的地址。将addr指定为0可获得最大可移植性</li><li>MAP_SHARED：这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件，也就是，存储操作相当于对该文件的write。必须指定本标志或下一个标志（MAP_PRIVATE），但不能同时指定两者</li><li>MAP_PRIVATE：本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。所有后来对该映射区的引用都是引用该副本。（此标志的一种用途是用于调试程序，它将程序文件的正文部分映射至存储区，但允许用户修改其中的指令。任何修改值影响程序文件的副本，而不影响原文件）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/存储映射文件的例子.png" alt="存储映射文件的例子" title>                </div>                <div class="image-caption">存储映射文件的例子</div>            </figure><p>每种实现都可能还有另外一些MAP_XXX标志值，它们是那种实现所特有的。详细情况清参考手册</p><p>off的值和addr的值（如果指定了MAP_FIXED）通常被要求是系统虚拟存储页长度的倍数。虚拟存储页长可用带参数_SC_PAGESIZE或_SC_PAGE_SIZE的sysconf函数得到。因为off和addr常常指定为0，所以这种要求一般并不重要</p><p>既然映射文件的起始偏移量受系统虚拟存储页长度的限制，那么如果映射区的长度不是页长度的整数倍时，会怎么样呢？假定文件长度为12字节，系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设置为0。可以修改后面的这500字节，但任何改动都不会在文件中反映出来。于是不能用mmap将数据添加到文件中。我们必须先加长该文件</p><p>与映射区相关的信号有SIGSEGV和SIGBUS。信号SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被mmap指定成了只读的，那么进程试图将数据存入这个映射存储区的时候，也会产生此信号。如果映射区的某个部分在访问时已不存在，则产生SIGBUS信号。例如，假设用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件截断。此时，如果进程试图访问对应于该文件已截去部分的映射区，将会接收到SIGBUS信号</p><p>子进程能通过fork继承存储映射区（因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分），但是由于同样的原因，新程序则不能通过exec继承存储映射区</p><p>调用mprotect可以更改一个现有映射的权限</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mprotect</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> prot)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>prot的合法值与mmap中的prot参数一样。请注意，地址参数addr的值必须是系统页长的整数倍</p><p>如果修改的页是通过MAP_SHARED标志映射到地址空间的，那么修改不会立即写回到文件中。相反，何时写回脏页由内核的守护进程决定，决定的依据是系统负载和用来限制在系统失败事件中的数据损失的配置参数。因此，如果只修改了一页中的一个字节，当修改被写回到文件中时，整个页都会被写回</p><p>如果共享映射中的页已修改，那么可以调用msync将该页冲洗到被映射的文件中。msync函数类似于fsync，但作用于存储映射区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msync</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页边界对齐</p><p>flags参数使我们对如何冲洗存储区有某种程度的控制。可以指定MS_ASYNC标志来简单的调试要写的页。如果希望在返回之前等待写操作完成，则可指定MS_SYNC标志。一定要指定两个标志中的一个</p><p>MS_INVALIDATE是一个可选标志，允许我们通知操作系统丢弃那些与底层存储器没有同步的页。若使用了此标志，某些实现将丢弃指定范围中的所有页，但这种行为并不是必需的</p><p>当进程终止时，会自动解除存储映射区的映射，或者直接调用munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>munmap并不影响被映射的对象，也就是说，调用munmap并不会使映射区的内容写到磁盘文件上。对于MAP_SHARED区磁盘文件的更新，会在我们将数据写到存储映射区后的某个时刻，按内核虚拟存储算法自动进行。在存储区解除映射后对MAP_PRIVATE存储区的修改会被丢弃</p><p>可以使用mmap和memcpy来读取或写入文件，与mmap和memcpy相比，read和write执行了更多的系统调用，并做了更多的复制。read和write函数将数据从内核缓存区中复制到应用缓冲区（read），然后再把数据从应用缓冲区复制到内核缓冲区（write）。而mmap和memcpy则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果而出现（每次错页读发生一次错误，每次错页写发生一次错误）。如果系统调用和额外的复制操作的开销和页错误的开销不同，那么这两种方法中就会有一种比另一种表现更好</p><h1 id="第十五章-进程间通信"><a href="#第十五章-进程间通信" class="headerlink" title="第十五章 进程间通信"></a>第十五章 进程间通信</h1><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道是UNIX系统IPC（InterProcess Communication，进程间通信）的最古老形式，所有UNIX系统都提供此种通信机制。管道有以下两种局限性</p><ul><li>历史上，它们是半双工的（即数据只能在一个方向上流动）。现在，某些系统提供全双工管道，但是为了最佳的可移植性，我们决不应预先假定系统支持全双工管道</li><li>管道只能在具有公共祖先的两个进程之间使用。通常，一个管道由一个进程创建，在进程调用fork之后，这个管道就能在父进程和子进程之间使用了</li></ul><p>FIFO没有第二种局限性，UNIX系统域套接字没有这两种局限性</p><p>尽管有这两种局限性，半双工管道仍是最常用的IPC形式。每当在管道中键入一个命令序列，让shell执行时，shell都会为每一条命令单独创建一个进程，然后用管道将前一条命令进程的标准输出与后一条命令的标准输入相连接</p><p>管道是通过调用pipe函数创建的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>经由参数fd返回的两个文件描述符：fd[0]为读而打开，fd[1]为写而打开。fd[1]的输出是fd[0]的输入</p><p>fstat函数对个管道的每一端都返回一个FIFO类型的文件描述符。可以用S_ISFIFO宏来测试管道</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/半双工管道.png" alt="半双工管道" title>                </div>                <div class="image-caption">半双工管道</div>            </figure><p>单个进程中的管道几乎没有什么用处。通常进程会先调用pipe，接着调用fork从而创建父进程到子进程的IPC通道，反之亦然。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fork之后的半双工管道.png" alt="fork之后的半双工管道" title>                </div>                <div class="image-caption">fork之后的半双工管道</div>            </figure><p>fork之后做什么取决于我们想要的数据流的方向，对于从父进程到子进程的管道，父进程关闭管道的读端，子进程关闭写端。反之亦然。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/从父进程到子进程的管道.png" alt="从父进程到子进程的管道" title>                </div>                <div class="image-caption">从父进程到子进程的管道</div>            </figure><p>当管道的一端被关闭后，下列两条规则起作用</p><ul><li>当读（read）一个写端已被关闭的管道时，在所有的数据都被读取后，read返回0，表示文件结束（从技术上来讲，如果管道的写端还有检查，就不会产生文件的结束。可以复制一个管道的描述符，使得有多个进程对它具有写打开文件描述符。但是通常一个管道只有一个读进程和一个写进程。下一节介绍FIFO时，会看到对于单个的FIFO常常有多个写进程）</li><li>如果写（write）一个读端已被关闭的管道，则产生信号SIGPIPE。如果忽略该信号或者捕捉该信号并从其处理程序返回，则write返回-1，errno设置为EPIPE</li></ul><p>在写管道（或FIFO时），常量PIPE_BUF规定了内核的管道缓冲区大小。如果对管道调用write，而且要求写的字节数小于等于PIPE_BUF，则此操作不会与其他进程对同一管道（或FIFO）的write操作操作交叉进行。但是若有多个进程同时写一个管道（或FIFO），而且我们要求写的字节数超过PIPE_BUF，那么我们所写的数据可能会与其他进程所写的数据相互交叉。用pathconf或fpathconf函数可以确定PIPE_BUF的值</p><h2 id="函数popen和pclose"><a href="#函数popen和pclose" class="headerlink" title="函数popen和pclose"></a>函数popen和pclose</h2><p>常见的操作是创建一个连接到另一个进程的管道，然后读其输出或向其输入端发送数据，为此标准IO库提供了两个函数popen和pclose。这两个函数实现的操作是：创建一个管道，fork一个子进程，关闭未使用的管道端，执行一个shell运行命令，然后等待命令终止。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">popen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmdstring, <span class="keyword">const</span> <span class="keyword">char</span>* type)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pclose</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回cmdstring的终止状态；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数popen先执行fork然后调用exec执行cmdstring，并且返回一个标准IO文件指针。如果type是r，则文件指针连接到cmdstring的标准输出。如果type是w，则文件指针连接到cmdstring的标准输入</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/popen的状态.png" alt="popen的状态" title>                </div>                <div class="image-caption">popen的状态</div>            </figure><p>pclose函数关闭标准IO流，等待命令终止，然后返回shell的终止状态。如果shell不能被执行，则pclose返回的终止状态与shell已执行exit(127)一样。</p><p>popen决不应由设置用户ID或设置组ID程序调用。</p><h2 id="FIFO"><a href="#FIFO" class="headerlink" title="FIFO"></a>FIFO</h2><p>FIFO有时被称为命名管道。未命名的管道只能在两个相关的进程之间使用，而这两个相关的进程还要有一个共同的创建了它们的祖先进程。但是通过FIFO不相关的进程也能交换数据</p><p>FIFO是一种文件类型，可以通过stat结构的st_mode成员来确定是否是FIFO类型</p><p>创建FIFO类似于创建文件。确实，FIFO的路径名存在于文件系统中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>mode参数与open函数中的mode参数说明相同。新FIFO的用户和组的所有权规则与文件相同</p><p>mkfifoat函数和mkfifo函数相似，但是mkfifoat函数可以被用来在fd文件描述符表示的目录的相关位置创建一个FIFO。与其他*at函数类似</p><p>当我们用mkfifo或mkfifoat创建FIFO时，需要用open来打开它。确实，正常的文件IO函数（如close、read、write和unlink）都可以在FIFO上工作</p><p>当open一个FIFO时，非阻塞标志（O_NONBLOCK）会产生下列影响</p><ul><li>在一般情况下（没有指定非阻塞标志），只读open要阻塞到某个其他进程为写而打开这个FIFO为止。类似的，只写open要阻塞到某个其他进程为读而打开它为止</li><li>如果指定了非阻塞标志，则只读open立即返回。但是，如果没有进程为读而打开一个FIFO，那么只写open将返回-1，并将errno设置为ENXIO</li></ul><p>类似于管道，若一个write一个尚无进程为读而打开的FIFO，则产生信号SIGPIPE。若某个FIFO的最后一个写进程关闭了该FIFO，则将为该FIFO的读进程产生一个文件结束标志</p><p>一个给定的FIFO有多个写进程是常见的。这就意味着，如果不希望多个进程所写的数据交叉，则必须考虑原子写操作。和管道一样，常量PIPE_BUF说明了可被原子的写到FIFO的最大数据量</p><p>FIFO有以下两种用途</p><ul><li>shell命令使用FIFO将数据从一条管道传送到另一条时，无需创建中间临时文件</li><li>客户进程-服务器进程应用程序中，FIFO用作汇聚点，在客户进程和服务器进程二者之间传递数据</li></ul><h2 id="XSI-IPC"><a href="#XSI-IPC" class="headerlink" title="XSI IPC"></a>XSI IPC</h2><p>有3种称作XSI IPC的IPC：消息队列、信号量以及共享存储器。他们之间有很多相似之处。</p><h2 id="标识符和键"><a href="#标识符和键" class="headerlink" title="标识符和键"></a>标识符和键</h2><p>每个内核中的IPC结构（消息队列、信号量和共享存储段）都用一个非负整数的标识符（identifier）加以引用。与文件描述符不同，IPC标识符不是小的整数。当一个IPC结构被创建，然后又被删除时，与这种结构相关的标识符连续加1，直到达到一个整型数的最大值，然后又回转到0</p><p>标识符是IPC对象的内部名。为使多个合作进程能够在同一IPC对象上汇聚，需要提供一个外部命名方案。为此每个IPC对象都与一个键（key）相关联，将这个键作为该对象的外部名</p><p>无论何时创建IPC结构（通过调用msgget、semget或shmget创建），都应指定一个键。这个键的数据类型是基本系统数据类型key_t，通常在头文件&lt;sys/types.h&gt;中被定义为长整型。这个键由内核变换成标识符</p><p>可以使用ftok函数将路径名和项目ID变换成一个键</p><p>XSI IPC有一个ipc_perm结构。该结构规定了权限和所有者。创建IPC结构时，对所有字段都赋值。以后可以调用msgctl、semctl或shmctl修改uid、gid和mode字段（调用进程必须是IPC结构的创建者或超级用户）</p><h2 id="优点和缺点"><a href="#优点和缺点" class="headerlink" title="优点和缺点"></a>优点和缺点</h2><p>XSI IPC的一个基本问题是：IPC结构是在系统范围内起作用的，没有引用计数。例如，如果进程创建了一个消息队列、并且在该队列中放入了几则消息，然后终止，那么该消息队列及其内容不会被删除。它们会一直留在系统中直至发生下列动作为止：由某个进程调用msgrcv或msgctl读消息或删除消息队列；当某个进程执行ipcrm命令删除消息队列；或正在自举的系统删除消息队列。将此与管道相比，当最后一个引用管道的进程终止时，管道就被完全的删除了。对于FIFO而言，在最后一个引用FIFO的进程终止时，虽然FIFO的名字仍保留在系统中，直至被显式的删除，但是留在FIFO中的数据已被删除了</p><p>XSI IPC的另一个问题是：这些IPC结构在文件系统中没有名字。为了支持这些IPC对象，内核中增加了十几个全新的系统调用（msgget、semop、shmat等）。增加了两个命令ipcs和ipcrm</p><p>其不使用文件描述符，不能对它们使用多路转接IO函数（select等）。这使得它很难一次使用一个以上这样的机构，或者在文件或设备IO中使用这样的IPC结构。</p><p>消息队列是可靠的，流控制的以及面向记录的；它们可以用非先进先出次序处理</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/IPC之间的比较.png" alt="IPC之间的比较" title>                </div>                <div class="image-caption">IPC之间的比较</div>            </figure><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是消息的链接表，存储在内核中，由消息队列标识符标识。</p><p>msgget用于创建一个新队列或打开一个现有队列。msgsnd将新消息添加到队列尾端。每个消息包含一个正的长整型类型的字段、一个非负的长度以及实际数据字节数（对应于长度），所有这些都在将消息添加到队列时，传送给msgsnd。msgrcv用于从队列中取消息。我们并不一定要以先进先出次序取消息，也可以按照消息的类型字段取消息</p><p>消息队列有一些限制</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/消息队列的系统限制.png" alt="消息队列的系统限制" title>                </div>                <div class="image-caption">消息队列的系统限制</div>            </figure><p>对删除消息队列的处理不是很完善。因为每个消息队列没有维护引用计数（打开文件有这种计数），所以在队列被删除以后，仍在使用这一队列的进程在下次对队列进行操作时会出错返回。信号量也以同样的方式处理其删除。相反，删除一个文件时，要等到使用该文件的最后一个进程关闭了它的文件描述符以后，才能删除文件中的内容</p><p>消息队列在新的应用程序中不应当再使用它们。因为消息队列与其他形式的IPC在速度方面已经没有什么差别了。但其存在一些问题</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>信号量与已经介绍过的IPC（管道、FIFO以及消息队列）不同。它是一个计数器，用于为多个进程提供对共享数据对象的访问</p><p>为了获得共享资源，进程需要执行下列操作</p><ul><li>测试控制该资源的信号量</li><li>若此信号量的值为正，则进程可以使用该资源。在这种情况下，进程会将信号量值减1，表示它使用了一个资源单位</li><li>否则，若此信号量的值为0，则进程进入休眠状态，直至信号量值大于0。进程被唤醒后，它返回至步骤1</li></ul><p>当进程不再使用由一个信号控制的共享资源时，该信号量值增1。如果有进程正在休眠等待此信号量，则唤醒它们。为了正确的实现信号量，信号量值的测试以及减1操作应当是原子操作。为此信号量通常是在内核中实现的</p><p>常用的信号量形式被称为二元信号量（binary semaphore）。他控制单个资源，其初始值为1。但是一般而言，信号量的初值可以是任意一个正值，该值表明有多少个共享资源单位可供共享应用</p><p>遗憾的是XSI信号量与此相比要复杂的多。</p><ul><li>信号量并非是单个非负值，而必须定义为含有一个或多个信号量值的集合。当创建信号量时，要指定集合中信号量值的数量</li><li>信号量的创建（semget）是独立于它的初始化（semctl）的。这是一个致命的缺点，因为不能原子的创建一个信号量集合，并且对该集合中的各个信号量赋初值</li><li>即使没有进程正在使用各种形式的XSI IPC，他们仍然是存在的。有的程序终止时并没有释放已经 分配给它的信号量，所以我们不得不为这种程序担心。undo功能可以处理这种情况</li></ul><p>信号量也有系统限制</p><p>信号量、互斥锁和记录锁有时可以实现相同的功能，如果信号不需要所有复杂的功能，可以使用互斥锁或记录锁来替代</p><h2 id="共享存储"><a href="#共享存储" class="headerlink" title="共享存储"></a>共享存储</h2><p>共享存储允许两个或多个进程共享一个给定的存储区。因为数据不需要再客户进程和服务器进程之间复制，所以这是最快的一种IPC。使用共享存储时唯一要掌握的窍门是，再多个进程之间同步访问一个给定的存储区。通常，可以用信号量同步共享存储访问（也可以用记录锁或互斥量代替）</p><p>共享存储有一定的系统限制</p><p>mmap也可以实现共享存储，但mmap需要有相关的文件关联（但利用mmap也可以实现匿名内存映射）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/共享存储区布局.png" alt="共享存储区布局" title>                </div>                <div class="image-caption">共享存储区布局</div>            </figure><h2 id="POSIX信号量"><a href="#POSIX信号量" class="headerlink" title="POSIX信号量"></a>POSIX信号量</h2><p>POSIX信号量接口意在解决XSI信号量接口的几个缺陷</p><ul><li>相比于XSI接口，POSIX信号量接口考虑到了更高性能的实现</li><li>POSIX信号量接口使用更简单：没有信号量集，在熟悉的文件系统操作后一些接口被模式化了。尽管没有要求一定要在文件系统中实现，但是一些系统的确是这么实现的</li><li>POSIX信号量在删除时表现更完美。使用POSIX信号量时，操作能继续正常工作直到该信号量的最后一次引用被释放</li></ul><p>POSIX信号量有两种形式：命名的和未命名的。它们的差异在于创建和销毁的形式上，其他工作方式一样。未命名的信号量只存在于内存中，并要求能使用信号量的进程必须可以访问内存。这意味着它们只能应用在同一进程中的线程，或者不同进程中已经映射相同内存内容到它们的地址空间中的线程。相反，命名信号量可以通过名字访问，因此可以被任何已知它们名字的进程中的线程使用</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过分别消息队列与全双工管道的时间以及信号量与记录锁的事件进行比较，提出下列建议：要学会使用管道和FIFO，因为这两种基本技术仍可高效的应用于大量的应用程序。在新的应用程序中，要尽可能避免使用消息队列以及信号量，而应当考虑全双工管道和记录锁，它们使用起来会简单得多。共享存储仍然有它的用途，虽然通过mmap函数也能提供同样的功能</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十四章-高级IO&quot;&gt;&lt;a href=&quot;#第十四章-高级IO&quot; class=&quot;headerlink&quot; title=&quot;第十四章 高级IO&quot;&gt;&lt;/a&gt;第十四章 高级IO&lt;/h1&gt;&lt;h2 id=&quot;非阻塞IO&quot;&gt;&lt;a href=&quot;#非阻塞IO&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记-四</title>
    <link href="https://gwq5210.com/2022/07/25/APUE%E7%AC%94%E8%AE%B0-%E5%9B%9B/"/>
    <id>https://gwq5210.com/2022/07/25/APUE笔记-四/</id>
    <published>2022-07-25T23:04:56.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十一章-线程"><a href="#第十一章-线程" class="headerlink" title="第十一章 线程"></a>第十一章 线程</h1><h2 id="线程概念"><a href="#线程概念" class="headerlink" title="线程概念"></a>线程概念</h2><p>典型的UNIX进程可以看成只有一个控制进程：一个进程在某一时刻只能做一件事情。有了多个控制线程以后，在程序设计时就可以把进程设计成在某一时刻能够做不止一件事，每个线程处理各自独立的任务。其好处如下</p><ul><li>通过为每种事件类型分配单独的处理线程，可以简化处理异步时间的代码。每个线程会采用同步编程模式，其比异步编程模式简单得多</li><li>多个进程必须使用操作系统提供的复杂机制才能实现内存和文件描述符的共享，而多个线程自动的可以访问相同的存储地址和文件描述符</li><li>有些问题可以分解而提高整个程序吞吐量。当然只有在两个任务的处理过程互不依赖的情况下，两个任务才可以较差运行</li><li>交互程序同样可以使用多线程来改善响应时间，多线程可以把程序中处理用户输入输出的部分与其他部分分开</li></ul><p>有些人把多线程的程序设计与多处理器或多核系统联系起来。但是即使程序运行在单处理器上也能得到多线程编程模型的好处。其并不影响程序结构。程序都可以通过使用线程得以简化。</p><p>每个线程都包含有表示执行环境所必须的信息，其中包括进程中标识线程的线程ID、一组寄存器值、栈、调度优先级和策略、信号屏蔽字、errno变量以及线程私有数据。一个进程的所有信息对该进程的所有线程都是共享的，包括可执行程序的代码、程序的全局内存和堆内存、栈以及文件描述符</p><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>每个线程有一个线程ID。进程ID在整个系统中是唯一的，但线程ID不同，线程ID只有在它所属的进程上下文中才有意义</p><p>与pid_t是一个非负整数不同。线程ID是用pthread_t数据类型表示的，实现的时候可以用一个结构来代表，所以可移植的实现不能把它作为整数处理。因此必须使用一个函数来对两个线程ID进行比较</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_equal</span><span class="params">(<span class="keyword">pthread_t</span> tid1, <span class="keyword">pthread_t</span> tid2)</span></span>;</span><br><span class="line"></span><br><span class="line">若相等，返回非<span class="number">0</span>数值；否则，返回<span class="number">0</span></span><br></pre></td></tr></table></figure><p>无法用可移植的方法打印pthread_t的值，但线程ID通常在调试过程中需要打印</p><p>线程可以通过调用pthread_self函数获得自身的线程ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pthread_t</span> <span class="title">pthread_self</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">返回调用线程的线程ID</span><br></pre></td></tr></table></figure><h2 id="线程创建"><a href="#线程创建" class="headerlink" title="线程创建"></a>线程创建</h2><p>在传统的UNIX进程模型中，每个进程只有一个控制线程。从概念上讲，这与基于线程模型中每个进程只包含一个线程是相同的。在pthread的情况下，程序开始运行时，它也是以单进程中的单个控制线程启动的。在创建多个控制线程以前，程序的行为与传统的进程并没有什么区别。新增的线程可以通过调用pthread_create函数创建</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* <span class="keyword">restrict</span> tidp, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>* <span class="keyword">restrict</span> attr, <span class="keyword">void</span>* (*start_rtn)(<span class="keyword">void</span>*), <span class="keyword">void</span>* <span class="keyword">restrict</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；否则返回错误编号</span><br></pre></td></tr></table></figure><p>attr参数用于定制各种不同的线程属性。为NULL时创建一个具有默认属性的线程。新创建的线程从start_rtn函数的地址开始运行，参数为arg</p><p>线程创建时并不能保证哪个线程会先运行：是新创建的线程，还是调用线程。新创建的线程可以访问进程的地址空间，并继承调用线程浮点环境和信号屏蔽字，但是该线程的挂起信号集会被清除</p><p>注意pthread函数在调用失败时，通常会返回错误码，并不设置errno。每个线程提供errno的副本，这只是为了与使用errno的现有函数兼容。在线程中，从函数中返回错误码更清晰整洁，不需要依赖那些随着函数执行不断变化的全局状态，这样可以把错误范围限制在出错的函数中</p><p>pthread_create虽然会返回新线程ID，但是新建的线程并不能安全的使用它，如果新线程在主线程调用pthread_create返回之前就运行了，那么新线程看到的是未初始化的tidp内容，这个内容并不是正确的线程ID</p><h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程中的任意线程调用了exit、_Exit或_exit，那么整个进程就会终止。与此相似，如果默认的动作是终止进程，那么发送到线程的信号就会终止整个进程</p><p>单个线程有3中方式退出，因此可以在不终止整个进程的情况下，停止它的控制流</p><ul><li>线程可以简单的从启动例程中返回，返回值是线程的退出码</li><li>线程可以被同一进程中的其他线程取消</li><li>线程调用pthread_exit</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* rval_ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>进程中的线程可以通过调用pthread_join函数访问到退出指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** rval_ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；否则，返回错误编码</span><br></pre></td></tr></table></figure><p>调用线程将一直阻塞，直到指定的线程退出。如果线程简单的从它的启动例程中返回，rval_ptr就包含了返回码。如果线程被取消，由rval_ptr指定的内存单元就设置为PTHREAD_CANCELED</p><p>可以通过调用pthread_detach自动把线程置于分离状态，这样资源就可以恢复。如果线程已处理分离状态，pthread_join调用就会失败，返回EINVAL，尽管这种行为是与具体实现相关的</p><p>如果对线程的返回值不感兴趣，可以将rval_ptr设置为NULL。在这种情况下，调用pthread_join的函数可以等待指定的线程终止，但并不获取线程的终止状态</p><p>线程可以通过调用pthread_cancel函数来取消同一进程中的其他线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>在默认情况下，pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数，但是，线程可以选择忽略取消或者控制如何被取消。注意pthread_cancel并不等待线程终止，它仅仅提出请求</p><p>线程可以安排它退出时需要调用的函数，这与进程在退出时可以用atexit函数安排退出是类似的。这样的函数称为线程清理处理程序（thread cleanup handler）。一个线程可以建立多个清理处理程序。处理程序记录再栈中，也就是说，它们的执行顺序与他们注册时相反</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_push</span><span class="params">(<span class="keyword">void</span> (*rtn)(<span class="keyword">void</span>*), <span class="keyword">void</span>* arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_cleanup_pop</span><span class="params">(<span class="keyword">int</span> execute)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_cleanup_push函数注册线程清理处理程序，当线程执行以下动作时，清理函数rtn被执行，参数为arg</p><ul><li>调用pthread_exit时</li><li>响应取消请求时</li><li>用非零execute参数调用pthread_cleanup_pop时</li></ul><p>如果execute参数设置为0，清理函数将不被调用。不管发生上述哪种情况，pthread_cleanup_pop都将删除上次pthread_cleanup_push调用建立的清理处理程序</p><p>这些函数有一些限制，由于它们可以实现为宏，所以必须在与线程相同的作用域中以匹配对的形式使用。pthread_cleanup_push的宏定义可以包含{，在这种情况下，在pthread_cleanup_pop的定义中要有对应的匹配字符</p><p>在Single UNIX Specification中，如果函数在调用pthread_cleanup_push和pthread_cleanup_pop之间返回，会产生未定义行为。唯一的可移植方法是调用pthread_exit</p><p>线程和进程函数之间有相似之处，如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/进程和线程原语比较.png" alt="进程和线程原语比较" title>                </div>                <div class="image-caption">进程和线程原语比较</div>            </figure><p>在默认情况下，线程的终止状态会保存直到对该线程调用pthread_join。如果线程已经被分离，线程的底层存储资源可以在线程终止时立即被回收。在线程分离后，我们不能用pthread_join函数等待它的终止状态，因为对分离状态的线程调用pthread_join会产生未定义行为。可以调用pthread_detach分离线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_detach</span><span class="params">(<span class="keyword">pthread_t</span> tid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>我们将学习通过修改传给pthread_create函数的线程属性，创建一个已处于分离状态的线程</p><h2 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h2><p>可以使用pthread的互斥接口来保护数据，确保同一时间只有一个线程访问数据。互斥量（mutex）从本质上是一把锁，在访问共享资源前对互斥量进行加锁，在访问完成后解锁互斥量。对互斥量进行加锁以后，任何其他视图再次对互斥量加锁的线程都会被阻塞知道当前线程释放该互斥锁。如果释放互斥量时有一个以上的线程阻塞，那么所有该锁上的阻塞线程都会变成可运行状态，第一个变成运行的线程就可以对互斥量加锁，其他线程就会看到互斥量依然是锁着的，只能回去再次等待它重新变为可用。在这种方式下，每次只有一个线程可以向前执行。</p><p>只有将所有线程都设计成遵守相同的数据访问规则的，互斥机制才能正常工作。操作系统并不会为我们做的数据访问串行化。如果允许其中的某个线程在没有得到锁的情况下也可以访问共享资源，那么即使其他线程在使用共享资源前都申请锁，也还是会出现数据不一致的问题</p><p>互斥变量是用pthread_mutex_t数据类型表示的。在使用互斥变量以前，必须首先对它进行初始化，可以把它设置为常量PTHREAD_MUTEX_INITIALIZER（只适用于静态分配的互斥量），也可以通过调用pthread_mutex_init函数进行初始化。如果动态分配互斥量（例如通过调用malloc函数），在释放内存前需要调用pthread_mutex_destroy</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>* <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>要用默认的属性初始化互斥量，只需要把attr设置为NULL。</p><p>对互斥量进行加锁，需要调用pthread_mutex_lock。如果互斥量已经上锁，调用线程将阻塞直到互斥量被解锁。对互斥量解锁，需要调用pthread_mutex_unlock</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* mutex)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>如果线程不希望被阻塞，它可以使用pthread_mutex_trylock尝试对互斥量进行加锁。如果调用pthread_mutex_trylock时互斥量处于为锁住状态，那么pthread_mutex_trylock将锁住互斥量，不会出现阻塞直接返回0，否则pthread_mutex_trylock就会失败，不能锁住互斥量，返回EBUSY</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>如果线程视图对同一个互斥量加锁两次，那么自身就会陷入死锁状态，但是使用互斥量时，还有其他不太明显的方式也能产生死锁。</p><p>可以通过仔细控制互斥量加锁的顺序来避免死锁的发生。即不同的线程总是以相同的顺序加锁互斥量</p><p>但有时候，应用程序的结构使得对互斥量进行排序是很困难的。如果涉及了太多的锁和数据结构，可用的函数并不能把它转换成简单的层次，那么就需要采用另外的方法。在这种情况下，可以先释放占用的锁，然后过一段时间再试。这种情况可以使用pthread_mutex_trylock接口避免死锁。如果已经占有某些锁而且pthread_mutex_trylock接口返回成功，那么就可以前进。但是如果不能获取锁，可以先释放已经占用的锁，做好清理工作，然后过一段时间再重新尝试</p><p>如果锁的粒度太粗，就会出现很多线程阻塞等待相同的锁，这可能并不能改善并发性。如果锁的粒度太细，那么过多的锁开销就会使系统性能收到影响，而且代码变得复杂。作为一个程序员，需要在满足锁需求的情况下，在代码复杂性和性能之间找到正确的平衡</p><h3 id="函数pthread-mutex-timedlock"><a href="#函数pthread-mutex-timedlock" class="headerlink" title="函数pthread_mutex_timedlock"></a>函数pthread_mutex_timedlock</h3><p>当线程视图获取一个已加锁的互斥量时，pthread_mutex_timedlock互斥量原语允许绑定线程阻塞时间。pthread_mutex_timedlock与pthread_mutex_lock是基本等价的，但是在到达超时时间值时，pthread_mutex_timedlock不会对互斥量进行加锁，而是返回错误码ETIMEDOUT</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_timedlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> timespec)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>超时指定愿意等待的绝对时间（与相对时间比较而言，指定在时间X之间可以阻塞等待，而不是说愿意阻塞Y秒）。这个超时时间是用timespec结构来表示的，它用秒和纳秒来描述时间</p><p>注意，阻塞的时间可能会有所不同，造成不同的原因有很多种：开始时间可能在某秒的中间位置，系统时钟的精度可能不足以精确支持我们指定的超时时间值，或者在程序继续运行前，调度延迟可能会增加时间值</p><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p>读写锁（reader-writer-lock）与互斥量类似，不过读写锁允许更高的并行性。互斥量要么是锁住状态，要么就是不加锁状态，而且一次只有一个线程可以对其加锁。读写锁可以有3种状态：读模式下加锁状态，写模式下加锁状态，不加锁状态。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式的读写锁</p><p>在读写锁是写加锁状态时，在这个锁被解锁之前，所有尝试读对这个锁加锁的线程都会被阻塞。当读写锁在读加锁状态时，所有尝试以读模式对它进行加锁的线程都可以得到访问权，但是任何希望以写模式对此锁进行加锁的线程都会阻塞，知道所有的线程释放它们的读锁为止。</p><p>虽然各操作系统对读写锁的实现各不相同，但当读写锁处于读模式锁住的状态，而这时有一个线程视图以写模式获取锁时，读写锁通常会阻塞随后的读模式锁请求。这样可以避免读模式锁长期占用，而等待的写模式锁请求一直得不到满足</p><p>读写锁非常适用于对数据结构读的次数远大于写的情况。当读写锁在写模式下时，它所保护的数据结构就可以被安全的修改，因为一次只有一个线程可以在写模式下拥有这个锁。当读写锁在读模式下时，只要线程先获取了读模式下的读写锁，读锁所保护的数据结构就可以被多个获得读模式锁的线程读取</p><p>读写锁也叫做共享互斥锁（shared-execlusive lock）。当读写锁是以读模式锁住时，就可以说成是以共享模式锁住的。当它是写模式锁住的时候，就可以说成是互斥模式锁住的。</p><p>像互斥量一样，读写锁在使用之前必须初始化，在释放它们底层的内存之前必须销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_init</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> <span class="keyword">pthread_rwlockattr_t</span>* <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_destroy</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>读写锁通过调用pthread_rwlock_init进行初始化。如果希望读写锁有默认属性，可以传一个NULL指针给attr</p><p>可以使用PTHREAD_RWLOCK_INITIALIZER对静态分配的读写锁进行初始化</p><p>在释放读写锁占用的内存之前，需要调用pthread_rwlock_destroy做清理工作。如果pthread_rwlock_init为读写锁分配了资源，pthread_rwlock_destroy将释放这些资源。如果在调用pthread_rwlock_destroy之前就释放了读写锁占用的内存空间，那么分配给这个锁的资源就会丢失</p><p>要在读模式下锁定读写锁，需要调用pthread_rwlock_rdlock。要在写模式下锁定读写锁，需要调用pthread_rwlock_wrlock。不过以何种方式锁住读写锁，都可以调用pthread_rwlock_unlock进行解锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_rdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_wrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_unlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>各种实现可能会对共享模式下可获取的读写锁的次数进行限制，所以需要检查pthread_rwlock_rdlock的返回值。尽管pthread_rwlock_wrlock和pthread_rwlock_unlock有错误返回，而且从技术上来讲，在调用函数时应该总是检查错误返回，但是如果锁设计合理的话，就不需要检查它们。错误返回值的定义只是针对不正确使用读写锁的情况（如未经初始化的锁），或试图获取已拥有的锁而可能产生死锁的情况。但是需要注意，有些特定的实现可能会定义另外的错误返回</p><p>Single UNIX Specification还定义了读写锁原语的条件版本</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_tryrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_trywrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* rwlock)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>可以获取锁时，两个函数返回0，否则，它们返回EBUSY。这两个函数可以用于我们前面讨论的遵守某种锁层次但还不能完全避免死锁的情况</p><h3 id="带有超时的读写锁"><a href="#带有超时的读写锁" class="headerlink" title="带有超时的读写锁"></a>带有超时的读写锁</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedrdlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_rwlock_timedwrlock</span><span class="params">(<span class="keyword">pthread_rwlock_t</span>* <span class="keyword">restrict</span> rwlock, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>其行为与它们的不计时版本类似。如果不能获取锁，超时时间到达时，这两个函数将返回ETIMEDOUT错误。超时指定的是绝对时间，而不是相对时间</p><h2 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h2><p>条件变量是线程可用的另一种同步机制。条件变量给多线程提供了一个汇合的场所。条件变量与互斥量一起使用允许线程已无竞争的方式，等待特定的条件发生。</p><p>条件本身是由互斥量保护的，线程在改变条件状态之前必须首先锁住互斥量。其他线程在获得互斥量之前不会察觉到这种变化，因互斥量必须在锁定以后才能计算条件。</p><p>在使用条件变量之前必须先对它进行初始化。由pthread_cond_t数据类型表示的条件变量可以用两种方式进行初始化，可以把常量PTHREAD_COND_INITIALIZER赋给静态分配的条件变量，但是如果条件变量是动态分配的，则需要使用pthread_cond_init函数对它进行初始化</p><p>在释放条件变量底层的内存空间前，可以使用pthread_cond_destroy函数对条件变量进行销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>* <span class="keyword">restrict</span> attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>当attr参数为NULL时，创建一个具有默认属性的条件变量</p><p>我们使用pthread_cond_wait等待条件变量变为真。如果在给定的时间内条件不能满足，那么会返回错误编码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_timedwait</span><span class="params">(<span class="keyword">pthread_cond_t</span>* <span class="keyword">restrict</span> cond, <span class="keyword">pthread_mutex_t</span>* <span class="keyword">restrict</span> mutex, <span class="keyword">const</span> struct timespec* <span class="keyword">restrict</span> tsptr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>传递给pthread_cond_wait的互斥量对条件变量进行保护。调用者把锁住的互斥量传给函数，函数然后自动把调用线程放到等待条件的线程列表上，对互斥量解锁。这就关闭了条件检查和线程进入休眠状态等待条件改变这两个操作之间的时间通道，这样线程就不会错过条件的任何变化。pthread_cond_wait返回时，互斥量再次被锁住。pthread_cond_timedwait可以指定等待的超时，其是一个绝对时间，如果超时到期条件还没有出现，那么pthread_cond_timedwait将重新获取互斥量，然后返回错误ETIMEDOUT。从pthread_cond_wait和pthread_cond_timedwait调用成功返回时，线程需要重新计算条件，因为另一个线程可能已经在运行并改变了条件</p><p>有两个函数可以用于通知线程条件已经满足。pthread_cond_signal函数至少能唤醒一个等待该条件的线程，pthread_cond_broadcast函数则能唤醒等待该条件的所有线程。POSIX规范为了简化pthread_cond_signal的实现，允许它在实现时唤醒一个以上的线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>* cond)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>在给等待线程发送信号时，不需要占有互斥量。我们在while循环中检查条件，所以不存在这样的问题：线程醒来，发现队列仍是空，然后返回继续等待。如果代码不能容忍这种竞争，就需要再给线程发信号的时候，占有互斥量</p><h2 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h2><p>自旋锁与互斥量类似，但它不是通过休眠使进程阻塞，而是在获取锁之前一直处于忙等（自旋）阻塞状态。自旋锁可用于以下情况：锁被持有的时间短，而且线程并不希望在重新调度上花费太多的成本。</p><p>自旋锁通常作为底层原语用于实现其他类型的锁。根据他们所基于的系统体系结构，可以通过使用测试并设置指令有效地实现。当然这里说的有效还是会导致CPU资源的浪费：当线程自旋等待锁变为为可用时，CPU不能做其他的事情。这也是自旋锁只能够被持有一小段时间的原因。</p><p>当自旋锁在非抢占式内核中时是非常有用的：除了提供互斥机制以外，他们会阻塞中断，这样中断处理程序就不会让系统陷入死锁状态，因为他需要获取已被加锁的自旋锁（把中断想成是另一种抢占）。在这种类型的内核中，中断处理处理程序不能休眠，因此他们能用的同步原语只能是自旋锁。</p><p>但是，在用户层自旋锁并不是非常有用，除非运行在不允许抢占的实时调度类中。运行在分时调度类中的用户层线程在两种情况下可以被取消调度：当他们的时间片到期时，或者具有更高优先级的线程就绪变成可运行时。在这些情况下，如果线程拥有自旋锁，他就会进入休眠状态，阻塞在锁上的其他线程自旋的时间可能会比预期的时间更长。</p><p>很多互斥量的实现非常高效，以至于应用程序采用互斥锁的性能与曾经采用过自旋锁的性能基本是相同的。事实上，有些互斥量的实现在试图获取互斥量的时候会自旋一小段时间，只有在自旋计数达到某一阈值的时候才会休眠。这些因素，加上现代处理器的进步，使得上下文切换越来越快，也使得自旋锁只在某些特定的情况下有用。</p><p>自旋锁的接口与互斥量的接口类似，这使得它可以比较容易的从一个替换成另一个。可以用pthread_spin_init函数对自旋锁进行初始化。用pthread_spin_destroy函数进行自旋锁的销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_init</span><span class="params">(<span class="keyword">pthread_spinlock_t</span>* lock, <span class="keyword">int</span> pshared)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_destroy</span><span class="params">(<span class="keyword">pthread_spinlock_t</span>* lock)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>只有一个属性是自旋锁特有的，这个属性只在支持线程进程同步（Thread Process-Shared Synchronization）选项的平台上才用得到。pshared参数表示进程共享属性，表明自旋锁是如何获取的。如果它设为PTHREAD_PROCESS_SHARED，则自旋锁能被可以访问底层内存的线程锁获取，即便那些线程属于不同的进程，情况也是如此。否则pshared参数设置为PTHREAD_PROCESS_PRIVATE，自旋锁就只能被初始化该锁的进程内部的线程所访问</p><p>可以用pthread_spin_lock或pthread_spin_trylock对自旋锁进行加锁，前者在获取锁之前一直自旋，后者如果不能获取锁，就立即返回EBUSY错误。注意pthread_spin_trylock不能自旋。不管以何种方式加锁，自旋锁都可以调用pthread_spin_unlock函数解锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_lock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_trylock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> *lock)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_spin_unlock</span><span class="params">(<span class="keyword">pthread_spinlock_t</span> * lock)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>注意，如果自旋锁当前在解锁状态的话，pthread_spin_lock函数不要自旋就可以对它加锁。如果线程应对它加锁了，结果就是未定义的。调用pthread_spin_lock会返回EDEADLK错误（或其他错误），或者调用可能会永久自旋。具体行为依赖于实际的实现。视图对没有加锁的自旋锁进行解锁，结果也是未定义的</p><p>不管是pthread_spin_lock还是pthread_spin_trylock，返回值为0的话就表示自旋锁被加锁。需要注意，不要调用再持有自旋锁情况下可能会进入休眠状态的函数。如果调用了这些函数，会浪费CPU资源，因为其他线程需要获取自旋锁需要等待的时间就延长了。</p><h2 id="屏障"><a href="#屏障" class="headerlink" title="屏障"></a>屏障</h2><p>屏障（barrier）是用户协调多个线程并行工作的同步机制。屏障允许每个线程等待，直到所有的合作线程都到达某一点，然后从该点继续执行。我们已经看到一种屏障，pthread_join函数就是一种屏障，允许一个线程等待，直到另一个线程退出。</p><p>但是屏障对象的概念更广，他们允许任意数量的线程等待，直到所有的线程完成处理工作，而线程不需要退出，所有的线程到达屏障后可以接着工作。</p><p>可以使用pthread_barrier_init函数对屏障进行初始化，用pthread_barrier_destroy函数进行销毁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_init</span><span class="params">(<span class="keyword">pthread_barrier_t</span>* <span class="keyword">restrict</span> barrier, <span class="keyword">const</span> <span class="keyword">pthread_barrierattr_t</span>* <span class="keyword">restrict</span> attr, <span class="keyword">unsigned</span> <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_destroy</span><span class="params">(<span class="keyword">pthread_barrier_t</span>* barrier)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>初始化屏障时，可以使用count参数指定，在允许所有线程继续运行之前，必须到达屏障的线程数目。使用attr参数指定屏障对象的属性。当attr参数为NULL时，使用默认属性初始化屏障。如果使用pthread_barrier_init函数为屏障分配资源，那么在销毁屏障时可以调用pthread_barrier_destroy函数释放相应的资源。</p><p>可以使用pthread_barrier_wait函数来表明线程已完成工作，准备等待所有其他线程赶上来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_barrier_wait</span><span class="params">(<span class="keyword">pthread_barrier_t</span>* barrier)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>或者PTHREAD_BARRIER_SERIAL_THREAD；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>调用pthread_barrier_wait的线程在屏障计数未满足条件时，会进入休眠状态。如果该线程是最后一个调用pthread_barrier_wait的线程就满足了屏障计数，所有的线程都被唤醒</p><p>对于一个任意线程，pthread_barrier_wait函数返回了PTHREAD_BARRIER_SERIAL_THREAD。剩下的线程返回值是0.这使得一个线程可以作为主线程，他可以工作在其他所有线程已完成的工作结果上</p><p>一旦达到屏障计数值，而且线程处于非阻塞状态，屏障就可以被重用。但是除非在调用了pthread_barrier_destroy函数之后，有调用了pthread_barrier_init函数对计数用另外的数进行初始化，否则屏障计数不会改变</p><h1 id="第十二章-线程控制"><a href="#第十二章-线程控制" class="headerlink" title="第十二章 线程控制"></a>第十二章 线程控制</h1><h2 id="线程限制"><a href="#线程限制" class="headerlink" title="线程限制"></a>线程限制</h2><p>线程有一些限制，如创建的键（线程私有数据）的最大数目，线程栈的最小字节数，进程可以创建的线程的最大数目等</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/线程配置限制的实例.png" alt="线程配置限制的实例" title>                </div>                <div class="image-caption">线程配置限制的实例</div>            </figure><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>pthread接口允许我们通过设置每个对象关联的不同属性来细调线程和同步对象的行为。通常管理这些属性的函数都遵循相同的模式</p><ul><li>每个对象与他自己类型的属性对象进行关联（线程与线程属性关联，互斥量与互斥量属性关联等等）。一个属性对象可以代表多个属性。属性对象对应用程序来说是不透明的。这意味着应用程序并不需要了解有关属性对象内部结构的详细细节，这样可以增强应用程序的可移植性，取而代之的是需要提供相应的函数来管理这些属性对象。</li><li>有一个初始化函数，把属性设置为默认值。</li><li>还有一个销毁属性对象的函数，如果初始化函数分配了与属性对象关联的资源，销毁函数负责释放这些资源。</li><li>每个属性都有一个从属性对象中获取属性值的函数。由于函数成功时返回零，失败时返回错误编号，所以可以通过把属性值存储在函数的某一参数指定的内存单元中，把属性值返回给调用者</li><li>每个属性都有一个设置属性值的函数，在这种情况下属性值作为参数按值传递。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/线程属性.png" alt="线程属性" title>                </div>                <div class="image-caption">线程属性</div>            </figure><p>线程分离属性的有效值为：PTHREAD_CREATE_DETACHED或PTHREAD_CREATE_JOINABLE</p><p>对于进程来说，虚地址空间的大小是固定的，因为进程中只有一个栈，所以它的大小通常不是问题。但对于线程来说，同样大小的虚拟地址空间，必须被所有的线程栈站共享。如果应用程序，使用了许多线程，以致这些线程栈的累积大小超过了可用的虚拟地址空间，就需要减少默认的线程栈大小。另一方面，如果线程调用的函数分配了大量的自动变量或者调用的函数，涉及许多很深的栈帧（stack frame），那么需要的栈大小，可能要比默认的大。</p><p>如果线程栈的虚地址空间都用完了，那可以使用malloc或者mmap来为可替代的栈分配空间，并用pthread_attr_setstack函数来改变新建线程的栈位置。由stackaddr参数指定的地址可以用作线程栈的内存范围中的最低可寻址地址，改地址与处理器结构相应的边界应对齐。当然，这要假设malloc和mmap所用的虚地址范围与线程栈当前使用的虚地址范围不同。stackaddr线程属性被定义为栈的最低内存地址，但这并不一定是栈的开始位置。对于一个给定的处理器结构来说，如果栈是从高地址向低地址方向增长的，那么stackaddr线程属性将是栈的结尾位置，而不是开始位置</p><p>可以修改默认栈的大小，但最小不能小于PTHREAD_STACK_MIN</p><p>线程属性guardsize控制着线程栈末尾之后用于避免栈溢出的扩展内存大小。这个属性默认值的由具体的实现来定义的，但常用值是系统页大小。如果线程的栈指针溢出到警戒区，应用程序就可能通过信号接收到出错信息</p><p>线程还有一些其他的pthread_attr_t结构中没有表示的属性：可撤销状态和可撤销类型</p><h2 id="互斥量属性"><a href="#互斥量属性" class="headerlink" title="互斥量属性"></a>互斥量属性</h2><p>互斥量值得注意的3个属性是：进程共享属性、健壮属性以及类型属性</p><p>在进程中，多个线程可以访问同一个同步对象。这是默认的行为，在这种情况下，进程共享互斥量属性需设置为PTHREAD_PROCESS_PRIVATE。存在这样的机制，允许相互独立的多个进程把同一个内存数据块映射到它们各自独立的地址空间中。就像多个线程访问共享数据一样，多个进程访问共享数据通常也需要同步。如果进程共享互斥量属性设置为PTHREAD_PROCESS_SHARED，从多个进程彼此之间共享的内存数据块中分配的互斥量就可以用于这些进程的同步</p><p>进程共享互斥量属性设置为PTHREAD_PROCESS_PRIVATE时，允许pthread线程库提供更有效的互斥量实现，这在多线程应用程序中是默认的情况。在多个进程共享多个互斥量的情况下，pthread线程库可以限制开销较大的互斥量实现</p><p>互斥量健壮属性与多个进程间共享的互斥量有关，这意味当持有互斥量的进程终止时，需要解决互斥量状态恢复的问题。这种情况发生时，互斥量处于锁定状态，恢复起来很困难。其他阻塞在这个锁的进程，将会一直阻塞下去。</p><p>健壮属性取值有两种可能的情况，默认值是PTHREAD_MUTEX_STALLED，这意味着时有互斥量的进程终止时不需要采取特别的动作。在这种情况下，使用互斥量后的行为是未定义的，等待该互斥量解锁的应用程序会被有效地“拖住”。</p><p>另一个取值是PTHREAD_MUTEX_ROBUST。这个值将导致线程调用pthread_mutex_lock获取锁，而该锁被另一个进程持有，但他终止时并没有对该锁进行解锁，此时线程会阻塞，从pthread_mutex_lock返回的值为EOWNERDEAD而不是0。你应用程序可以通过这个特殊的返回值获知，若有可能（要保护状态的细节以及如何进行恢复会已经不同的应用程序而异），不管他们保护的互斥量状态如何，都需要进行恢复。使用健壮的互斥量改变了我们使用pthread_mutex_lock的方式，因为现在必须检查三个返回值，而不是之前的两个：不需要恢复的成功，需要恢复的成功以及失败。但是即使不用健壮的互斥量，也可以只检查成功或者失败。Linux 3.2.0支持健壮的线程互斥量</p><p>如果应用状态无法恢复，在线程对互斥量解锁以后，该互斥量将处于永久不可用的状态。为了避免这样的问题，线程可以调用函数pthread_mutex_consistent函数，指明该互斥量相关的状态在互斥量解锁之前是一致的。如果线程没有先调用pthread_mutex_consistent函数就对互斥量进行了解锁，那么其他试图获取该互斥量的阻塞线程就会得到错误吗ENOTRECOVERABLE。如果发生这种情况，互斥量将不再可用。线程通过提前调用pthread_mutex_consistent，能让互斥量正常工作，这样他就可以持续被使用。</p><p>类型互斥量属性控制着互斥量的锁定特性</p><ul><li>PTHREAD_MUTEX_NORMAL: 一种标准互斥量类型,不做任何特殊的错误检查或死锁检测。</li><li>PTHREAD_MUTEX_ERRORCHECK: 此互斥量类型提供错误检查</li><li>PTHREAD_MUTEX_RECURSIVE: 此互斥量类型允许同一线程在互斥量解锁之前对该互斥量进行多次加锁。递归互斥量维护锁的计数，在解锁次数和加锁次数不相同的情况下，不会释放锁。所以如果对一个递归互斥量加锁两次，然后解锁一次，那么这个互斥量将依然处于加锁状态，对他再次解锁以前不能释放该锁。</li><li>PTHREAD_MUTEX_DEFAULT: 此互斥量类型可以提供默认特性和行为。操作系统在实现它的时候，可以把这种类型自由的映射到其他互斥量类型中的一种。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/互斥量类型行为.png" alt="互斥量类型行为" title>                </div>                <div class="image-caption">互斥量类型行为</div>            </figure><p>互斥量用于保护与条件变量关联的条件。在阻塞线程之前，pthread_cond_wait和pthread_cond_timedwait函数释放与条件变量相关的互斥量，这就允许其他线程获取互斥量、改变条件、释放互斥量以及给条件变量发信号。既然改变条件时，必须占有互斥量，使用递归互斥量就不是一个好主意，如果递归互斥量被多次加锁，然后用在调用pthread_cond_wait函数中，那么条件永远不会得到满足，因为pthread_cond_wait所做的解锁操作并不能释放互斥量。</p><p>如果需要把现有的单线程接口放到多线程环境中，递归互斥量是非常有用的，但由于现有程序兼容性的限制，不能对函数接口进行修改。然而，使用递归锁可能很难处理，因此应该只在没有其他可行方案的时候才使用他们。</p><h2 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h2><p>读写锁支持的唯一属性是进程共享属性。它与互斥量的进程共享属性是相同的，就像互斥量的进程共享属性一样，有一个函数用于读取和设置读写所的进程共享属性。</p><h2 id="条件变量属性"><a href="#条件变量属性" class="headerlink" title="条件变量属性"></a>条件变量属性</h2><p>Single UNIX Specification目前定义了条件变量的两个属性：进程共享属性和时钟属性。</p><p>与其他的同步属性一样，条件变量的进程共享属性控制着条件变量是可以被单进程的多个线程使用，还是可以被多进程的线程使用。</p><p>时钟属性控制计算pthread_cond_timedwait函数超时参数tsptr时采用的是哪个时钟。奇怪的是Single UNIX Specification并没有为其他有超时等待函数的属性对象定义时钟属性</p><h2 id="屏障属性"><a href="#屏障属性" class="headerlink" title="屏障属性"></a>屏障属性</h2><p>目前定义的屏障属性只有进程共享属性</p><h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>线程在遇到重入问题时与信号处理程序是类似的。在这两种情况下，多个控制线程在相同的时间有可能调用相同的函数。如果一个函数在相同的时间点可以被多个线程安全的调用，就称该函数是线程安全的。在Single UNIX Specification中定义的所有函数中，除了下房列出的函数，其他函数都保证是线程安全的。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/不能保证线程安全的函数.png" alt="不能保证线程安全的函数" title>                </div>                <div class="image-caption">不能保证线程安全的函数</div>            </figure><p>如果一个函数对多个线程来说是可重入的，就说这个函数是线程安全的。但这并不能说明对信号处理程序来说，该函数也是可重入的。如果函数对异步信号处理程序的重入是安全的，那么就可以说函数是异步信号安全的。</p><h2 id="线程特定数据"><a href="#线程特定数据" class="headerlink" title="线程特定数据"></a>线程特定数据</h2><p>线程特定数据（thread-specific data），也称为线程私有数据（thread-private data），是存储和查询某个特定线程相关数据的一种机制。我们把这种数据称为线程特定数据或线程私有数据的原因是，我们希望每个线程可以访问他自己单独的数据副本，而不需要担心与其他线程的同步访问问题。</p><p>线程模型促进了进程中数据和属性的共享，许多人在设计线程模型时会遇到各种麻烦。那么为什么有人想在这样的模型中设计阻止共享的借口呢？这其中有两个原因</p><ul><li>有时候需要维护基于每个线程（per-thread）的数据，因为线程ID并不能保证是最小而连续的整数，所以就不能简单的分配 一个每线程数据数组，用线程ID作为数组的索引。即使线程ID确实是最小而连续的整数，我们可能还希望有一些额外的保护，防止某个线程的数据，与其他线程的数据相混淆。</li><li>它提供了让基于进程的接口适应多线程环境的机制。一个很明显的实例就是errno。以前的接口（线程出现以前）把errno定义为进程上下文中全局可访问的整数。系统调用和库例程在调用或执行失败时设置errno，把它作为操作失败时的附属结果。为了让线程也能够使用那些原本基于进程的系统调用和库例程，errno被重新定义为线程私有数据。这样一个线程做了重置errno的操作，也不会影响进程中其他线程的errno值。</li></ul><p>我们知道一个进程中的所有线程都可以访问这个进程的整个地址空间，除了使用寄存器外，一个线程没有办法阻止另一个线程访问他的数据。线程特定数据也不例外。虽然底层的实现部分并不能阻止这种访问能力，但管理线程特定数据的函数，可以提高线程间的数据独立性，使得线程不太容易访问到其他线程的线程特定数据。</p><p>在分配线程特定数据之前，需要创建与该数据关联的键。这个键用于获取对线程特定数据的访问。使用pthread_key_create创建一个键</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span>* keyp, <span class="keyword">void</span> (*destructor)(<span class="keyword">void</span>*))</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>创建的键存储在keyp指向的内存单元中，这个键可以被进程中所有的线程使用，但每个线程把这个键与不同的线程特定数据地址进行关联。创建新键时，每个线程的数据地址设为空值</p><p>除了创建键以外，pthread_key_create可以为该键关联一个可选择的析构函数。当这个线程退出时，如果数据地址空间已经被设置为非空值，那么析构函数就会被调用，他唯一的参数就是该数据地址，如果传入的析构函数为空就表明没有析构函数与这个键相关联，当线程调用pthread_exit或线程执行返回，正常退出时，析构函数就会被调用。同样线程取消时，只有在最后的清理处理程序返回之后，析构函数才会被调用。如果线程调用了exit、_exit、_Exit或abort，或者出现其他非正常的退出时，就不会调用析构函数。</p><p>线程经常使用malloc为线程特定数据分配内存，析构函数通常释放已分配的内存。如果线程在没有释放内存之前就退出了，那么这块内存就会丢失，即线程所属进程就出现了内存泄露。</p><p>线程可以为线程特定数据分配多个键，每个键都可以有一个析构函数与他关联，每个键的析构函数可以互不相同，当然所有键也可以使用相同的析构函数，每个操作系统实现对进程可分配的键的数量进行限制。</p><p>线程退出时线程特定数据的析构函数，将按照操作系统实现中定义的顺序被调用。析构函数可能会掉用另一个函数，该函数可能会创建新的线程特定数据，并且把这个数据与当前的键关联起来。当所有的析构函数都调用完成以后，系统会检查是否还有非空的线程特定数据值与当前的键关联，如果有的话再次调用析构函数。这个过程将会一直重复，直到所有的键都为空线程特定数据值，或者已经做了PTHREAD_DESTRUCTOR_ITERATIONS中定义的最大次数的尝试</p><p>对所有的线程我们都可以调用pthread_key_delete来取消键与线程特定数据值之间的关联关系</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>注意，调用pthread_key_delete并不会激活与键关联的析构函数。要释放任何与键关联的线程特定数据值的内存，需要在应用程序中采取额外的步骤</p><p>需要确保分配的键并不会由于初始化阶段的竞争而发生变动。下面的代码会导致两个线程都调用pthread_key_create</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">int</span> init_done = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadfunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!init_done) &#123;</span><br><span class="line">    init_done = <span class="number">1</span>;</span><br><span class="line">    err = pthread_key_create(&amp;key, destructor);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些线程可能看到一个键值，而其他线程看到的可能是另一个不同的键值，这取决于系统是如何调度线程的，解决这种竞争的办法是使用pthread_once</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_once_t</span> initflag = PTHREAD_ONCE_INIT;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_once</span><span class="params">(<span class="keyword">pthread_once_t</span>* initflag, <span class="keyword">void</span> (*initfn)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>initflag必须是一个非本地变量（如全局变量或静态变量），而且必须初始化为PTHREAD_ONCE_INIT</p><p>如果每个线程都调用pthread_once，系统就能保证初始化例程initfn只被调用一次，即系统首次调用pthread_once时。创建键时避免出现冲突的一个正确方法如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destructor</span><span class="params">(<span class="keyword">void</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_key_t</span> key;</span><br><span class="line"><span class="keyword">pthread_once_t</span> init_done = PTHREAD_ONCE_INIT;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_init</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  err = pthread_key_create(&amp;key, destructor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">threadfunc</span><span class="params">(<span class="keyword">void</span>* arg)</span> </span>&#123;</span><br><span class="line">  pthread_once(&amp;init_done, thread_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>键一旦创建成功以后，就可以通过调用pthread_setspecific函数把键和线程特定数据关联起来。可以通过pthread_getspeciffic函数获得线程特定数据的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"></span><br><span class="line">返回线程特定数据值；若没有值与该键关联，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspeciffic</span><span class="params">(<span class="keyword">pthread_key_t</span> key, <span class="keyword">const</span> <span class="keyword">void</span>* value)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>如果没有线程特定数据与键关联，pthread_getspecific将返回一个空指针，我们可以用这个返回值来确定是否需要调用pthread_setspecific</p><h2 id="取消选项"><a href="#取消选项" class="headerlink" title="取消选项"></a>取消选项</h2><p>有两个线程属性并没有包含在pthread_attr_t结构中，它们是可取消状态和可取消类型。这两个属性影响pthread_cancel函数调用时所呈现的行为</p><p>可取消状态可以是PTHREAD_CANCEL_ENABLE也可以是PTHREAD_CANCEL_DISABLE。</p><p>pthread_cancel调用并不等待线程终止。在默认情况下，线程在取消请求发出以后还是继续运行，直到线程到达某个取消点。取消点是线程检查它是否被取消的一个位置，如果取消了，则按照请求行事。取消点的函数如下（还有一些可选的取消点）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/定义的取消点.png" alt="定义的取消点" title>                </div>                <div class="image-caption">定义的取消点</div>            </figure><p>线程启动时默认的可取消状态是PTHREAD_CANCEL_ENABLE。当状态设置为了PTHREAD_CANCEL_DISABLE时，对pthread_cancel的调用并不会杀死线程。相反，取消请求对这个线程来说还处于挂起状态，当取消状态再次变为PTHREAD_CANCEL_ENABLE时，线程将在下一个取消点上对所有挂起的请求进行处理</p><p>如果应用程序在很长一段时间都不会调用取消点的函数，那么可以调用pthread_testcancel函数在应用程序中添加自己的取消点。调用pthread_testcancel时，如果某个取消请求正处于挂起状态，而且取消并没有设置为无效，那么线程就会被取消。但是，如果取消被置为无效，pthread_testcancel调用就没有任何效果了</p><p>我们所描述的默认取消类型也称为推迟取消。调用pthread_cancel以后，在现场到达取消点之前，并不会出现真正的取消。取消类型可以是PTHREAD_CANCEL_DEFERRED或PTHREAD_CANCEL_ASYNCHRONOUS。异步取消与推迟取消不同，使用异步取消时，线程可以在任意时间撤销，不是非得遇到取消点才能被取消</p><h2 id="线程和信号"><a href="#线程和信号" class="headerlink" title="线程和信号"></a>线程和信号</h2><p>即使在基于进程的编程范型中，信号的处理有时候也是很复杂的。把线程引入编程范型，就使信号的处理变得更加复杂</p><p>每个线程都有自己的信号屏蔽字，但是信号的处理是进程中所有线程共享的。这意味着单个线程可以阻止某些信号，但是当没某个线程修改了与某个给定信号的相关处理行为以后，所有的线程都必须共享这个处理行为的改变。这样，如果一个线程选择忽略某个给定信号，那么另一个线程就可以通过以下两种方式撤销上述线程的信号选择：恢复信号的默认处理行为或者为信号设置一个新的信号处理程序</p><p>进程中的信号是递送到单个线程的。如果一个信号与硬件故障相关，那么该信号一般会被发送到引起该事件的线程中去，而其他的信号则被发送到任意一个线程。</p><p>sigprocmask的行为在多线程的进程中并没有定义，线程必须使用pthread_sigmask</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">sigset_t</span>* <span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">sigset_t</span>* <span class="keyword">restrict</span> oset)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>pthread_sigmask函数与sigprocmask基本相同，不过pthread_sigmask工作在现场中，而且失败时返回错误码，不再像sigprocmask那样设置errno并返回-1。set参数包含线程用于修改信号屏蔽字的信号集。how参数可以取以下3个值之一：SIG_BLOCK，把信号集添加到线程信号屏蔽字中，SIG_SETMASK，用信号集替换线程的信号屏蔽字，SIG_UNBLOCK，从线程信号屏蔽字中移除信号集。如果oset参数不为空，线程之前的信号屏蔽字就存储在它指向的sigset_t结构中。线程可以通过把set参数设置为NULL，并把oset设置为sigset_t结构的地址，来获取当前的信号屏蔽字。这种情况中的how参数会被忽略</p><p>线程可以调用sigwait等待一个或多个信号的出现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="keyword">restrict</span> <span class="built_in">set</span>, <span class="keyword">int</span>* <span class="keyword">restrict</span> signop)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>set参数指定了线程等待的信号集。返回时，signop指向的整数将包含发送的信号值</p><p>如果信号集的某个信号在sigwait调用的时候处于挂起状态，那么sigwait将无阻塞的返回。在返回之前，sigwait将从进程中移除那些处于挂起等待状态的信号。如果具体实现支持排队信号，并且信号的多个实例被挂起，那么sigwait将会移除该信号的一个实例，其他的实例还要继续排队。</p><p>为了避免错误行为发生，线程在调用sigwait之前，必须阻塞那些正在等待的信号。sigwait函数会原子的取消信号集的阻塞状态，直到有新的信号被递送。在返回之前，sigwait将恢复线程的信号屏蔽字。如果信号在sigwait被调用的时候没有被阻塞，那么在线程完成对sigwait的调用之前会出现一个时间窗，在这个时间窗中，信号就可以被发送给线程</p><p>使用sigwait的好处在于它可以简化信号处理，允许把异步产生的信号用同步的方式处理。为了防止信号中断线程，可以把信号加到每个线程的信号屏蔽字中。然后可以安排专用线程处理信号。这些专用线程可以进行函数调用，不需要担心在信号处理程序中调用哪些函数是安全的，因为这些函数调用来自正常的线程上下文，而非会中断线程正常执行的传统信号处理程序</p><p>如果多个线程在sigwait的调用中，因等待同一个信号而阻塞，那么信号在递送的时候，就只有一个线程可以从sigwait中返回。如果一个信号被捕获（例如进程通过使用sigaction建立了一个信号处理程序），而且一个线程正在sigwait调用中等待同一信号，那么这时将由操作系统实现来决定以何种方式递送信号。操作系统实现可以让sigwait返回，也可以激活信号处理程序，但这两种情况不会同时发生</p><p>要把信号发送给进程可以调用kill。要把信号发送给线程，可以调用pthread_kill</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> tid, <span class="keyword">int</span> signo)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回错误编号</span><br></pre></td></tr></table></figure><p>可以传一个0值的signo来检查线程是否存在。如果信号的默认处理动作是终止该进程，那么把信号传递给某个线程仍然会杀死整个进程。</p><p>注意闹钟定时器是进程资源，并且所有的线程共享相同的闹钟。所以，进程中的多个线程不可能互不干扰（或互不合作）的使用闹钟定时器</p><h2 id="线程和fork"><a href="#线程和fork" class="headerlink" title="线程和fork"></a>线程和fork</h2><p>当线程调用fork时，就为子进程创建了整个地址空间的副本。子进程与父进程是完全不同的进程，只要两者都没有对内存内容做出改动，父进程和子进程之间还可以共享内存页的副本。</p><p>子进程通过继承整个地址空间的副本，还从子进程那里继承了每个互斥量、读写锁和条件变量的状态。如果父进程包含一个以上的线程，子进程在fork返回以后，如果紧接着不是马上调用exec的话，就需要清理锁状态。</p><p>在子进程内部，只存在一个线程，它是由父进程中调用fork的线程的副本构成的。如果父进程中的线程占有锁，子进程将同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以子进程没办法知道它占有了哪些锁、需要释放哪些锁</p><p>如果子进程从fork返回以后马上调用其中一个exec函数，就可以避免这样的问题。这种情况下，旧的地址空间就被丢弃，所以锁的状态无关紧要。但是如果子进程需要继续做处理工作的话，这种策略就行不通，还需要使用其他的策略</p><p>在多线程的进程中，为了避免不一致状态的问题，POSIX.1声明，在fork返回和子进程调用其中一个exec函数之间，子进程只能调用异步信号安全的函数。这就限制了在调用exec之前子进程能做什么，但不涉及子进程中锁状态的问题。</p><p>如果要清除锁状态，可以通过调用pthread_atfork函数建立fork处理程序</p><h2 id="线程和IO"><a href="#线程和IO" class="headerlink" title="线程和IO"></a>线程和IO</h2><p>pread和pwrite函数在多线程环境下是非常有用的，因为进程中的所有线程共享相同的文件描述符。其偏移量的设定和数据读取或写入是一个原子操作。可以用来解决并发线程对同一文件的读写操作问题</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第十一章-线程&quot;&gt;&lt;a href=&quot;#第十一章-线程&quot; class=&quot;headerlink&quot; title=&quot;第十一章 线程&quot;&gt;&lt;/a&gt;第十一章 线程&lt;/h1&gt;&lt;h2 id=&quot;线程概念&quot;&gt;&lt;a href=&quot;#线程概念&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记-三</title>
    <link href="https://gwq5210.com/2022/07/19/APUE%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <id>https://gwq5210.com/2022/07/19/APUE笔记-三/</id>
    <published>2022-07-19T17:03:04.000Z</published>
    <updated>2022-08-03T12:56:33.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第八章-进程控制"><a href="#第八章-进程控制" class="headerlink" title="第八章 进程控制"></a>第八章 进程控制</h1><h2 id="进程标识"><a href="#进程标识" class="headerlink" title="进程标识"></a>进程标识</h2><p>每个进程都有一个非负整型表示的唯一进程ID。虽然是唯一的，但是进程ID是可复用的，当一个进程终止后，其进程ID就成为复用的候选者，大多数UNIX系统实现延迟算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID</p><p>系统中有一些专用进程，但是具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。进程ID 1通常是init进程，init进程绝不会终止，它是一个普通的用户进程，但是他以超级用户特权运行。init会成为孤儿进程的父进程</p><p>下列函数返回进程的标识符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getppid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的父进程ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的实际用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的有效用户ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的实际组ID</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">(<span class="keyword">void</span>)</span></span>;  <span class="comment">// 返回调用进程的有效组ID</span></span><br></pre></td></tr></table></figure><p>以上函数都没有出错返回</p><h2 id="函数fork"><a href="#函数fork" class="headerlink" title="函数fork"></a>函数fork</h2><p>一个现有的进程可以调用fork函数创建一个新进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">子进程返回<span class="number">0</span>，父进程返回子进程Id；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>由fork创建的新进程被称为子进程（child process），fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。一个进程的子进程可以有多个，但并没有一个函数使一个进程可以获得其所有子进程的进程ID。子进程ID不可能为0，因为进程ID 0总是由内核交换进程使用</p><p>子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本，父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段</p><p>由于在fork之后经常跟着exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为代替，使用了写时复制（Copy-On-Write，COW）技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一页</p><p>Linux 3.2.0提供clone系统调用，是fork的推广形式，允许调用者控制哪些部分由父进程和子进程共享</p><p>一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信</p><p>fork之后标准IO库的缓存区也被复制，如果缓冲区中存在数据，则在子进程中也存在相应的数据，可能会输出两次</p><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p>重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，就好像对每个文件描述符来说，执行了dup函数，父进程和子进程每个相同的打开描述符共享一个文件表项。</p><p>重要的一点是父进程和子进程共享同一个文件偏移量。如果不共享，则要实现父子进程都写到同一个文件则要困难的多。但如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步，那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的），但这并不是常用的操作模式</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fork之后父进程和子进程之间对打开文件的共享.png" alt="fork之后父进程和子进程之间对打开文件的共享" title>                </div>                <div class="image-caption">fork之后父进程和子进程之间对打开文件的共享</div>            </figure><p>在fork之后，处理文件描述符有以下两种常见的情况</p><ul><li>父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新</li><li>父进程和子进程各自执行不同的程序段。这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的</li></ul><p>除了打开文件之外，父进程的很多其他属性也由子进程继承</p><ul><li>实际用户ID、实际组ID、有效用户ID、有效组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>设置用户ID标志和设置组ID标志</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>对任一打开文件描述符的执行时关闭（close-on-exec）标志</li><li>环境</li><li>连接的共享存储段</li><li>存储映像</li><li>资源限制</li></ul><p>父进程和子进程之间的区别如下</p><ul><li>fork的返回值不同</li><li>进程ID不同</li><li>这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程ID，而父进程的父进程ID则不变</li><li>子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0</li><li>子进程不继承父进程设置的文件锁</li><li>子进程的未处理闹钟被清除</li><li>子进程的未处理信号集设置为空</li></ul><p>fork失败的两个主要原因是</p><ul><li>系统中已经有了太多的进程（通常意味着某个方面除了问题）</li><li>该实际用户ID的进程总数超过了系统限制</li></ul><p>fork有以下两种用法</p><ul><li>一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求</li><li>一个进程要执行一个不同的程序。这对shell是常见的。在这种情况下，子进程从fork返回后立即调用exec</li></ul><p>某些操作系统将第二种用法中的两个操作组合成一个操作，称为spawn，UNIX将这两个操作分开，使得子进程在fork和exec之间可以更改自己的树形，如IO重定向、用户ID、信号安排等</p><h2 id="函数vfork"><a href="#函数vfork" class="headerlink" title="函数vfork"></a>函数vfork</h2><p>vfork函数的调用序列和返回值与fork相同，但两者的语义不同</p><p>vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。</p><p>不过在子进程调用exec或exit之前，它在父进程的空间运行，这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改数据（除了用于存放vfork返回值的变量）、进行函数调用、或者没有调用exec或exit就返回都可能带来未知的结果。</p><p>vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数的任意一个时，父进程会恢复运行。如果在调用这两个函数之前，子进程依赖于父进程的进一步动作，则会导致死锁</p><h2 id="函数exit"><a href="#函数exit" class="headerlink" title="函数exit"></a>函数exit</h2><p>进程5种正常终止方式如下</p><ul><li>在main函数内执行return语句，这等效于调用exit</li><li>调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序（调用atexit登记），然后关闭所有标准IO流等。因为ISO C并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的</li><li>调用_exit和_Exit函数。ISO C定义_Exit函数其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对于标准IO流是否进行冲洗，这取决于实现。在UNIX系统中_Exit和_exit是同义的，并不冲洗标准IO流。_exit函数由exit调用，它处理UNIX系统特定的细节。大多数UNIX系统实现中，exit是C库的一个函数，_exit是一个系统调用</li><li>进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用做进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回</li><li>进程的最后一个线程调用pthread_exit函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给pthread_exit的参数无关</li></ul><p>3种异常终止具体如下</p><ul><li>调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例</li><li>当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生</li><li>最后一个线程对“取消”（cancellation）请求做出相应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止</li></ul><p>不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器</p><p>上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数（exit、_exit和_Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传递给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态</p><p>子进程是父进程调用欧冠fork之后生成的。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，又将如何呢？其回答是：对于父进程已经终止的所有进程，它们父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1（init的进程ID），这种处理方法保证了每个进程有一个父进程</p><p>另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时可以得到这些信息。这些信号至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX系统术语中，一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程（zombie）。ps命令将僵死进程的状态打印为Z。如果一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程</p><p>被init收养的进程不会变成僵死进程。因为init进程在子进程终止时会调用wait函数取得其终止状态</p><h2 id="函数wait和waitpid"><a href="#函数wait和waitpid" class="headerlink" title="函数wait和waitpid"></a>函数wait和waitpid</h2><p>当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是一个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它。</p><p>调用wait或waitpid的进程可能发生如下情况</p><ul><li>如果其所有子进程都还在运行，则阻塞</li><li>如果一个子进程已终止，正等待父进程获取其状态，则取得该子进程的终止状态立即返回</li><li>如果它没有任何子进程，则立即出错返回</li></ul><p>如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* statloc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程ID；若出错，返回<span class="number">0</span>或<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>这两个函数的区别如下</p><ul><li>在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞</li><li>waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，它可以控制它所等待的进程</li></ul><p>如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如果调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪个子进程终止了</p><p>statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在statloc中，如果不关心终止状态，则可以将该参数设置为空指针</p><p>依据传统，这两个函数返回的整型状态字是由实现定义的，终止状态使用如下宏来查看</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/终止状态的宏.png" alt="终止状态的宏" title>                </div>                <div class="image-caption">终止状态的宏</div>            </figure><p>如果需要等待一个指定进程终止，在早期的UNIX系统中，必须调用wait，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则该进程ID和终止状态保存起来，然后再次调用wait，反复调用直到指定进程终止，下一次又想等待一个特定进程时，先查看已终止的进程列表或继续调用wait。</p><p>waitpid可以实现这一功能及其他功能，根据pid参数，作用如下</p><ul><li>pid等于-1：等待任一子进程。此种情况下，waitpid和wait等效</li><li>pid大于0：等待进程ID与pid相等的子进程</li><li>pid等于0：等待组ID等于调用进程组ID的任一子进程</li><li>pid小于-1：等待组ID等于pid绝对值的任一子进程</li></ul><p>对于wait其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错</p><p>参数options可以进一步控制waitpid的操作，此参数或者是0或者是如下常量按位或运算的结果</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitpid的options参数.png" alt="waitpid的options参数" title>                </div>                <div class="image-caption">waitpid的options参数</div>            </figure><p>waitpid提供了wait函数没有的3个功能</p><ul><li>waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态</li><li>waitpid提供了一个wait的非阻塞版本</li><li>wait通过WUNTRACED和WCONTINUED选项支持作业控制</li></ul><p>如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态知道父进程终止，实现这一要求的诀窍是调用fork两次，子进程的子进程会被init收养</p><h2 id="函数waitid"><a href="#函数waitid" class="headerlink" title="函数waitid"></a>函数waitid</h2><p>Single UNIX Specification包括了另一个取得进程终止状态的函数waitid，此函数类似于waitpid，但提供了更多的灵活性</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span>* infop, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>与waitpid类似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数</p><p>idtype类型如下</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitid的idtype常量.png" alt="waitid的idtype常量" title>                </div>                <div class="image-caption">waitid的idtype常量</div>            </figure><p>options是以下各标志的按位或运算，这些标志指示调用者关注哪些状态变化</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/waitid的options常量.png" alt="waitid的options常量" title>                </div>                <div class="image-caption">waitid的options常量</div>            </figure><p>WCONTINUED、WEXITED或WSTOPPED这三个常量之一必须在options参数中指定</p><p>infop是指向siginfo结构的指针，该结构包含了造成子进程进程状态改变有关信号的详细信息</p><h2 id="函数wait3和wait4"><a href="#函数wait3和wait4" class="headerlink" title="函数wait3和wait4"></a>函数wait3和wait4</h2><p>大多数UNIX系统实现提供了另外两个函数wait3和wait4。该函数允许内核返回由终止进程机器所有子进程使用的资源概况</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait3</span><span class="params">(<span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait4</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* statloc, <span class="keyword">int</span> options, struct rusage* rusage)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。可以参考getrusage(2)手册页</p><h2 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h2><p>当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。fork之后无法确定哪个进程先运行，因此需要某种形式的同步</p><p>如果一个进程需要等待其父进程终止，则可使用下列形式的循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (getppid() != <span class="number">1</span>) &#123;</span><br><span class="line">  sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种形式的循环称为轮询（polling），它的问题是浪费了CPU的时间</p><p>为了避免竞争条件和轮询，在多个进程间需要某种形式的信号发送和接收的方法，比如使用信号和各种形式的进程间通信</p><h2 id="函数exec"><a href="#函数exec" class="headerlink" title="函数exec"></a>函数exec</h2><p>fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。</p><p>调用exec并不创建新进程，其进程ID并不会改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段</p><p>有7中不同的exec函数，常常被统称为exec函数。</p><p>fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止，这是我们需要的基本进程控制原语。我们可以用这些原语构造另外一些如popen和system之类的函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ..., <span class="comment">/* (char*)0, */</span> <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* pathname, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">const</span> <span class="keyword">char</span>* arg0, ... <span class="comment">/* (char*)0 */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* filename, <span class="keyword">char</span>* <span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fexecve</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">char</span>* <span class="keyword">const</span> argv[], <span class="keyword">char</span>* <span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><p>这些函数之间的第一个区别是前4个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时：</p><ul><li>如果filename包含/，则就将其视为路径名</li><li>否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件</li></ul><p>如果execlp或execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的可执行文件，则就认为该文件是一个shell脚本，于是试着调用/bin/sh，并以该filename作为shell输入</p><p>fexecve函数避免了寻找正确的可执行文件，而是依赖调用进程来完成这项工作。调用进程可以使用文件描述符验证所需文件并且无竞争的执行该文件</p><p>第二个区别与参数表的传递相关（l表示list，v表示矢量vector）。函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外四个函数，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数</p><p>最后一个区别与向新程序传递环境表相关。以e结尾的3个函数可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境。通常一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的环境</p><p>函数名中的字符会给我们一些记忆的帮助。字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个<code>argv[]</code>矢量。最后字母e表示该函数取<code>envp[]</code>数组，而不使用当前环境变量</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/7个exec函数之间的区别.png" alt="7个exec函数之间的区别" title>                </div>                <div class="image-caption">7个exec函数之间的区别</div>            </figure><p>每个系统对参数表和环境表的总长度都有一个限制。这种限制是由ARG_MAX给出的，此值至少是4096字节</p><p>执行exec后，进程ID没有改变，但新程序从调用进程继承了下列属性</p><ul><li>进程ID和父进程ID</li><li>实际用户ID和实际组ID</li><li>附属组ID</li><li>进程组ID</li><li>会话ID</li><li>控制终端</li><li>闹钟尚余留的时间</li><li>当前工作目录</li><li>根目录</li><li>文件模式创建屏蔽字</li><li>文件锁</li><li>进程信号屏蔽</li><li>资源限制</li><li>nice值</li><li>tms_utime、tms_stime、tms_cutime以及tms_cstime值</li></ul><p>对打开文件的处理与每个描述符的执行时关闭（close-on-exec）标志值有关。若设置了该标志，则在执行exec时关闭该描述符；否则该描述符仍打开。除非特地的用fcntl设置了该执行时关闭标志，否则系统的默认操作是在exec后仍保持这种描述符打开</p><p>POSIX.1明确要求再exec时关闭打开目录流（opendir函数）。这通常是由opendir函数实现的，它调用fcntl函数为对应于打开目录流的描述符设置执行时关闭标志</p><p>注意，在exec前后实际用户ID和实际组ID保持不变，而有效ID是否改变则取决于所执行程序文件的设置用户ID位和设置组ID位是否设置。如果新程序的设置用户ID位已设置，则有效用户ID变成程序文件所有者的ID；否则有效用户ID不变。对组ID的处理方式与此相同</p><p>在很多UNIX系统实现中只有execve是内核的系统调用，另外6个只是库函数，它们最终都要调用该系统调用</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/7个exec函数之间的关系.png" alt="7个exec函数之间的关系" title>                </div>                <div class="image-caption">7个exec函数之间的关系</div>            </figure><h2 id="更改用户ID和更改组ID"><a href="#更改用户ID和更改组ID" class="headerlink" title="更改用户ID和更改组ID"></a>更改用户ID和更改组ID</h2><p>在UNIX系统中，特权（如能改变当前日期的表示法）以及访问控制（如能否读、写一个特定文件），是基于用户ID和组ID的。当程序需要增加特权，或需要访问当前并不允许访问的资源时，我们需要更换自己的用户ID或组ID，使得新ID具有合适的特权或访问权限。同样如果需要降低权限，则也需要更换用户ID或组ID</p><p>一般而言，在设计应用时，我们总是视图使用最小特权（least privilege）模型。依照此模型，我们的程序应当只具有为完成给定任务所需的最小特权。这降低了由恶意用户试图哄骗我们的进程以未预料的方式使用特权造成的安全性风险</p><p>可以用setuid函数设置实际用户ID和有效用户ID，与此类似，可以用setgid函数设置实际组ID和有效组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>更改用户ID的规则如下（适用于组ID）</p><ul><li>若进程具有超级用户特权，则setuid函数将实际用户ID、有效用户ID以及保存的设置用户ID（saved set-user-ID）设置为uid</li><li>若进程没有超级用户特权，但是uid等于实际用户ID或保存的设置用户ID，则setuid只将有效用户ID设置为uid，不更改实际用户ID和保存的设置用户ID</li><li>如果上边两个条件都不满足，则errno设置为EPERM，并返回-1</li></ul><p>上述假定_POSIX_SAVED_IDS为真，如果没有提供这种功能，则上边关于保存的设置用户ID部分都无效</p><p>关于内核维护的3个用户ID，还需要注意</p><ul><li>只有超级用户进程可以更改实际用户ID。通常，实际用户ID是在用户登录时，有login程序设置的，而且绝不会改变它。login是一个超级用户进程</li><li>仅当对程序文件设置了设置用户ID位时，exec函数才设置有效用户ID。如果设置用户ID位没有设置，exec函数不会改变有效用户ID，而将维持其现有值。任何时候都可以调用setuid，将有效用户ID设置为实际用户ID或保存的设置用户ID。</li><li>保存的设置用户ID是由exec复制有效用户ID而得到的，如果设置了文件的设置用户ID位则在exec根据文件的用户ID设置了进程的有效用户ID以后，这个副本就被保存起来了</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/更改3个用户ID的不同方法.png" alt="更改3个用户ID的不同方法" title>                </div>                <div class="image-caption">更改3个用户ID的不同方法</div>            </figure><p>历史上BSD支持setreuid函数，其功能是交换实际用户ID和有效用户ID的值，具体用法参考手册</p><p>函数seteuid和setegid只更改有效用户ID和有效组ID，一个非特权用户可以将其有效用户ID设置为其实际用户ID或其保存的设置用户ID。对于一个特权用户则可将有效用户ID设置为uid</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/设置不同用户ID的各函数.png" alt="设置不同用户ID的各函数" title>                </div>                <div class="image-caption">设置不同用户ID的各函数</div>            </figure><p>以上说的一切都以类似方式适用于各个组ID。附属组ID不受setgid、setregid和setegid函数影响</p><h2 id="解释器文件"><a href="#解释器文件" class="headerlink" title="解释器文件"></a>解释器文件</h2><p>现如今的UNIX系统都支持解释器文件（interpreter file）。这种文件是文本文件，其起始行的形式是</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! pathname [optional-argument]</span></span><br></pre></td></tr></table></figure><p>感叹号和pathname之间的空格是可选的，最常见的解释器文件以下列行开始</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">! /bin/sh</span></span><br></pre></td></tr></table></figure><p>pathname通常是绝对路径名，对它不进行什么特殊的处理（不使用PATH进行路径搜索）。对这种文件的识别是由内核作为exec系统调用处理的一部分来完成的。内核使调用exec函数的进程实际执行的文件并不是解释器文件，而是在该解释器文件第一行中pathname所指定的文件，而是在该解释器文件第一行中pathname所指定的文件。注意解释器文件（文本文件，它以#!开头）和解释器（由该解释器文件第一行中的pathname指定）的区别</p><p>解释器文件的第一行一般由长度限制，这包括#!、pathname、可选参数、终止换行符以及空格数。Linux 3.2.0中是128字节</p><p>当内核exec解释器时，argv[0]参数是该解释器的pathname，其后是解释器文件中的可选参数，其余参数是exec的pathname以及调用exec的参数（argv[1]及其后参数），此时调用exec的argv[1]和其后参数已经右移。注意内核取exec调用中的pathname而不是argv[0]，因为一般而言pathname包含了比第一个参数更多的信息</p><p>解释器文件使得用户得到效率方面的好处，其代价是内核的额外开销（因为识别解释器文件的是内核）。</p><ul><li>有些程序是用某种语言写的脚本，解释器文件可以将这一事实隐藏起来。使用somecmd optional-arguments调用即可</li><li>解释器脚本在效率方面也提供了好处。我们可以编写shell脚本来实现相同的功能，但要求做更多动作。首先shell读此命令，然后试图execlp此文件，因为shell脚本是一个可执行文件，但却不是机器可执行的，于是返回一个错误，execlp就认为该文件是一个shell脚本，然后执行/bin/sh，并以该shell脚本的路径名作为其参数。shell正确的执行我们的shell脚本，但是为了运行shell脚本中的程序（如awk程序），它调用fork、exec和wait，于是一个shell脚本代替解释器脚本需要更多的开销</li><li>解释器脚本使我们可以使用除/bin/sh意外的其他shell来编写shell脚本</li></ul><h2 id="函数system"><a href="#函数system" class="headerlink" title="函数system"></a>函数system</h2><p>system函数可以执行给定的命令</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cmdstring)</span></span>;</span><br></pre></td></tr></table></figure><p>如果cmdstring是一个空指针，则仅当命令处理程序可用时，system返回非0值，这一特征可以确定在一个给定的操作系统上是否支持system函数。在UNIX系统中system总是可用的</p><p>system在其实现中调用了fork、exec和waitpid，因此有3中返回值</p><ul><li>fork失败或者waitpid返回除EINTR之外的出错，则system返回-1，并且设置errno</li><li>如果exec失败（表示不能执行shell），则其返回值如同shell执行了exit(127)一样</li><li>否则所有3个函数都成功，那么system的返回值是shell的终止状态，其格式已在waitpid中说明</li></ul><h3 id="system的安全性漏洞"><a href="#system的安全性漏洞" class="headerlink" title="system的安全性漏洞"></a>system的安全性漏洞</h3><p>如果在一个设置用户ID程序中调用system，会发生什么呢？这是一个安全性方面的漏洞，决不应该这样做</p><p>有些实现通过更改/bin/sh，当有效用户ID与实际用户ID不匹配时，将有效用户ID设置为实际用户ID</p><p>如果一个进程正以特殊的权限运行，它又想生成另一个进程执行另一个程序，则它应该直接使用fork和exec，而且在fork之后，exec之前要更改回普通权限。设置用户ID或设置组ID程序决不应该调用system函数</p><h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>大多数UNIX系统提供了一个宣讲以进行进程会计（process accounting）处理，启用该选项后，每当进程结束时内核就写一个会计记录。典型的会计记录包含总量较小的二进制数据，一般包括命令名，所适用的CPU时间总量、用户ID和组ID、启动时间等</p><p>会计记录所需的各个数据都由内核保存在进程表中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生两个后果</p><ul><li>我们不能获取永远不终止的进程的会计记录。如init或内核守护进程</li><li>会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li></ul><p>会计记录对应进程而不是程序，在fork之后，内核为子进程初始化一个记录，而不是在一个新程序被执行时初始化。虽然exec并不创建一个新的会计记录，但相应记录中的命令名改变了，AFORK则被清除。如果一个程序执行了3个程序（A exec B、B exec C，最后C exit）只会写一个会计记录，命令名对应C，CPU时间是A、B和C之和</p><h2 id="用户标识"><a href="#用户标识" class="headerlink" title="用户标识"></a>用户标识</h2><p>一个人在口令文件中可以有多个登录项，它们的用户ID相同，但登录shell不同（因此通过getpwuid(getuid())不可行）。可以使用getlogin函数可以获取登录名。如果调用此函数的进程没有连接到用户登录时所用的终端，则函数会失败，通常称这些进程为守护进程（daemon）</p><h2 id="进程调度"><a href="#进程调度" class="headerlink" title="进程调度"></a>进程调度</h2><p>UNIX系统历史上对进程提供的只是基于调度优先级的粗粒度的控制。调度策略和调度优先级是由内核确定的。进程可以通过调整nice值选择以更低优先级运行。只有特权进程允许提高调度权限。</p><p>nice值的返回在<code>0~(2*NZERO)-1</code>之间，nice值越小，优先级越高。NZERO是系统默认的nice值。</p><p>进程可以通过nice函数获取或更改它的nice值。使用这个函数，进程只能影响自己的nice值，不能影响任何其他进程的nice值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> incr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回新的nice值NZERO；若出错返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>incr参数会被增加到调用进程的nice值上，如果incr太大，系统直接把它降到最大合法值，不给出提示。类似的如果incr太小，系统会把它提高到最小合法值。由于-1是合法的成功返回值，在调用nice函数之前需要清除errno，在nice函数返回-1时，需要检查errno。如果nice调用成功，并且返回值为-1，那么errno仍然为0。如果errno不为0，说明nice调用失败</p><p>getpriority函数可以向nice函数那样用于获取进程的nice值，但是getpriority还可以获取一组相关进程的nice值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回-NZERO~NZERO<span class="number">-1</span>之间的nice值；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>which参数可以取以下三个值之一：PRIO_PROCESS表示进程，PRIO_PGRP表示进程组，PRIO_USER表示用户ID。which参数控制who参数是如何解释的，who参数选择感兴趣的一个或多个进程。如果who参数为0，表示调用进程、进程组或用户。当which设置为PRIO_USER并且who为0时，使用调用进程的实际用户ID。如果which参数作用域多个进程，则返回所有作用进程中优先级最高的（最小的nice值）</p><p>setpriority函数可用于为进程，进程组和属于特定用户ID的所有进程设置优先级</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>参数which和who与getpriority函数中相同。value增加到NZERO上，然后变为新的nice值</p><p>遵循XSI的系统要求进程调用exec后保留nice值。如Linux 3.2.0、MacOS等</p><h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p>我们可以度量的时间有三个：墙上时钟时间、用户CPU时间和系统CPU时间。任一进程都可以调用times获得它自己以及已终止进程的上述时间</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">clock_t</span> <span class="title">times</span><span class="params">(struct tms* buf)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回流逝的墙上时钟时间（以时钟滴答数为单位）；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>此函数填写由buf指向的tms结构，定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_utime;  <span class="comment">/* user CPU time */</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_stime;  <span class="comment">/* system CPU time */</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cutime; <span class="comment">/* user CPU time of children, all waited-for terminated children*/</span></span><br><span class="line">  <span class="keyword">clock_t</span> tms_cstime; <span class="comment">/* system CPU time of children, all waited-for terminated children */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>times函数返回墙上时钟时间作为其函数值。次值是相对于过去的某一时刻度量的，所以不能用其绝对值而必须使用其相对值。例如，调用times两次，其差值就是墙上时钟时间</p><p>结构中两个针对子进程的字段包含了此进程用wait函数族已等待到的各子进程的值。所有由此函数返回的clock_t值都用_SC_CLK_TCK转换成秒数</p><p>大多数实现提供了getrusage(2)函数，该函数返回CPU时间以及指示资源使用情况的另外14个值</p><h1 id="第九章-进程关系"><a href="#第九章-进程关系" class="headerlink" title="第九章 进程关系"></a>第九章 进程关系</h1><h2 id="终端登录和网络登录"><a href="#终端登录和网络登录" class="headerlink" title="终端登录和网络登录"></a>终端登录和网络登录</h2><p>我们可以经由终端登录至UNIX系统，终端的类型可以是基于字符的终端、图形终端等</p><p>系统使用伪终端（pseudo terminal），来处理终端登录和网络登录</p><h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>每个进程除了有一进程ID外，还属于一个进程组。进程组是一个或多个进程的集合。通常它们是在同一作业中结合起来的，同一进程组中各进程接收来自同一终端的各种信号。每个进程组有一个唯一的进程组ID。进程组ID类似于进程ID，它是一个正整数，并可存放在pid_t数据类型中。函数getpgrp返回调用进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgrp</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">返回调用进程的进程组ID</span><br></pre></td></tr></table></figure><p>getpgid返回指定进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>若pid是0，返回调用进程的进程组ID，即<code>getpgid(0)</code>等价于<code>getpgrp()</code></p><p>每个进程组有一个组长进程，组长进程的进程组ID等于其进程ID，进程组组长可以创建一个进程组、创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，则该进程组就存在，这与其组长进程是否终止无关。从进程组创建开始到其中最后一个进程离开为止的时间区间称为进程组的生命期。某个进程组中的最后一个进程可以终止，也可以转移到另一个进程组</p><p>进程调用setpgid可以加入一个现有的进程组或者创建一个新的进程组</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>setpgid将pid进程的进程组ID设置为pgid。如果这两个参数相等，则由pid指定的进程变成进程组组长。如果pid是0，则使用调用者的进程ID。另外，如果pgid是0，则由pid指定的进程ID用作进程组ID</p><p>一个进程只能为它自己或它的子进程设置进程组ID。在它的子进程调用exec之后，它就不再更改该子进程的进程组ID</p><p>大多数作业控制shell中，在fork之后调用此函数，使父进程设置其子进程的进程组ID，并且也使子进程设置其自己的进程组ID，这两个调用有一个是冗余的，但让父进程和子进程都这样可以保证，在父进程和子进程认为子进程已进入了该进程组之前，这确实已经发生了。如果不这样做，在fork之后，由于父子进程运行的先后次序不确定，会导致子进程的组员身份不确定。</p><h2 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h2><p>会话（session）是一个或多个进程组的集合。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/会话中的进程组安排.png" alt="会话中的进程组安排" title>                </div>                <div class="image-caption">会话中的进程组安排</div>            </figure><p>进程调用setsid函数建立一个新会话</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如果调用此函数的进程不是一个进程组的组长，则此函数创建一个新会话。会发生以下3件事</p><ul><li>该进程变成新会话的会话首进程（session leader，会话首进程是创建该会话的进程）。此时，该进程是新会话中的唯一进程</li><li>该进程成为一个新进程组的组长进程。新进程组ID是该调用进程的进程ID</li><li>该进程没有控制终端。如果在调用setsid之前该进程有一个控制终端，那么这种联系也被切断</li></ul><p>如果该调用进程已经是一个进程组的组长，则此函数返回出错。为了保证不处于这种情况，通常先调用fork，然后使其父进程终止，而子进程继续，因为子进程继承了父进程的进程组ID，而其进程ID则是新分配的，两者不可能相等，这就保证了子进程不是一个进程组的组长</p><p>getsid函数返回会话首进程的进程组ID。会话首进程总是一个进程组的组长进程，所以可以将“会话首进程的进程组ID”称为会话ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回会话首进程的进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>如若pid是0，getsid返回调用进程的会话首进程的进程组ID。出于安全方面的考虑，一些实现有如下限制：如果pid并不属于调用者所在的会话，那么调用进程就不能得到该会话首进程的进程组ID</p><h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p>会话和进程组还有一些其他特性</p><ul><li>一个会话可以有一个控制终端（controlling terminal）。这通常是终端设备（终端登录）或伪终端设备（网络登录）</li><li>建立与控制终端连接的会话首进程被称为控制进程（controlling process）</li><li>一个会话中的几个进程组可被分成一个前台进程组（foreground process group）以及一个或多个后台进程组（background process group）</li><li>如果一个会话有一个控制终端，则它有一个前台进程组，其他进程组为后台进程组</li><li>无论何时键入终端的中断键（常常是Delete或Ctrl+C），都会将中断信号发送至前台进程组的所有进程</li><li>无论何时键入终端的退出键（常常是Ctrl+\），都会将推出信号发送至前台进程组的所有进程</li><li>如果终端接口检测到调制解调器（或网络）已经断开连接，则将挂断信号发送至控制进程（会话首进程）</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/控制终端.png" alt="控制终端" title>                </div>                <div class="image-caption">控制终端</div>            </figure><p>通常我们不必担心控制终端，登录时，将自动建立控制终端</p><p>可以open文件/dev/tty（在内核中，此设备是控制终端的同义词）来与控制终端对话，如果程序没有终止终端，则对于此设备的open将失败</p><h2 id="函数tcgetpgrp、tcsetpgrp和tcgetsid"><a href="#函数tcgetpgrp、tcsetpgrp和tcgetsid" class="headerlink" title="函数tcgetpgrp、tcsetpgrp和tcgetsid"></a>函数tcgetpgrp、tcsetpgrp和tcgetsid</h2><p>需要有一种方法来通知内核哪一个进程组是前台进程组，这样终端设备驱动程序就能知道将终端输入和终端产生的信号发送到何处</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetpgrp</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回前台进程组ID；若出错，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrpid)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>函数tcgetpgrp返回前台进程组ID，它与在fd打开的终端相关联</p><p>如果进程有一个控制终端，则该进程可以调用tcsetpgrp将前台进程组ID设置为pgrpid。pgrpid值应当是在同一会话中的一个进程组的ID。fd必须引用该会话的控制终端</p><p>大多数应用程序并不直接调用这两个函数。它们通常由作业控制shell调用</p><p>给出控制TTY的文件描述符，通过tcgetsid函数，应用程序就能获得会话首进程的进程组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">tcgetsid</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回会话首进程的进程组ID；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><p>需要管理控制终端的应用程序可以调用tcgetsid函数识别出控制终端的会话首进程的会话ID（它等价于会话首进程的进程组ID）</p><h2 id="作业控制"><a href="#作业控制" class="headerlink" title="作业控制"></a>作业控制</h2><p>作业控制允许在一个终端上启动多个作业（进程组），它控制哪一个作业可以访问控制终端以及哪些作业在后台运行。作业控制要求以下3中形式的支持</p><ul><li>支持作业控制的shell</li><li>内核中的终端驱动程序必须支持作业控制</li><li>内核必须提供对某些作业控制信号的支持</li></ul><p>我们可以在终端上键入影响前台作业的特殊字符</p><ul><li>中断字符（一般采用Delete或Ctrl+C）产生SIGINT</li><li>退出字符（一般采用Ctrl+\）产生SIGQUIT</li><li>挂起字符（一般采用Ctrl+Z）产生SIGTSTP</li></ul><h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p>一个其父进程已终止的进程称为孤儿进程（orphan process），这种进程由init进程收养。整个进程组也可成为孤儿</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第八章-进程控制&quot;&gt;&lt;a href=&quot;#第八章-进程控制&quot; class=&quot;headerlink&quot; title=&quot;第八章 进程控制&quot;&gt;&lt;/a&gt;第八章 进程控制&lt;/h1&gt;&lt;h2 id=&quot;进程标识&quot;&gt;&lt;a href=&quot;#进程标识&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>APUE笔记-二</title>
    <link href="https://gwq5210.com/2022/07/17/APUE%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <id>https://gwq5210.com/2022/07/17/APUE笔记-二/</id>
    <published>2022-07-17T23:58:29.000Z</published>
    <updated>2022-08-03T12:56:33.264Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第五章-标准IO库"><a href="#第五章-标准IO库" class="headerlink" title="第五章 标准IO库"></a>第五章 标准IO库</h1><p>标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标准IO库</p><h2 id="流和FILE对象"><a href="#流和FILE对象" class="headerlink" title="流和FILE对象"></a>流和FILE对象</h2><p>在第三章所有的文件IO都是围绕文件描述符的。对于标准IO库，其操作是围绕流（stream）进行的，打开或创建一个文件时，使一个流与一个文件相关联</p><p>标准IO文件流可用于单字节和多字节字符集。流的定向（stream’s orientation）决定了读、写字符是单字节还是多字节的。</p><p>当一个流最初被创建时，它并没有定向。若在流上使用一个单字节IO函数，则将流设置为字节定向的。若在流上使用一个多字节IO函数，则将流设置为字宽定向的。</p><p>只有freopen和fwide这两个函数可以改变流的定向。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE* fp, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line">返回值: &gt;<span class="number">0</span> : 宽定向；&lt;<span class="number">0</span> 字节定向；<span class="number">0</span> : 未定向</span><br></pre></td></tr></table></figure><p>fwide并不能改变已定向流的定向。fwide无法返回出错。需要在调用fwide前清除errno，返回时再检查errno的值</p><p>一个流的结构（FILE*，通常称为文件指针）通常包含一些必要的信息，如实际IO的文件描述符，缓存区指针和长度，当前在缓冲区中的字符数和出错标志等</p><p>一个进程预定义了3个流，标准输入流，标准输出流，标准出错流(分别是stdin, stdout, stderr)可以自动被进程使用。分别对应文件描述符STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO</p><h2 id="缓冲"><a href="#缓冲" class="headerlink" title="缓冲"></a>缓冲</h2><p>标准IO库提供缓冲的目的是尽可能减少read、write系统调用的次数。它对每个IO流自动进行缓冲管理，避免应用程序考虑应使用多大的缓冲区。</p><p>标准IO提供3中类型的缓冲</p><ul><li>全缓冲。这种情况下，缓冲区满才进行实际的IO操作，磁盘文件通常是全缓冲的。当然我们可以通过fflush手动冲洗流的缓冲区</li><li>行缓冲。这种情况下，输入和输出遇到换行符执行IO操作。流涉及一个终端时通常使用行缓冲。行缓冲有以下两个限制<ul><li>缓冲区大小固定。缓冲区满时，即使没有换行符也进行IO操作</li><li>任何时候，只要通过标准IO库要求从a）不带缓冲的流或b)一个行缓冲的流得到输入数据，那么就会冲洗所有行缓冲输出流</li></ul></li><li>不带缓冲。标准IO库不对字符进行缓冲存储。标准错误流通常是不带缓冲的，这使得出错信息可以尽快的显示出来</li></ul><p>ISO C要求</p><ul><li>当且仅当标准输入和标准输出并不指向交互式设备时，它们才是全缓冲的</li><li>标准错误绝不会是全缓冲的</li></ul><p>一般系统默认如下方案</p><ul><li>标准错误流是不带缓冲的</li><li>若是指向终端的流，则是行缓冲的；否则是全缓冲的</li></ul><p>我们可以通过如下函数修改系统默认的缓冲类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>以上函数应在流被打开后调用，且应在对流执行任何一个其他操作之前调用</p><p>可以使用setbuf打开或关闭缓冲机制。buf为NULL，则关闭缓冲；为了带缓冲进行IO，参数buf必须指向一个长度为BUFSIZ的缓冲区。一般在此之后流就是全缓冲的，但是如果一个流与一个终端设备相关，某些系统也可将其设置为行缓冲的</p><p>使用setvbuf可以通过mode精确的指定缓冲类型</p><ul><li>_IOFBF：全缓冲</li><li>_IOLBF：行缓冲<ul><li>以上可以通过buf和size设置缓冲区和长度；如果buf为NULL，则标准IO库将自动分配合适的缓冲区，适当长度一般由BUFSIZ指定（GNU C使用stat结构中的st_blksize来决定最佳缓冲区长度）</li></ul></li><li>_IONBF：不带缓冲，忽略buf和size参数</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/setbuf和setvbuf函数.png" alt="setbuf和setvbuf函数" title>                </div>                <div class="image-caption">setbuf和setvbuf函数</div>            </figure><p>一般而言我们应该由系统选择缓冲区的长度，并自动分配缓冲区，流关闭时，将自动释放缓冲区</p><p>任何时候我们可以强制冲洗一个流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>此函数使所有未写的数据都传送至内核。如果fp是NULL，则导致所有的输出流被冲洗</p><h2 id="打开流"><a href="#打开流" class="headerlink" title="打开流"></a>打开流</h2><p>以下3个函数打开一个标准流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> pathname, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function">FILE* <span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> type)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>说明如下</p><ul><li>fopen打开路径名为pathname的指定文件</li><li>freopen在一个指定流上打开一个指定文件，如若流已经被打开，则先关闭该流。若流已经定向，则使用freopen清除该定向。此函数一般用于将一个指定文件打开为一个预定义的流：标准输入、标准输出、标准错误</li><li>fdopen函数取一个已有的文件描述符（如从open、dup、dup2、fcntl、pipe、socket、socketpair或accept函数得到），并使一个标准的IO流与此文件描述符相结合</li></ul><p>参数type有如下组合</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/fopen的type.png" alt="fopen的type" title>                </div>                <div class="image-caption">fopen的type</div>            </figure><p>使用字符b可以使得标准IO系统区分二进制和文本文件。UNIX内核并不区分这两种文件，所以在UNIX系统下并无作用</p><p>对于fdopen，type参数的作用稍有区别。因为该描述符已被打开，所有fdopen为写打开并不截断文件。标准IO追加写方式也不能用于创建该文件（该文件一定存在，fd引用一个文件）</p><p>当以读和写类型（type中+号）打开一个文件时，有如下限制</p><ul><li>如果中间没有fflush、fseek、fsetpos或rewind，则在输出后边不能直接跟随输入</li><li>如果中间没有fseek、fsetpos或rewind或者一个输入操作没有到达文件尾端，则在输入操作之后不能直接跟随输出</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/打开流的不同方式.png" alt="打开流的不同方式" title>                </div>                <div class="image-caption">打开流的不同方式</div>            </figure><p>在w和a类型创建一个文件时，我们无法指定文件的访问权限位，我们可以通过调整umask值来限制这些权限或创建之后修改权限</p><p>调用fclose可以关闭一个打开的流</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>在该文件被关闭之前，冲洗缓冲区中的输出数据，缓冲区中的任何输入数据被丢弃。如果分配和缓冲区，则自动释放缓冲区</p><p>进程正常终止时（直接调用exit或从main函数返回），则所有带未写缓冲数据的标准IO流都被冲洗，所有打开的标准IO流都被关闭</p><h2 id="读和写流"><a href="#读和写流" class="headerlink" title="读和写流"></a>读和写流</h2><p>有三种不同的非格式化IO可以对流进行读写操作</p><ul><li>每次一个字符的IO。如果流带缓冲，则标准IO函数处理所有缓冲</li><li>每次一行的IO。</li><li>直接IO，或者称为二进制IO。fread和fwrite支持这种类型的IO</li></ul><h3 id="输入函数"><a href="#输入函数" class="headerlink" title="输入函数"></a>输入函数</h3><p>以下函数可以一次读取一个字符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>; <span class="comment">// 等同于fgetc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回下一个字符；若已到文件结尾或出错，返回EOF</span><br></pre></td></tr></table></figure><p>返回值会将unsigned char转换为int类型。无符号即使最高位为1也不会返回负值。要求int返回值是因为除了返回所有可能的字符，还要加上一个已出错或到达文件尾端的标记值。EOF被要求是一个负值，通常为-1</p><p>为了区分出错或到达文件尾端，需要使用以下函数进行区分</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若条件为真，返回非<span class="number">0</span>；否则，返回<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数实现在文件指针中维护了两个标志：出错标志和文件结束标志；调用clearerr可以清除这两个标志</p><p>从流中读取数据后，可以调用ungetc再将字符压入流中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>压送回流的字符又可以从流中读出，但读出字符的顺序与压送回流的顺序相反。回送的字符不一定必须是上次读到的字符，不能回送EOF。但是当已经达到文件尾端时，仍可以回送一个字符。调用ungetc只是将字符写入流缓冲区中</p><h3 id="输出函数"><a href="#输出函数" class="headerlink" title="输出函数"></a>输出函数</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 可以实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;  <span class="comment">// 不能实现为宏</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>; <span class="comment">// 等同于fputc(stdin);</span></span><br><span class="line"></span><br><span class="line">若成功，返回c；若出错，返回EOF</span><br></pre></td></tr></table></figure><h2 id="每次一行IO"><a href="#每次一行IO" class="headerlink" title="每次一行IO"></a>每次一行IO</h2><p>由以下函数提供每次输入一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf, <span class="keyword">int</span> n, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gets</span><span class="params">(<span class="keyword">char</span>* <span class="keyword">restrict</span> buf)</span></span>;  <span class="comment">// 可能造成缓冲区溢出，应使用fgets(buf, n, stdin)替换</span></span><br><span class="line"></span><br><span class="line">若成功，返回buf；若已到达文件末尾或出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>fgets读取不超过n-1个字符，buf总是以null字节结尾。gets不将换行符写入buf，而fgets则将换行符写入buf</p><p>fputs和puts提供每次输出一行的功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">restrict</span> str, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span></span>;  <span class="comment">// 等价于fputs(str, stdout); fputs("\n", stdout);</span></span><br><span class="line"></span><br><span class="line">若成功，返回非负值；若出错，返回EOF</span><br></pre></td></tr></table></figure><p>应尽量使用fget和fputs组合，以便记得在每行终止时必须处理换行符</p><h2 id="标准IO的效率"><a href="#标准IO的效率" class="headerlink" title="标准IO的效率"></a>标准IO的效率</h2><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/标准IO库的效率.png" alt="标准IO库的效率" title>                </div>                <div class="image-caption">标准IO库的效率</div>            </figure><h2 id="二进制IO"><a href="#二进制IO" class="headerlink" title="二进制IO"></a>二进制IO</h2><p>使用以下函数处理二进制IO</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fread</span><span class="params">(<span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">fwrite</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* <span class="keyword">restrict</span> ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* <span class="keyword">restrict</span> fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回读或写的对象数</span><br></pre></td></tr></table></figure><p>对于读，如果出错或到达文件尾端，则此数字可以小于nobj，这时应调用ferror或feof判断是哪种情况。对于写如果返回值小于nobj则出错</p><p>二进制IO需要对读写的数据有限制，否则可能产生兼容性的问题。如结构体对齐问题，导致数据错误</p><h2 id="定位流"><a href="#定位流" class="headerlink" title="定位流"></a>定位流</h2><p>有三种方法定位标准IO流</p><ul><li>ftell和fseek，用long进行定位</li><li>ftello和fseeko，用off_t进行定位</li><li>fgetpos和fsetpos，由ISO C引入，使用fpos_t进行定位；移植到非UNIX系统的应用程序应当使用这两个函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回当前文件位置指示；若出错，返回<span class="number">-1L</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE* fp, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;  <span class="comment">// whence与lseek的参数相同</span></span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure><p>可以使用rewind将流设置到文件的起始位置</p><p>除了偏移类型是off_t外，ftello和fseeko函数与上述函数相同</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE* <span class="keyword">restrict</span> fp, <span class="keyword">fpos_t</span>* <span class="keyword">restrict</span> pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE* fp, <span class="keyword">const</span> <span class="keyword">fpos_t</span>* pos)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="格式化IO"><a href="#格式化IO" class="headerlink" title="格式化IO"></a>格式化IO</h2><p>格式化IO有scanf和printf函数族来实现，同时也提供了vscanf和vprintf函数族来处理可变参数</p><p>有关格式化IO的详细信息，这里不过多介绍，需要时可以参考手册或书籍</p><h2 id="标准IO库的文件描述符"><a href="#标准IO库的文件描述符" class="headerlink" title="标准IO库的文件描述符"></a>标准IO库的文件描述符</h2><p>fileno可以获取对应流关联的文件描述符，其不是ISO C标准，不可移植</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fileno</span><span class="params">(FILE* fp)</span></span>;</span><br><span class="line"></span><br><span class="line">返回与流相关联的文件描述符</span><br></pre></td></tr></table></figure><h2 id="临时文件"><a href="#临时文件" class="headerlink" title="临时文件"></a>临时文件</h2><p>ISO C标准库提供了两个函数来帮助创建临时文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span>* ptr)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向唯一路径名的指针</span><br><span class="line"></span><br><span class="line"><span class="function">FILE* <span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回文件指针；若出错，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>tmpnam函数产生一个与现有文件名不通的有效路径名字符串，最多调动TMP_MAX次。若ptr是NULL，则所产生的路径名存放在静态存储区中，指向该静态区的指针作为返回值返回。若ptr不为空，则长度至少为L_tmpnam，并返回ptr</p><p>tmpfile创建一个临时二进制文件（wb+），在关闭该文件或程序结束时将自动删除这中文件。其原理一般是调用tmpnam函数产生一个唯一路径名，然后用该路径名创建一个文件，并立即unlink它</p><p>另外mkdtemp和mkstemp也可以创建临时目录或文件。</p><p>一般应使用mkstemp（文件不会自动删除）和tmpfile，因为使用tmpnam和tempnam至少有一个缺点：因为在调用其获取唯一文件名和创建文件之间，可能有其他进程使用相同名字创建文件，而mkstemp和tmpfile不存在这个问题</p><h2 id="内存流"><a href="#内存流" class="headerlink" title="内存流"></a>内存流</h2><p>内存流一般不会用到，不做介绍</p><h2 id="标准IO库的替代软件"><a href="#标准IO库的替代软件" class="headerlink" title="标准IO库的替代软件"></a>标准IO库的替代软件</h2><p>标准IO库有一些缺点。效率不高，通常需要复制两次数据：内核到标准IO库缓冲区、标准IO库缓冲区到用户程序缓冲区。</p><p>mmap函数也可以用来读写文件</p><h1 id="第六章-系统数据文件和信息"><a href="#第六章-系统数据文件和信息" class="headerlink" title="第六章 系统数据文件和信息"></a>第六章 系统数据文件和信息</h1><p>UNIX系统有很多与系统有关的数据文件，由于历史原因这些数据文件都是ASCII文本文件，本章简单介绍这些文件。除此之外还介绍系统标识函数、时间和日期函数</p><h2 id="口令文件"><a href="#口令文件" class="headerlink" title="口令文件"></a>口令文件</h2><p>UNIX系统口令文件包含如下字段，其定义在&lt;pwd.h&gt;中的passwd结构中</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/passwd文件中的字段.png" alt="passwd文件中的字段" title>                </div>                <div class="image-caption">passwd文件中的字段</div>            </figure><p>可以通过getpwuid和getpwunam获取uid或name，同时也提供了函数来读取/etc/passwd文件，具体可查看文档</p><p>目前，加密口令一般存放在阴影口令文件中，一般为/etc/shadow，可以通过函数来读取加密口令</p><p>组文件一般为/etc/group。UNXI系统一般支持附属组，一个用户可以加入多个附属组中，用户附属组可以通过函数获取</p><h2 id="登录账户记录"><a href="#登录账户记录" class="headerlink" title="登录账户记录"></a>登录账户记录</h2><p>大多数UNIX会提供utmp——记录当前登录到系统的各个用户，wtmp——跟踪各个登录和注销事件，其一般为二进制文件，存放相应的结构体</p><h2 id="系统标识"><a href="#系统标识" class="headerlink" title="系统标识"></a>系统标识</h2><p>可以通过uname获取系统标识，一般包括如下字段</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utsname</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> sysname[];  <span class="comment">// name of the operating system</span></span><br><span class="line">  <span class="keyword">char</span> nodename[];  <span class="comment">// name of the node</span></span><br><span class="line">  <span class="keyword">char</span> release[];  <span class="comment">// current release of operating system</span></span><br><span class="line">  <span class="keyword">char</span> version[];  <span class="comment">// current version of release</span></span><br><span class="line">  <span class="keyword">char</span> machine[];  <span class="comment">// name of hardware type</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>历史上，BSD派生的系统提供gethostname函数，它只返回主机名，改名字通常就是TCP/IP网络上主机的名字</p><h2 id="时间和日期例程"><a href="#时间和日期例程" class="headerlink" title="时间和日期例程"></a>时间和日期例程</h2><p>time函数返回自协调世界时公元1970年1月1日 00:00:00这一特定时间以来经过的秒数</p><p>clock_gettime函数可用于获取指定时钟时间，clock_getres用于获取指定时钟精度，clock_settime对特定的时钟设置时间</p><p>gettimeofday可以获取微秒级的时间</p><p>其余函数可以将秒数转换为tm结构体，如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tm</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> tm_sec;                   <span class="comment">/* Seconds.     [0-60] (1 leap second) */</span></span><br><span class="line">  <span class="keyword">int</span> tm_min;                   <span class="comment">/* Minutes.     [0-59] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_hour;                  <span class="comment">/* Hours.       [0-23] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mday;                  <span class="comment">/* Day.         [1-31] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_mon;                   <span class="comment">/* Month.       [0-11] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_year;                  <span class="comment">/* Year - 1900.  */</span></span><br><span class="line">  <span class="keyword">int</span> tm_wday;                  <span class="comment">/* Day of week. [0-6] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_yday;                  <span class="comment">/* Days in year.[0-365] */</span></span><br><span class="line">  <span class="keyword">int</span> tm_isdst;                 <span class="comment">/* DST.         [-1/0/1]*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/时间函数之间的关系.png" alt="时间函数之间的关系" title>                </div>                <div class="image-caption">时间函数之间的关系</div>            </figure><h1 id="第七章-进程环境"><a href="#第七章-进程环境" class="headerlink" title="第七章 进程环境"></a>第七章 进程环境</h1><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>C程序总是从main函数开始执行，其原型如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// argc为命令行参数的个数</span></span><br><span class="line"><span class="comment">// argv是指向参数的各个指针构成的数组</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>;</span><br></pre></td></tr></table></figure><p>内核（使用exec函数，后续将会介绍）执行C程序时，在调用main函数前会先调用一个特殊的启动例程。可执行程序文件将此启动例程指定为程序的起始地——这是由链接编辑器指定的，而链接编辑器由C编译器调用。启动例程从内核取得命令行参数和环境变量值，然后为按照上述方式调用main函数做好准备</p><h2 id="进程终止"><a href="#进程终止" class="headerlink" title="进程终止"></a>进程终止</h2><p>有八种方式终止进程（termination），前5种为正常终止，后3种为异常终止</p><ul><li>从main函数返回</li><li>调用exit</li><li>调用_exit或_Exit</li><li>最后一个线程从启动例程返回</li><li>从最后一个线程调用pthread_exit</li><li>调用abort</li><li>接到一个信号</li><li>最后一个线程对取消请求做出响应</li></ul><p>启动例程一般是从main函数返回后立即调用main函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语义为如下C语言调用，但启动例程一般用汇编语言编写</span></span><br><span class="line"><span class="built_in">exit</span>(main(argc, argv));</span><br></pre></td></tr></table></figure><h3 id="退出函数"><a href="#退出函数" class="headerlink" title="退出函数"></a>退出函数</h3><p>_exit和_Exit立即进入内核，exit则先执行一些清理，然后返回内核</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure><p>exit函数总是执行一个标准IO库的相关清理工作：对于所有打开流调用fclose函数</p><p>3个函数都带一个整型参数，称为终止状态（exit status）。大多数UNIX系统shell都提供检查进程终止状态的方法（echo $?）</p><p>main函数推荐声明为int，并且需要返回整型值，否则，可能终止状态是未定义的</p><p>main函数返回一个整型值与用该值调用exit是等价的，即exit(0)等价于return 0</p><h3 id="函数atexit"><a href="#函数atexit" class="headerlink" title="函数atexit"></a>函数atexit</h3><p>ISO C规定一个进程可以登记多至32个函数，这些函数将由exit自动调用，这些函数称为终止处理程序（exit handler），使用atexit来登记这些函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*func)(<span class="keyword">void</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>其参数是一个函数地址，其无参数也无返回值。exit调用这些函数的顺序与它们登记时候的顺序相反。同一函数若登记多次也会被调用多次</p><p>exit首先调用各种终止处理程序，然后关闭所有打开的流。若程序调用exec函数族的任一函数，则将清除所有已安装的终止处理程序</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/程序的启动和终止.png" alt="程序的启动和终止" title>                </div>                <div class="image-caption">程序的启动和终止</div>            </figure><p>内核使程序执行的唯一方法是调用一个exec函数。进程自愿终止的唯一方法是显式或隐式的（通过调用exit）调用_exit或_Exit。进程也可非自愿的由一个信号使其终止</p><h2 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h2><p>执行一个程序时，调用exec的进程可以将命令行参数传递给该新程序。这是UNIX shell的一部分常规操作。参数<code>argv[argc]</code>被要求为NULL</p><h2 id="环境表"><a href="#环境表" class="headerlink" title="环境表"></a>环境表</h2><p>每个程序都接收到一张环境表，与参数一样环境表也是一个字符串指针数组，其中每个指针包含一个以null字节结尾的C字符串地址。全局变量environ包含了该指针数组的地址</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>** environ;</span><br></pre></td></tr></table></figure><p>environ称为环境指针（environment pointer），指针数组称为环境表，各指针指向的字符串称为环境字符串</p><p>环境字符串的格式为</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name=value</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/环境指针.png" alt="环境指针" title>                </div>                <div class="image-caption">环境指针</div>            </figure><p>大多数环境预定义名全部由大写字母组成，这只是一个惯例。历史上UNIX系统支持main函数带3个参数，第三个参数是环境表指针。但通常我们应使用environ全局变量，而不是使用第3个参数。更好的方法是getenv和putenv函数，但如果要查看整个环境，则必须访问environ全局变量</p><h2 id="C程序的存储空间布局"><a href="#C程序的存储空间布局" class="headerlink" title="C程序的存储空间布局"></a>C程序的存储空间布局</h2><p>历史沿袭至今，C程序一直由以下部分组成</p><ul><li>正文段。这是由CPU执行的机器指令部分。通常正文段是共享的和只读的（防止程序由于意外而修改其指令）</li><li>初始化数据段。通常将此段称为数据段，它包含了程序中需明确的赋初值的变量（已初始化的全局变量和静态变量）。如C程序中任何函数外的声明int maxcount = 99;则此变量和初值存放在初始化数据段中</li><li>未初始化数据段。通常将此段称为bss段，在程序开始执行之前，内核将此段中的数据初始化为0或空指针。包含未初始化的全局变量和静态变量</li><li>栈。自动变量以及每次函数调用时所需保存的信息都存放在此段中。每次函数调用时，其返回地址以及调用者的环境信息都存放在栈中。然后最近被调用的函数在栈上为其自动变量和临时变量分配空间。通过此方式使用栈，C递归函数可以工作。一次函数的调用产生一个新的栈帧，因此一次函数的调用不会影响另一次函数调用实例中的变量</li><li>堆。通常在堆中进行动态内存分配。由于历史上形成的惯例，堆位于未初始化段和栈之间</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/典型的存储空间安排.png" alt="典型的存储空间安排" title>                </div>                <div class="image-caption">典型的存储空间安排</div>            </figure><p>程序中还有其他的段，如包含符号表的段、包含调试信息的段，包含动态共享库链接表的段，这些部分并不装载到进程执行的程序映像中</p><p>未初始化段的内容并不存放在磁盘程序文件中，其原因是内核在程序开始运行前都将它们设置为0，需要存放在磁盘文件中的段只有正文段和初始化数据段</p><p>size(1)命令可以报告正文段、数据段和bss段的以字节为单位的长度</p><h2 id="共享库"><a href="#共享库" class="headerlink" title="共享库"></a>共享库</h2><p>共享库使得可执行文件不再需要包含共用的函数库，而只需要在所有进程都可引用的存储区保存这种库例程的一个副本。</p><p>程序第一次执行或者第一次调用某个函数库时，用动态链接方法将程序与共享库函数相链接。这减少了每个可执行文件的长度，但增加了一些运行时间开销。这种时间开销发生在该程序第一次被执行时，或者每个共享库函数第一次被调用时。</p><p>共享库的另一个优点是可以用库函数的新版本代替老版本而无需对使用该库的程序重新链接编辑（假定参数的数目和类型都没有发生改变）。</p><p>gcc可使用-static阻止使用共享库</p><h2 id="存储空间分配"><a href="#存储空间分配" class="headerlink" title="存储空间分配"></a>存储空间分配</h2><p>ISO C说明了3个可用于存储空间动态分配的函数</p><ul><li>malloc，分配指定字节数的存储区。此存储区中的初始值不确定</li><li>calloc，为指定数量指定长度的对象分配存储空间。该空间中的每一个bit都初始化为0</li><li>realloc，增加或减少以前分配区的长度。当增加长度时，可能需要将以前分配区的内容移动到另一个足够大的区域，以便在尾端提供增加的存储区，而新增加区域内的初始值则不确定</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nobj, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">recalloc</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> newsize)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回非空指针；若出错，返回<span class="literal">NULL</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span>* ptr)</span></span>;</span><br></pre></td></tr></table></figure><p>这3个分配函数所返回的指针一定是适当对齐的，使其可用于任何数据对象</p><p>realloc的最后一个参数是存储区的新长度，不是新旧存储区长度之差。作为一个特例，如果ptr是一个空指针，则realloc的功能与malloc相同，用于分配一个指定长度为newsize的存储区</p><p>这些分配例程通常用sbrk(2)系统调用实现，该系统调用扩充或缩小进程的堆。虽然sbrk可以扩充或缩小进程的存储空间，但是大多数malloc和free实现都不减少进程的存储空间。释放的空间可供以后再分配，但将它们保持在malloc池中而不返回给内核</p><p>大多数实现所分配的存储空间比所要求的的要稍大一些，额外的空间用来记录管理信息——分配块的长度、指向下一个分配块的指针等。这就意味着，如果超过一个已分配区的尾端或者在已分配区的起始位置之前进行写操作，则会改写另一块的管理记录信息。这种类型的错误是灾难性的，但是这种错误不会很快暴露出来，所以也就很难发现</p><p>常见的错误是：释放一个已经释放的块；调用free时所用的指针不是3个alloc函数返回的指针</p><p>常见的代替分配方法为jemalloc和tcmalloc</p><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><p>UNIX内核并不查看环境变量字符串，它们的解释完全取决于各个应用程序。</p><p>getenv可以取环境变量值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>;</span><br><span class="line"></span><br><span class="line">返回指向与name关联的value的指针；若未找到，返回<span class="literal">NULL</span></span><br></pre></td></tr></table></figure><p>此函数返回一个指针，它指向<code>name=value</code>字符串中的value</p><p>我们也希望可以改变现有变量的值，或者是增加新的环境变量。我们能影响的只是当前进程及其后生成和调用的任何子进程的环境，但不能影响父进程的环境，这通常是一个shell进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span>* str)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* value, <span class="keyword">int</span> rewrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回<span class="number">-1</span></span><br></pre></td></tr></table></figure><ul><li>putenv取形式为<code>name=value</code>的字符串，将其放到环境表中，如果name已经存在，则先删除原来的定义。其参数str指针直接放到环境变量中</li><li>setenv将name设置为value。若环境中name已经存在，那么a）若rewrite非0，则首先删除其现有定义；b)若rewrite为0，则不删除其现有定义（name不设置为新的value，而且也不出错）。与putenv不同setenv必须分配存储空间</li><li>unsetenv删除name的定义，即使不存在这种定义也不算出错</li></ul><h2 id="函数setjmp和longjmp"><a href="#函数setjmp和longjmp" class="headerlink" title="函数setjmp和longjmp"></a>函数setjmp和longjmp</h2><p>在C中，goto语句是不能跨越函数的，而执行这种类型跳转功能的函数是setjmp和longjmp。这两个函数对于处理发生在很深层嵌套函数调用中的出错情况是非常有用的</p><p>如果对嵌套层次很深的错误进行判断，逐层返回，会比较麻烦。可以使用setjmp和longjmp来实现非局部跳转。其不是由普通C语言goto语句在一个函数内实施的跳转，而是在栈上跳过若干调用帧，返回到当前函数调用路径上的某一个函数中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"></span><br><span class="line">若直接调用，返回<span class="number">0</span>；若从longjmp返回，则为非<span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><p>在希望返回到的位置调用setjmp。jmp_buf是某种形式的数组，其中存放在调用longjmp时能用来恢复栈状态的所有信息。</p><p>longjmp参数val将成为setjmp处返回的值，因为一个setjmp可以有多处longjmp，通过val值就可以进行区分</p><p>当longjmp发生跳转时，自动变量和寄存器变量的值会如何变化，这是不确定的，大多数实现并不回滚这些自动变量和寄存器变量的值，而所有的标准则称它们的值是不确定的。如果你有一个自动变量，而又不想使其回滚，则可以定义其为volatile属性。声明为全局变量、静态变量的值在执行longjmp时保持不变。</p><h2 id="函数getrlimit和setrlimit"><a href="#函数getrlimit和setrlimit" class="headerlink" title="函数getrlimit和setrlimit"></a>函数getrlimit和setrlimit</h2><p>每个进程都有一组资源限制，其中一些是可以用getrlimit和setrlimit函数查询和更改</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys//resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit* rlptr)</span></span>;</span><br><span class="line"></span><br><span class="line">若成功，返回<span class="number">0</span>；若出错，返回非<span class="number">0</span></span><br></pre></td></tr></table></figure><p>这两个函数的每一次调用都指定一个资源以及一个指向下列结构的指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_cur;  <span class="comment">// soft limit: current limit</span></span><br><span class="line">  <span class="keyword">rlim_t</span> rlim_max;  <span class="comment">// hard limit: maximum value for rlim_cur</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>更改资源时，需要遵循下列规则</p><ul><li>任何一个进程都可以将一个软限制更改为小于或等于其硬限制值</li><li>任何一个进程都可以降低其硬限制值，但它必须大于或等于其软限制值。这种降低，对普通用户而言是不可逆的</li><li>只有超级用户进程才可以提高硬限制值</li></ul><p>常量RLIM_INFINITY指定一个无限量的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/对资源限制的支持.png" alt="对资源限制的支持" title>                </div>                <div class="image-caption">对资源限制的支持</div>            </figure><p>资源限制影响到调用进程并由其子进程继承。shell具有内置ulimit命令，用于修改限制值</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第五章-标准IO库&quot;&gt;&lt;a href=&quot;#第五章-标准IO库&quot; class=&quot;headerlink&quot; title=&quot;第五章 标准IO库&quot;&gt;&lt;/a&gt;第五章 标准IO库&lt;/h1&gt;&lt;p&gt;标准IO库是ISO C的标准，不仅仅UNIX系统提供了，很多其他操作系统也都实现了标
      
    
    </summary>
    
    
      <category term="unix" scheme="https://gwq5210.com/tags/unix/"/>
    
      <category term="linux" scheme="https://gwq5210.com/tags/linux/"/>
    
      <category term="读书笔记" scheme="https://gwq5210.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
      <category term="APUE" scheme="https://gwq5210.com/tags/APUE/"/>
    
  </entry>
  
  <entry>
    <title>STL之string</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E4%B9%8Bstring/"/>
    <id>https://gwq5210.com/2021/11/14/STL之string/</id>
    <published>2021-11-14T20:20:57.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="string概述"><a href="#string概述" class="headerlink" title="string概述"></a>string概述</h1><p>string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常使用string，否则就使用vector</p><p>string和vector自动管理动态数组，并自动扩充数组的大小，析构时自动释放内存</p><p>string提供了字符串查找，替换等成员函数，方便使用</p><h1 id="string实现"><a href="#string实现" class="headerlink" title="string实现"></a>string实现</h1><p>string在编程中十分常见，了解字符串的实现很有帮助</p><p>为了提高string的性能，一般有三种方式来实现string，有时会对这几种方法相结合</p><ul><li>eager copy，即每次都执行深拷贝</li><li>SSO，即Small String Optimization，较小的字符串在栈中分配内存</li><li>COW，即Copy On Write，写时复制</li></ul><h2 id="string的结构"><a href="#string的结构" class="headerlink" title="string的结构"></a>string的结构</h2><p>介绍三种实现前，先大致介绍下string的结构</p><p>如果按照我们自己的设计，字符串必定包含以下三个数据成员：字符串长度，字符串的容量和字符数组指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StringStorage</span> &#123;</span></span><br><span class="line">  size_type size;</span><br><span class="line">  size_type capacity;</span><br><span class="line">  pointer data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="eager-copy"><a href="#eager-copy" class="headerlink" title="eager copy"></a>eager copy</h2><p>直接深拷贝的方式很容易理解，因为string中保存的是指向堆内存的指针，在复制时，需要执行以下步骤执行深拷贝</p><ul><li>分配新的内存</li><li>将字符串的内容复制到新内存</li><li>设置字符串大小和容量</li></ul><p>这种字符串的实现方式，相对简单，比较容易理解，但带来的问题是每次复制都需要分配内存和执行复制的操作，当字符串很大时，会带来性能的问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">StringStorage <span class="title">AllocateMediumStorage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = kMaxMediumSize;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(Allocate(kMaxMediumSize + <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitMedium</span><span class="params">(const_pointer str, <span class="keyword">size_t</span> len)</span> </span>&#123;</span><br><span class="line">  assert(len &lt;= kMaxMediumSize);</span><br><span class="line">  store_ = AllocateMediumStorage();</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kMedium;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SSO"><a href="#SSO" class="headerlink" title="SSO"></a>SSO</h2><p>短字符串优化是一个很巧妙的优化方法，利用string本身结构的buffer来存储较小的字符串</p><p>上边给出的例子中，至少需要三个变量，因此string的结构本身需要24个字节</p><p>当字符串较小时，如果仍在堆上分配内存，但size和capacity本身的值则很小，高位bit都是0，浪费了许多空间</p><p>因此在SSO的实现，只用一个字节表示字符串大小，容量大小是固定的，不需要存储，则可以有24-1=23个字节存储字符串，除去尾部的’\0’，则实际的容量为22，这便是llvm/clang/libc++采用的实现</p><p>SSO的字符串，复制时只需简单的复制SmallString结构即可，无需在堆上分配内存</p><p>另外，他们的实现，会结合SSO、COW和eager copy的实现，因此需要标记字符串的类型，它用一个bit来区分是长字符还是短字符，然后用位操作和掩码 (mask) 来取重叠部分的数据，因此实现是最复杂的。</p><p>本文的实现，为了简单，使用一个字节来区分字符串类型</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SmallString</span> &#123;</span></span><br><span class="line">  SmallString() &#123; Init(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">    data[size] = <span class="string">'\0'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">(const_pointer str, size_type len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str) &#123;</span><br><span class="line">      assert(len &lt;= kMaxSmallSize);</span><br><span class="line">      size = len;</span><br><span class="line">      <span class="built_in">memcpy</span>(data, str, <span class="keyword">sizeof</span>(value_type) * len);</span><br><span class="line">      data[len] = <span class="string">'\0'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Init();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">uint8_t</span> size;</span><br><span class="line">  value_type data[kMaxSmallSize + <span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/sso_string.png" alt="sso_string" title>                </div>                <div class="image-caption">sso_string</div>            </figure><h2 id="COW"><a href="#COW" class="headerlink" title="COW"></a>COW</h2><p>写时复制（Copy-on-write，简称COW）是一种很重要的优化手段。核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享资源，当需要修改时，才真正进行资源的分配</p><p>Linux内核在进程fork时对进程地址空间的处理就使用到了COW技术</p><h3 id="COW优点"><a href="#COW优点" class="headerlink" title="COW优点"></a>COW优点</h3><ul><li>减少了分配（和复制）大量资源带来的瞬间延迟（实际上该延迟被分摊到后续的操作中，其累积耗时很可能比一次统一处理的延迟要高，造成throughput下降是有可能的）</li><li>减少了不必要的资源分配。（例如只读的复制没有必要执行深拷贝）</li></ul><p>当然COW不是没有缺点，下文会进行介绍</p><h3 id="COW实现"><a href="#COW实现" class="headerlink" title="COW实现"></a>COW实现</h3><p>基于COW的思想，我们知道，在string复制时，只进行浅拷贝，而在需要修改对象时，则执行深拷贝的动作。</p><p>我们要在什么时候需要执行深拷贝？</p><ul><li>当前字符串没有被共享，则不需要拷贝</li><li>当前字符串被共享，当需要修改时，进行深拷贝的动作</li></ul><p>因此，为了区分是否被共享，我们引入一个引用计数来记录字符串被多少个string共享</p><p>引用计数一般是原子操作，保证线程安全，下文会详细介绍；引用计数需要在堆上分配，保证不同的string对象能够共享</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LargeString</span> &#123;</span></span><br><span class="line">  LargeString() : ref_count(<span class="number">1</span>) &#123; data[<span class="number">0</span>] = <span class="string">'\0'</span>; &#125;</span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;size_type&gt; ref_count;</span><br><span class="line">  value_type data[];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">StringStorage <span class="title">AllocateLargeStorage</span><span class="params">(size_type capacity)</span> </span>&#123;</span><br><span class="line">  assert(capacity &gt; kMaxMediumSize);</span><br><span class="line">  StringStorage store;</span><br><span class="line">  store.size = <span class="number">0</span>;</span><br><span class="line">  store.capacity = capacity;</span><br><span class="line">  store.data = <span class="keyword">static_cast</span>&lt;pointer&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span> *&gt;(Allocate(LargeString::GetDataOffset() + capacity + <span class="number">1</span>)) + LargeString::GetDataOffset());</span><br><span class="line">  LargeString::ConstrctAt(store);</span><br><span class="line">  <span class="keyword">return</span> store;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnsafeInitLarge</span><span class="params">(const_pointer str, size_type len, size_type c = <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">  store_ = AllocateLargeStorage(c &gt; <span class="number">0</span> ? c : len);</span><br><span class="line">  store_.UnsafeCopyFrom(str, len);</span><br><span class="line">  type_ = StringType::kLarge;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">pointer <span class="title">MutableData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 引用计数大于1，则执行深拷贝</span></span><br><span class="line">  <span class="keyword">if</span> (type_ == StringType::kLarge &amp;&amp; LargeString::RefCount(store_) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    LargeString::DecRefCount(store_);</span><br><span class="line">    UnsafeInitLarge(store_.data, store_.size);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> store_.data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="COW在多线程中的问题"><a href="#COW在多线程中的问题" class="headerlink" title="COW在多线程中的问题"></a>COW在多线程中的问题</h1><p>像STL的其他容器一样，多线程操作共享的string不是线程安全的。但不同的线程操作不同的字符串是线程安全的。</p><p>聪明的同学立马会想到，在COW的string实现中，不同的string对象，可能共享同一块内存，那不同线程同时修改COW实现的string时，怎么保证线程安全呢？</p><p>这就要求COW的string必须能够正确的处理这种竞争条件：</p><ul><li>对引用计数进行原子操作</li><li>需要修改时，先分配和复制，再将引用计数减1（当引用计数为0时，负责释放内存）</li></ul><h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>比起mutex之类的同步手段，原子操作自然要轻上不少，但比起普通的算术指令，依然算得上完全的重量级</p><p>COW为了保证“线程安全”而使用了原子操作，而原子操作本身的效率并不十分高。而且在多线程环境下，多个CPU对同一个地址的原子操作开销更大。COW中”共享“的实现，反而影响了多线程环境下string”拷贝“的性能。</p><h2 id="操作顺序"><a href="#操作顺序" class="headerlink" title="操作顺序"></a>操作顺序</h2><p>COW中，需要修改时，先分配和复制，再将引用计数减1，这在多线程操作中，会导致不必要的分配和复制</p><p>两个线程同时操作两个string，这两个string共享同一片内存（即引用计数为2），当两个线程都需要对string修改时，他们都需要先分配和复制，再将引用计数减1（最终会有一个线程释放内存）</p><p>这时，COW一共进行了3次内存分配和复制（初始化时1次，修改时2次）和1次内存释放</p><p>但如果没有使用COW技术，从string的初始化到目前为止也只进行了2次内存分配和复制（都是在初始化时进行）</p><h1 id="COW的失效问题"><a href="#COW的失效问题" class="headerlink" title="COW的失效问题"></a>COW的失效问题</h1><p>这个问题其实是字符串接口导致的问题，string类提供了data、operator[]等接口，可以直接修改字符串本身，但由于他们返回的是指针和引用，只读操作也会导致分配和复制</p><p>这可能导致COW不能完全发挥作用，每次都是在深拷贝。</p><p>这当然可以通过重新设计接口，严格区分只读和修改造作来解决。但维护非标准接口，并非是一个简单的工作</p><h2 id="代理类区分读写操作"><a href="#代理类区分读写操作" class="headerlink" title="代理类区分读写操作"></a>代理类区分读写操作</h2><p>区分读写的另一种方式是，定义CharProxy类，operator[]返回CharProxy，在对CharProxy赋值时，才执行分配和复制</p><p>但这也会增加编码的复杂度</p><h1 id="fbstring"><a href="#fbstring" class="headerlink" title="fbstring"></a>fbstring</h1><p>Fackbook的开源库folly中提供了fbstring，它是std::string的替代。其对string类的设计进行了许多优化</p><ul><li>将字符串区分为small/medium/large，针对他们分别采用SSO、eager copy和COW的策略（使用capacity最高位的4个bits来判断string的种类）<ul><li>small：结构体长度为24字节，减去末尾的1字节（用来表示长度）和为结束符’\0’（data()和c_str()方法的需要）预留的1字节，可以放置22字节的有效长度</li><li>medium：不超过255字节</li><li>large：超过255字节</li></ul></li><li>word-wise copy（逐字拷贝）</li><li>直接使用malloc/free，并在使用jemalloc时，使用非标准扩展接口来提高性能</li><li>末尾’\0’的处理：平时预留空间，在调用data或c_str时，才添加’\0’，避免了每次修改字符串时的额外开销</li><li>find使用BM算法</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://book.douban.com/subject/1792179/" target="_blank" rel="noopener">Effective STL中文版</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/03/22/2412686.html" target="_blank" rel="noopener">std::string的Copy-on-Write：不如想象中美好</a></li><li><a href="https://www.cnblogs.com/promise6522/archive/2012/06/05/2535530.html" target="_blank" rel="noopener">漫步Facebook开源C++库folly：string类的设计</a></li><li><a href="https://www.cnblogs.com/cthon/p/9181979.html" target="_blank" rel="noopener">c++再探string之eager-copy、COW和SSO方案</a></li><li><a href="https://github.com/facebook/folly" target="_blank" rel="noopener">folly</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;string概述&quot;&gt;&lt;a href=&quot;#string概述&quot; class=&quot;headerlink&quot; title=&quot;string概述&quot;&gt;&lt;/a&gt;string概述&lt;/h1&gt;&lt;p&gt;string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="字符串" scheme="https://gwq5210.com/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>智能指针</title>
    <link href="https://gwq5210.com/2021/11/14/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    <id>https://gwq5210.com/2021/11/14/智能指针/</id>
    <published>2021-11-14T20:18:54.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="RAII"><a href="#RAII" class="headerlink" title="RAII"></a>RAII</h1><p>了解智能指针前，我们先了解下C++编程中常用的RAII的思想</p><p>RAII全称为Resource Acquisition is Initialization，直译就是资源获取即初始化。</p><p>它的思想是将必须在使用前获取的资源（堆内存，线程，文件，互斥锁等）与一个对象的声明周期绑定，常用做法是在构造函数中请求资源，在析构函数中释放资源</p><p>以上由C++的语言机制保证，当对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数</p><p>智能指针就是使用RAII思想的例子</p><h1 id="智能指针概述"><a href="#智能指针概述" class="headerlink" title="智能指针概述"></a>智能指针概述</h1><p>智能指针本质是模板类独享，其行为类似指针。其最主要的功能是帮助管理动态内存，防止发生内存泄漏</p><p>C++提供了四种智能指针</p><ul><li>auto_ptr(C++11废弃，C++17移除)</li><li>unique_ptr(C++11)：独占智能指针</li><li>shared_ptr(C++11)：引用计数智能指针</li><li>weak_ptr(C++11)：弱引用智能指针，解决shared_ptr的循环引用，不能访问直接访问对象</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="comment">// p析构时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto_ptr是C++98提供的，现已废弃，应使用unique_ptr或shared_ptr替代</p><p>考虑如下情况，将p赋值给p2会发生什么？</p><p>按照常规指针的做法，p2和p会指向同一个对象，但是如果这样，p2和p在析构时会释放两次内存，这当然是不可行的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">  p2 = p; <span class="comment">// 会发生什么</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对以上问题，有如下解决方案</p><ul><li>执行深拷贝，但这会造成两个指针指向不同对象</li><li>建立所有权（ownership）的概念，仅可以让一个智能指针拥有该对象，该智能指针析构时执行内存释放操作。赋值操作将所有权转移。<ul><li>auto_ptr和unique_ptr都采用此策略，unique_ptr的策略更加严格</li></ul></li><li>使用引用计数，记录有多少个智能指针指向该对象，当引用计数变为0时，执行内存释放操作<ul><li>shared_ptr采用此策略</li></ul></li></ul><h1 id="auto-ptr使用"><a href="#auto-ptr使用" class="headerlink" title="auto_ptr使用"></a>auto_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>auto_ptr对象的复制构造和赋值会转移所有权</li><li>作为参数不要按值传递</li><li>auto_ptr不支持数组</li><li>无法作为STL容器的元素，auto_ptr的复制构造和赋值要求参数左值引用</li><li>仅支持new分配的内存</li></ul><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">double</span>(<span class="number">10.0</span>))</span></span>;</span><br><span class="line"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p2;</span><br><span class="line">p2 = p; <span class="comment">// p的所有权被转移给p2，p不再有效</span></span><br><span class="line">*p = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 按值传递，调用时会将所有权转移给临时对象p3，函数结束时将内存释放</span></span><br><span class="line"><span class="comment">// 这里应采用按引用传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="built_in">auto_ptr</span>&lt;<span class="keyword">double</span>&gt; p3)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%.2f\n"</span>, *p3);</span><br><span class="line">&#125;</span><br><span class="line">test(p2);</span><br><span class="line">*p2 = <span class="number">10.0</span>; <span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line">auto_ptr&lt;double[]&gt; pa(new double[100]()); // bad</span><br></pre></td></tr></table></figure><h2 id="auto-ptr实现"><a href="#auto-ptr实现" class="headerlink" title="auto_ptr实现"></a>auto_ptr实现</h2><ul><li>auto_ptr的复制构造函数和赋值运算符要求左值引用</li><li>需要考虑右值的构造和赋值，通过AutoPtrRef的方式实现</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">AutoPtrRef</span> &#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtrRef</span><span class="params">(T* p)</span> : <span class="title">ptr</span><span class="params">(p)</span> </span>&#123;&#125;</span><br><span class="line">  T* ptr;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AutoPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">AutoPtr</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  AutoPtr(AutoPtr&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  <span class="comment">// 为了实现右值的初始化</span></span><br><span class="line">  AutoPtr(AutoPtrRef&lt;element_type&gt; ref) : data_(ref.ptr) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr(AutoPtr&lt;Y&gt;&amp; other) : data_(other.release()) &#123;&#125;</span><br><span class="line">  ~AutoPtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtr&lt;Y&gt;&amp; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtr&lt;Y&gt;&amp; other)\n"</span>);</span><br><span class="line">    reset(other.release());</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  AutoPtr&amp; <span class="keyword">operator</span>=(AutoPtrRef&lt;Y&gt; other) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"calling AutoPtr::operator=(AutoPtrRef&lt;Y&gt; other)\n"</span>);</span><br><span class="line">    reset(other.ptr);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">element_type* <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  element_type* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtrRef&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtrRef&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  <span class="keyword">operator</span> AutoPtr&lt;Y&gt;() &#123;</span><br><span class="line">    <span class="keyword">return</span> AutoPtr&lt;Y&gt;(release());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(element_type* data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">element_type* <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    element_type* ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data_;</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  element_type* data_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr使用"><a href="#unique-ptr使用" class="headerlink" title="unique_ptr使用"></a>unique_ptr使用</h1><p>相比于auto_ptr，unique_ptr有如下优点</p><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>禁用拷贝构造函数和赋值运算符</li><li>使用移动语义std::move转移所有权</li><li>使用移动语义可以作为STL容器的元素，但某些需要拷贝和赋值的算法操作会受限</li><li>支持数组，并提供operator[]，使用delete[]释放内存</li><li>支持自定义deleter</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name = <span class="string">"student1"</span>;</span><br><span class="line">  <span class="keyword">double</span> score = <span class="number">100.0</span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Student&gt; <span class="title">p</span><span class="params">(gtl::make_unique&lt;Student&gt;(name, score))</span></span>;</span><br><span class="line">  <span class="keyword">auto</span>* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(name, p-&gt;name());</span><br><span class="line">  EXPECT_EQ(score, p-&gt;score());</span><br><span class="line">  <span class="function">gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; <span class="title">p2</span><span class="params">(<span class="built_in">std</span>::move(p))</span></span>;</span><br><span class="line">  EXPECT_EQ(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line">  p2 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">  EXPECT_EQ(p2.get(), p_bak);</span><br><span class="line">  EXPECT_EQ(name, p2-&gt;name());</span><br><span class="line"></span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person&gt; p3;</span><br><span class="line">  p3 = <span class="built_in">std</span>::move(p2);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 支持数组指针即使用new[]/delete[]</span></span><br><span class="line">  <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">  gtl::<span class="built_in">unique_ptr</span>&lt;Person[]&gt; p = gtl::make_unique&lt;Person[]&gt;(n);</span><br><span class="line">  Person* p_bak = p.get();</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line">  p = <span class="built_in">std</span>::move(p);</span><br><span class="line">  EXPECT_NE(p.get(), <span class="literal">nullptr</span>);</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(p), <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    p[i].set_name(<span class="built_in">std</span>::to_string(i));</span><br><span class="line">    EXPECT_EQ(<span class="built_in">std</span>::to_string(i), p[i].name());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="unique-ptr实现"><a href="#unique-ptr实现" class="headerlink" title="unique_ptr实现"></a>unique_ptr实现</h1><ul><li>unique_ptr存在针对对象和数组的两个版本<ul><li>分别使用new/delete和new[]/delete[]</li></ul></li><li>需要支持自定义deleter</li><li>禁用拷贝构造函数和赋值运算符</li><li>定义移动构造函数和移动复制运算符</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter = <span class="built_in">std</span>::default_delete&lt;T&gt;&gt;</span><br><span class="line">class UniquePtr &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  explicit UniquePtr(pointer data = nullptr, deleter_type deleter = deleter_type()) : data_(data), deleter_(deleter) &#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr(UniquePtr&lt;Y&gt;&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.get_deleter())) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> get(); &#125;</span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *get(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data != data_) &#123;</span><br><span class="line">      Destroy();</span><br><span class="line">      data_ = data;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Deleter&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UniquePtr</span>&lt;T[], Deleter&gt; &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> pointer = T*;</span><br><span class="line">  <span class="keyword">using</span> element_type = T;</span><br><span class="line">  <span class="keyword">using</span> deleter_type = Deleter;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">UniquePtr</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> : <span class="title">data_</span><span class="params">(data)</span> </span>&#123;&#125;</span><br><span class="line">  UniquePtr(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(<span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125;</span><br><span class="line">  ~UniquePtr() &#123; Destroy(); &#125;</span><br><span class="line"></span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> UniquePtr&amp; other) = <span class="keyword">delete</span>;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Y&gt;</span><br><span class="line">  UniquePtr&amp; <span class="keyword">operator</span>=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123;</span><br><span class="line">    reset(other.release());</span><br><span class="line">    deleter_ = <span class="built_in">std</span>::forward&lt;deleter_type&gt;(other.deleter_);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  element_type&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> index) <span class="keyword">const</span> &#123; <span class="keyword">return</span> data_[index]; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_ != <span class="literal">nullptr</span>; &#125;</span><br><span class="line">  <span class="function">deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> deleter_type&amp; <span class="title">get_deleter</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> deleter_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data_; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer data = <span class="literal">nullptr</span>)</span> </span>&#123;</span><br><span class="line">    Destroy();</span><br><span class="line">    data_ = data;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">pointer <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    pointer ret = data_;</span><br><span class="line">    data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(UniquePtr&amp; other)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::swap(data_, other.data_);</span><br><span class="line">    <span class="built_in">std</span>::swap(deleter_, other.deleter_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_) &#123;</span><br><span class="line">      deleter_(data_);</span><br><span class="line">      data_ = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  pointer data_;</span><br><span class="line">  deleter_type deleter_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr使用"><a href="#shared-ptr和weak-ptr使用" class="headerlink" title="shared_ptr和weak_ptr使用"></a>shared_ptr和weak_ptr使用</h1><ul><li>不要将同一个原生指针赋值给多个智能指针</li><li>shared_ptr是共享所有权的智能指针，使用上更像普通指针</li><li>支持数组（C++17）</li><li>注意循环引用——将任一shared_ptr替换为weak_ptr打破循环即可</li><li>weak_ptr无法访问其所管理的资源，其是为了解决循环引用的问题，weak_ptr不会增加引用计数<ul><li>weak_ptr可以通过expired函数判断对应的资源是否已经释放</li><li>访问所管理的对象必须通过lock函数返回一个shared_ptr对象（注意判断返回值是否为空，可能其所对应的资源已经释放）</li></ul></li><li>线程安全问题<ul><li>多个线程在不同shared_ptr的实例上调用所有成员函数（包含复制构造和赋值）是安全的，即使他们共享同一个对象的所有权</li><li>多个线程只读方式访问同一个shared_ptr的实例是安全的</li><li>多个线程访问同一个shared_ptr的实例的非const成员函数是不安全的，会出现数据竞争</li><li>所拥有资源的线程安全由资源本身决定</li></ul></li></ul><p>循环引用的例子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">double</span> score_;</span><br><span class="line">  SharedPtr&lt;Teacher&gt; teacher_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span> <span class="keyword">public</span> Person &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> id_;</span><br><span class="line">  SharedPtr&lt;Student&gt; student_;</span><br><span class="line">  WeakPtr&lt;Student&gt; student_weak_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// teacher包含student，student包含teacher，会造成循环引用</span></span><br><span class="line">  <span class="comment">// 析构时引用数都不会变为0，造成内存泄漏</span></span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">  <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">1</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">1</span>);</span><br><span class="line">  teacher-&gt;set_student(student);</span><br><span class="line">  student-&gt;set_teacher(teacher);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher-&gt;name().c_str(), teacher.use_count());</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student-&gt;name().c_str(), student.use_count());</span><br><span class="line">  EXPECT_EQ(teacher.use_count(), <span class="number">2</span>);</span><br><span class="line">  EXPECT_EQ(student.use_count(), <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  gtl::WeakPtr&lt;Student&gt; student_weak_bak;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Teacher&gt; <span class="title">teacher_weak</span><span class="params">(gtl::make_shared&lt;Teacher&gt;(<span class="string">"teacher_weak"</span>, <span class="number">10</span>))</span></span>;</span><br><span class="line">    <span class="function">gtl::<span class="built_in">shared_ptr</span>&lt;Student&gt; <span class="title">student_weak</span><span class="params">(gtl::make_shared&lt;Student&gt;(<span class="string">"student_weak"</span>, <span class="number">100.0</span>))</span></span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    teacher_weak-&gt;set_student_weak(student_weak);</span><br><span class="line">    student_weak-&gt;set_teacher(teacher_weak);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, teacher_weak-&gt;name().c_str(), teacher_weak.use_count());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s count %zu\n"</span>, student_weak-&gt;name().c_str(), student_weak.use_count());</span><br><span class="line">    EXPECT_EQ(teacher_weak.use_count(), <span class="number">2</span>);</span><br><span class="line">    EXPECT_EQ(student_weak.use_count(), <span class="number">1</span>);</span><br><span class="line">    student_weak_bak = student_weak;</span><br><span class="line">    EXPECT_EQ(student_weak_bak.use_count(), <span class="number">1</span>);</span><br><span class="line">    EXPECT_EQ(student_weak_bak.expired(), <span class="literal">false</span>);</span><br><span class="line">    EXPECT_EQ(<span class="keyword">bool</span>(student_weak_bak.lock()), <span class="literal">true</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, student_weak.get());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"weak test\n"</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.use_count(), <span class="number">0</span>);</span><br><span class="line">  EXPECT_EQ(student_weak_bak.expired(), <span class="literal">true</span>);</span><br><span class="line">  <span class="keyword">auto</span> stucent_shared_ptr = student_weak_bak.lock();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"student_weak ptr %p\n"</span>, stucent_shared_ptr.get());</span><br><span class="line">  EXPECT_EQ(<span class="keyword">bool</span>(stucent_shared_ptr), <span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shared-ptr和weak-ptr实现"><a href="#shared-ptr和weak-ptr实现" class="headerlink" title="shared_ptr和weak_ptr实现"></a>shared_ptr和weak_ptr实现</h1><ul><li>shared_ptr包含指向对象的指针和引用计数的指针<ul><li>包含对象指针是为了不同的对象共享所有权</li><li>包含引用计数的指针而不是对象，是为了共享所有权的shared_ptr得到的引用计数是相同的</li></ul></li><li>引用计数包含use_count和weak_count<ul><li>由于weak_ptr需要在所有的shared_ptr都释放时也能够判断引用计数的数量是否为0，因此shared_ptr释放时，如果weak_count&gt;1，则仅可以释放所管理对象的资源，引用计数的资源不能释放</li><li>当weak_ptr析构时，需要判断是否需要释放引用计数的资源</li></ul></li><li>shared_ptr的use_count和weak_count如何变化<ul><li>以空指针构造，两个指针都为空</li><li>以非空指针构造，use_count和weak_count都设置为1</li><li>复制构造，若非空则use_count加1</li><li>移动构造use_count不变，资源转移到新构造的shared_ptr，被移动的shared_ptr变为空</li><li>赋值操作，左侧操作数use_count减1，右侧操作数use_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数use_count减1，右侧操作数use_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>shared_ptr析构，use_count减1</li><li>use_count为0时，释放所管理对象的资源，weak_count减1（为0时释放引用计数的资源）</li></ul></li><li>weak_ptr的use_count和weak_count如何变化<ul><li>默认构造，weak_ptr不管理任何对象</li><li>weak_ptr不接受普通指针构造</li><li>复制构造，若非空则weak_count加1</li><li>以shared_ptr构造，若非空则weak_count加1</li><li>移动构造，weak_count不变，被移动weak_ptr变为空</li><li>赋值操作，左侧操作数weak_count减1，右侧操作数weak_count加1，并且赋值给左操作数，左右侧操作数指向同一对象</li><li>移动赋值，左侧操作数weak_count减1，右侧操作数weak_count不变，并且赋值给左操作数，右侧操作数变为空</li><li>weak_ptr析构，weak_count减1</li><li>weak_count为0时，释放引用计数的资源</li><li>调用lock函数构造shared_ptr，use_count加1</li></ul></li></ul><p>具体实现可参考<a href="https://github.com/gwq5210/gtl/blob/main/gtl/memory/smart_pointers.h" target="_blank" rel="noopener">smart_pointers.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RefCount</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; use_count; <span class="comment">// 有多少个shared_ptr指向这个对象</span></span><br><span class="line">  <span class="built_in">std</span>::atomic&lt;<span class="built_in">std</span>::<span class="keyword">size_t</span>&gt; weak_count; <span class="comment">// 有多少个weak_ptr指向这个对象</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SharedPtr</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"> <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  RefCount* ref_count_;</span><br><span class="line">  T* data_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/language/raii" target="_blank" rel="noopener">raii</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory" target="_blank" rel="noopener">memory</a></li><li><a href="https://item.jd.com/11017238.html" target="_blank" rel="noopener">C++ Primer Plus（第6版 中文版）</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;RAII&quot;&gt;&lt;a href=&quot;#RAII&quot; class=&quot;headerlink&quot; title=&quot;RAII&quot;&gt;&lt;/a&gt;RAII&lt;/h1&gt;&lt;p&gt;了解智能指针前，我们先了解下C++编程中常用的RAII的思想&lt;/p&gt;
&lt;p&gt;RAII全称为Resource Acquisit
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="智能指针" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    
      <category term="智能指针" scheme="https://gwq5210.com/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之无序关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之无序关联容器/</id>
    <published>2021-11-14T20:17:36.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><p>无序关联容器有以下几种</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><p>无序关联容器底层由哈希表实现，下文主要对哈希表进行介绍</p><h1 id="哈希表概述"><a href="#哈希表概述" class="headerlink" title="哈希表概述"></a>哈希表概述</h1><p>哈希表的基本原理是利用数组可以随机存取的特点，通过哈希函数（hasher）将键（key_type）均匀的映射到数组的下标，这样我们可以很快的通过数组下标快速找到对应的元素</p><p>数组中的每个元素称为桶（bucket）</p><p>这样会存在两个问题：</p><ul><li>不同的键映射到了相同的数组下标</li><li>数组大小是固定的，添加了更多元素之后，如何对数组进行扩容</li></ul><h2 id="解决哈希表碰撞"><a href="#解决哈希表碰撞" class="headerlink" title="解决哈希表碰撞"></a>解决哈希表碰撞</h2><p>不同的的元素被映射到相同的数组下标，被称为碰撞。解决碰撞有许多种方法</p><ul><li>开放定址法：哈希冲突时，从冲突的位置按照一定的次序寻找一个空闲的桶。删除元素时需要进行标记，否则会导致查找错误<ul><li>线性探测：依次判断位置为i+1,i+2,i+3,到达最后一个桶时从头开始判断</li><li>二次探测：依次判断位置为i+1^2,i+2^2,i+3^2</li></ul></li><li>链地址法：哈希冲突时，冲突的元素放在链表中。可以理解为数组的每个桶都是一个链表，只是大部分的链表仅包含一个元素</li></ul><p>大部分的实现采用链地址法处理冲突</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/hashtable.png" alt="hashtable" title>                </div>                <div class="image-caption">hashtable</div>            </figure><h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>在一般的实现中，哈希桶的数量为2的次幂，这样可以通过位运算得到元素哈希桶的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type bucket_idx = hasher()(key) % bucket_count();</span><br><span class="line">size_type bucket_idx = hasher()(key) &amp; (bucket_count() - <span class="number">1</span>); <span class="comment">// 当bucket_count为2的幂时</span></span><br></pre></td></tr></table></figure><h3 id="负载因子和初始容量"><a href="#负载因子和初始容量" class="headerlink" title="负载因子和初始容量"></a>负载因子和初始容量</h3><p>首先介绍一个负载因子（load factor）的概念：即元素个数除以桶个数。</p><p>哈希表一般通过负载因子来指定扩容的临界值。例如负载因子可以设置为0.75。当元素的数量超过bucket_count*load_factor时，会触发扩容操作</p><p>哈希表另一个比较重要的概念是初始容量，即初始哈希桶的数量，插入元素较多的情况下可以指定较大的初始容量减少扩容的次数。默认初始容量可以设置为16</p><h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p>哈希表的扩容也称为重新哈希（rehash），大致步骤如下</p><ul><li>以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组</li><li>遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中<ul><li>在同数量为2的次幂时，可以将桶中元素分为两部分，这两部分元素在新桶数组中的位置分别是：i和i+old_bucket_count（按照位运算很好理解）</li></ul></li><li>所有元素迁移完成之后，释放原桶数组</li></ul><p>以下例子是数组+单链表（下文介绍）的重新哈希的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_rehash</span><span class="params">(size_type new_bucket_count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 新分配桶数组</span></span><br><span class="line">  BucketStorage new_buckets = alloc_buckets(new_bucket_count);</span><br><span class="line">  SListNode old_head = head_;</span><br><span class="line">  buckets_.swap(new_buckets); <span class="comment">// 与旧桶数组交换</span></span><br><span class="line">  head_.next = <span class="literal">nullptr</span>;</span><br><span class="line">  get_size() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash new bucket count %zu %zu\n"</span>, bucket_count(), new_bucket_count);</span><br><span class="line">  SListNode* prev = &amp;old_head; <span class="comment">// 旧链表的伪头节点，便于实现</span></span><br><span class="line">  SListNode* first = prev-&gt;next;</span><br><span class="line">  <span class="comment">// 2. 遍历所有元素的链表</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    <span class="comment">// 计算链表头节点在新桶数组中的位置</span></span><br><span class="line">    <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(first));</span><br><span class="line">    size_type new_bucket_idx = bucket(key);</span><br><span class="line">    <span class="comment">// 找到相同key的元素</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, prev);</span><br><span class="line">    <span class="comment">// 将(range_res.first.before, range_res.first.node]这些元素从链表中移除</span></span><br><span class="line">    RemoveAfter(range_res.first.before, range_res.first.node);</span><br><span class="line">    <span class="comment">// 插入到新链表中并设置桶的所在元素的范围</span></span><br><span class="line">    insert_node(new_bucket_idx, buckets_[new_bucket_idx].node_before_begin ? buckets_[new_bucket_idx].node_before_begin : &amp;head_, first, range_res.first.node, range_res.second);</span><br><span class="line">    <span class="comment">// 旧链表的新头节点</span></span><br><span class="line">    first = prev-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash done. new bucket count %zu\n"</span>, bucket_count());</span><br><span class="line">  <span class="comment">// 3. 旧桶数组在作用域结束时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="哈希表的具体实现"><a href="#哈希表的具体实现" class="headerlink" title="哈希表的具体实现"></a>哈希表的具体实现</h1><p>哈希表一般有以下几种实现</p><ul><li>仅数组<ul><li>迭代元素需要遍历整个桶数组</li><li>元素迭代的顺序与插入顺序无关，与在桶中的位置有关</li><li>同一个桶内的元素以相反的顺序遍历（在头部插入）</li></ul></li><li>数组+单链表：所有的元素用单链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相反（找不到元素时在头部插入）</li><li>桶的结构中保存链表节点的指针或迭代器(before, node]</li><li>插入元素时如果更改了某个桶的尾元素node，则需要更新node-&gt;next元素所在桶的before指针</li><li>单链表包含一个伪头结点head_利于实现</li><li>swap时要更新链表头结点的before指针</li></ul></li><li>数组+双链表：所有的元素用双链表进行串联<ul><li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li><li>元素的迭代顺序与插入顺序相同（找不到元素时在尾部插入）</li><li>桶的结构中保存链表节点的指针或迭代器[begin, node]</li><li>实现相较数组+单链表简单</li></ul></li></ul><p>说明</p><ul><li>以上只说明大致思路，具体的实现可能略有不同</li><li>以上针对元素key唯一的情况，key相同的情况下，相同的key元素在链表中紧邻存放(相同key的元素的迭代顺序由实现决定，可以不做保证)</li><li>哈希表是无序的，不对key进行排序</li><li>哈希表重新哈希之后元素迭代顺序会发生变化</li><li>哈希表的实现中，会提供两个函数insert_unique和insert_equal分别来实现unordered_set/unordered_map和unordered_multiset/unordered_multimap（也可通过模板特化来针对唯一key或相同key实现不同的逻辑，提升性能）</li></ul><h2 id="数组-单链表的实现介绍"><a href="#数组-单链表的实现介绍" class="headerlink" title="数组+单链表的实现介绍"></a>数组+单链表的实现介绍</h2><h3 id="数据结构结构"><a href="#数据结构结构" class="headerlink" title="数据结构结构"></a>数据结构结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span> &#123;</span></span><br><span class="line">  SListNode* next;</span><br><span class="line">  SListNode() : next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">typename</span> KeyEquel = <span class="built_in">std</span>::equal_to&lt;Key&gt;&gt;</span><br><span class="line">class HashTable &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 哈希桶的结构，链表中范围(node_before_begin, node_finish]内的节点在该桶内</span></span><br><span class="line">  struct HashNode &#123;</span><br><span class="line">    HashNode(): node_before_begin(<span class="literal">nullptr</span>), node_finish(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    HashNode(SListNode* b, SListNode* f): node_before_begin(b), node_finish(f) &#123;&#125;</span><br><span class="line">    SListNode* node_before_begin;</span><br><span class="line">    SListNode* node_finish;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ExtractKey get_key_func_;</span><br><span class="line">  key_equal key_equal_;</span><br><span class="line">  hasher hasher_;</span><br><span class="line">  SListNode head_;</span><br><span class="line">  <span class="keyword">float</span> max_load_factor_;</span><br><span class="line">  BucketStorage buckets_;</span><br><span class="line">  CompressedPair&lt;size_type, NodeAllocator&gt; size_alloc_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* first, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将新的[first, last]内的元素插入到before节点后</span></span><br><span class="line">  InsertAfter(before, first, last);</span><br><span class="line">  <span class="comment">// 更新该桶内的元素范围</span></span><br><span class="line">  buckets_[bucket_idx].insert_node(before, first, last);</span><br><span class="line">  incr_size(count);</span><br><span class="line">  <span class="comment">// 更新下一个bucket的前一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; insert_node(bool unique, const_iterator hint, Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="comment">// 原位构造元素</span></span><br><span class="line">  Node* node = NewNode(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  SListNode* prev = hint.node;</span><br><span class="line">  <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(node));</span><br><span class="line">  size_type bucket_idx = bucket(key);</span><br><span class="line">  <span class="comment">// 元素唯一的情况下，已找到元素直接结束插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev &amp;&amp; (key_equal_(get_key(Node::Value(prev)), key) || (prev-&gt;next &amp;&amp; key_equal_(get_key(Node::Value(prev-&gt;next)), key)))) &#123;</span><br><span class="line">    <span class="comment">// hint或hint-&gt;next对应元素的key与新元素的key相同，使用hint作为插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到对应元素的插入位置</span></span><br><span class="line">    FindNodeResult result = find_node(key, bucket_idx);</span><br><span class="line">    <span class="keyword">if</span> (unique &amp;&amp; result.node) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = result.before;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  insert_node(bucket_idx, prev, node);</span><br><span class="line">  <span class="comment">// 可以先添加，然后再rehash</span></span><br><span class="line">  check_for_rehash(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(node), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><h4 id="查找单节点"><a href="#查找单节点" class="headerlink" title="查找单节点"></a>查找单节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定位到哈希桶</span></span><br><span class="line">  <span class="keyword">return</span> find_node(key, bucket(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key, size_type bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">  <span class="comment">// 该桶为空直接返回未找到</span></span><br><span class="line">  <span class="keyword">if</span> (hnode.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">const_cast</span>&lt;SListNode*&gt;(&amp;head_), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依次查找该桶的元素，找到相同的key则返回</span></span><br><span class="line">  <span class="keyword">for</span> (SListNode* prev = hnode.node_before_begin; prev-&gt;next != hnode.node_finish-&gt;next; prev = prev-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key_equal_(key, get_key(Node::Value(prev-&gt;next)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;prev, prev-&gt;next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 到这里说明没找到</span></span><br><span class="line">  <span class="keyword">return</span> &#123;hnode.node_before_begin, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找范围"><a href="#查找范围" class="headerlink" title="查找范围"></a>查找范围</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;iterator, iterator&gt; equal_range(bool unique, const key_type&amp; key) &#123;</span><br><span class="line">  <span class="comment">// 先查找单个元素，未找到则直接返回</span></span><br><span class="line">  <span class="keyword">auto</span> res = find_node(key);</span><br><span class="line">  <span class="keyword">if</span> (!res.node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), iterator());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果键唯一，则找到后直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(res.node-&gt;next));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 键不唯一，从before开始查找相同key的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, res.before);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(range_res.first.node-&gt;next));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::pair&lt;FindNodeResult, size_type&gt; find_range(const key_type&amp; key, const SListNode* before) const &#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;FindNodeResult, size_type&gt; res = <span class="built_in">std</span>::make_pair(FindNodeResult(), <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 从before-&gt;next开始，直到key不相同</span></span><br><span class="line">  res.first.before = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">while</span> (before-&gt;next &amp;&amp; key_equal_(key, get_key(Node::Value(before-&gt;next)))) &#123;</span><br><span class="line">    before = before-&gt;next;</span><br><span class="line">    ++res.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时before为key的最后一个元素</span></span><br><span class="line">  res.first.node = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除单个元素的操作相对简单，这里是删除范围的代码</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 范围为空，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到first的前一个节点before</span></span><br><span class="line">  <span class="keyword">const</span> value_type&amp; value = Node::Value(first.node);</span><br><span class="line">  size_type bucket_idx = bucket(get_key(value));</span><br><span class="line">  SListNode* before = PrevNode(buckets_[bucket_idx].node_before_begin, first.node);</span><br><span class="line">  SListNode* prev = before;</span><br><span class="line">  <span class="comment">// printf("erase range before key: %d\n", get_key(Node::Value(before)));</span></span><br><span class="line">  <span class="comment">// 遍历[first, last)的节点并删除</span></span><br><span class="line">  <span class="keyword">while</span> (prev-&gt;next != last.node) &#123;</span><br><span class="line">    HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">    SListNode* node_end = hnode.node_finish-&gt;next;</span><br><span class="line">    <span class="comment">// printf("erase begin\n");</span></span><br><span class="line">    size_type count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断该桶内元素删除的范围</span></span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != node_end &amp;&amp; prev-&gt;next != last.node) &#123;</span><br><span class="line">      <span class="comment">// printf("erase range key: %d\n", Node::Value(prev-&gt;next));</span></span><br><span class="line">      prev = prev-&gt;next;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行元素的删除</span></span><br><span class="line">    erase_node(bucket_idx, before, prev, count);</span><br><span class="line">    prev = before;</span><br><span class="line">    <span class="comment">// printf("bucket %zu size %zu\n", bucket_idx, hnode.size());</span></span><br><span class="line">    <span class="comment">// 已经删除完毕，break</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == last.node) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个删除元素的桶位置</span></span><br><span class="line">    bucket_idx = bucket(get_key(Node::Value(prev-&gt;next)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是最后一个元素，则下一个bucket的前一个节点需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = before;</span><br><span class="line">  &#125;</span><br><span class="line">  SListNode* first = before-&gt;next;</span><br><span class="line">  SListNode* next = first-&gt;next;</span><br><span class="line">  <span class="comment">// 更新该桶节点的范围</span></span><br><span class="line">  buckets_[bucket_idx].erase_node(before, last);</span><br><span class="line">  <span class="comment">// 将元素从链表中删除</span></span><br><span class="line">  RemoveAfter(before, last);</span><br><span class="line">  <span class="comment">// 更新size</span></span><br><span class="line">  incr_size(-count);</span><br><span class="line">  <span class="comment">// 析构节点并释放内存</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    next = first-&gt;next;</span><br><span class="line">    DeleteNode(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作</h3><p>上文已介绍</p><h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>可直接使用单链表的迭代器</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = SListIteratorBase;</span><br><span class="line">  SListNode* node;</span><br><span class="line">  SListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  SListIteratorBase(SListNode* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    SListNode* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Difference = <span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">struct SListConstIterator : <span class="keyword">public</span> SListIteratorBase &#123;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">const</span> T&amp;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">const</span> T*;</span><br><span class="line">  <span class="keyword">using</span> difference_type = Difference;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> Node = singly_list::SListNodeT&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> Base = SListIteratorBase;</span><br><span class="line">  <span class="keyword">using</span> Self = SListConstIterator;</span><br><span class="line">  SListConstIterator(): Base() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SListConstIterator</span><span class="params">(<span class="keyword">const</span> SListNode* node)</span> : <span class="title">Base</span><span class="params">(<span class="keyword">const_cast</span>&lt;SListNode*&gt;(node))</span> </span>&#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Node::Value(node); &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><ul><li>无重新哈希：无序关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</li><li>插入元素导致重新哈希：迭代器（包括end迭代器）非法化，引用有效</li></ul><h1 id="无序关联式容器的注意事项"><a href="#无序关联式容器的注意事项" class="headerlink" title="无序关联式容器的注意事项"></a>无序关联式容器的注意事项</h1><ul><li>unordered_map的operator[]可能会新增元素</li><li>无序关联式容器的元素没有顺序</li><li>删除元素时注意迭代器失效的问题；代码<code>unordered_map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改unordered_map/unordered_multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" target="_blank" rel="noopener">HashMap&amp;HashSet</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;无序关联容器&quot;&gt;&lt;a href=&quot;#无序关联容器&quot; class=&quot;headerlink&quot; title=&quot;无序关联容器&quot;&gt;&lt;/a&gt;无序关联容器&lt;/h1&gt;&lt;p&gt;无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。&lt;/p&gt;
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="无序关联容器" scheme="https://gwq5210.com/tags/%E6%97%A0%E5%BA%8F%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之关联容器</title>
    <link href="https://gwq5210.com/2021/11/14/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/11/14/STL容器之关联容器/</id>
    <published>2021-11-14T20:16:41.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><p>关联容器有以下几种</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h1><p>关联容器的内部由红黑树实现，红黑树是一颗平衡的二叉搜索树（BST，Binary Search Tree）</p><p>在二叉搜索树中，任何节点的值一定大于左子树每一个节点的键值，小于右子树中每一个节点的键值</p><p>但是在极端的情况下，二叉搜索树可能失去平衡，退化为一个链表，造成查找效率低下。因此出现了平衡二叉搜索树，如AVL-tree，红黑树等</p><p>STL的红黑树实现中，会提供两个函数insert_unique和insert_equal分别来实现set/map和multiset/multimap</p><p>由于实现的特性，关联式容器是根据键值有序的，默认从小到大排序（使用std::less<t>进行比较）</t></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/rbtree.png" alt="rbtree" title>                </div>                <div class="image-caption">rbtree</div>            </figure><h2 id="为什么选择红黑树"><a href="#为什么选择红黑树" class="headerlink" title="为什么选择红黑树"></a>为什么选择红黑树</h2><p>AVL树要求每个节点的左右子树高度差不超过1，因此其最坏的查找时间为O(logn)</p><p>但为了严格满足AVL树的高度要求，在每次插入或删除节点时，几乎都会破坏AVL树的平衡，进而我们需要通过旋转来使之平衡</p><p>显然这对插入，删除频繁的场景很不友好，性能大大降低</p><p>而红黑树的高度要求不像AVL树那样严格，频繁插入删除不会频繁破坏平衡，也就不需要频繁调整，这其实是一种折中的方案</p><p>但仅从查找效率来说，AVL树要由于红黑树</p><p>总的来说：平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况</p><h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><p>关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</p><h1 id="关联式容器的注意事项"><a href="#关联式容器的注意事项" class="headerlink" title="关联式容器的注意事项"></a>关联式容器的注意事项</h1><ul><li>map的operator[]可能会新增元素</li><li>关联式容器实现了lower_bound，upper_bound和equal_range的成员函数<ul><li>使用通用的lower_bound，upper_bound和equal_range函数会导致查找效率变低（用在非随机存取迭代器上都会导致效率变低）</li></ul></li><li>删除元素时注意迭代器失效的问题；代码<code>map.erase(it); it++;</code>是错误的</li><li>无法通过迭代器修改键值，但可以修改map/multimap的value值</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zhuanlan.zhihu.com/p/72505589" target="_blank" rel="noopener">平衡树和红黑树</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关联容器&quot;&gt;&lt;a href=&quot;#关联容器&quot; class=&quot;headerlink&quot; title=&quot;关联容器&quot;&gt;&lt;/a&gt;关联容器&lt;/h1&gt;&lt;p&gt;关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。&lt;/p&gt;
&lt;p&gt;关联容器有以下几种&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="关联容器" scheme="https://gwq5210.com/tags/%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之priority_queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bpriority-queue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之priority-queue/</id>
    <published>2021-10-26T00:15:50.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h1><p>与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元素</p><p>可以通过模板参数Compare更改顺序，默认使用std::less<t>进行比较，返回最大元素</t></p><p>priority_queue的底层用堆实现</p><h1 id="二叉堆"><a href="#二叉堆" class="headerlink" title="二叉堆"></a>二叉堆</h1><p>堆并不属于容器组件，是一个数据结构，堆实际上是一个完全二叉树（整个二叉树除了最底层的叶节点外，是填满的），并且每个节点的键值都大于等于/小于等于其父节点的值</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/heap.png" alt="heap" title>                </div>                <div class="image-caption">heap</div>            </figure><p>由于二叉树的性质，我们可以使用数组来表示一个二叉堆(假设下标从0开始)</p><ul><li>下标为i的节点的子节点为<code>2*i+1</code>和<code>2*i+2</code></li><li>下标为i的节点的父节点为<code>(i-1)/2</code></li></ul><h2 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h2><p>在已有的堆中插入元素，一般在堆最下层最右边的叶子之后插入一个元素（或者新增一层）</p><p>插入新元素之后，可能不满足堆的性质，这时候需要进行向上调整（sift_up）的操作</p><ul><li>如果这个节点的值大于父节点的值，则与父节点进行交换，重复次过程直到满足堆的条件或者到达根</li></ul><p>向上调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_up</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &gt; <span class="number">0</span> &amp;&amp; arr[(i - <span class="number">1</span>) / <span class="number">2</span>] &lt; arr[i]; i = (i - <span class="number">1</span>) / <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[(i - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h2><p>删除操作是删除堆的最大元素，一般将最大元素即根节点与最后一个节点交换，再将新的根节点进行向下调整（sift_down）的操作</p><ul><li>在该节点的儿子中选择较大节点与该节点进行交换，重复此操作直到底层或已满足堆的条件</li></ul><p>向下调整的时间复杂度是O(logn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sift_down</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = x; i &lt; n / <span class="number">2</span>; i = <span class="number">2</span> * x + <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">2</span> * x + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n &amp;&amp; arr[j + <span class="number">1</span>] &gt; arr[j]) &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt;= arr[j]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h2><h3 id="向上调整建堆"><a href="#向上调整建堆" class="headerlink" title="向上调整建堆"></a>向上调整建堆</h3><p>即相当于每次在堆的结尾添加一个元素，比较好理解</p><p>复杂度为log1+log2+…+logn=O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    sift_up(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="向下调整建堆"><a href="#向下调整建堆" class="headerlink" title="向下调整建堆"></a>向下调整建堆</h3><p>从叶子开始建堆，逐个向下调整，相当于每次”合并”两个已经调整好的堆</p><p>复杂度为O(n)，每个节点最多向下调整一次，只需要从最后一个非叶子结点进行调整</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">    sift_down(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="堆操作算法"><a href="#堆操作算法" class="headerlink" title="堆操作算法"></a>堆操作算法</h1><p>STL提供了以下几个算法，可以方便的实现优先队列</p><h2 id="push-heap"><a href="#push-heap" class="headerlink" title="push_heap"></a>push_heap</h2><p>将位置<code>last-1</code>的元素插入到<code>[first, last - 1)</code>定义的堆中</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    gtl::sift_up(first, last, gtl::distance(first, last) - <span class="number">1</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::push_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="pop-heap"><a href="#pop-heap" class="headerlink" title="pop_heap"></a>pop_heap</h2><p>交换在位置<code>first</code>的值和位置<code>last-1</code>的值，并将范围<code>[first, last-1)</code>调整为堆</p><p>这达到将范围<code>[first, last)</code>所定义的堆移除首个元素的效果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    --last;</span><br><span class="line">    gtl::iter_swap(first, last);</span><br><span class="line">    gtl::sift_down(first, last, <span class="number">0</span>, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::pop_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort-heap"><a href="#sort-heap" class="headerlink" title="sort_heap"></a>sort_heap</h2><p>将最大堆<code>[first, last)</code>转换为为以升序排序的序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; --last) &#123;</span><br><span class="line">    gtl::pop_heap(first, last, comp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::sort_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="make-heap"><a href="#make-heap" class="headerlink" title="make_heap"></a>make_heap</h2><p>在范围<code>[first, last)</code>中构造最大堆</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (first != last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i = gtl::distance(first, last) / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">      gtl::sift_down(first, last, i, comp);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">make_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::make_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap-until"><a href="#is-heap-until" class="headerlink" title="is_heap_until"></a>is_heap_until</h2><p>检验范围<code>[first, last)</code>并寻找始于<code>first</code>且为最大堆的最大范围</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> n = gtl::distance(first, last);</span><br><span class="line">  <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::difference_type i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">auto</span> it = first;</span><br><span class="line">  <span class="keyword">auto</span> left_it = first + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (; i &lt; n / <span class="number">2</span>; ++i, ++it, ++left_it) &#123;</span><br><span class="line">    <span class="keyword">if</span> (comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">    ++left_it;</span><br><span class="line">    <span class="keyword">if</span> (left_it &lt; last &amp;&amp; comp(*it, *left_it)) &#123;</span><br><span class="line">      <span class="keyword">return</span> left_it;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function">RandomIt <span class="title">is_heap_until</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-heap"><a href="#is-heap" class="headerlink" title="is_heap"></a>is_heap</h2><p>检查范围 [first, last) 中的元素是否为最大堆。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt, <span class="keyword">typename</span> Compare&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last, Compare comp)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap_until(first, last, comp) == last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomIt&gt;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">is_heap</span><span class="params">(RandomIt first, RandomIt last)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> gtl::is_heap(first, last, <span class="built_in">std</span>::less&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;RandomIt&gt;::value_type&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="优先队列的实现"><a href="#优先队列的实现" class="headerlink" title="优先队列的实现"></a>优先队列的实现</h1><p>有了堆的操作算法，很容易通过这些算法实现优先队列</p><p>具体代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Compare = <span class="built_in">std</span>::less&lt;T&gt;, <span class="keyword">typename</span> Container = Vector&lt;T&gt;&gt;</span><br><span class="line">class PriorityQueue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Compare_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs,</span><br><span class="line">                        <span class="keyword">const</span> PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  PriorityQueue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">PriorityQueue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  PriorityQueue(InputIt first, InputIt last) : c_(first, last) &#123;</span><br><span class="line">    gtl::make_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(v);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123;</span><br><span class="line">    c_.push_back(<span class="built_in">std</span>::move(v));</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">    gtl::push_heap(c_.begin(), c_.end(), compare_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gtl::pop_heap(c_.begin(), c_.end());</span><br><span class="line">    c_.pop_back();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(PriorityQueue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">  Compare compare_;</span><br><span class="line">&#125;;  <span class="comment">// class PriorityQueue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/priority_queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/algorithm" target="_blank" rel="noopener">算法库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://oi-wiki.org/ds/binary-heap/" target="_blank" rel="noopener">二叉堆</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;优先队列&quot;&gt;&lt;a href=&quot;#优先队列&quot; class=&quot;headerlink&quot; title=&quot;优先队列&quot;&gt;&lt;/a&gt;优先队列&lt;/h1&gt;&lt;p&gt;与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="优先队列" scheme="https://gwq5210.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之queue</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bqueue/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之queue/</id>
    <published>2021-10-26T00:15:39.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="queue概述"><a href="#queue概述" class="headerlink" title="queue概述"></a>queue概述</h1><p>queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许在一个入口(队尾)添加元素，在另一个入口(队头)获取和删除元素</p><p>queue不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/queue.png" alt="queue" title>                </div>                <div class="image-caption">queue</div>            </figure><p>通常使用deque来作为queue的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此queue往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改queue的底层容器</p><h1 id="queue实现"><a href="#queue实现" class="headerlink" title="queue实现"></a>queue实现</h1><p>queue的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Queue &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Queue&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Queue() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Queue</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Queue(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line">  ~Queue() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  <span class="function">reference <span class="title">front</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">front</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.front(); &#125;</span><br><span class="line">  <span class="function">reference <span class="title">back</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">back</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_front(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Queue&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Queue</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/queue" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;queue概述&quot;&gt;&lt;a href=&quot;#queue概述&quot; class=&quot;headerlink&quot; title=&quot;queue概述&quot;&gt;&lt;/a&gt;queue概述&lt;/h1&gt;&lt;p&gt;queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="队列" scheme="https://gwq5210.com/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之stack</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bstack/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之stack/</id>
    <published>2021-10-26T00:15:34.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="stack概述"><a href="#stack概述" class="headerlink" title="stack概述"></a>stack概述</h1><p>stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出口。</p><p>stack不允许有遍历行为，所以不提供迭代器</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/stack.png" alt="stack" title>                </div>                <div class="image-caption">stack</div>            </figure><p>stack是一种很简单的数据接口，只允许在栈顶新增，删除，获取元素</p><p>通常使用deque来作为stack的底层实现，这种修改接口的方法被称为<a href="/2021/10/26/设计模式之适配器模式/">适配器模式</a></p><p>因此stack往往不归类为container（容器），而被归类为container adapter（容器适配器）</p><p>STL的实现中，可以通过模板参数修改stack的底层容器</p><h1 id="stack实现"><a href="#stack实现" class="headerlink" title="stack实现"></a>stack实现</h1><p>stack的实现非常简单，完全调用底层容器的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Container = Deque&lt;T&gt;&gt;</span><br><span class="line">class Stack &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> container_type = Container;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> Container::value_type;</span><br><span class="line">  <span class="keyword">using</span> size_type = <span class="keyword">typename</span> Container::size_type;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> Container::reference;</span><br><span class="line">  <span class="keyword">using</span> const_reference = <span class="keyword">typename</span> Container::const_reference;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T_, <span class="keyword">typename</span> Container_&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; lhs, <span class="keyword">const</span> Stack&lt;T_, Container_&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line">  Stack() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(<span class="keyword">const</span> Container&amp; c)</span> : <span class="title">c_</span><span class="params">(c)</span> </span>&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">Stack</span><span class="params">(Container&amp;&amp; c)</span> : <span class="title">c_</span><span class="params">(<span class="built_in">std</span>::move(c))</span> </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  Stack(InputIt first, InputIt last) : c_(first, last) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Element access</span></span><br><span class="line">  reference top() &#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line">  <span class="function">const_reference <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.back(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Capacity</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.empty(); &#125;</span><br><span class="line">  <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> c_.size(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Modifiers</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> T&amp; v)</span> </span>&#123; c_.push_back(v); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp; v)</span> </span>&#123; c_.push_back(<span class="built_in">std</span>::move(v)); &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">    c_.emplace_back(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> Category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category&gt;</span><br><span class="line">  <span class="keyword">void</span> push(InputIt first, InputIt last) &#123;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first) &#123;</span><br><span class="line">      emplace(*first);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123; c_.pop_back(); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Stack&amp; other)</span> </span>&#123; <span class="built_in">std</span>::swap(c_, other.c_); &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Container c_;</span><br><span class="line">&#125;;  <span class="comment">// class Stack</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/stack" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;stack概述&quot;&gt;&lt;a href=&quot;#stack概述&quot; class=&quot;headerlink&quot; title=&quot;stack概述&quot;&gt;&lt;/a&gt;stack概述&lt;/h1&gt;&lt;p&gt;stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="栈" scheme="https://gwq5210.com/tags/%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之deque</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bdeque/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之deque/</id>
    <published>2021-10-26T00:15:29.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="deque概述"><a href="#deque概述" class="headerlink" title="deque概述"></a>deque概述</h1><p>deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快速插入或删除数据。与vector的连续空间存储不同，deque的元素可能不是相邻存储的</p><p>vecotr也允许在头尾两端添加或删除数据，但可能会涉及到元素的移动和扩容，导致效率不高</p><p>deque的迭代器也提供随机存储功能，但与vector的迭代器是普通指针不同，为了实现随机存取，deque的迭代器实现比较复杂</p><p>deque的存储按需自动扩展及收缩。deque的扩容相比vector更优，它既不会涉及到元素的移动，也不会过多的浪费存储空间</p><h2 id="deque常见操作的复杂度"><a href="#deque常见操作的复杂度" class="headerlink" title="deque常见操作的复杂度"></a>deque常见操作的复杂度</h2><ul><li>随机访问——常数 O(1)</li><li>在结尾或起始插入或移除元素——常数 O(1)</li><li>插入或移除元素——线性 O(n)</li></ul><h1 id="deque的实现"><a href="#deque的实现" class="headerlink" title="deque的实现"></a>deque的实现</h1><p>deque由一段一段固定大小的连续空间组成，扩容时，便在deque的首或尾新增一个固定大小的连续空间，这就需要额外的结构来串联起这一段段的固定大小空间</p><p>同时为了实现随机存取的接口，则实现了复杂的迭代器架构</p><p>deque采用的是两层架构，采用map（与STL的map不同），记录有多少个固定的连续空间，其中的每个元素称为节点缓冲区，存储实际的元素。</p><p>有的实现我们可以指定固定缓冲区的大小</p><p>这就意味着为了访问真实的元素，必须先定为到节点缓冲区，然后再定位到元素本身，需要进行两次指针访问，而vector只需要一次指针访问</p><p>map中的节点缓冲区满时，需要重新分配map本身的区域，移动原有的节点缓冲区到新的map区域，但这代价很小，仅仅是移动指针而已</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/deque.png" alt="deque" title>                </div>                <div class="image-caption">deque</div>            </figure><p>deque的数据结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">typedef</span> T value_type;</span><br><span class="line">  <span class="keyword">typedef</span> value_type* pointer;</span><br><span class="line">  <span class="keyword">typedef</span> pointer* map_pointer;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  map_pointer <span class="built_in">map</span>; <span class="comment">// 记录节点缓冲区</span></span><br><span class="line">  size_type map_size; <span class="comment">// map可以容纳多少个缓冲区</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="deque的迭代器"><a href="#deque的迭代器" class="headerlink" title="deque的迭代器"></a>deque的迭代器</h1><p>通过deque的结构可以知道，deque的迭代器至少需要保存两个信息：当前元素在哪个节点缓冲区；当前元素在这个缓冲区的哪个位置</p><p>如可能的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque_iterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">      ++cur;</span><br><span class="line">      <span class="keyword">if</span> (cur == last) &#123; <span class="comment">// 到达该节点缓冲区的尾部就切换到下一个缓冲区</span></span><br><span class="line">        set_node(node + <span class="number">1</span>);</span><br><span class="line">        cur = first;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  T* cur; <span class="comment">// 当前元素</span></span><br><span class="line">  T* first; <span class="comment">// 当前节点缓冲区的第一个元素</span></span><br><span class="line">  T* last; <span class="comment">// 当前节点缓冲区的尾，包含备用空间</span></span><br><span class="line">  map_pointer node; <span class="comment">// 指向管控中心</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="迭代器的失效"><a href="#迭代器的失效" class="headerlink" title="迭代器的失效"></a>迭代器的失效</h2><ul><li>在队列中间的插入操作导致所有迭代器和引用失效——可能涉及到元素移动或map中控器扩容</li><li>在队列头尾插入操作会导致迭代器失效——可能涉及map中控器扩容，但不会非法化引用</li><li>在队列中间擦除操作导致所有迭代器和引用失效——涉及元素移动</li><li>在队列头尾擦除操作导致擦除元素的迭代器失效（在尾部删除还会导致end迭代器失效），但不会非法化未擦除元素的引用</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/deque" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;deque概述&quot;&gt;&lt;a href=&quot;#deque概述&quot; class=&quot;headerlink&quot; title=&quot;deque概述&quot;&gt;&lt;/a&gt;deque概述&lt;/h1&gt;&lt;p&gt;deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="双端队列" scheme="https://gwq5210.com/tags/%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之list</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8Blist/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之list/</id>
    <published>2021-10-26T00:15:25.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="list概述"><a href="#list概述" class="headerlink" title="list概述"></a>list概述</h1><p>不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针进行关联</p><p>同时list也不会浪费空间(实际上会多占用前后指针的空间)，有多少个元素就占用多少空间</p><p>list的元素插入是常数级别，但无法想vector一样实现随机元素访问</p><p>在list内添加，删除或移动元素不会导致已有迭代器失效或引用非法，对应元素被删除时该迭代器失效或引用非法</p><h1 id="list的实现"><a href="#list的实现" class="headerlink" title="list的实现"></a>list的实现</h1><h2 id="list节点"><a href="#list节点" class="headerlink" title="list节点"></a>list节点</h2><p>list本身和list的节点是不同的结构，常见的list节点如下，包含前后指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 要实现一个通用的链表需要使用模板类</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">  ListNode* prev;</span><br><span class="line">  ListNode* next;</span><br><span class="line">  T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list结构"><a href="#list结构" class="headerlink" title="list结构"></a>list结构</h2><p>在STL的list实现中，list不仅是一个双向链表，还是一个环形双向链表</p><p>实现list的一个技巧是添加一个虚拟的空白节点，让list的end迭代器指向该空白节点，既符合STL迭代器前闭后开的要求，也方便了编程的实现</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/list.png" alt="list" title>                </div>                <div class="image-caption">list</div>            </figure><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  List() &#123;</span><br><span class="line">    dummy_head_ = node_allocator::allocate(); <span class="comment">// 分配一个空间，不设置值</span></span><br><span class="line">    dummy_head_-&gt;prev = dummy_head_; <span class="comment">// 头尾都指向自己</span></span><br><span class="line">    dummy_head_-&gt;next = dummy_head_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator <span class="title">begin</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_-&gt;next; &#125; <span class="comment">// begin是next节点</span></span><br><span class="line">  <span class="function">iterator <span class="title">end</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> dummy_head_; &#125; <span class="comment">// end是虚拟节点自身</span></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ListNode&lt;T&gt;* dummy_head_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="list的迭代器"><a href="#list的迭代器" class="headerlink" title="list的迭代器"></a>list的迭代器</h2><p>由于list的特殊实现方式，因此我们需要实现一个list的迭代器，允许用户遍历list中保存的元素</p><p>迭代器的表现类似指针，list的迭代器是双向迭代器，支持++和–操作，同时要实现*和-&gt;运算符</p><p>典型的实现如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">ListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::bidirectional_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = ListIteratorBase;</span><br><span class="line">  ListNode&lt;T&gt;* node;</span><br><span class="line">  ListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  ListIteratorBase(ListNode&lt;T&gt;* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ++it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// --it;</span></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// it++;</span></span><br><span class="line">  Self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    ListNode&lt;T&gt;* ret = node;</span><br><span class="line">    node = node-&gt;prev;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> node-&gt;data; &#125;</span><br><span class="line">  <span class="comment">// *(*this) *this即为迭代器本身，则第一个*为调用迭代器的operator*，返回数据的引用</span></span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/list" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;list概述&quot;&gt;&lt;a href=&quot;#list概述&quot; class=&quot;headerlink&quot; title=&quot;list概述&quot;&gt;&lt;/a&gt;list概述&lt;/h1&gt;&lt;p&gt;不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="链表" scheme="https://gwq5210.com/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之空间配置器</title>
    <link href="https://gwq5210.com/2021/10/26/STL%E5%AE%B9%E5%99%A8%E4%B9%8B%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    <id>https://gwq5210.com/2021/10/26/STL容器之空间配置器/</id>
    <published>2021-10-26T00:12:46.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="空间配置器"><a href="#空间配置器" class="headerlink" title="空间配置器"></a>空间配置器</h1><p>从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了</p><p>allocator为什么叫做空间配置器，不叫内存配置器？因为allocator的实现不仅可以从内存分配空间，也可以从磁盘分配空间</p><p>在STL容器的实现中，每个容器都有一个模板参数，可以指定使用的空间配置器</p><p>allocator包含以下类型</p><ul><li>value_type：T</li><li>pointer (C++17 中弃用)(C++20 中移除)：T*</li><li>const_pointer (C++17 中弃用)(C++20 中移除)：const T*</li><li>reference (C++17 中弃用)(C++20 中移除)：T&amp;</li><li>const_reference (C++17 中弃用)(C++20 中移除)：const T&amp;</li><li>size_type：std::size_t</li><li>difference_type：std::ptrdiff_t</li></ul><p>allocator主要包含以下成员函数</p><ul><li>allocate：分配未初始化的存储</li><li>deallocate：解分配存储</li><li>construct(C++17 中弃用)(C++20 中移除)：在分配的存储构造对象</li><li>destroy (C++17 中弃用)(C++20 中移除)：析构在已分配存储中的对象</li></ul><p>在C++的头文件<code>&lt;memory&gt;</code>中定义了一些与未初始化内存相关的函数，在STL容器的实现中，起到了很大的作用，如construct_at(C++20)，uninitialized_copy，uninitialized_fill等</p><h1 id="空间配置器在STL容器中的应用"><a href="#空间配置器在STL容器中的应用" class="headerlink" title="空间配置器在STL容器中的应用"></a>空间配置器在STL容器中的应用</h1><p>STL容器的实现思想中，实际上将空间的分配/释放和对象的构造/析构进行了拆分：空间配置器负责空间的分配/释放；<code>&lt;memory&gt;</code>中的未初始化内存相关的函数负责对象构造/析构，移动等</p><p>能够实现上述拆分，主要由于C++的以下特性</p><ul><li>operator new只进行内存分配，不进行对象构造</li><li>placement new是operator new的一个特殊版本，在已分配的内存上构造对象</li><li>new关键字的作用是：调用operator new，并调用对象的构造函数</li></ul><p>以下两种代码实际上是等价的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  Test(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; name): name_(name) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"construct %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line">  ~Test() &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"destroy %s\n"</span>, name_.c_str());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">string</span> name_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码1</span></span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">new</span> Test(<span class="string">"new_test"</span>);</span><br><span class="line">    <span class="keyword">delete</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 代码2</span></span><br><span class="line">    <span class="keyword">void</span>* p = ::<span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Test));</span><br><span class="line">    <span class="keyword">auto</span>* t = <span class="keyword">reinterpret_cast</span>&lt;Test*&gt;(p);</span><br><span class="line">    t-&gt;Test::Test(<span class="string">"allocator_test"</span>);</span><br><span class="line">    <span class="comment">// auto* t = new (p) Test("allocator_test"); // placement new</span></span><br><span class="line">    t-&gt;~Test();</span><br><span class="line">    ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(p)</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">output:</span></span><br><span class="line"><span class="comment">construct new_test</span></span><br><span class="line"><span class="comment">destroy new_test</span></span><br><span class="line"><span class="comment">construct allocator_test</span></span><br><span class="line"><span class="comment">destroy allocator_test</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="未初始化内存算法的实现"><a href="#未初始化内存算法的实现" class="headerlink" title="未初始化内存算法的实现"></a>未初始化内存算法的实现</h1><p>有了上述基础，可以实现简单的未初始化内存的算法，更多实现参见<a href="https://github.com/gwq5210/gtl/blob/main/gtl/algorithm/gtl_memory.h" target="_blank" rel="noopener">gtl_memory.h</a></p><p>construct_at用到了std::forward的完美转发（C++11），两次强制转换是为了除去cv限定符</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">// 在给定地址 p 创建以参数 args... 初始化的 T 对象</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T* <span class="title">construct_at</span><span class="params">(T* p, Args&amp;&amp;... args)</span> </span>&#123;</span><br><span class="line">  ::<span class="keyword">new</span> (<span class="keyword">const_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">volatile</span> <span class="keyword">void</span>*&gt;(p))) T(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 销毁指针p指向的对象</span></span><br><span class="line"><span class="comment"> * 若 T 不是数组类型，则调用 p 所指向对象的析构函数，如同用 p-&gt;~T()</span></span><br><span class="line"><span class="comment"> * 若 T 是数组类型，则按顺序递归地销毁 *p 的元素，如同通过调用 std::destroy(std::begin(*p), std::end(*p))</span></span><br><span class="line"><span class="comment"> * C++17 version:</span></span><br><span class="line"><span class="comment"> * template&lt;class T&gt; void destroy_at(T* p) &#123; p-&gt;~T(); &#125;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param p 指向要被销毁的对象的指针</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">destroy_at</span><span class="params">(T* p)</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_array_v&lt;T&gt;)</span> </span>&#123;  <span class="comment">// C++ 20</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : *p) &#123;</span><br><span class="line">      gtl::destroy_at(gtl::addressof(v));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    p-&gt;~T();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; first != last; ++first, ++d_first) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> SizeType, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy_range_n</span><span class="params">(InputIt first, SizeType count, ForwardIt d_first, <span class="built_in">std</span>::input_iterator_tag,</span></span></span><br><span class="line"><span class="function"><span class="params">                                     <span class="built_in">std</span>::forward_iterator_tag)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (; count &gt; <span class="number">0</span>; ++first, ++d_first, --count) &#123;</span><br><span class="line">    gtl::construct_at(gtl::addressof(*d_first), *first);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> d_first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 复制来自范围 [first, last) 的元素到始于 d_first 的未初始化内存</span></span><br><span class="line"><span class="comment"> * 若初始化中抛异常，则以未指定顺序销毁已构造的对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return ForwardIt 指向最后复制的元素后一元素的迭代器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">TODO:</span> 处理异常的情况</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIt, <span class="keyword">typename</span> ForwardIt&gt;</span><br><span class="line"><span class="function">ForwardIt <span class="title">uninitialized_copy</span><span class="params">(InputIt first, InputIt last, ForwardIt d_first)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">using</span> input_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;InputIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> forward_iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIt&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">return</span> gtl::uninitialized_copy_range(first, last, d_first, input_iterator_category(), forward_iterator_category());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/memory/allocator" target="_blank" rel="noopener">std::allocator</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;空间配置器&quot;&gt;&lt;a href=&quot;#空间配置器&quot; class=&quot;headerlink&quot; title=&quot;空间配置器&quot;&gt;&lt;/a&gt;空间配置器&lt;/h1&gt;&lt;p&gt;从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了
      
    
    </summary>
    
      <category term="STL" scheme="https://gwq5210.com/categories/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/categories/STL/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="空间配置器" scheme="https://gwq5210.com/tags/%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之适配器模式</title>
    <link href="https://gwq5210.com/2021/10/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/26/设计模式之适配器模式/</id>
    <published>2021-10-26T00:08:42.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h1><p>在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器</p><p>适配器模式的定义为：将一个类的接口转换为另一个类的接口，使原本因接口不兼容而不能工作的类可以一起工作</p><p>适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>客户端通过适配器可以透明地调用目标接口。</li><li>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</li><li>将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。</li><li>在很多业务场景中符合开闭原则。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。</li><li>增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。</li></ul><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><h1 id="适配器的实现"><a href="#适配器的实现" class="headerlink" title="适配器的实现"></a>适配器的实现</h1><p>适配器模式（Adapter）包含以下主要角色。</p><ul><li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li><li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li><li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li></ul><h2 id="类适配器实现"><a href="#类适配器实现" class="headerlink" title="类适配器实现"></a>类适配器实现</h2><p>类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口。</p><p>Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/class_adapter.gif" alt="class_adapter" title>                </div>                <div class="image-caption">class_adapter</div>            </figure><h2 id="对象适配器实现"><a href="#对象适配器实现" class="headerlink" title="对象适配器实现"></a>对象适配器实现</h2><p>对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/object_adapter.gif" alt="object_adapter" title>                </div>                <div class="image-caption">object_adapter</div>            </figure><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>在STL中有三种容器适配器，这里不过多介绍</p><ul><li><a href="/2021/10/26/STL容器之queue/">stack</a></li><li><a href="/2021/10/26/STL容器之stack/">queue</a></li><li><a href="/2021/10/26/STL容器之priority-queue/">priority_queue</a></li></ul><h1 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h1><ul><li>reverse_iterator: 逆序遍历的迭代器适配器(类模板)</li><li>make_reverse_iterator(C++14): 创建拥有从实参推出的类型的 std::reverse_iterator(函数模板)</li><li>move_iterator(C++11): 解引用结果为右值引用的迭代器适配器(类模板)</li><li>make_move_iterator(C++11): 创建拥有从实参推出的类型的 std::move_iterator(函数模板)</li><li>back_insert_iterator: 用于在容器尾部插入的迭代器适配器(类模板)</li><li>back_inserter: 创建拥有从实参推出的类型的 std::back_insert_iterator(函数模板)</li><li>front_insert_iterator: 用于在容器头部插入的迭代器适配器(类模板)</li><li>front_inserter: 创建拥有从实参推出的类型的 std::front_insert_iterator(函数模板)</li><li>insert_iterator: 用于插入容器的迭代器适配器(类模板)</li><li>inserter: 创建拥有从实参推出的类型的 std::insert_iterator(函数模板)</li></ul><p>如ReverseIterator的实现，将++操作换成迭代器的–操作，实现逆向遍历</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReverseIterator</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> iterator_type = Iterator;</span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::iterator_category;</span><br><span class="line">  <span class="keyword">using</span> value_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::value_type;</span><br><span class="line">  <span class="keyword">using</span> difference_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::difference_type;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::pointer;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;Iterator&gt;::reference;</span><br><span class="line"></span><br><span class="line">  ReverseIterator() : it_() &#123;&#125;</span><br><span class="line">  ReverseIterator(iterator_type it) : it_(it) &#123;&#125;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) : it_(other.it_) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; other) &#123;</span><br><span class="line">    it_ = other.it_;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">iterator_type <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> it_; &#125;</span><br><span class="line"></span><br><span class="line">  reference <span class="keyword">operator</span>*() &#123;</span><br><span class="line">    <span class="keyword">return</span> *gtl::prev(it_);</span><br><span class="line">  &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> gtl::addressof(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  reference <span class="keyword">operator</span>[](difference_type n) &#123; <span class="keyword">return</span> *gtl::prev(n + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    --it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++it_;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>+=(difference_type n) &#123;</span><br><span class="line">    it_ -= n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator&amp; <span class="keyword">operator</span>-=(difference_type n) &#123;</span><br><span class="line">    it_ += n;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>+(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ - n); &#125;</span><br><span class="line">  ReverseIterator <span class="keyword">operator</span>-(difference_type n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> ReverseIterator(it_ + n); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; lhs, <span class="keyword">const</span> ReverseIterator&lt;It&gt;&amp; rhs);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  iterator_type it_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="函数适配器"><a href="#函数适配器" class="headerlink" title="函数适配器"></a>函数适配器</h1><p>早期的C++提供了一些函数适配器，如bind1st和bind2nd（C++11后可用bind替代）</p><p>早期提供功能支持的几个工具在C++11中弃用，并于 C++17 中移除（旧否定器于 C++17 中弃用并于 C++20 中移除），这里不再过多介绍</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1361.html" target="_blank" rel="noopener">适配器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://zh.cppreference.com/w/cpp/iterator" target="_blank" rel="noopener">迭代器库</a></li><li><a href="https://zh.cppreference.com/w/cpp/utility/functional" target="_blank" rel="noopener">函数对象</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;适配器模式&quot;&gt;&lt;a href=&quot;#适配器模式&quot; class=&quot;headerlink&quot; title=&quot;适配器模式&quot;&gt;&lt;/a&gt;适配器模式&lt;/h1&gt;&lt;p&gt;在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器&lt;/p&gt;
&lt;p&gt;适配器模式的定义为：将一
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之迭代器模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之迭代器模式/</id>
    <published>2021-10-22T12:12:43.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h1><p>实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素<br>通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。</p><p>既然将遍历方法封装在容器类中不可取，那么容器类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点：</p><ul><li>暴露了容器类的内部表示，使其数据不安全</li><li>增加了客户的负担</li></ul><p>“迭代器模式”能较好地克服以上缺点，它在客户访问类与容器类之间插入一个迭代器，这分离了容器对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则”</p><p>迭代器模式定义：提供一种方法，使之能够依次访问某个容器所含的各个元素，而又无需暴露该容器的内部实现。</p><p>迭代器模式是一种对象行为型模式，其主要优点如下</p><ul><li>访问一个容器对象的内容而无须暴露它的内部表示。</li><li>遍历任务交由迭代器完成，这简化了容器类。</li><li>它支持以不同方式遍历一个容器，甚至可以自定义迭代器的子类以支持新的遍历。</li><li>增加新的容器类和迭代器类都很方便，无须修改原有代码。</li><li>封装性良好，为遍历不同的容器结构提供一个统一的接口。</li></ul><p>其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。</p><p>在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。</p><p>一般来说，迭代器需要了解容器类的内部实现，才能正确的遍历容器中的元素</p><h2 id="模式的结构"><a href="#模式的结构" class="headerlink" title="模式的结构"></a>模式的结构</h2><p>迭代器模式主要包含以下角色。</p><ul><li>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。</li><li>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</li><li>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。</li><li>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://gwq5210.com/images/iterator.gif" alt="迭代器模式结构" title>                </div>                <div class="image-caption">迭代器模式结构</div>            </figure><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>迭代器模式通常在以下几种情况使用。</p><ul><li>当需要为容器对象提供多种遍历方式时。</li><li>当需要为遍历不同的容器结构提供一个统一的接口时。</li><li>当访问一个容器对象的内容而无须暴露其内部细节的表示时。</li></ul><p>由于容器与迭代器的关系非常密切，所以大多数语言在实现容器类时都提供了迭代器类，因此大数情况下使用语言中已有的容器类的迭代器就已经够了。</p><h1 id="STL中的迭代器"><a href="#STL中的迭代器" class="headerlink" title="STL中的迭代器"></a>STL中的迭代器</h1><p>在STL中的vector、list、set、map等容器都包含了迭代器，迭代器的行为与指针类似，迭代器可以是原生指针，也可以是重载operator*和operator-&gt;的对象。</p><p>与容器相似，该容器对应的迭代器可以获取特定类型的值，我们需要通过特性萃取技术（traits）来获取迭代器对应的类型。c++提供了iterator_traits来实现该功能。</p><p>一般来说，迭代器需要提供以下几种类型，针对原生指针，可以通过对iterator_traits进行模板特化来获取对应的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">value_type</span><br><span class="line">difference_type</span><br><span class="line">pointer</span><br><span class="line">reference</span><br><span class="line">iterator_category</span><br></pre></td></tr></table></figure><h2 id="迭代器分类"><a href="#迭代器分类" class="headerlink" title="迭代器分类"></a>迭代器分类</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输入迭代器，只读，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span> &#125;; <span class="comment">// 输出迭代器，可写，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123; &#125;; <span class="comment">// 前向迭代器，只能向前移动，只能++</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123; &#125;; <span class="comment">// 可双向移动，可++，--</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123; &#125;; <span class="comment">// 可随机访问，与原生指针类似</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">contiguous_iterator_tag</span>:</span> <span class="keyword">public</span> random_access_iterator_tag &#123; &#125;; <span class="comment">//  (C++20) 要求逻辑相邻元素在内存中物理上也相邻</span></span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1395.html" target="_blank" rel="noopener">迭代器模式（详解版）</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;迭代器模式&quot;&gt;&lt;a href=&quot;#迭代器模式&quot; class=&quot;headerlink&quot; title=&quot;迭代器模式&quot;&gt;&lt;/a&gt;迭代器模式&lt;/h1&gt;&lt;p&gt;实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素&lt;br&gt;通常的做法是将链表的创建和遍历都放在同
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="迭代器模式" scheme="https://gwq5210.com/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式之状态模式</title>
    <link href="https://gwq5210.com/2021/10/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    <id>https://gwq5210.com/2021/10/22/设计模式之状态模式/</id>
    <published>2021-10-22T12:04:33.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="状态模式概述"><a href="#状态模式概述" class="headerlink" title="状态模式概述"></a>状态模式概述</h1><p>在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态</p><p>当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变</p><p>对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理</p><p>但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展</p><p>以上问题如果采用“状态模式”就能很好地得到解决。</p><p>状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。</p><h1 id="状态模式定义与特点"><a href="#状态模式定义与特点" class="headerlink" title="状态模式定义与特点"></a>状态模式定义与特点</h1><p>状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。</li><li>将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。</li><li>状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。</li></ul><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><ul><li>状态模式的使用必然会增加系统的类与对象的个数。</li><li>状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。</li><li>状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。</li></ul><h1 id="状态模式的结构"><a href="#状态模式的结构" class="headerlink" title="状态模式的结构"></a>状态模式的结构</h1><p>状态模式涉及的角色如下</p><ul><li>环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。</li><li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。</li><li>具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。</li></ul><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https/gwq5210.com/images/state.gif" alt="状态模式结构图" title>                </div>                <div class="image-caption">状态模式结构图</div>            </figure><h1 id="状态模式的实现"><a href="#状态模式的实现" class="headerlink" title="状态模式的实现"></a>状态模式的实现</h1><p>本例子实现了一个投票的简单例子</p><ul><li>同一个用户可以投一次票，初始状态为正常状态(NormalVoteState)</li><li>成功投票之后，状态转换为重复投票状态(RepeatVoteState)，不能再进行投票</li></ul><p>例子十分简单，具体工程上，可以实现很复杂的状态转换</p><p>核心代码如下，具体可参见代码<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.cc" target="_blank" rel="noopener">state.cc</a>和<a href="https://github.com/gwq5210/learning_notes/blob/main/design_pattern/state.h" target="_blank" rel="noopener">state.h</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NormalVoteState::vote</span><span class="params">(VoteManager* manager, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; username)</span> </span>&#123;</span><br><span class="line">  manager-&gt;inc_vote(username);</span><br><span class="line">  manager-&gt;set_state(&amp;VoteManager::repeat_vote_state);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s, 投票成功!\n"</span>, username.c_str());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  VoteManager manager;</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  manager.vote(<span class="string">"gwq5210"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="环境和状态处理对象"><a href="#环境和状态处理对象" class="headerlink" title="环境和状态处理对象"></a>环境和状态处理对象</h2><p>在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。</p><p>在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。</p><p>客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://c.biancheng.net/view/1388.html" target="_blank" rel="noopener">状态模式（详解版）</a></li><li><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/08/2538146.html" target="_blank" rel="noopener">《JAVA与模式》之状态模式</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;状态模式概述&quot;&gt;&lt;a href=&quot;#状态模式概述&quot; class=&quot;headerlink&quot; title=&quot;状态模式概述&quot;&gt;&lt;/a&gt;状态模式概述&lt;/h1&gt;&lt;p&gt;在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而
      
    
    </summary>
    
      <category term="设计模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="https://gwq5210.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="状态模式" scheme="https://gwq5210.com/tags/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>STL容器之vector</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器之vector/</id>
    <published>2021-10-22T12:02:02.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="vector概述"><a href="#vector概述" class="headerlink" title="vector概述"></a>vector概述</h1><p>vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在物理上也是相邻的</p><p>vector的底层是数组，这也说明必要的时候，vector的元素指针可以当做数组指针来使用</p><p>一般的实现中，vector的迭代器就是指针本身</p><p>vector元素访问复杂度</p><ul><li>随机访问——常数 O(1)</li><li>在末尾插入或移除元素——均摊常数 O(1)</li><li>插入或移除元素——与到 vector 结尾的距离成线性 O(n)</li></ul><p>vector有两个特点</p><ul><li>数据连续存储</li><li>空间动态分配</li></ul><p>下边主要针对空间动态分配进行介绍</p><h1 id="vector的实现"><a href="#vector的实现" class="headerlink" title="vector的实现"></a>vector的实现</h1><p>vector的空间是动态分配的，随着元素的增加，vector会自动扩充空间以容纳新元素</p><p>当需要扩充空间时，vector内部会进行如下操作</p><ul><li>分配一块更大的空间</li><li>将原有的数据移动到新的位置</li><li>释放原有空间</li></ul><p>可以看到自动扩充空间涉及到内存分配和元素移动，时间成本很高，需要设计一个合理的数据结构和空间配置策略</p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>vector需要表示一块连续存储空间，因此我们需要知道内存的位置，内存的大小和已存储元素的个数</p><p>一个简单的结构如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">vector</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T* start_;</span><br><span class="line">    <span class="keyword">size_t</span> size_;</span><br><span class="line">    <span class="keyword">size_t</span> capacity_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了降低内存分配的时间成本，vector的实际空间要比使用的空间要大一些，为将来的元素增加做好准备，为此就需要一个容量来表示当前内存的最大大小</p><h2 id="空间配置策略"><a href="#空间配置策略" class="headerlink" title="空间配置策略"></a>空间配置策略</h2><p>当vector空间满时，新添加元素，会触发自动空间分配，这个时候再分配多少合适呢</p><p>选的扩容太小比如新的大小是当前大小的1.1倍，可能会频繁导致空间分配，如果新的大小是当前大小的3或4倍，可能会导致内存的浪费</p><p>我们先看下主流的实现，gcc新的大小是当前空间大小的2倍，vs是新大小是当前空间大小的1.5倍</p><p>如果选择增长因子为2，可能是最坏的可能，因为它不允许vector重用先前分配好的任何内存，因此选择1.5是一个更好的选择</p><p>如果增长因子为k，则每次分配的内存为，当为2的时候每次分配的内存都比先前分配的所有内存和都大，选择1.5时，则可以在4次分配后重用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">C, C*k,  C*k^2, C*k^3, ...</span><br><span class="line">1 + 2^1 + 2^2 + 2^3... + 2^n = 2^(n+1) - 1</span><br></pre></td></tr></table></figure><h2 id="内存的释放"><a href="#内存的释放" class="headerlink" title="内存的释放"></a>内存的释放</h2><p>vector删除元素并不会删除已经申请好的内存，即使vector里已经不包含任何元素</p><p>C++11增加公共成员函数shrink_to_fit，允许释放未使用的内存</p><p>或者通过swap临时变量的方式释放内存</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;().swap(v);</span><br></pre></td></tr></table></figure><h1 id="vector的迭代器失效"><a href="#vector的迭代器失效" class="headerlink" title="vector的迭代器失效"></a>vector的迭代器失效</h1><p>对容器的操作影响了元素的存放位置，称为迭代器失效</p><p>由于vector的实现特点，在发生以下情况时，迭代器和引用都会失效</p><ul><li>容量发生改变</li><li>插入或移除元素后的迭代器(插入或移除元素前的迭代器和引用不会失效)</li></ul><h1 id="vector原位构造元素"><a href="#vector原位构造元素" class="headerlink" title="vector原位构造元素"></a>vector原位构造元素</h1><p>C++11提供以下两个函数来原位构造元素</p><ul><li>emplace</li><li>emplace_back</li></ul><p>这两个函数通过完美转发实现原位构造，相比push_back这一类函数，少了一次拷贝的动作</p><p>实际上，当前的push_back实现会使用move语义，不会进行拷贝</p><h1 id="vector的特化"><a href="#vector的特化" class="headerlink" title="vector的特化"></a>vector的特化</h1><p>STL针对vector<bool>进行了特化，可以提供更优的存储空间，实际上它实现了一个动态bitmap</bool></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container/vector" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li><li><a href="https://github.com/facebook/folly/blob/main/folly/docs/FBVector.md" target="_blank" rel="noopener">fbvector</a></li><li><a href="https://segmentfault.com/a/1190000040103598" target="_blank" rel="noopener">vector实现原理</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;vector概述&quot;&gt;&lt;a href=&quot;#vector概述&quot; class=&quot;headerlink&quot; title=&quot;vector概述&quot;&gt;&lt;/a&gt;vector概述&lt;/h1&gt;&lt;p&gt;vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
      <category term="顺序容器" scheme="https://gwq5210.com/tags/%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>STL容器概述</title>
    <link href="https://gwq5210.com/2021/10/22/STL%E5%AE%B9%E5%99%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://gwq5210.com/2021/10/22/STL容器概述/</id>
    <published>2021-10-22T11:59:54.000Z</published>
    <updated>2022-08-03T12:56:33.268Z</updated>
    
    <content type="html"><![CDATA[<h1 id="STL容器概述"><a href="#STL容器概述" class="headerlink" title="STL容器概述"></a>STL容器概述</h1><p>容器被设计来存储数据，可以使程序员简单的访问常见的数据结构</p><p>每种不同的容器底层使用不同的数据结构，并拥有不同的特征，可在特定场景提供高效的数据存储和访问的方式</p><p>每种容器提供<a href="/2021/10/22/设计模式之迭代器模式/">迭代器</a>来访问存储在其中的元素</p><p>容器一般分为以下几种类别</p><h1 id="顺序容器"><a href="#顺序容器" class="headerlink" title="顺序容器"></a>顺序容器</h1><p>顺序容器实现能按顺序访问的数据结构</p><ul><li>array：静态连续数组</li><li>vector：动态连续数组</li><li>deque：双端队列</li><li>forward_list：单链表</li><li>list：双链表</li></ul><h1 id="关联容器"><a href="#关联容器" class="headerlink" title="关联容器"></a>关联容器</h1><p>关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。</p><ul><li>set：有序集合，键唯一</li><li>map：键值对集合，键唯一</li><li>multiset：键集合，键不唯一</li><li>multimap：键值对集合，键不唯一</li></ul><h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p><ul><li>unordered_set：无序集合，键唯一</li><li>unordered_map：无序键值对集合，键唯一</li><li>unordered_multiset：无序集合，键不唯一</li><li>unordered_multimap：无序键值对集合，键不唯一</li></ul><h1 id="容器适配器"><a href="#容器适配器" class="headerlink" title="容器适配器"></a>容器适配器</h1><p>容器适配器提供顺序容器的不同接口</p><ul><li>stack：栈</li><li>queue：队列</li><li>priority_queue：优先队列</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li><li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;STL容器概述&quot;&gt;&lt;a href=&quot;#STL容器概述&quot; class=&quot;headerlink&quot; title=&quot;STL容器概述&quot;&gt;&lt;/a&gt;STL容器概述&lt;/h1&gt;&lt;p&gt;容器被设计来存储数据，可以使程序员简单的访问常见的数据结构&lt;/p&gt;
&lt;p&gt;每种不同的容器底层使用不同
      
    
    </summary>
    
      <category term="编程" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/"/>
    
      <category term="STL" scheme="https://gwq5210.com/categories/%E7%BC%96%E7%A8%8B/STL/"/>
    
    
      <category term="STL" scheme="https://gwq5210.com/tags/STL/"/>
    
      <category term="容器库" scheme="https://gwq5210.com/tags/%E5%AE%B9%E5%99%A8%E5%BA%93/"/>
    
  </entry>
  
</feed>
