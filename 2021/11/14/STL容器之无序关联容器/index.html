<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    

    

    



    <meta charset="utf-8">
    
    
    
    <title>STL容器之无序关联容器 | gwq5210&#39;s Blog | 凡是过往，皆为序章！</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="STL,容器库,无序关联容器">
    <meta name="description" content="无序关联容器无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 无序关联容器有以下几种  unordered_set：无序集合，键唯一 unordered_map：无序键值对集合，键唯一 unordered_multiset：无序集合，键不唯一 unordered_multimap：无序键值对集合，键不唯一  无序关联容器底层由哈希表实现，下文主要">
<meta name="keywords" content="STL,容器库,无序关联容器">
<meta property="og:type" content="article">
<meta property="og:title" content="STL容器之无序关联容器">
<meta property="og:url" content="https://gwq5210.com/2021/11/14/STL容器之无序关联容器/index.html">
<meta property="og:site_name" content="gwq5210&#39;s Blog">
<meta property="og:description" content="无序关联容器无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 无序关联容器有以下几种  unordered_set：无序集合，键唯一 unordered_map：无序键值对集合，键唯一 unordered_multiset：无序集合，键不唯一 unordered_multimap：无序键值对集合，键不唯一  无序关联容器底层由哈希表实现，下文主要">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://gwq5210.com/images/hashtable.png">
<meta property="og:updated_time" content="2022-07-29T07:10:14.219Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="STL容器之无序关联容器">
<meta name="twitter:description" content="无序关联容器无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 无序关联容器有以下几种  unordered_set：无序集合，键唯一 unordered_map：无序键值对集合，键唯一 unordered_multiset：无序集合，键不唯一 unordered_multimap：无序键值对集合，键不唯一  无序关联容器底层由哈希表实现，下文主要">
<meta name="twitter:image" content="https://gwq5210.com/images/hashtable.png">
    
        <link rel="alternate" type="application/atom+xml" title="gwq5210&#39;s Blog" href="/atom.xml">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu"  >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/images/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/images/logo.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">gwq5210</h5>
          <a href="mailto:gwq5210@qq.com" title="gwq5210@qq.com" class="mail">gwq5210@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                文章
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                标签
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/gwq5210" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/about"  >
                <i class="icon icon-lg icon-link"></i>
                关于
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">STL容器之无序关联容器</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">STL容器之无序关联容器</h1>
        <h5 class="subtitle">
            
                <time datetime="2021-11-14T20:17:36.000Z" itemprop="datePublished" class="page-time">
  2021-11-14
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/STL/">STL</a></li></ul></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#无序关联容器"><span class="post-toc-number">1.</span> <span class="post-toc-text">无序关联容器</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#哈希表概述"><span class="post-toc-number">2.</span> <span class="post-toc-text">哈希表概述</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#解决哈希表碰撞"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">解决哈希表碰撞</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#哈希表扩容"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">哈希表扩容</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#负载因子和初始容量"><span class="post-toc-number">2.2.1.</span> <span class="post-toc-text">负载因子和初始容量</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#扩容步骤"><span class="post-toc-number">2.2.2.</span> <span class="post-toc-text">扩容步骤</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#哈希表的具体实现"><span class="post-toc-number">3.</span> <span class="post-toc-text">哈希表的具体实现</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#数组-单链表的实现介绍"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">数组+单链表的实现介绍</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#数据结构结构"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">数据结构结构</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#insert操作"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">insert操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#find操作"><span class="post-toc-number">3.1.3.</span> <span class="post-toc-text">find操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#查找单节点"><span class="post-toc-number">3.1.3.1.</span> <span class="post-toc-text">查找单节点</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#查找范围"><span class="post-toc-number">3.1.3.2.</span> <span class="post-toc-text">查找范围</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#删除操作"><span class="post-toc-number">3.1.4.</span> <span class="post-toc-text">删除操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#rehash操作"><span class="post-toc-number">3.1.5.</span> <span class="post-toc-text">rehash操作</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#迭代器实现"><span class="post-toc-number">3.1.6.</span> <span class="post-toc-text">迭代器实现</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#迭代器失效"><span class="post-toc-number">4.</span> <span class="post-toc-text">迭代器失效</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#无序关联式容器的注意事项"><span class="post-toc-number">5.</span> <span class="post-toc-text">无序关联式容器的注意事项</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#参考"><span class="post-toc-number">6.</span> <span class="post-toc-text">参考</span></a></li></ol>
        </nav>
    </aside>
    
<article id="post-STL容器之无序关联容器"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">STL容器之无序关联容器</h1>
        <div class="post-meta">
            <time class="post-time" title="2021-11-14 20:17:36" datetime="2021-11-14T20:17:36.000Z"  itemprop="datePublished">2021-11-14</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/">编程</a><ul class="article-category-list-child"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/编程/STL/">STL</a></li></ul></li></ul>



            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h1 id="无序关联容器"><a href="#无序关联容器" class="headerlink" title="无序关联容器"></a>无序关联容器</h1><p>无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。</p>
<p>无序关联容器有以下几种</p>
<ul>
<li>unordered_set：无序集合，键唯一</li>
<li>unordered_map：无序键值对集合，键唯一</li>
<li>unordered_multiset：无序集合，键不唯一</li>
<li>unordered_multimap：无序键值对集合，键不唯一</li>
</ul>
<p>无序关联容器底层由哈希表实现，下文主要对哈希表进行介绍</p>
<h1 id="哈希表概述"><a href="#哈希表概述" class="headerlink" title="哈希表概述"></a>哈希表概述</h1><p>哈希表的基本原理是利用数组可以随机存取的特点，通过哈希函数（hasher）将键（key_type）均匀的映射到数组的下标，这样我们可以很快的通过数组下标快速找到对应的元素</p>
<p>数组中的每个元素称为桶（bucket）</p>
<p>这样会存在两个问题：</p>
<ul>
<li>不同的键映射到了相同的数组下标</li>
<li>数组大小是固定的，添加了更多元素之后，如何对数组进行扩容</li>
</ul>
<h2 id="解决哈希表碰撞"><a href="#解决哈希表碰撞" class="headerlink" title="解决哈希表碰撞"></a>解决哈希表碰撞</h2><p>不同的的元素被映射到相同的数组下标，被称为碰撞。解决碰撞有许多种方法</p>
<ul>
<li>开放定址法：哈希冲突时，从冲突的位置按照一定的次序寻找一个空闲的桶。删除元素时需要进行标记，否则会导致查找错误<ul>
<li>线性探测：依次判断位置为i+1,i+2,i+3,到达最后一个桶时从头开始判断</li>
<li>二次探测：依次判断位置为i+1^2,i+2^2,i+3^2</li>
</ul>
</li>
<li>链地址法：哈希冲突时，冲突的元素放在链表中。可以理解为数组的每个桶都是一个链表，只是大部分的链表仅包含一个元素</li>
</ul>
<p>大部分的实现采用链地址法处理冲突</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://gwq5210.com/images/hashtable.png" alt="hashtable" title>
                </div>
                <div class="image-caption">hashtable</div>
            </figure>
<h2 id="哈希表扩容"><a href="#哈希表扩容" class="headerlink" title="哈希表扩容"></a>哈希表扩容</h2><p>在一般的实现中，哈希桶的数量为2的次幂，这样可以通过位运算得到元素哈希桶的位置</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">size_type bucket_idx = hasher()(key) % bucket_count();</span><br><span class="line">size_type bucket_idx = hasher()(key) &amp; (bucket_count() - <span class="number">1</span>); <span class="comment">// 当bucket_count为2的幂时</span></span><br></pre></td></tr></table></figure>
<h3 id="负载因子和初始容量"><a href="#负载因子和初始容量" class="headerlink" title="负载因子和初始容量"></a>负载因子和初始容量</h3><p>首先介绍一个负载因子（load factor）的概念：即元素个数除以桶个数。</p>
<p>哈希表一般通过负载因子来指定扩容的临界值。例如负载因子可以设置为0.75。当元素的数量超过bucket_count*load_factor时，会触发扩容操作</p>
<p>哈希表另一个比较重要的概念是初始容量，即初始哈希桶的数量，插入元素较多的情况下可以指定较大的初始容量减少扩容的次数。默认初始容量可以设置为16</p>
<h3 id="扩容步骤"><a href="#扩容步骤" class="headerlink" title="扩容步骤"></a>扩容步骤</h3><p>哈希表的扩容也称为重新哈希（rehash），大致步骤如下</p>
<ul>
<li>以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组</li>
<li>遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中<ul>
<li>在同数量为2的次幂时，可以将桶中元素分为两部分，这两部分元素在新桶数组中的位置分别是：i和i+old_bucket_count（按照位运算很好理解）</li>
</ul>
</li>
<li>所有元素迁移完成之后，释放原桶数组</li>
</ul>
<p>以下例子是数组+单链表（下文介绍）的重新哈希的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_rehash</span><span class="params">(size_type new_bucket_count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 新分配桶数组</span></span><br><span class="line">  BucketStorage new_buckets = alloc_buckets(new_bucket_count);</span><br><span class="line">  SListNode old_head = head_;</span><br><span class="line">  buckets_.swap(new_buckets); <span class="comment">// 与旧桶数组交换</span></span><br><span class="line">  head_.next = <span class="literal">nullptr</span>;</span><br><span class="line">  get_size() = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash new bucket count %zu %zu\n"</span>, bucket_count(), new_bucket_count);</span><br><span class="line">  SListNode* prev = &amp;old_head; <span class="comment">// 旧链表的伪头节点，便于实现</span></span><br><span class="line">  SListNode* first = prev-&gt;next;</span><br><span class="line">  <span class="comment">// 2. 遍历所有元素的链表</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    <span class="comment">// 计算链表头节点在新桶数组中的位置</span></span><br><span class="line">    <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(first));</span><br><span class="line">    size_type new_bucket_idx = bucket(key);</span><br><span class="line">    <span class="comment">// 找到相同key的元素</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, prev);</span><br><span class="line">    <span class="comment">// 将(range_res.first.before, range_res.first.node]这些元素从链表中移除</span></span><br><span class="line">    RemoveAfter(range_res.first.before, range_res.first.node);</span><br><span class="line">    <span class="comment">// 插入到新链表中并设置桶的所在元素的范围</span></span><br><span class="line">    insert_node(new_bucket_idx, buckets_[new_bucket_idx].node_before_begin ? buckets_[new_bucket_idx].node_before_begin : &amp;head_, first, range_res.first.node, range_res.second);</span><br><span class="line">    <span class="comment">// 旧链表的新头节点</span></span><br><span class="line">    first = prev-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"rehash done. new bucket count %zu\n"</span>, bucket_count());</span><br><span class="line">  <span class="comment">// 3. 旧桶数组在作用域结束时自动释放内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="哈希表的具体实现"><a href="#哈希表的具体实现" class="headerlink" title="哈希表的具体实现"></a>哈希表的具体实现</h1><p>哈希表一般有以下几种实现</p>
<ul>
<li>仅数组<ul>
<li>迭代元素需要遍历整个桶数组</li>
<li>元素迭代的顺序与插入顺序无关，与在桶中的位置有关</li>
<li>同一个桶内的元素以相反的顺序遍历（在头部插入）</li>
</ul>
</li>
<li>数组+单链表：所有的元素用单链表进行串联<ul>
<li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li>
<li>元素的迭代顺序与插入顺序相反（找不到元素时在头部插入）</li>
<li>桶的结构中保存链表节点的指针或迭代器(before, node]</li>
<li>插入元素时如果更改了某个桶的尾元素node，则需要更新node-&gt;next元素所在桶的before指针</li>
<li>单链表包含一个伪头结点head_利于实现</li>
<li>swap时要更新链表头结点的before指针</li>
</ul>
</li>
<li>数组+双链表：所有的元素用双链表进行串联<ul>
<li>迭代元素无需遍历整个桶数组，迭代次数与元素次数相同</li>
<li>元素的迭代顺序与插入顺序相同（找不到元素时在尾部插入）</li>
<li>桶的结构中保存链表节点的指针或迭代器[begin, node]</li>
<li>实现相较数组+单链表简单</li>
</ul>
</li>
</ul>
<p>说明</p>
<ul>
<li>以上只说明大致思路，具体的实现可能略有不同</li>
<li>以上针对元素key唯一的情况，key相同的情况下，相同的key元素在链表中紧邻存放(相同key的元素的迭代顺序由实现决定，可以不做保证)</li>
<li>哈希表是无序的，不对key进行排序</li>
<li>哈希表重新哈希之后元素迭代顺序会发生变化</li>
<li>哈希表的实现中，会提供两个函数insert_unique和insert_equal分别来实现unordered_set/unordered_map和unordered_multiset/unordered_multimap（也可通过模板特化来针对唯一key或相同key实现不同的逻辑，提升性能）</li>
</ul>
<h2 id="数组-单链表的实现介绍"><a href="#数组-单链表的实现介绍" class="headerlink" title="数组+单链表的实现介绍"></a>数组+单链表的实现介绍</h2><h3 id="数据结构结构"><a href="#数据结构结构" class="headerlink" title="数据结构结构"></a>数据结构结构</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListNode</span> &#123;</span></span><br><span class="line">  SListNode* next;</span><br><span class="line">  SListNode() : next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123; next = <span class="literal">nullptr</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key, <span class="keyword">typename</span> Value, <span class="keyword">typename</span> ExtractKey, <span class="keyword">typename</span> Hash = <span class="built_in">std</span>::hash&lt;Key&gt;, <span class="keyword">typename</span> KeyEquel = <span class="built_in">std</span>::equal_to&lt;Key&gt;&gt;</span><br><span class="line">class HashTable &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 哈希桶的结构，链表中范围(node_before_begin, node_finish]内的节点在该桶内</span></span><br><span class="line">  struct HashNode &#123;</span><br><span class="line">    HashNode(): node_before_begin(<span class="literal">nullptr</span>), node_finish(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    HashNode(SListNode* b, SListNode* f): node_before_begin(b), node_finish(f) &#123;&#125;</span><br><span class="line">    SListNode* node_before_begin;</span><br><span class="line">    SListNode* node_finish;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  ExtractKey get_key_func_;</span><br><span class="line">  key_equal key_equal_;</span><br><span class="line">  hasher hasher_;</span><br><span class="line">  SListNode head_;</span><br><span class="line">  <span class="keyword">float</span> max_load_factor_;</span><br><span class="line">  BucketStorage buckets_;</span><br><span class="line">  CompressedPair&lt;size_type, NodeAllocator&gt; size_alloc_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="insert操作"><a href="#insert操作" class="headerlink" title="insert操作"></a>insert操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* first, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 将新的[first, last]内的元素插入到before节点后</span></span><br><span class="line">  InsertAfter(before, first, last);</span><br><span class="line">  <span class="comment">// 更新该桶内的元素范围</span></span><br><span class="line">  buckets_[bucket_idx].insert_node(before, first, last);</span><br><span class="line">  incr_size(count);</span><br><span class="line">  <span class="comment">// 更新下一个bucket的前一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line">std::pair&lt;iterator, bool&gt; insert_node(bool unique, const_iterator hint, Args&amp;&amp;... args) &#123;</span><br><span class="line">  <span class="comment">// 原位构造元素</span></span><br><span class="line">  Node* node = NewNode(<span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">  SListNode* prev = hint.node;</span><br><span class="line">  <span class="keyword">const</span> key_type&amp; key = get_key(Node::Value(node));</span><br><span class="line">  size_type bucket_idx = bucket(key);</span><br><span class="line">  <span class="comment">// 元素唯一的情况下，已找到元素直接结束插入</span></span><br><span class="line">  <span class="keyword">if</span> (prev &amp;&amp; (key_equal_(get_key(Node::Value(prev)), key) || (prev-&gt;next &amp;&amp; key_equal_(get_key(Node::Value(prev-&gt;next)), key)))) &#123;</span><br><span class="line">    <span class="comment">// hint或hint-&gt;next对应元素的key与新元素的key相同，使用hint作为插入位置</span></span><br><span class="line">    <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 找到对应元素的插入位置</span></span><br><span class="line">    FindNodeResult result = find_node(key, bucket_idx);</span><br><span class="line">    <span class="keyword">if</span> (unique &amp;&amp; result.node) &#123;</span><br><span class="line">      DeleteNode(node);</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    prev = result.before;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 插入元素</span></span><br><span class="line">  insert_node(bucket_idx, prev, node);</span><br><span class="line">  <span class="comment">// 可以先添加，然后再rehash</span></span><br><span class="line">  check_for_rehash(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(node), <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="find操作"><a href="#find操作" class="headerlink" title="find操作"></a>find操作</h3><h4 id="查找单节点"><a href="#查找单节点" class="headerlink" title="查找单节点"></a>查找单节点</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定位到哈希桶</span></span><br><span class="line">  <span class="keyword">return</span> find_node(key, bucket(key));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">FindNodeResult <span class="title">find_node</span><span class="params">(<span class="keyword">const</span> key_type&amp; key, size_type bucket_idx)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">  <span class="comment">// 该桶为空直接返回未找到</span></span><br><span class="line">  <span class="keyword">if</span> (hnode.empty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="keyword">const_cast</span>&lt;SListNode*&gt;(&amp;head_), <span class="literal">nullptr</span>&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依次查找该桶的元素，找到相同的key则返回</span></span><br><span class="line">  <span class="keyword">for</span> (SListNode* prev = hnode.node_before_begin; prev-&gt;next != hnode.node_finish-&gt;next; prev = prev-&gt;next) &#123;</span><br><span class="line">    <span class="keyword">if</span> (key_equal_(key, get_key(Node::Value(prev-&gt;next)))) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;prev, prev-&gt;next&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 到这里说明没找到</span></span><br><span class="line">  <span class="keyword">return</span> &#123;hnode.node_before_begin, <span class="literal">nullptr</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找范围"><a href="#查找范围" class="headerlink" title="查找范围"></a>查找范围</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::pair&lt;iterator, iterator&gt; equal_range(bool unique, const key_type&amp; key) &#123;</span><br><span class="line">  <span class="comment">// 先查找单个元素，未找到则直接返回</span></span><br><span class="line">  <span class="keyword">auto</span> res = find_node(key);</span><br><span class="line">  <span class="keyword">if</span> (!res.node) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(), iterator());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果键唯一，则找到后直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (unique) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(res.node-&gt;next));</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 键不唯一，从before开始查找相同key的元素范围</span></span><br><span class="line">    <span class="keyword">auto</span> range_res = find_range(key, res.before);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::make_pair(iterator(res.node), iterator(range_res.first.node-&gt;next));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">std::pair&lt;FindNodeResult, size_type&gt; find_range(const key_type&amp; key, const SListNode* before) const &#123;</span><br><span class="line">  <span class="built_in">std</span>::pair&lt;FindNodeResult, size_type&gt; res = <span class="built_in">std</span>::make_pair(FindNodeResult(), <span class="number">0</span>);</span><br><span class="line">  <span class="comment">// 从before-&gt;next开始，直到key不相同</span></span><br><span class="line">  res.first.before = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">while</span> (before-&gt;next &amp;&amp; key_equal_(key, get_key(Node::Value(before-&gt;next)))) &#123;</span><br><span class="line">    before = before-&gt;next;</span><br><span class="line">    ++res.second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 此时before为key的最后一个元素</span></span><br><span class="line">  res.first.node = <span class="keyword">const_cast</span>&lt;SListNode*&gt;(before);</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>删除单个元素的操作相对简单，这里是删除范围的代码</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">iterator <span class="title">erase</span><span class="params">(const_iterator first, const_iterator last)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 范围为空，直接返回</span></span><br><span class="line">  <span class="keyword">if</span> (first == last) &#123;</span><br><span class="line">    <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 找到first的前一个节点before</span></span><br><span class="line">  <span class="keyword">const</span> value_type&amp; value = Node::Value(first.node);</span><br><span class="line">  size_type bucket_idx = bucket(get_key(value));</span><br><span class="line">  SListNode* before = PrevNode(buckets_[bucket_idx].node_before_begin, first.node);</span><br><span class="line">  SListNode* prev = before;</span><br><span class="line">  <span class="comment">// printf("erase range before key: %d\n", get_key(Node::Value(before)));</span></span><br><span class="line">  <span class="comment">// 遍历[first, last)的节点并删除</span></span><br><span class="line">  <span class="keyword">while</span> (prev-&gt;next != last.node) &#123;</span><br><span class="line">    HashNode&amp; hnode = buckets_[bucket_idx];</span><br><span class="line">    SListNode* node_end = hnode.node_finish-&gt;next;</span><br><span class="line">    <span class="comment">// printf("erase begin\n");</span></span><br><span class="line">    size_type count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 判断该桶内元素删除的范围</span></span><br><span class="line">    <span class="keyword">while</span> (prev-&gt;next != node_end &amp;&amp; prev-&gt;next != last.node) &#123;</span><br><span class="line">      <span class="comment">// printf("erase range key: %d\n", Node::Value(prev-&gt;next));</span></span><br><span class="line">      prev = prev-&gt;next;</span><br><span class="line">      ++count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行元素的删除</span></span><br><span class="line">    erase_node(bucket_idx, before, prev, count);</span><br><span class="line">    prev = before;</span><br><span class="line">    <span class="comment">// printf("bucket %zu size %zu\n", bucket_idx, hnode.size());</span></span><br><span class="line">    <span class="comment">// 已经删除完毕，break</span></span><br><span class="line">    <span class="keyword">if</span> (prev-&gt;next == last.node) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算下一个删除元素的桶位置</span></span><br><span class="line">    bucket_idx = bucket(get_key(Node::Value(prev-&gt;next)));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> iterator(last.node);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">erase_node</span><span class="params">(size_type bucket_idx, SListNode* before, SListNode* last, size_type count)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是最后一个元素，则下一个bucket的前一个节点需要更新</span></span><br><span class="line">  <span class="keyword">if</span> (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123;</span><br><span class="line">    buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = before;</span><br><span class="line">  &#125;</span><br><span class="line">  SListNode* first = before-&gt;next;</span><br><span class="line">  SListNode* next = first-&gt;next;</span><br><span class="line">  <span class="comment">// 更新该桶节点的范围</span></span><br><span class="line">  buckets_[bucket_idx].erase_node(before, last);</span><br><span class="line">  <span class="comment">// 将元素从链表中删除</span></span><br><span class="line">  RemoveAfter(before, last);</span><br><span class="line">  <span class="comment">// 更新size</span></span><br><span class="line">  incr_size(-count);</span><br><span class="line">  <span class="comment">// 析构节点并释放内存</span></span><br><span class="line">  <span class="keyword">while</span> (first) &#123;</span><br><span class="line">    next = first-&gt;next;</span><br><span class="line">    DeleteNode(first);</span><br><span class="line">    first = next;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="rehash操作"><a href="#rehash操作" class="headerlink" title="rehash操作"></a>rehash操作</h3><p>上文已介绍</p>
<h3 id="迭代器实现"><a href="#迭代器实现" class="headerlink" title="迭代器实现"></a>迭代器实现</h3><p>可直接使用单链表的迭代器</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SListIteratorBase</span> &#123;</span></span><br><span class="line">  <span class="keyword">using</span> iterator_category = <span class="built_in">std</span>::forward_iterator_tag;</span><br><span class="line">  <span class="keyword">using</span> Self = SListIteratorBase;</span><br><span class="line">  SListNode* node;</span><br><span class="line">  SListIteratorBase() : node(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  SListIteratorBase(SListNode* n) : node(n) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    SListNode* ret = node;</span><br><span class="line">    node = node-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> Self(ret);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node == other.node; &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Self&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> node != other.node; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Difference = <span class="built_in">std</span>::<span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">struct SListConstIterator : <span class="keyword">public</span> SListIteratorBase &#123;</span><br><span class="line">  <span class="keyword">using</span> reference = <span class="keyword">const</span> T&amp;;</span><br><span class="line">  <span class="keyword">using</span> pointer = <span class="keyword">const</span> T*;</span><br><span class="line">  <span class="keyword">using</span> difference_type = Difference;</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line">  <span class="keyword">using</span> Node = singly_list::SListNodeT&lt;T&gt;;</span><br><span class="line">  <span class="keyword">using</span> Base = SListIteratorBase;</span><br><span class="line">  <span class="keyword">using</span> Self = SListConstIterator;</span><br><span class="line">  SListConstIterator(): Base() &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">SListConstIterator</span><span class="params">(<span class="keyword">const</span> SListNode* node)</span> : <span class="title">Base</span><span class="params">(<span class="keyword">const_cast</span>&lt;SListNode*&gt;(node))</span> </span>&#123;&#125;</span><br><span class="line">  reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Node::Value(node); &#125;</span><br><span class="line">  pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> &#123; <span class="keyword">return</span> <span class="built_in">std</span>::pointer_traits&lt;pointer&gt;::pointer_to(**<span class="keyword">this</span>); &#125;</span><br><span class="line">  Self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = *<span class="keyword">this</span>;</span><br><span class="line">    Base::<span class="keyword">operator</span>++();</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h1 id="迭代器失效"><a href="#迭代器失效" class="headerlink" title="迭代器失效"></a>迭代器失效</h1><ul>
<li>无重新哈希：无序关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器）</li>
<li>插入元素导致重新哈希：迭代器（包括end迭代器）非法化，引用有效</li>
</ul>
<h1 id="无序关联式容器的注意事项"><a href="#无序关联式容器的注意事项" class="headerlink" title="无序关联式容器的注意事项"></a>无序关联式容器的注意事项</h1><ul>
<li>unordered_map的operator[]可能会新增元素</li>
<li>无序关联式容器的元素没有顺序</li>
<li>删除元素时注意迭代器失效的问题；代码<code>unordered_map.erase(it); it++;</code>是错误的</li>
<li>无法通过迭代器修改键值，但可以修改unordered_map/unordered_multimap的value值</li>
</ul>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://zh.cppreference.com/w/cpp/container" target="_blank" rel="noopener">容器库</a></li>
<li><a href="https://item.jd.com/11821611.html" target="_blank" rel="noopener">STL源码剖析</a></li>
<li><a href="https://pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html" target="_blank" rel="noopener">HashMap&amp;HashSet</a></li>
</ul>

        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2022-07-29T07:10:14.219Z" itemprop="dateUpdated">2022-07-29 07:10:14</time>
</span><br>


        
    </div>
    <footer>
        <a href="https://gwq5210.com">
            <img src="/images/logo.jpg" alt="gwq5210">
            gwq5210
        </a>
    </footer>
</blockquote>

        
<div class="page-reward">
    <a id="rewardBtn" href="javascript:;" class="page-reward-btn waves-effect waves-circle waves-light">赏</a>
</div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/STL/">STL</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/容器库/">容器库</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/无序关联容器/">无序关联容器</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&title=《STL容器之无序关联容器》 — gwq5210's Blog&pic=https://gwq5210.com/images/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&title=《STL容器之无序关联容器》 — gwq5210's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《STL容器之无序关联容器》 — gwq5210's Blog&url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&via=https://gwq5210.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2021/11/14/智能指针/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">智能指针</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2021/11/14/STL容器之关联容器/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">STL容器之关联容器</h4>
      </a>
    </div>
  
</nav>



    











    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "IriDzPGksK3yHDWn9k9LXd7n-gzGzoHsz",
            appKey: "cto0PcUNCVqr0zck28XwwDwt",
            avatar: "mm",
            placeholder: "Just go go",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->




</article>

<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        谢谢大爷~
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" src="/images/wechat.jpg" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/images/wechat.jpg" data-alipay="/images/alipay.jpg">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechat">微信</span>
                <span class="reward-toggle-label"></span>
                <span class="reward-toggle-item alipay">支付宝</span>
            </div>
        </label>
        
    </div>
</div>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
                <span><a href="/atom.xml" target="_blank" class="rss" title="rss"><i class="icon icon-lg icon-rss"></i></a></span>
            
            <span>This blog is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>gwq5210 &copy; 2015 - 2022</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&title=《STL容器之无序关联容器》 — gwq5210's Blog&pic=https://gwq5210.com/images/logo.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&title=《STL容器之无序关联容器》 — gwq5210's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《STL容器之无序关联容器》 — gwq5210's Blog&url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/&via=https://gwq5210.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://gwq5210.com/2021/11/14/STL容器之无序关联容器/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLklEQVR42u3a227qMBAF0P7/T1PpvLaYve3QowzLTxE0kGWkqefy9RWvx7+1fv3xY61f//nu+rsuWBgYGLdlPJYrZ6x5+Tatt+DZdmBgYHwCo32U9Re3UbHdAgwMDIw28J0jLwj0GBgYGMvkc524XhXKMTAwMPLHSoJsfkz8D7k4BgbGDRltY+Avr9/Y38DAwLgJ47G19j755Lj54nkwMDBGM5KEs33EnL1OeushDAwMjKGMthyWp6/JNiWvR+U2DAyM0Yw27F5VYmuLa5sJLQYGxghGEgTzgLgXOvcC/S+5OAYGxmhGO4yVP1A7opFs6ItCGwYGxjhGe5jLy2HtAEebMD/9TTAwMEYz2g9dp69XFeYKJAYGxmjGeWuzTXT3Snt7DVcMDIwZjPMhsHaE4qQNUBwNMTAwPoaRjzvkf98eAaN2KQYGxlBGO6qVtxvfd/30d8DAwBjK2AuLebm/DdaXZeQYGBiDGCcpZVv6T/CbwR0DA2M047yUf1Xj8/wuDAyM2YwkdLZFtL2himIIbO8/AAYGxs0ZLaBNSpMwegLGwMCYzbgqXLaftjfY8eIuDAyMcYxHud5xBMy34OldGBgYoxn5Oin377UQkusag4GBcVtGHmTz49pJYtwGdAwMjM9h5IFvr9DWhvI6ecbAwMA4KPS37c/N5igGBgZGcHxMSmx5Ka3dFAwMjE9g5IWz9gh4sgX5uxgYGLMZbWMgRybtybbAtzeigYGBcVvGNw5kS6ndXjYVAAAAAElFTkSuQmCC" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };


lazyScripts.push('//s95.cnzz.com/z_stat.php?id=1260464046&web_id=1260464046')

</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '死鬼去哪里了！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又好了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
