{"meta":{"title":"gwq5210's Blog","subtitle":"凡是过往，皆为序章！","description":null,"author":"gwq5210","url":"https://gwq5210.com"},"pages":[{"title":"","date":"2022-07-17T15:47:36.030Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"404.html","permalink":"https://gwq5210.com/404.html","excerpt":"","text":""},{"title":"关于","date":"2015-11-08T20:31:42.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"about/index.html","permalink":"https://gwq5210.com/about/index.html","excerpt":"","text":"自我简介C++后台开发程序猿一枚，目前就职于搜狗公司。欢迎交流技术相关的问题。"},{"title":"","date":"2022-07-17T15:47:36.034Z","updated":"2022-07-17T15:47:36.034Z","comments":false,"path":"categories/index.html","permalink":"https://gwq5210.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-07-17T15:47:36.078Z","updated":"2022-07-17T15:47:36.078Z","comments":false,"path":"tags/index.html","permalink":"https://gwq5210.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"STL之string","slug":"STL之string","date":"2021-11-14T20:20:57.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/11/14/STL之string/","link":"","permalink":"https://gwq5210.com/2021/11/14/STL之string/","excerpt":"","text":"string概述string和vector在本质上都是动态数组，当存储的类型是字符类型（如char）时，通常使用string，否则就使用vector string和vector自动管理动态数组，并自动扩充数组的大小，析构时自动释放内存 string提供了字符串查找，替换等成员函数，方便使用 string实现string在编程中十分常见，了解字符串的实现很有帮助 为了提高string的性能，一般有三种方式来实现string，有时会对这几种方法相结合 eager copy，即每次都执行深拷贝 SSO，即Small String Optimization，较小的字符串在栈中分配内存 COW，即Copy On Write，写时复制 string的结构介绍三种实现前，先大致介绍下string的结构 如果按照我们自己的设计，字符串必定包含以下三个数据成员：字符串长度，字符串的容量和字符数组指针 12345struct StringStorage &#123; size_type size; size_type capacity; pointer data;&#125;; eager copy直接深拷贝的方式很容易理解，因为string中保存的是指向堆内存的指针，在复制时，需要执行以下步骤执行深拷贝 分配新的内存 将字符串的内容复制到新内存 设置字符串大小和容量 这种字符串的实现方式，相对简单，比较容易理解，但带来的问题是每次复制都需要分配内存和执行复制的操作，当字符串很大时，会带来性能的问题 12345678910111213StringStorage AllocateMediumStorage() &#123; StringStorage store; store.size = 0; store.capacity = kMaxMediumSize; store.data = static_cast&lt;pointer&gt;(Allocate(kMaxMediumSize + 1)); return store;&#125;void UnsafeInitMedium(const_pointer str, size_t len) &#123; assert(len &lt;= kMaxMediumSize); store_ = AllocateMediumStorage(); store_.UnsafeCopyFrom(str, len); type_ = StringType::kMedium;&#125; SSO短字符串优化是一个很巧妙的优化方法，利用string本身结构的buffer来存储较小的字符串 上边给出的例子中，至少需要三个变量，因此string的结构本身需要24个字节 当字符串较小时，如果仍在堆上分配内存，但size和capacity本身的值则很小，高位bit都是0，浪费了许多空间 因此在SSO的实现，只用一个字节表示字符串大小，容量大小是固定的，不需要存储，则可以有24-1=23个字节存储字符串，除去尾部的’\\0’，则实际的容量为22，这便是llvm/clang/libc++采用的实现 SSO的字符串，复制时只需简单的复制SmallString结构即可，无需在堆上分配内存 另外，他们的实现，会结合SSO、COW和eager copy的实现，因此需要标记字符串的类型，它用一个bit来区分是长字符还是短字符，然后用位操作和掩码 (mask) 来取重叠部分的数据，因此实现是最复杂的。 本文的实现，为了简单，使用一个字节来区分字符串类型 12345678910111213141516171819struct SmallString &#123; SmallString() &#123; Init(); &#125; void Init() &#123; size = 0; data[size] = '\\0'; &#125; void Init(const_pointer str, size_type len) &#123; if (str) &#123; assert(len &lt;= kMaxSmallSize); size = len; memcpy(data, str, sizeof(value_type) * len); data[len] = '\\0'; &#125; else &#123; Init(); &#125; &#125; uint8_t size; value_type data[kMaxSmallSize + 1];&#125;; sso_string COW写时复制（Copy-on-write，简称COW）是一种很重要的优化手段。核心思想是懒惰处理多个实体的资源请求，在多个实体之间共享资源，当需要修改时，才真正进行资源的分配 Linux内核在进程fork时对进程地址空间的处理就使用到了COW技术 COW优点 减少了分配（和复制）大量资源带来的瞬间延迟（实际上该延迟被分摊到后续的操作中，其累积耗时很可能比一次统一处理的延迟要高，造成throughput下降是有可能的） 减少了不必要的资源分配。（例如只读的复制没有必要执行深拷贝） 当然COW不是没有缺点，下文会进行介绍 COW实现基于COW的思想，我们知道，在string复制时，只进行浅拷贝，而在需要修改对象时，则执行深拷贝的动作。 我们要在什么时候需要执行深拷贝？ 当前字符串没有被共享，则不需要拷贝 当前字符串被共享，当需要修改时，进行深拷贝的动作 因此，为了区分是否被共享，我们引入一个引用计数来记录字符串被多少个string共享 引用计数一般是原子操作，保证线程安全，下文会详细介绍；引用计数需要在堆上分配，保证不同的string对象能够共享 123456789101112131415161718192021222324252627struct LargeString &#123; LargeString() : ref_count(1) &#123; data[0] = '\\0'; &#125; std::atomic&lt;size_type&gt; ref_count; value_type data[];&#125;;StringStorage AllocateLargeStorage(size_type capacity) &#123; assert(capacity &gt; kMaxMediumSize); StringStorage store; store.size = 0; store.capacity = capacity; store.data = static_cast&lt;pointer&gt;(static_cast&lt;char *&gt;(Allocate(LargeString::GetDataOffset() + capacity + 1)) + LargeString::GetDataOffset()); LargeString::ConstrctAt(store); return store;&#125;void UnsafeInitLarge(const_pointer str, size_type len, size_type c = 0) &#123; store_ = AllocateLargeStorage(c &gt; 0 ? c : len); store_.UnsafeCopyFrom(str, len); type_ = StringType::kLarge;&#125;pointer MutableData() &#123; // 引用计数大于1，则执行深拷贝 if (type_ == StringType::kLarge &amp;&amp; LargeString::RefCount(store_) &gt; 1) &#123; LargeString::DecRefCount(store_); UnsafeInitLarge(store_.data, store_.size); &#125; return store_.data;&#125; COW在多线程中的问题像STL的其他容器一样，多线程操作共享的string不是线程安全的。但不同的线程操作不同的字符串是线程安全的。 聪明的同学立马会想到，在COW的string实现中，不同的string对象，可能共享同一块内存，那不同线程同时修改COW实现的string时，怎么保证线程安全呢？ 这就要求COW的string必须能够正确的处理这种竞争条件： 对引用计数进行原子操作 需要修改时，先分配和复制，再将引用计数减1（当引用计数为0时，负责释放内存） 原子操作比起mutex之类的同步手段，原子操作自然要轻上不少，但比起普通的算术指令，依然算得上完全的重量级 COW为了保证“线程安全”而使用了原子操作，而原子操作本身的效率并不十分高。而且在多线程环境下，多个CPU对同一个地址的原子操作开销更大。COW中”共享“的实现，反而影响了多线程环境下string”拷贝“的性能。 操作顺序COW中，需要修改时，先分配和复制，再将引用计数减1，这在多线程操作中，会导致不必要的分配和复制 两个线程同时操作两个string，这两个string共享同一片内存（即引用计数为2），当两个线程都需要对string修改时，他们都需要先分配和复制，再将引用计数减1（最终会有一个线程释放内存） 这时，COW一共进行了3次内存分配和复制（初始化时1次，修改时2次）和1次内存释放 但如果没有使用COW技术，从string的初始化到目前为止也只进行了2次内存分配和复制（都是在初始化时进行） COW的失效问题这个问题其实是字符串接口导致的问题，string类提供了data、operator[]等接口，可以直接修改字符串本身，但由于他们返回的是指针和引用，只读操作也会导致分配和复制 这可能导致COW不能完全发挥作用，每次都是在深拷贝。 这当然可以通过重新设计接口，严格区分只读和修改造作来解决。但维护非标准接口，并非是一个简单的工作 代理类区分读写操作区分读写的另一种方式是，定义CharProxy类，operator[]返回CharProxy，在对CharProxy赋值时，才执行分配和复制 但这也会增加编码的复杂度 fbstringFackbook的开源库folly中提供了fbstring，它是std::string的替代。其对string类的设计进行了许多优化 将字符串区分为small/medium/large，针对他们分别采用SSO、eager copy和COW的策略（使用capacity最高位的4个bits来判断string的种类） small：结构体长度为24字节，减去末尾的1字节（用来表示长度）和为结束符’\\0’（data()和c_str()方法的需要）预留的1字节，可以放置22字节的有效长度 medium：不超过255字节 large：超过255字节 word-wise copy（逐字拷贝） 直接使用malloc/free，并在使用jemalloc时，使用非标准扩展接口来提高性能 末尾’\\0’的处理：平时预留空间，在调用data或c_str时，才添加’\\0’，避免了每次修改字符串时的额外开销 find使用BM算法 参考 Effective STL中文版 std::string的Copy-on-Write：不如想象中美好 漫步Facebook开源C++库folly：string类的设计 c++再探string之eager-copy、COW和SSO方案 folly","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"字符串","slug":"字符串","permalink":"https://gwq5210.com/tags/字符串/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"智能指针","slug":"智能指针","date":"2021-11-14T20:18:54.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/11/14/智能指针/","link":"","permalink":"https://gwq5210.com/2021/11/14/智能指针/","excerpt":"","text":"RAII了解智能指针前，我们先了解下C++编程中常用的RAII的思想 RAII全称为Resource Acquisition is Initialization，直译就是资源获取即初始化。 它的思想是将必须在使用前获取的资源（堆内存，线程，文件，互斥锁等）与一个对象的声明周期绑定，常用做法是在构造函数中请求资源，在析构函数中释放资源 以上由C++的语言机制保证，当对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数 智能指针就是使用RAII思想的例子 智能指针概述智能指针本质是模板类独享，其行为类似指针。其最主要的功能是帮助管理动态内存，防止发生内存泄漏 C++提供了四种智能指针 auto_ptr(C++11废弃，C++17移除) unique_ptr(C++11)：独占智能指针 shared_ptr(C++11)：引用计数智能指针 weak_ptr(C++11)：弱引用智能指针，解决shared_ptr的循环引用，不能访问直接访问对象 1234&#123; auto_ptr&lt;double&gt; p(new double(10.0)); // p析构时自动释放内存&#125; auto_ptr是C++98提供的，现已废弃，应使用unique_ptr或shared_ptr替代 考虑如下情况，将p赋值给p2会发生什么？ 按照常规指针的做法，p2和p会指向同一个对象，但是如果这样，p2和p在析构时会释放两次内存，这当然是不可行的 12345&#123; auto_ptr&lt;double&gt; p(new double(10.0)); auto_ptr&lt;double&gt; p2; p2 = p; // 会发生什么&#125; 针对以上问题，有如下解决方案 执行深拷贝，但这会造成两个指针指向不同对象 建立所有权（ownership）的概念，仅可以让一个智能指针拥有该对象，该智能指针析构时执行内存释放操作。赋值操作将所有权转移。 auto_ptr和unique_ptr都采用此策略，unique_ptr的策略更加严格 使用引用计数，记录有多少个智能指针指向该对象，当引用计数变为0时，执行内存释放操作 shared_ptr采用此策略 auto_ptr使用 不要将同一个原生指针赋值给多个智能指针 auto_ptr对象的复制构造和赋值会转移所有权 作为参数不要按值传递 auto_ptr不支持数组 无法作为STL容器的元素，auto_ptr的复制构造和赋值要求参数左值引用 仅支持new分配的内存 1234567891011121314auto_ptr&lt;double&gt; p(new double(10.0));auto_ptr&lt;double&gt; p2;p2 = p; // p的所有权被转移给p2，p不再有效*p = 10.0; // bad// 按值传递，调用时会将所有权转移给临时对象p3，函数结束时将内存释放// 这里应采用按引用传递void test(auto_ptr&lt;double&gt; p3) &#123; printf(\"%.2f\\n\", *p3);&#125;test(p2);*p2 = 10.0; // badauto_ptr&lt;double[]&gt; pa(new double[100]()); // bad auto_ptr实现 auto_ptr的复制构造函数和赋值运算符要求左值引用 需要考虑右值的构造和赋值，通过AutoPtrRef的方式实现 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071template &lt;typename T&gt;struct AutoPtrRef &#123; explicit AutoPtrRef(T* p) : ptr(p) &#123;&#125; T* ptr;&#125;;template &lt;typename T&gt;class AutoPtr &#123; public: using element_type = T; explicit AutoPtr(element_type* data = nullptr) : data_(data) &#123;&#125; AutoPtr(AutoPtr&amp; other) : data_(other.release()) &#123;&#125; // 为了实现右值的初始化 AutoPtr(AutoPtrRef&lt;element_type&gt; ref) : data_(ref.ptr) &#123;&#125; template &lt;typename Y&gt; AutoPtr(AutoPtr&lt;Y&gt;&amp; other) : data_(other.release()) &#123;&#125; ~AutoPtr() &#123; Destroy(); &#125; AutoPtr&amp; operator=(AutoPtr&amp; other) &#123; printf(\"calling AutoPtr::operator=(AutoPtr&amp; other)\\n\"); reset(other.release()); return *this; &#125; template &lt;typename Y&gt; AutoPtr&amp; operator=(AutoPtr&lt;Y&gt;&amp; other) &#123; printf(\"calling AutoPtr::operator=(AutoPtr&lt;Y&gt;&amp; other)\\n\"); reset(other.release()); return *this; &#125; template &lt;typename Y&gt; AutoPtr&amp; operator=(AutoPtrRef&lt;Y&gt; other) &#123; printf(\"calling AutoPtr::operator=(AutoPtrRef&lt;Y&gt; other)\\n\"); reset(other.ptr); return *this; &#125; element_type* get() const &#123; return data_; &#125; element_type* operator-&gt;() const &#123; return get(); &#125; element_type&amp; operator*() const &#123; return *get(); &#125; template &lt;typename Y&gt; operator AutoPtrRef&lt;Y&gt;() &#123; return AutoPtrRef&lt;Y&gt;(release()); &#125; template &lt;typename Y&gt; operator AutoPtr&lt;Y&gt;() &#123; return AutoPtr&lt;Y&gt;(release()); &#125; void reset(element_type* data = nullptr) &#123; if (data != data_) &#123; Destroy(); data_ = data; &#125; &#125; element_type* release() &#123; element_type* ret = data_; data_ = nullptr; return ret; &#125; private: void Destroy() &#123; if (data_) &#123; delete data_; data_ = nullptr; &#125; &#125; element_type* data_;&#125;; unique_ptr使用相比于auto_ptr，unique_ptr有如下优点 不要将同一个原生指针赋值给多个智能指针 禁用拷贝构造函数和赋值运算符 使用移动语义std::move转移所有权 使用移动语义可以作为STL容器的元素，但某些需要拷贝和赋值的算法操作会受限 支持数组，并提供operator[]，使用delete[]释放内存 支持自定义deleter 1234567891011121314151617181920212223242526272829303132333435&#123; std::string name = \"student1\"; double score = 100.0; gtl::unique_ptr&lt;Student&gt; p(gtl::make_unique&lt;Student&gt;(name, score)); auto* p_bak = p.get(); EXPECT_NE(p.get(), nullptr); EXPECT_EQ(name, p-&gt;name()); EXPECT_EQ(score, p-&gt;score()); gtl::unique_ptr&lt;Person&gt; p2(std::move(p)); EXPECT_EQ(p.get(), nullptr); EXPECT_EQ(p2.get(), p_bak); EXPECT_EQ(name, p2-&gt;name()); p2 = std::move(p2); EXPECT_EQ(p2.get(), p_bak); EXPECT_EQ(name, p2-&gt;name()); gtl::unique_ptr&lt;Person&gt; p3; p3 = std::move(p2);&#125;&#123; // 支持数组指针即使用new[]/delete[] int n = 10; gtl::unique_ptr&lt;Person[]&gt; p = gtl::make_unique&lt;Person[]&gt;(n); Person* p_bak = p.get(); EXPECT_NE(p.get(), nullptr); EXPECT_EQ(bool(p), true); p = std::move(p); EXPECT_NE(p.get(), nullptr); EXPECT_EQ(bool(p), true); for (int i = 0; i &lt; n; ++i) &#123; p[i].set_name(std::to_string(i)); EXPECT_EQ(std::to_string(i), p[i].name()); &#125;&#125; unique_ptr实现 unique_ptr存在针对对象和数组的两个版本 分别使用new/delete和new[]/delete[] 需要支持自定义deleter 禁用拷贝构造函数和赋值运算符 定义移动构造函数和移动复制运算符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120template &lt;typename T, typename Deleter = std::default_delete&lt;T&gt;&gt;class UniquePtr &#123; public: using pointer = T*; using element_type = T; using deleter_type = Deleter; explicit UniquePtr(pointer data = nullptr, deleter_type deleter = deleter_type()) : data_(data), deleter_(deleter) &#123;&#125; UniquePtr(const UniquePtr&amp; other) = delete; UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(std::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125; template &lt;typename Y&gt; UniquePtr(UniquePtr&lt;Y&gt;&amp;&amp; other) : data_(other.release()), deleter_(std::forward&lt;deleter_type&gt;(other.get_deleter())) &#123;&#125; ~UniquePtr() &#123; Destroy(); &#125; UniquePtr&amp; operator=(const UniquePtr&amp; other) = delete; UniquePtr&amp; operator=(UniquePtr&amp;&amp; other) &#123; reset(other.release()); deleter_ = std::forward&lt;deleter_type&gt;(other.deleter_); return *this; &#125; template &lt;typename Y&gt; UniquePtr&amp; operator=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123; reset(other.release()); deleter_ = std::forward&lt;deleter_type&gt;(other.deleter_); return *this; &#125; pointer operator-&gt;() const &#123; return get(); &#125; element_type&amp; operator*() const &#123; return *get(); &#125; explicit operator bool() const &#123; return data_ != nullptr; &#125; deleter_type&amp; get_deleter() &#123; return deleter_; &#125; const deleter_type&amp; get_deleter() const &#123; return deleter_; &#125; pointer get() const &#123; return data_; &#125; void reset(pointer data = nullptr) &#123; if (data != data_) &#123; Destroy(); data_ = data; &#125; &#125; pointer release() &#123; pointer ret = data_; data_ = nullptr; return ret; &#125; void swap(UniquePtr&amp; other) &#123; std::swap(data_, other.data_); std::swap(deleter_, other.deleter_); &#125; private: void Destroy() &#123; if (data_) &#123; deleter_(data_); data_ = nullptr; &#125; &#125; pointer data_; deleter_type deleter_;&#125;;template &lt;typename T, typename Deleter&gt;class UniquePtr&lt;T[], Deleter&gt; &#123; public: using pointer = T*; using element_type = T; using deleter_type = Deleter; explicit UniquePtr(pointer data = nullptr) : data_(data) &#123;&#125; UniquePtr(const UniquePtr&amp; other) = delete; UniquePtr(UniquePtr&amp;&amp; other) : data_(other.release()), deleter_(std::forward&lt;deleter_type&gt;(other.deleter_)) &#123;&#125; ~UniquePtr() &#123; Destroy(); &#125; UniquePtr&amp; operator=(const UniquePtr&amp; other) = delete; UniquePtr&amp; operator=(UniquePtr&amp;&amp; other) &#123; reset(other.release()); deleter_ = std::forward&lt;deleter_type&gt;(other.deleter_); return *this; &#125; template &lt;typename Y&gt; UniquePtr&amp; operator=(UniquePtr&lt;Y&gt;&amp;&amp; other) &#123; reset(other.release()); deleter_ = std::forward&lt;deleter_type&gt;(other.deleter_); return *this; &#125; element_type&amp; operator[](std::size_t index) const &#123; return data_[index]; &#125; explicit operator bool() const &#123; return data_ != nullptr; &#125; deleter_type&amp; get_deleter() &#123; return deleter_; &#125; const deleter_type&amp; get_deleter() const &#123; return deleter_; &#125; pointer get() const &#123; return data_; &#125; void reset(pointer data = nullptr) &#123; Destroy(); data_ = data; &#125; pointer release() &#123; pointer ret = data_; data_ = nullptr; return ret; &#125; void swap(UniquePtr&amp; other) &#123; std::swap(data_, other.data_); std::swap(deleter_, other.deleter_); &#125; private: void Destroy() &#123; if (data_) &#123; deleter_(data_); data_ = nullptr; &#125; &#125; pointer data_; deleter_type deleter_;&#125;; shared_ptr和weak_ptr使用 不要将同一个原生指针赋值给多个智能指针 shared_ptr是共享所有权的智能指针，使用上更像普通指针 支持数组（C++17） 注意循环引用——将任一shared_ptr替换为weak_ptr打破循环即可 weak_ptr无法访问其所管理的资源，其是为了解决循环引用的问题，weak_ptr不会增加引用计数 weak_ptr可以通过expired函数判断对应的资源是否已经释放 访问所管理的对象必须通过lock函数返回一个shared_ptr对象（注意判断返回值是否为空，可能其所对应的资源已经释放） 线程安全问题 多个线程在不同shared_ptr的实例上调用所有成员函数（包含复制构造和赋值）是安全的，即使他们共享同一个对象的所有权 多个线程只读方式访问同一个shared_ptr的实例是安全的 多个线程访问同一个shared_ptr的实例的非const成员函数是不安全的，会出现数据竞争 所拥有资源的线程安全由资源本身决定 循环引用的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class Student : public Person &#123; public: // ... private: double score_; SharedPtr&lt;Teacher&gt; teacher_;&#125;;class Teacher : public Person &#123; public: // ... private: int id_; SharedPtr&lt;Student&gt; student_; WeakPtr&lt;Student&gt; student_weak_;&#125;;&#123; // teacher包含student，student包含teacher，会造成循环引用 // 析构时引用数都不会变为0，造成内存泄漏 gtl::shared_ptr&lt;Teacher&gt; teacher(gtl::make_shared&lt;Teacher&gt;(\"teacher\", 10)); gtl::shared_ptr&lt;Student&gt; student(gtl::make_shared&lt;Student&gt;(\"student\", 100.0)); printf(\"%s count %zu\\n\", teacher-&gt;name().c_str(), teacher.use_count()); printf(\"%s count %zu\\n\", student-&gt;name().c_str(), student.use_count()); EXPECT_EQ(teacher.use_count(), 1); EXPECT_EQ(student.use_count(), 1); teacher-&gt;set_student(student); student-&gt;set_teacher(teacher); printf(\"%s count %zu\\n\", teacher-&gt;name().c_str(), teacher.use_count()); printf(\"%s count %zu\\n\", student-&gt;name().c_str(), student.use_count()); EXPECT_EQ(teacher.use_count(), 2); EXPECT_EQ(student.use_count(), 2);&#125;&#123; gtl::WeakPtr&lt;Student&gt; student_weak_bak; &#123; gtl::shared_ptr&lt;Teacher&gt; teacher_weak(gtl::make_shared&lt;Teacher&gt;(\"teacher_weak\", 10)); gtl::shared_ptr&lt;Student&gt; student_weak(gtl::make_shared&lt;Student&gt;(\"student_weak\", 100.0)); printf(\"%s count %zu\\n\", teacher_weak-&gt;name().c_str(), teacher_weak.use_count()); printf(\"%s count %zu\\n\", student_weak-&gt;name().c_str(), student_weak.use_count()); EXPECT_EQ(teacher_weak.use_count(), 1); EXPECT_EQ(student_weak.use_count(), 1); teacher_weak-&gt;set_student_weak(student_weak); student_weak-&gt;set_teacher(teacher_weak); printf(\"%s count %zu\\n\", teacher_weak-&gt;name().c_str(), teacher_weak.use_count()); printf(\"%s count %zu\\n\", student_weak-&gt;name().c_str(), student_weak.use_count()); EXPECT_EQ(teacher_weak.use_count(), 2); EXPECT_EQ(student_weak.use_count(), 1); student_weak_bak = student_weak; EXPECT_EQ(student_weak_bak.use_count(), 1); EXPECT_EQ(student_weak_bak.expired(), false); EXPECT_EQ(bool(student_weak_bak.lock()), true); printf(\"student_weak ptr %p\\n\", student_weak.get()); &#125; printf(\"weak test\\n\"); EXPECT_EQ(student_weak_bak.use_count(), 0); EXPECT_EQ(student_weak_bak.expired(), true); auto stucent_shared_ptr = student_weak_bak.lock(); printf(\"student_weak ptr %p\\n\", stucent_shared_ptr.get()); EXPECT_EQ(bool(stucent_shared_ptr), false);&#125; shared_ptr和weak_ptr实现 shared_ptr包含指向对象的指针和引用计数的指针 包含对象指针是为了不同的对象共享所有权 包含引用计数的指针而不是对象，是为了共享所有权的shared_ptr得到的引用计数是相同的 引用计数包含use_count和weak_count 由于weak_ptr需要在所有的shared_ptr都释放时也能够判断引用计数的数量是否为0，因此shared_ptr释放时，如果weak_count&gt;1，则仅可以释放所管理对象的资源，引用计数的资源不能释放 当weak_ptr析构时，需要判断是否需要释放引用计数的资源 shared_ptr的use_count和weak_count如何变化 以空指针构造，两个指针都为空 以非空指针构造，use_count和weak_count都设置为1 复制构造，若非空则use_count加1 移动构造use_count不变，资源转移到新构造的shared_ptr，被移动的shared_ptr变为空 赋值操作，左侧操作数use_count减1，右侧操作数use_count加1，并且赋值给左操作数，左右侧操作数指向同一对象 移动赋值，左侧操作数use_count减1，右侧操作数use_count不变，并且赋值给左操作数，右侧操作数变为空 shared_ptr析构，use_count减1 use_count为0时，释放所管理对象的资源，weak_count减1（为0时释放引用计数的资源） weak_ptr的use_count和weak_count如何变化 默认构造，weak_ptr不管理任何对象 weak_ptr不接受普通指针构造 复制构造，若非空则weak_count加1 以shared_ptr构造，若非空则weak_count加1 移动构造，weak_count不变，被移动weak_ptr变为空 赋值操作，左侧操作数weak_count减1，右侧操作数weak_count加1，并且赋值给左操作数，左右侧操作数指向同一对象 移动赋值，左侧操作数weak_count减1，右侧操作数weak_count不变，并且赋值给左操作数，右侧操作数变为空 weak_ptr析构，weak_count减1 weak_count为0时，释放引用计数的资源 调用lock函数构造shared_ptr，use_count加1 具体实现可参考smart_pointers.h 123456789101112131415template &lt;typename T&gt;struct RefCount &#123; // ... std::atomic&lt;std::size_t&gt; use_count; // 有多少个shared_ptr指向这个对象 std::atomic&lt;std::size_t&gt; weak_count; // 有多少个weak_ptr指向这个对象&#125;;class SharedPtr &#123; public: // ... private: RefCount* ref_count_; T* data_;&#125; 参考 raii memory C++ Primer Plus（第6版 中文版）","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"智能指针","slug":"编程/智能指针","permalink":"https://gwq5210.com/categories/编程/智能指针/"}],"tags":[{"name":"智能指针","slug":"智能指针","permalink":"https://gwq5210.com/tags/智能指针/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"智能指针","slug":"编程/智能指针","permalink":"https://gwq5210.com/categories/编程/智能指针/"}]},{"title":"STL容器之无序关联容器","slug":"STL容器之无序关联容器","date":"2021-11-14T20:17:36.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/11/14/STL容器之无序关联容器/","link":"","permalink":"https://gwq5210.com/2021/11/14/STL容器之无序关联容器/","excerpt":"","text":"无序关联容器无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 无序关联容器有以下几种 unordered_set：无序集合，键唯一 unordered_map：无序键值对集合，键唯一 unordered_multiset：无序集合，键不唯一 unordered_multimap：无序键值对集合，键不唯一 无序关联容器底层由哈希表实现，下文主要对哈希表进行介绍 哈希表概述哈希表的基本原理是利用数组可以随机存取的特点，通过哈希函数（hasher）将键（key_type）均匀的映射到数组的下标，这样我们可以很快的通过数组下标快速找到对应的元素 数组中的每个元素称为桶（bucket） 这样会存在两个问题： 不同的键映射到了相同的数组下标 数组大小是固定的，添加了更多元素之后，如何对数组进行扩容 解决哈希表碰撞不同的的元素被映射到相同的数组下标，被称为碰撞。解决碰撞有许多种方法 开放定址法：哈希冲突时，从冲突的位置按照一定的次序寻找一个空闲的桶。删除元素时需要进行标记，否则会导致查找错误 线性探测：依次判断位置为i+1,i+2,i+3,到达最后一个桶时从头开始判断 二次探测：依次判断位置为i+1^2,i+2^2,i+3^2 链地址法：哈希冲突时，冲突的元素放在链表中。可以理解为数组的每个桶都是一个链表，只是大部分的链表仅包含一个元素 大部分的实现采用链地址法处理冲突 hashtable 哈希表扩容在一般的实现中，哈希桶的数量为2的次幂，这样可以通过位运算得到元素哈希桶的位置 12size_type bucket_idx = hasher()(key) % bucket_count();size_type bucket_idx = hasher()(key) &amp; (bucket_count() - 1); // 当bucket_count为2的幂时 负载因子和初始容量首先介绍一个负载因子（load factor）的概念：即元素个数除以桶个数。 哈希表一般通过负载因子来指定扩容的临界值。例如负载因子可以设置为0.75。当元素的数量超过bucket_count*load_factor时，会触发扩容操作 哈希表另一个比较重要的概念是初始容量，即初始哈希桶的数量，插入元素较多的情况下可以指定较大的初始容量减少扩容的次数。默认初始容量可以设置为16 扩容步骤哈希表的扩容也称为重新哈希（rehash），大致步骤如下 以2倍的原桶容量（2*old_bucket_count）分配一个新的桶数组 遍历原桶数组，计算原桶数组中的每个元素在新桶数组中的位置，并插入到相应的桶中 在同数量为2的次幂时，可以将桶中元素分为两部分，这两部分元素在新桶数组中的位置分别是：i和i+old_bucket_count（按照位运算很好理解） 所有元素迁移完成之后，释放原桶数组 以下例子是数组+单链表（下文介绍）的重新哈希的代码 12345678910111213141516171819202122232425262728void do_rehash(size_type new_bucket_count) &#123; // 1. 新分配桶数组 BucketStorage new_buckets = alloc_buckets(new_bucket_count); SListNode old_head = head_; buckets_.swap(new_buckets); // 与旧桶数组交换 head_.next = nullptr; get_size() = 0; printf(\"rehash new bucket count %zu %zu\\n\", bucket_count(), new_bucket_count); SListNode* prev = &amp;old_head; // 旧链表的伪头节点，便于实现 SListNode* first = prev-&gt;next; // 2. 遍历所有元素的链表 while (first) &#123; // 计算链表头节点在新桶数组中的位置 const key_type&amp; key = get_key(Node::Value(first)); size_type new_bucket_idx = bucket(key); // 找到相同key的元素 auto range_res = find_range(key, prev); // 将(range_res.first.before, range_res.first.node]这些元素从链表中移除 RemoveAfter(range_res.first.before, range_res.first.node); // 插入到新链表中并设置桶的所在元素的范围 insert_node(new_bucket_idx, buckets_[new_bucket_idx].node_before_begin ? buckets_[new_bucket_idx].node_before_begin : &amp;head_, first, range_res.first.node, range_res.second); // 旧链表的新头节点 first = prev-&gt;next; &#125; printf(\"rehash done. new bucket count %zu\\n\", bucket_count()); // 3. 旧桶数组在作用域结束时自动释放内存&#125; 哈希表的具体实现哈希表一般有以下几种实现 仅数组 迭代元素需要遍历整个桶数组 元素迭代的顺序与插入顺序无关，与在桶中的位置有关 同一个桶内的元素以相反的顺序遍历（在头部插入） 数组+单链表：所有的元素用单链表进行串联 迭代元素无需遍历整个桶数组，迭代次数与元素次数相同 元素的迭代顺序与插入顺序相反（找不到元素时在头部插入） 桶的结构中保存链表节点的指针或迭代器(before, node] 插入元素时如果更改了某个桶的尾元素node，则需要更新node-&gt;next元素所在桶的before指针 单链表包含一个伪头结点head_利于实现 swap时要更新链表头结点的before指针 数组+双链表：所有的元素用双链表进行串联 迭代元素无需遍历整个桶数组，迭代次数与元素次数相同 元素的迭代顺序与插入顺序相同（找不到元素时在尾部插入） 桶的结构中保存链表节点的指针或迭代器[begin, node] 实现相较数组+单链表简单 说明 以上只说明大致思路，具体的实现可能略有不同 以上针对元素key唯一的情况，key相同的情况下，相同的key元素在链表中紧邻存放(相同key的元素的迭代顺序由实现决定，可以不做保证) 哈希表是无序的，不对key进行排序 哈希表重新哈希之后元素迭代顺序会发生变化 哈希表的实现中，会提供两个函数insert_unique和insert_equal分别来实现unordered_set/unordered_map和unordered_multiset/unordered_multimap（也可通过模板特化来针对唯一key或相同key实现不同的逻辑，提升性能） 数组+单链表的实现介绍数据结构结构12345678910111213141516171819202122232425struct SListNode &#123; SListNode* next; SListNode() : next(nullptr) &#123;&#125; void init() &#123; next = nullptr; &#125;&#125;;template &lt;typename Key, typename Value, typename ExtractKey, typename Hash = std::hash&lt;Key&gt;, typename KeyEquel = std::equal_to&lt;Key&gt;&gt;class HashTable &#123; public: // 哈希桶的结构，链表中范围(node_before_begin, node_finish]内的节点在该桶内 struct HashNode &#123; HashNode(): node_before_begin(nullptr), node_finish(nullptr) &#123;&#125; HashNode(SListNode* b, SListNode* f): node_before_begin(b), node_finish(f) &#123;&#125; SListNode* node_before_begin; SListNode* node_finish; &#125;; ExtractKey get_key_func_; key_equal key_equal_; hasher hasher_; SListNode head_; float max_load_factor_; BucketStorage buckets_; CompressedPair&lt;size_type, NodeAllocator&gt; size_alloc_;&#125;; insert操作12345678910111213141516171819202122232425262728293031323334353637383940void insert_node(size_type bucket_idx, SListNode* before, SListNode* first, SListNode* last, size_type count) &#123; // 将新的[first, last]内的元素插入到before节点后 InsertAfter(before, first, last); // 更新该桶内的元素范围 buckets_[bucket_idx].insert_node(before, first, last); incr_size(count); // 更新下一个bucket的前一个节点 if (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123; buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = last; &#125;&#125;template &lt;typename... Args&gt;std::pair&lt;iterator, bool&gt; insert_node(bool unique, const_iterator hint, Args&amp;&amp;... args) &#123; // 原位构造元素 Node* node = NewNode(std::forward&lt;Args&gt;(args)...); SListNode* prev = hint.node; const key_type&amp; key = get_key(Node::Value(node)); size_type bucket_idx = bucket(key); // 元素唯一的情况下，已找到元素直接结束插入 if (prev &amp;&amp; (key_equal_(get_key(Node::Value(prev)), key) || (prev-&gt;next &amp;&amp; key_equal_(get_key(Node::Value(prev-&gt;next)), key)))) &#123; // hint或hint-&gt;next对应元素的key与新元素的key相同，使用hint作为插入位置 if (unique) &#123; DeleteNode(node); return std::make_pair(iterator(), false); &#125; &#125; else &#123; // 找到对应元素的插入位置 FindNodeResult result = find_node(key, bucket_idx); if (unique &amp;&amp; result.node) &#123; DeleteNode(node); return std::make_pair(iterator(), false); &#125; prev = result.before; &#125; // 插入元素 insert_node(bucket_idx, prev, node); // 可以先添加，然后再rehash check_for_rehash(0); return std::make_pair(iterator(node), true);&#125; find操作查找单节点12345678910111213141516171819FindNodeResult find_node(const key_type&amp; key) const &#123; // 定位到哈希桶 return find_node(key, bucket(key));&#125;FindNodeResult find_node(const key_type&amp; key, size_type bucket_idx) const &#123; const HashNode&amp; hnode = buckets_[bucket_idx]; // 该桶为空直接返回未找到 if (hnode.empty()) &#123; return &#123;const_cast&lt;SListNode*&gt;(&amp;head_), nullptr&#125;; &#125; // 依次查找该桶的元素，找到相同的key则返回 for (SListNode* prev = hnode.node_before_begin; prev-&gt;next != hnode.node_finish-&gt;next; prev = prev-&gt;next) &#123; if (key_equal_(key, get_key(Node::Value(prev-&gt;next)))) &#123; return &#123;prev, prev-&gt;next&#125;; &#125; &#125; // 到这里说明没找到 return &#123;hnode.node_before_begin, nullptr&#125;;&#125; 查找范围123456789101112131415161718192021222324252627std::pair&lt;iterator, iterator&gt; equal_range(bool unique, const key_type&amp; key) &#123; // 先查找单个元素，未找到则直接返回 auto res = find_node(key); if (!res.node) &#123; return std::make_pair(iterator(), iterator()); &#125; // 如果键唯一，则找到后直接返回 if (unique) &#123; return std::make_pair(iterator(res.node), iterator(res.node-&gt;next)); &#125; else &#123; // 键不唯一，从before开始查找相同key的元素范围 auto range_res = find_range(key, res.before); return std::make_pair(iterator(res.node), iterator(range_res.first.node-&gt;next)); &#125;&#125;std::pair&lt;FindNodeResult, size_type&gt; find_range(const key_type&amp; key, const SListNode* before) const &#123; std::pair&lt;FindNodeResult, size_type&gt; res = std::make_pair(FindNodeResult(), 0); // 从before-&gt;next开始，直到key不相同 res.first.before = const_cast&lt;SListNode*&gt;(before); while (before-&gt;next &amp;&amp; key_equal_(key, get_key(Node::Value(before-&gt;next)))) &#123; before = before-&gt;next; ++res.second; &#125; // 此时before为key的最后一个元素 res.first.node = const_cast&lt;SListNode*&gt;(before); return res;&#125; 删除操作删除单个元素的操作相对简单，这里是删除范围的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556iterator erase(const_iterator first, const_iterator last) &#123; // 范围为空，直接返回 if (first == last) &#123; return iterator(last.node); &#125; // 找到first的前一个节点before const value_type&amp; value = Node::Value(first.node); size_type bucket_idx = bucket(get_key(value)); SListNode* before = PrevNode(buckets_[bucket_idx].node_before_begin, first.node); SListNode* prev = before; // printf(\"erase range before key: %d\\n\", get_key(Node::Value(before))); // 遍历[first, last)的节点并删除 while (prev-&gt;next != last.node) &#123; HashNode&amp; hnode = buckets_[bucket_idx]; SListNode* node_end = hnode.node_finish-&gt;next; // printf(\"erase begin\\n\"); size_type count = 0; // 判断该桶内元素删除的范围 while (prev-&gt;next != node_end &amp;&amp; prev-&gt;next != last.node) &#123; // printf(\"erase range key: %d\\n\", Node::Value(prev-&gt;next)); prev = prev-&gt;next; ++count; &#125; // 执行元素的删除 erase_node(bucket_idx, before, prev, count); prev = before; // printf(\"bucket %zu size %zu\\n\", bucket_idx, hnode.size()); // 已经删除完毕，break if (prev-&gt;next == last.node) &#123; break; &#125; // 计算下一个删除元素的桶位置 bucket_idx = bucket(get_key(Node::Value(prev-&gt;next))); &#125; return iterator(last.node);&#125;void erase_node(size_type bucket_idx, SListNode* before, SListNode* last, size_type count) &#123; // 如果是最后一个元素，则下一个bucket的前一个节点需要更新 if (last-&gt;next &amp;&amp; last == buckets_[bucket_idx].node_finish) &#123; buckets_[bucket(get_key(Node::Value(last-&gt;next)))].node_before_begin = before; &#125; SListNode* first = before-&gt;next; SListNode* next = first-&gt;next; // 更新该桶节点的范围 buckets_[bucket_idx].erase_node(before, last); // 将元素从链表中删除 RemoveAfter(before, last); // 更新size incr_size(-count); // 析构节点并释放内存 while (first) &#123; next = first-&gt;next; DeleteNode(first); first = next; &#125;&#125; rehash操作上文已介绍 迭代器实现可直接使用单链表的迭代器 12345678910111213141516171819202122232425262728293031323334353637383940414243struct SListIteratorBase &#123; using iterator_category = std::forward_iterator_tag; using Self = SListIteratorBase; SListNode* node; SListIteratorBase() : node(nullptr) &#123;&#125; SListIteratorBase(SListNode* n) : node(n) &#123;&#125; Self&amp; operator++() &#123; node = node-&gt;next; return *this; &#125; Self operator++(int) &#123; SListNode* ret = node; node = node-&gt;next; return Self(ret); &#125; bool operator==(const Self&amp; other) const &#123; return node == other.node; &#125; bool operator!=(const Self&amp; other) const &#123; return node != other.node; &#125;&#125;;template &lt;typename T, typename Difference = std::ptrdiff_t&gt;struct SListConstIterator : public SListIteratorBase &#123; using reference = const T&amp;; using pointer = const T*; using difference_type = Difference; using value_type = T; using Node = singly_list::SListNodeT&lt;T&gt;; using Base = SListIteratorBase; using Self = SListConstIterator; SListConstIterator(): Base() &#123;&#125; explicit SListConstIterator(const SListNode* node) : Base(const_cast&lt;SListNode*&gt;(node)) &#123;&#125; reference operator*() const &#123; return Node::Value(node); &#125; pointer operator-&gt;() const &#123; return std::pointer_traits&lt;pointer&gt;::pointer_to(**this); &#125; Self&amp; operator++() &#123; Base::operator++(); return *this; &#125; Self operator++(int) &#123; auto ret = *this; Base::operator++(); return ret; &#125;&#125;; 迭代器失效 无重新哈希：无序关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器） 插入元素导致重新哈希：迭代器（包括end迭代器）非法化，引用有效 无序关联式容器的注意事项 unordered_map的operator[]可能会新增元素 无序关联式容器的元素没有顺序 删除元素时注意迭代器失效的问题；代码unordered_map.erase(it); it++;是错误的 无法通过迭代器修改键值，但可以修改unordered_map/unordered_multimap的value值 参考 容器库 STL源码剖析 HashMap&amp;HashSet","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"无序关联容器","slug":"无序关联容器","permalink":"https://gwq5210.com/tags/无序关联容器/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之关联容器","slug":"STL容器之关联容器","date":"2021-11-14T20:16:41.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/11/14/STL容器之关联容器/","link":"","permalink":"https://gwq5210.com/2021/11/14/STL容器之关联容器/","excerpt":"","text":"关联容器关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。 关联容器有以下几种 set：有序集合，键唯一 map：键值对集合，键唯一 multiset：键集合，键不唯一 multimap：键值对集合，键不唯一 关联容器的实现关联容器的内部由红黑树实现，红黑树是一颗平衡的二叉搜索树（BST，Binary Search Tree） 在二叉搜索树中，任何节点的值一定大于左子树每一个节点的键值，小于右子树中每一个节点的键值 但是在极端的情况下，二叉搜索树可能失去平衡，退化为一个链表，造成查找效率低下。因此出现了平衡二叉搜索树，如AVL-tree，红黑树等 STL的红黑树实现中，会提供两个函数insert_unique和insert_equal分别来实现set/map和multiset/multimap 由于实现的特性，关联式容器是根据键值有序的，默认从小到大排序（使用std::less进行比较） rbtree 为什么选择红黑树AVL树要求每个节点的左右子树高度差不超过1，因此其最坏的查找时间为O(logn) 但为了严格满足AVL树的高度要求，在每次插入或删除节点时，几乎都会破坏AVL树的平衡，进而我们需要通过旋转来使之平衡 显然这对插入，删除频繁的场景很不友好，性能大大降低 而红黑树的高度要求不像AVL树那样严格，频繁插入删除不会频繁破坏平衡，也就不需要频繁调整，这其实是一种折中的方案 但仅从查找效率来说，AVL树要由于红黑树 总的来说：平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况 迭代器失效关联容器的迭代器和引用除了元素被删除外不会被非法化（包括end迭代器） 关联式容器的注意事项 map的operator[]可能会新增元素 关联式容器实现了lower_bound，upper_bound和equal_range的成员函数 使用通用的lower_bound，upper_bound和equal_range函数会导致查找效率变低（用在非随机存取迭代器上都会导致效率变低） 删除元素时注意迭代器失效的问题；代码map.erase(it); it++;是错误的 无法通过迭代器修改键值，但可以修改map/multimap的value值 参考 容器库 STL源码剖析 平衡树和红黑树","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"关联容器","slug":"关联容器","permalink":"https://gwq5210.com/tags/关联容器/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之priority_queue","slug":"STL容器之priority-queue","date":"2021-10-26T00:15:50.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/26/STL容器之priority-queue/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之priority-queue/","excerpt":"","text":"优先队列与stack和queue相同，priority_queue是容器适配器，可提供常数时间获取最大元素，对数复杂度的插入和删除元素 可以通过模板参数Compare更改顺序，默认使用std::less进行比较，返回最大元素 priority_queue的底层用堆实现 二叉堆堆并不属于容器组件，是一个数据结构，堆实际上是一个完全二叉树（整个二叉树除了最底层的叶节点外，是填满的），并且每个节点的键值都大于等于/小于等于其父节点的值 heap 由于二叉树的性质，我们可以使用数组来表示一个二叉堆(假设下标从0开始) 下标为i的节点的子节点为2*i+1和2*i+2 下标为i的节点的父节点为(i-1)/2 插入操作在已有的堆中插入元素，一般在堆最下层最右边的叶子之后插入一个元素（或者新增一层） 插入新元素之后，可能不满足堆的性质，这时候需要进行向上调整（sift_up）的操作 如果这个节点的值大于父节点的值，则与父节点进行交换，重复次过程直到满足堆的条件或者到达根 向上调整的时间复杂度是O(logn) 12345void sift_up(int x) &#123; for (int i = x; i &gt; 0 &amp;&amp; arr[(i - 1) / 2] &lt; arr[i]; i = (i - 1) / 2) &#123; std::swap(arr[i], arr[(i - 1) / 2]); &#125;&#125; 删除操作删除操作是删除堆的最大元素，一般将最大元素即根节点与最后一个节点交换，再将新的根节点进行向下调整（sift_down）的操作 在该节点的儿子中选择较大节点与该节点进行交换，重复此操作直到底层或已满足堆的条件 向下调整的时间复杂度是O(logn) 123456789101112void sift_down(int x) &#123; for (int i = x; i &lt; n / 2; i = 2 * x + 1) &#123; int j = 2 * x + 1; if (j + 1 &lt; n &amp;&amp; arr[j + 1] &gt; arr[j]) &#123; ++j; &#125; if (arr[i] &gt;= arr[j]) &#123; break; &#125; std::swap(arr[i], arr[j]); &#125;&#125; 构建堆向上调整建堆即相当于每次在堆的结尾添加一个元素，比较好理解 复杂度为log1+log2+…+logn=O(nlogn) 123for (int i = 0; i &lt; n; ++i) &#123; sift_up(i);&#125; 向下调整建堆从叶子开始建堆，逐个向下调整，相当于每次”合并”两个已经调整好的堆 复杂度为O(n)，每个节点最多向下调整一次，只需要从最后一个非叶子结点进行调整 123for (int i = n / 2 - 1; i &gt;= 0; --i) &#123; sift_down(i);&#125; 堆操作算法STL提供了以下几个算法，可以方便的实现优先队列 push_heap将位置last-1的元素插入到[first, last - 1)定义的堆中 1234567891011template &lt;typename RandomIt, typename Compare&gt;void push_heap(RandomIt first, RandomIt last, Compare comp) &#123; if (first != last) &#123; gtl::sift_up(first, last, gtl::distance(first, last) - 1, comp); &#125;&#125;template &lt;typename RandomIt&gt;void push_heap(RandomIt first, RandomIt last) &#123; return gtl::push_heap(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; pop_heap交换在位置first的值和位置last-1的值，并将范围[first, last-1)调整为堆 这达到将范围[first, last)所定义的堆移除首个元素的效果 12345678910111213template &lt;typename RandomIt, typename Compare&gt;void pop_heap(RandomIt first, RandomIt last, Compare comp) &#123; if (first != last) &#123; --last; gtl::iter_swap(first, last); gtl::sift_down(first, last, 0, comp); &#125;&#125;template &lt;typename RandomIt&gt;void pop_heap(RandomIt first, RandomIt last) &#123; return gtl::pop_heap(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; sort_heap将最大堆[first, last)转换为为以升序排序的序列。 1234567891011template &lt;typename RandomIt, typename Compare&gt;void sort_heap(RandomIt first, RandomIt last, Compare comp) &#123; for (; first != last; --last) &#123; gtl::pop_heap(first, last, comp); &#125;&#125;template &lt;typename RandomIt&gt;void sort_heap(RandomIt first, RandomIt last) &#123; return gtl::sort_heap(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; make_heap在范围[first, last)中构造最大堆 12345678910111213template &lt;typename RandomIt, typename Compare&gt;void make_heap(RandomIt first, RandomIt last, Compare comp) &#123; if (first != last) &#123; for (auto i = gtl::distance(first, last) / 2 - 1; i &gt;= 0; --i) &#123; gtl::sift_down(first, last, i, comp); &#125; &#125;&#125;template &lt;typename RandomIt&gt;void make_heap(RandomIt first, RandomIt last) &#123; return gtl::make_heap(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; is_heap_until检验范围[first, last)并寻找始于first且为最大堆的最大范围 1234567891011121314151617181920212223242526template &lt;typename RandomIt, typename Compare&gt;RandomIt is_heap_until(RandomIt first, RandomIt last, Compare comp) &#123; auto n = gtl::distance(first, last); typename std::iterator_traits&lt;RandomIt&gt;::difference_type i = 0; if (n &lt;= 1) &#123; return last; &#125; auto it = first; auto left_it = first + 1; for (; i &lt; n / 2; ++i, ++it, ++left_it) &#123; if (comp(*it, *left_it)) &#123; return left_it; &#125; ++left_it; if (left_it &lt; last &amp;&amp; comp(*it, *left_it)) &#123; return left_it; &#125; &#125; return last;&#125;template &lt;typename RandomIt&gt;RandomIt is_heap_until(RandomIt first, RandomIt last) &#123; return gtl::is_heap_until(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; is_heap检查范围 [first, last) 中的元素是否为最大堆。 123456789template &lt;typename RandomIt, typename Compare&gt;bool is_heap(RandomIt first, RandomIt last, Compare comp) &#123; return gtl::is_heap_until(first, last, comp) == last;&#125;template &lt;typename RandomIt&gt;bool is_heap(RandomIt first, RandomIt last) &#123; return gtl::is_heap(first, last, std::less&lt;typename std::iterator_traits&lt;RandomIt&gt;::value_type&gt;());&#125; 优先队列的实现有了堆的操作算法，很容易通过这些算法实现优先队列 具体代码如下 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061template &lt;typename T, typename Compare = std::less&lt;T&gt;, typename Container = Vector&lt;T&gt;&gt;class PriorityQueue &#123; public: using container_type = Container; using value_type = typename Container::value_type; using size_type = typename Container::size_type; using reference = typename Container::reference; using const_reference = typename Container::const_reference; template &lt;typename T_, typename Compare_, typename Container_&gt; friend bool operator==(const PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs, const PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs); template &lt;typename T_, typename Compare_, typename Container_&gt; friend bool operator&lt;(const PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; lhs, const PriorityQueue&lt;T_, Compare_, Container_&gt;&amp; rhs); PriorityQueue() = default; explicit PriorityQueue(const Container&amp; c) : c_(c) &#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125; explicit PriorityQueue(Container&amp;&amp; c) : c_(std::move(c)) &#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; PriorityQueue(InputIt first, InputIt last) : c_(first, last) &#123; gtl::make_heap(c_.begin(), c_.end(), compare_); &#125; // Element access const_reference top() const &#123; return c_.front(); &#125; // Capacity bool empty() const &#123; return c_.empty(); &#125; size_type size() const &#123; return c_.size(); &#125; // Modifiers void push(const T&amp; v) &#123; c_.push_back(v); gtl::push_heap(c_.begin(), c_.end(), compare_); &#125; void push(T&amp;&amp; v) &#123; c_.push_back(std::move(v)); gtl::push_heap(c_.begin(), c_.end(), compare_); &#125; template &lt;typename... Args&gt; void emplace(Args&amp;&amp;... args) &#123; c_.emplace_back(std::forward&lt;Args&gt;(args)...); gtl::push_heap(c_.begin(), c_.end(), compare_); &#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; void push(InputIt first, InputIt last) &#123; for (; first != last; ++first) &#123; emplace(*first); &#125; &#125; void pop() &#123; gtl::pop_heap(c_.begin(), c_.end()); c_.pop_back(); &#125; void swap(PriorityQueue&amp; other) &#123; std::swap(c_, other.c_); &#125; private: Container c_; Compare compare_;&#125;; // class PriorityQueue 参考 容器库 算法库 STL源码剖析 二叉堆","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"优先队列","slug":"优先队列","permalink":"https://gwq5210.com/tags/优先队列/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之queue","slug":"STL容器之queue","date":"2021-10-26T00:15:39.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/26/STL容器之queue/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之queue/","excerpt":"","text":"queue概述queue是一种先进先出(First In First Out, FIFO)，它有两个入口，但只允许在一个入口(队尾)添加元素，在另一个入口(队头)获取和删除元素 queue不允许有遍历行为，所以不提供迭代器 queue 通常使用deque来作为queue的底层实现，这种修改接口的方法被称为适配器模式 因此queue往往不归类为container（容器），而被归类为container adapter（容器适配器） STL的实现中，可以通过模板参数修改queue的底层容器 queue实现queue的实现非常简单，完全调用底层容器的接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950template &lt;typename T, typename Container = Deque&lt;T&gt;&gt;class Queue &#123; public: using container_type = Container; using value_type = typename Container::value_type; using size_type = typename Container::size_type; using reference = typename Container::reference; using const_reference = typename Container::const_reference; template &lt;typename T_, typename Container_&gt; friend bool operator==(const Queue&lt;T_, Container_&gt;&amp; lhs, const Queue&lt;T_, Container_&gt;&amp; rhs); template &lt;typename T_, typename Container_&gt; friend bool operator&lt;(const Queue&lt;T_, Container_&gt;&amp; lhs, const Queue&lt;T_, Container_&gt;&amp; rhs); Queue() = default; explicit Queue(const Container&amp; c) : c_(c) &#123;&#125; explicit Queue(Container&amp;&amp; c) : c_(std::move(c)) &#123;&#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; Queue(InputIt first, InputIt last) : c_(first, last) &#123;&#125; ~Queue() = default; // Element access reference front() &#123; return c_.front(); &#125; const_reference front() const &#123; return c_.front(); &#125; reference back() &#123; return c_.back(); &#125; const_reference back() const &#123; return c_.back(); &#125; // Capacity bool empty() const &#123; return c_.empty(); &#125; size_type size() const &#123; return c_.size(); &#125; // Modifiers void push(const T&amp; v) &#123; c_.push_back(v); &#125; void push(T&amp;&amp; v) &#123; c_.push_back(std::move(v)); &#125; template &lt;typename... Args&gt; void emplace(Args&amp;&amp;... args) &#123; c_.emplace_back(std::forward&lt;Args&gt;(args)...); &#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; void push(InputIt first, InputIt last) &#123; for (; first != last; ++first) &#123; emplace(*first); &#125; &#125; void pop() &#123; c_.pop_front(); &#125; void swap(Queue&amp; other) &#123; std::swap(c_, other.c_); &#125; private: Container c_;&#125;; // class Queue 参考 容器库 STL源码剖析","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"队列","slug":"队列","permalink":"https://gwq5210.com/tags/队列/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之stack","slug":"STL容器之stack","date":"2021-10-26T00:15:34.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/26/STL容器之stack/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之stack/","excerpt":"","text":"stack概述stack是一种先进后出(First In Last Out, FILO)的结构，它只有一个入口和出口。 stack不允许有遍历行为，所以不提供迭代器 stack stack是一种很简单的数据接口，只允许在栈顶新增，删除，获取元素 通常使用deque来作为stack的底层实现，这种修改接口的方法被称为适配器模式 因此stack往往不归类为container（容器），而被归类为container adapter（容器适配器） STL的实现中，可以通过模板参数修改stack的底层容器 stack实现stack的实现非常简单，完全调用底层容器的接口 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647template &lt;typename T, typename Container = Deque&lt;T&gt;&gt;class Stack &#123; public: using container_type = Container; using value_type = typename Container::value_type; using size_type = typename Container::size_type; using reference = typename Container::reference; using const_reference = typename Container::const_reference; template &lt;typename T_, typename Container_&gt; friend bool operator==(const Stack&lt;T_, Container_&gt;&amp; lhs, const Stack&lt;T_, Container_&gt;&amp; rhs); template &lt;typename T_, typename Container_&gt; friend bool operator&lt;(const Stack&lt;T_, Container_&gt;&amp; lhs, const Stack&lt;T_, Container_&gt;&amp; rhs); Stack() = default; explicit Stack(const Container&amp; c) : c_(c) &#123;&#125; explicit Stack(Container&amp;&amp; c) : c_(std::move(c)) &#123;&#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; Stack(InputIt first, InputIt last) : c_(first, last) &#123;&#125; // Element access reference top() &#123; return c_.back(); &#125; const_reference top() const &#123; return c_.back(); &#125; // Capacity bool empty() const &#123; return c_.empty(); &#125; size_type size() const &#123; return c_.size(); &#125; // Modifiers void push(const T&amp; v) &#123; c_.push_back(v); &#125; void push(T&amp;&amp; v) &#123; c_.push_back(std::move(v)); &#125; template &lt;typename... Args&gt; void emplace(Args&amp;&amp;... args) &#123; c_.emplace_back(std::forward&lt;Args&gt;(args)...); &#125; template &lt;typename InputIt, typename Category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category&gt; void push(InputIt first, InputIt last) &#123; for (; first != last; ++first) &#123; emplace(*first); &#125; &#125; void pop() &#123; c_.pop_back(); &#125; void swap(Stack&amp; other) &#123; std::swap(c_, other.c_); &#125; private: Container c_;&#125;; // class Stack 参考 容器库 STL源码剖析","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"栈","slug":"栈","permalink":"https://gwq5210.com/tags/栈/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之deque","slug":"STL容器之deque","date":"2021-10-26T00:15:29.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/26/STL容器之deque/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之deque/","excerpt":"","text":"deque概述deque（ double-ended queue ，双端队列）是有下标的顺序容器，可以在首位两端快速插入或删除数据。与vector的连续空间存储不同，deque的元素可能不是相邻存储的 vecotr也允许在头尾两端添加或删除数据，但可能会涉及到元素的移动和扩容，导致效率不高 deque的迭代器也提供随机存储功能，但与vector的迭代器是普通指针不同，为了实现随机存取，deque的迭代器实现比较复杂 deque的存储按需自动扩展及收缩。deque的扩容相比vector更优，它既不会涉及到元素的移动，也不会过多的浪费存储空间 deque常见操作的复杂度 随机访问——常数 O(1) 在结尾或起始插入或移除元素——常数 O(1) 插入或移除元素——线性 O(n) deque的实现deque由一段一段固定大小的连续空间组成，扩容时，便在deque的首或尾新增一个固定大小的连续空间，这就需要额外的结构来串联起这一段段的固定大小空间 同时为了实现随机存取的接口，则实现了复杂的迭代器架构 deque采用的是两层架构，采用map（与STL的map不同），记录有多少个固定的连续空间，其中的每个元素称为节点缓冲区，存储实际的元素。 有的实现我们可以指定固定缓冲区的大小 这就意味着为了访问真实的元素，必须先定为到节点缓冲区，然后再定位到元素本身，需要进行两次指针访问，而vector只需要一次指针访问 map中的节点缓冲区满时，需要重新分配map本身的区域，移动原有的节点缓冲区到新的map区域，但这代价很小，仅仅是移动指针而已 deque deque的数据结构如下 1234567891011template &lt;typename T&gt;class deque &#123; public: typedef T value_type; typedef value_type* pointer; typedef pointer* map_pointer; private: map_pointer map; // 记录节点缓冲区 size_type map_size; // map可以容纳多少个缓冲区&#125;; deque的迭代器通过deque的结构可以知道，deque的迭代器至少需要保存两个信息：当前元素在哪个节点缓冲区；当前元素在这个缓冲区的哪个位置 如可能的结构如下 1234567891011121314151617class deque_iterator &#123; public: Self&amp; operator++() &#123; ++cur; if (cur == last) &#123; // 到达该节点缓冲区的尾部就切换到下一个缓冲区 set_node(node + 1); cur = first; &#125; return *this; &#125; private: T* cur; // 当前元素 T* first; // 当前节点缓冲区的第一个元素 T* last; // 当前节点缓冲区的尾，包含备用空间 map_pointer node; // 指向管控中心&#125;; 迭代器的失效 在队列中间的插入操作导致所有迭代器和引用失效——可能涉及到元素移动或map中控器扩容 在队列头尾插入操作会导致迭代器失效——可能涉及map中控器扩容，但不会非法化引用 在队列中间擦除操作导致所有迭代器和引用失效——涉及元素移动 在队列头尾擦除操作导致擦除元素的迭代器失效（在尾部删除还会导致end迭代器失效），但不会非法化未擦除元素的引用 参考 容器库 STL源码剖析","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"双端队列","slug":"双端队列","permalink":"https://gwq5210.com/tags/双端队列/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之list","slug":"STL容器之list","date":"2021-10-26T00:15:25.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/26/STL容器之list/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之list/","excerpt":"","text":"list概述不同于vector，list的元素在逻辑上相邻，但是在物理内存上是不相邻的，正因为如此，它们之间通过前后指针进行关联 同时list也不会浪费空间(实际上会多占用前后指针的空间)，有多少个元素就占用多少空间 list的元素插入是常数级别，但无法想vector一样实现随机元素访问 在list内添加，删除或移动元素不会导致已有迭代器失效或引用非法，对应元素被删除时该迭代器失效或引用非法 list的实现list节点list本身和list的节点是不同的结构，常见的list节点如下，包含前后指针 1234567// 要实现一个通用的链表需要使用模板类template &lt;class T&gt;struct ListNode &#123; ListNode* prev; ListNode* next; T data;&#125;; list结构在STL的list实现中，list不仅是一个双向链表，还是一个环形双向链表 实现list的一个技巧是添加一个虚拟的空白节点，让list的end迭代器指向该空白节点，既符合STL迭代器前闭后开的要求，也方便了编程的实现 list 代码如下 1234567891011121314template &lt;typename T&gt;class List &#123; public: List() &#123; dummy_head_ = node_allocator::allocate(); // 分配一个空间，不设置值 dummy_head_-&gt;prev = dummy_head_; // 头尾都指向自己 dummy_head_-&gt;next = dummy_head_; &#125; iterator begin() &#123; return dummy_head_-&gt;next; &#125; // begin是next节点 iterator end() &#123; return dummy_head_; &#125; // end是虚拟节点自身 private: ListNode&lt;T&gt;* dummy_head_;&#125;; list的迭代器由于list的特殊实现方式，因此我们需要实现一个list的迭代器，允许用户遍历list中保存的元素 迭代器的表现类似指针，list的迭代器是双向迭代器，支持++和–操作，同时要实现*和-&gt;运算符 典型的实现如下 1234567891011121314151617181920212223242526272829303132333435363738template &lt;class T&gt;struct ListIteratorBase &#123; using iterator_category = std::bidirectional_iterator_tag; using Self = ListIteratorBase; ListNode&lt;T&gt;* node; ListIteratorBase() : node(nullptr) &#123;&#125; ListIteratorBase(ListNode&lt;T&gt;* n) : node(n) &#123;&#125; // ++it; Self&amp; operator++() &#123; node = node-&gt;next; return *this; &#125; // it++; Self operator++(int) &#123; ListNode&lt;T&gt;* ret = node; node = node-&gt;next; return Self(ret); &#125; // --it; Self&amp; operator--() &#123; node = node-&gt;prev; return *this; &#125; // it++; Self operator--(int) &#123; ListNode&lt;T&gt;* ret = node; node = node-&gt;prev; return Self(ret); &#125; reference operator*() const &#123; return node-&gt;data; &#125; // *(*this) *this即为迭代器本身，则第一个*为调用迭代器的operator*，返回数据的引用 pointer operator-&gt;() const &#123; return std::pointer_traits&lt;pointer&gt;::pointer_to(**this); &#125; bool operator==(const Self&amp; other) const &#123; return node == other.node; &#125; bool operator!=(const Self&amp; other) const &#123; return node != other.node; &#125;&#125;; 参考 容器库 STL源码剖析","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"链表","slug":"链表","permalink":"https://gwq5210.com/tags/链表/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器之空间配置器","slug":"STL容器之空间配置器","date":"2021-10-26T00:12:46.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/10/26/STL容器之空间配置器/","link":"","permalink":"https://gwq5210.com/2021/10/26/STL容器之空间配置器/","excerpt":"","text":"空间配置器从STL使用的角度，我们一般不需要了解空间配置器（allocator）；但是从STL实现的角度，空间配置器就很重要了 allocator为什么叫做空间配置器，不叫内存配置器？因为allocator的实现不仅可以从内存分配空间，也可以从磁盘分配空间 在STL容器的实现中，每个容器都有一个模板参数，可以指定使用的空间配置器 allocator包含以下类型 value_type：T pointer (C++17 中弃用)(C++20 中移除)：T* const_pointer (C++17 中弃用)(C++20 中移除)：const T* reference (C++17 中弃用)(C++20 中移除)：T&amp; const_reference (C++17 中弃用)(C++20 中移除)：const T&amp; size_type：std::size_t difference_type：std::ptrdiff_t allocator主要包含以下成员函数 allocate：分配未初始化的存储 deallocate：解分配存储 construct(C++17 中弃用)(C++20 中移除)：在分配的存储构造对象 destroy (C++17 中弃用)(C++20 中移除)：析构在已分配存储中的对象 在C++的头文件&lt;memory&gt;中定义了一些与未初始化内存相关的函数，在STL容器的实现中，起到了很大的作用，如construct_at(C++20)，uninitialized_copy，uninitialized_fill等 空间配置器在STL容器中的应用STL容器的实现思想中，实际上将空间的分配/释放和对象的构造/析构进行了拆分：空间配置器负责空间的分配/释放；&lt;memory&gt;中的未初始化内存相关的函数负责对象构造/析构，移动等 能够实现上述拆分，主要由于C++的以下特性 operator new只进行内存分配，不进行对象构造 placement new是operator new的一个特殊版本，在已分配的内存上构造对象 new关键字的作用是：调用operator new，并调用对象的构造函数 以下两种代码实际上是等价的 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;string&gt;#include &lt;vector&gt;class Test &#123; public: Test(const std::string&amp; name): name_(name) &#123; printf(\"construct %s\\n\", name_.c_str()); &#125; ~Test() &#123; printf(\"destroy %s\\n\", name_.c_str()); &#125; private: std::string name_;&#125;;int main(int argc, char* argv[]) &#123; &#123; // 代码1 auto* t = new Test(\"new_test\"); delete t; &#125; &#123; // 代码2 void* p = ::operator new(sizeof(Test)); auto* t = reinterpret_cast&lt;Test*&gt;(p); t-&gt;Test::Test(\"allocator_test\"); // auto* t = new (p) Test(\"allocator_test\"); // placement new t-&gt;~Test(); ::operator delete(p); &#125; return 0;&#125;/*output:construct new_testdestroy new_testconstruct allocator_testdestroy allocator_test*/ 未初始化内存算法的实现有了上述基础，可以实现简单的未初始化内存的算法，更多实现参见gtl_memory.h construct_at用到了std::forward的完美转发（C++11），两次强制转换是为了除去cv限定符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960// 在给定地址 p 创建以参数 args... 初始化的 T 对象template &lt;typename T, typename... Args&gt;T* construct_at(T* p, Args&amp;&amp;... args) &#123; ::new (const_cast&lt;void*&gt;(static_cast&lt;const volatile void*&gt;(p))) T(std::forward&lt;Args&gt;(args)...); return p;&#125;/** * @brief 销毁指针p指向的对象 * 若 T 不是数组类型，则调用 p 所指向对象的析构函数，如同用 p-&gt;~T() * 若 T 是数组类型，则按顺序递归地销毁 *p 的元素，如同通过调用 std::destroy(std::begin(*p), std::end(*p)) * C++17 version: * template&lt;class T&gt; void destroy_at(T* p) &#123; p-&gt;~T(); &#125; * * @param p 指向要被销毁的对象的指针 */template &lt;typename T&gt;void destroy_at(T* p) &#123; if constexpr (std::is_array_v&lt;T&gt;) &#123; // C++ 20 for (auto&amp; v : *p) &#123; gtl::destroy_at(gtl::addressof(v)); &#125; &#125; else &#123; p-&gt;~T(); &#125;&#125;template &lt;typename InputIt, typename ForwardIt&gt;ForwardIt uninitialized_copy_range(InputIt first, InputIt last, ForwardIt d_first, std::input_iterator_tag, std::forward_iterator_tag) &#123; for (; first != last; ++first, ++d_first) &#123; gtl::construct_at(gtl::addressof(*d_first), *first); &#125; return d_first;&#125;template &lt;typename InputIt, typename SizeType, typename ForwardIt&gt;ForwardIt uninitialized_copy_range_n(InputIt first, SizeType count, ForwardIt d_first, std::input_iterator_tag, std::forward_iterator_tag) &#123; for (; count &gt; 0; ++first, ++d_first, --count) &#123; gtl::construct_at(gtl::addressof(*d_first), *first); &#125; return d_first;&#125;/** * @brief 复制来自范围 [first, last) 的元素到始于 d_first 的未初始化内存 * 若初始化中抛异常，则以未指定顺序销毁已构造的对象 * * @return ForwardIt 指向最后复制的元素后一元素的迭代器 * * TODO: 处理异常的情况 */template &lt;typename InputIt, typename ForwardIt&gt;ForwardIt uninitialized_copy(InputIt first, InputIt last, ForwardIt d_first) &#123; using input_iterator_category = typename std::iterator_traits&lt;InputIt&gt;::iterator_category; using forward_iterator_category = typename std::iterator_traits&lt;ForwardIt&gt;::iterator_category; return gtl::uninitialized_copy_range(first, last, d_first, input_iterator_category(), forward_iterator_category());&#125; 参考 STL源码剖析 std::allocator","categories":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/categories/STL/"},{"name":"空间配置器","slug":"STL/空间配置器","permalink":"https://gwq5210.com/categories/STL/空间配置器/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"空间配置器","slug":"空间配置器","permalink":"https://gwq5210.com/tags/空间配置器/"}],"keywords":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/categories/STL/"},{"name":"空间配置器","slug":"STL/空间配置器","permalink":"https://gwq5210.com/categories/STL/空间配置器/"}]},{"title":"设计模式之适配器模式","slug":"设计模式之适配器模式","date":"2021-10-26T00:08:42.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/10/26/设计模式之适配器模式/","link":"","permalink":"https://gwq5210.com/2021/10/26/设计模式之适配器模式/","excerpt":"","text":"适配器模式在STL中，很多地方都用到了适配器，包括容器适配器，迭代器适配器，函数适配器 适配器模式的定义为：将一个类的接口转换为另一个类的接口，使原本因接口不兼容而不能工作的类可以一起工作 适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。 优点 客户端通过适配器可以透明地调用目标接口。 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。 在很多业务场景中符合开闭原则。 缺点 适配器编写过程需要结合业务场景全面考虑，可能会增加系统的复杂性。 增加代码阅读难度，降低代码可读性，过多使用适配器会使系统代码变得凌乱。 应用场景 以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。 适配器的实现适配器模式（Adapter）包含以下主要角色。 目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。 适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。 类适配器实现类适配器模式可采用多重继承方式实现，如 C++ 可定义一个适配器类来同时继承当前系统的业务接口和现有组件库中已经存在的组件接口。 Java不支持多继承，但可以定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。 class_adapter 对象适配器实现对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口 object_adapter 容器适配器在STL中有三种容器适配器，这里不过多介绍 stack queue priority_queue 迭代器适配器 reverse_iterator: 逆序遍历的迭代器适配器(类模板) make_reverse_iterator(C++14): 创建拥有从实参推出的类型的 std::reverse_iterator(函数模板) move_iterator(C++11): 解引用结果为右值引用的迭代器适配器(类模板) make_move_iterator(C++11): 创建拥有从实参推出的类型的 std::move_iterator(函数模板) back_insert_iterator: 用于在容器尾部插入的迭代器适配器(类模板) back_inserter: 创建拥有从实参推出的类型的 std::back_insert_iterator(函数模板) front_insert_iterator: 用于在容器头部插入的迭代器适配器(类模板) front_inserter: 创建拥有从实参推出的类型的 std::front_insert_iterator(函数模板) insert_iterator: 用于插入容器的迭代器适配器(类模板) inserter: 创建拥有从实参推出的类型的 std::insert_iterator(函数模板) 如ReverseIterator的实现，将++操作换成迭代器的–操作，实现逆向遍历 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465template &lt;typename Iterator&gt;class ReverseIterator &#123; public: using iterator_type = Iterator; using iterator_category = typename std::iterator_traits&lt;Iterator&gt;::iterator_category; using value_type = typename std::iterator_traits&lt;Iterator&gt;::value_type; using difference_type = typename std::iterator_traits&lt;Iterator&gt;::difference_type; using pointer = typename std::iterator_traits&lt;Iterator&gt;::pointer; using reference = typename std::iterator_traits&lt;Iterator&gt;::reference; ReverseIterator() : it_() &#123;&#125; ReverseIterator(iterator_type it) : it_(it) &#123;&#125; template &lt;typename It&gt; ReverseIterator(const ReverseIterator&lt;It&gt;&amp; other) : it_(other.it_) &#123;&#125; template &lt;typename It&gt; ReverseIterator&amp; operator=(const ReverseIterator&lt;It&gt;&amp; other) &#123; it_ = other.it_; &#125; iterator_type base() const &#123; return it_; &#125; reference operator*() &#123; return *gtl::prev(it_); &#125; pointer operator-&gt;() &#123; return gtl::addressof(**this); &#125; reference operator[](difference_type n) &#123; return *gtl::prev(n + 1); &#125; ReverseIterator&amp; operator++() &#123; --it_; return *this; &#125; ReverseIterator operator++(int) &#123; auto ret = *this; --it_; return ret; &#125; ReverseIterator&amp; operator--() &#123; ++it_; return *this; &#125; ReverseIterator operator--(int) &#123; auto ret = *this; ++it_; return ret; &#125; ReverseIterator&amp; operator+=(difference_type n) &#123; it_ -= n; return *this; &#125; ReverseIterator&amp; operator-=(difference_type n) &#123; it_ += n; return *this; &#125; ReverseIterator operator+(difference_type n) const &#123; return ReverseIterator(it_ - n); &#125; ReverseIterator operator-(difference_type n) const &#123; return ReverseIterator(it_ + n); &#125; template &lt;typename It&gt; friend bool operator==(const ReverseIterator&lt;It&gt;&amp; lhs, const ReverseIterator&lt;It&gt;&amp; rhs); template &lt;typename It&gt; friend bool operator&lt;(const ReverseIterator&lt;It&gt;&amp; lhs, const ReverseIterator&lt;It&gt;&amp; rhs); private: iterator_type it_;&#125;; 函数适配器早期的C++提供了一些函数适配器，如bind1st和bind2nd（C++11后可用bind替代） 早期提供功能支持的几个工具在C++11中弃用，并于 C++17 中移除（旧否定器于 C++17 中弃用并于 C++20 中移除），这里不再过多介绍 参考 适配器模式（详解版） STL源码剖析 迭代器库 函数对象","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"迭代器模式","slug":"设计模式/迭代器模式","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/"},{"name":"STL","slug":"设计模式/迭代器模式/STL","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/tags/设计模式/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://gwq5210.com/tags/迭代器模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"迭代器模式","slug":"设计模式/迭代器模式","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/"},{"name":"STL","slug":"设计模式/迭代器模式/STL","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/STL/"}]},{"title":"设计模式之迭代器模式","slug":"设计模式之迭代器模式","date":"2021-10-22T12:12:43.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/10/22/设计模式之迭代器模式/","link":"","permalink":"https://gwq5210.com/2021/10/22/设计模式之迭代器模式/","excerpt":"","text":"迭代器模式实际编程中，我们经常需要访问容器对象中的各个元素，比如遍历链表中的元素通常的做法是将链表的创建和遍历都放在同一个类中，但这种方式不利于程序的扩展，如果要更换遍历方法就必须修改程序源代码，这违背了 “开闭原则”。 既然将遍历方法封装在容器类中不可取，那么容器类中不提供遍历方法，将遍历方法由用户自己实现是否可行呢？答案是同样不可取，因为这种方式会存在两个缺点： 暴露了容器类的内部表示，使其数据不安全 增加了客户的负担 “迭代器模式”能较好地克服以上缺点，它在客户访问类与容器类之间插入一个迭代器，这分离了容器对象与其遍历行为，对客户也隐藏了其内部细节，且满足“单一职责原则”和“开闭原则” 迭代器模式定义：提供一种方法，使之能够依次访问某个容器所含的各个元素，而又无需暴露该容器的内部实现。 迭代器模式是一种对象行为型模式，其主要优点如下 访问一个容器对象的内容而无须暴露它的内部表示。 遍历任务交由迭代器完成，这简化了容器类。 它支持以不同方式遍历一个容器，甚至可以自定义迭代器的子类以支持新的遍历。 增加新的容器类和迭代器类都很方便，无须修改原有代码。 封装性良好，为遍历不同的容器结构提供一个统一的接口。 其主要缺点是：增加了类的个数，这在一定程度上增加了系统的复杂性。 在日常开发中，我们几乎不会自己写迭代器。除非需要定制一个自己实现的数据结构对应的迭代器，否则，开源框架提供的 API 完全够用。 一般来说，迭代器需要了解容器类的内部实现，才能正确的遍历容器中的元素 模式的结构迭代器模式主要包含以下角色。 抽象聚合（Aggregate）角色：定义存储、添加、删除聚合对象以及创建迭代器对象的接口。 具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。 抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、first()、next() 等方法。 具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。 迭代器模式结构 应用场景迭代器模式通常在以下几种情况使用。 当需要为容器对象提供多种遍历方式时。 当需要为遍历不同的容器结构提供一个统一的接口时。 当访问一个容器对象的内容而无须暴露其内部细节的表示时。 由于容器与迭代器的关系非常密切，所以大多数语言在实现容器类时都提供了迭代器类，因此大数情况下使用语言中已有的容器类的迭代器就已经够了。 STL中的迭代器在STL中的vector、list、set、map等容器都包含了迭代器，迭代器的行为与指针类似，迭代器可以是原生指针，也可以是重载operator*和operator-&gt;的对象。 与容器相似，该容器对应的迭代器可以获取特定类型的值，我们需要通过特性萃取技术（traits）来获取迭代器对应的类型。c++提供了iterator_traits来实现该功能。 一般来说，迭代器需要提供以下几种类型，针对原生指针，可以通过对iterator_traits进行模板特化来获取对应的类型 12345value_typedifference_typepointerreferenceiterator_category 迭代器分类123456struct input_iterator_tag &#123; &#125;; // 输入迭代器，只读，只能++struct output_iterator_tag &#123; &#125;; // 输出迭代器，可写，只能++struct forward_iterator_tag : public input_iterator_tag &#123; &#125;; // 前向迭代器，只能向前移动，只能++struct bidirectional_iterator_tag : public forward_iterator_tag &#123; &#125;; // 可双向移动，可++，--struct random_access_iterator_tag : public bidirectional_iterator_tag &#123; &#125;; // 可随机访问，与原生指针类似struct contiguous_iterator_tag: public random_access_iterator_tag &#123; &#125;; // (C++20) 要求逻辑相邻元素在内存中物理上也相邻 参考 迭代器模式（详解版） STL源码剖析","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"迭代器模式","slug":"设计模式/迭代器模式","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/"},{"name":"STL","slug":"设计模式/迭代器模式/STL","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/tags/设计模式/"},{"name":"迭代器模式","slug":"迭代器模式","permalink":"https://gwq5210.com/tags/迭代器模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"迭代器模式","slug":"设计模式/迭代器模式","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/"},{"name":"STL","slug":"设计模式/迭代器模式/STL","permalink":"https://gwq5210.com/categories/设计模式/迭代器模式/STL/"}]},{"title":"设计模式之状态模式","slug":"设计模式之状态模式","date":"2021-10-22T12:04:33.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/10/22/设计模式之状态模式/","link":"","permalink":"https://gwq5210.com/2021/10/22/设计模式之状态模式/","excerpt":"","text":"状态模式概述在软件开发过程中，应用程序中的部分对象可能会根据不同的情况做出不同的行为，我们把这种对象称为有状态的对象，而把影响对象行为的一个或多个动态变化的属性称为状态 当有状态的对象与外部事件产生互动时，其内部状态就会发生改变，从而使其行为也发生改变 对这种有状态的对象编程，传统的解决方案是：将这些所有可能发生的情况全都考虑到，然后使用 if-else 或 switch-case 语句来做状态判断，再进行不同情况的处理 但是显然这种做法对复杂的状态判断存在天然弊端，条件判断语句会过于臃肿，可读性差，且不具备扩展性，维护难度也大。且增加新的状态时要添加新的 if-else 语句，这违背了“开闭原则”，不利于程序的扩展 以上问题如果采用“状态模式”就能很好地得到解决。 状态模式的解决思想是：当控制一个对象状态转换的条件表达式过于复杂时，把相关“判断逻辑”提取出来，用各个不同的类进行表示，系统处于哪种情况，直接使用相应的状态类对象进行处理，这样能把原来复杂的逻辑判断简单化，消除了 if-else、switch-case 等冗余语句，代码更有层次性，并且具备良好的扩展力。 状态模式定义与特点状态（State）模式的定义：对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。 优点 结构清晰，状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足“单一职责原则”。 将状态转换显示化，减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 状态类职责明确，有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。 缺点 状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。 状态模式对开闭原则的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源码，否则无法切换到新增状态，而且修改某个状态类的行为也需要修改对应类的源码。 状态模式的结构状态模式涉及的角色如下 环境类（Context）角色：也称为上下文，它定义了客户端需要的接口，内部维护一个当前状态，并负责具体状态的切换。 抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为，可以有一个或多个行为。 具体状态（Concrete State）角色：实现抽象状态所对应的行为，并且在需要的情况下进行状态切换。 状态模式结构图 状态模式的实现本例子实现了一个投票的简单例子 同一个用户可以投一次票，初始状态为正常状态(NormalVoteState) 成功投票之后，状态转换为重复投票状态(RepeatVoteState)，不能再进行投票 例子十分简单，具体工程上，可以实现很复杂的状态转换 核心代码如下，具体可参见代码state.cc和state.h 123456789101112void NormalVoteState::vote(VoteManager* manager, const std::string&amp; username) &#123; manager-&gt;inc_vote(username); manager-&gt;set_state(&amp;VoteManager::repeat_vote_state); printf(\"%s, 投票成功!\\n\", username.c_str());&#125;int main(int argc, char* argv[]) &#123; VoteManager manager; manager.vote(\"gwq5210\"); manager.vote(\"gwq5210\"); return 0;&#125; 环境和状态处理对象在状态模式中，环境(Context)是持有状态的对象，但是环境(Context)自身并不处理跟状态相关的行为，而是把处理状态的功能委托给了状态对应的状态处理类来处理。 在具体的状态处理类中经常需要获取环境(Context)自身的数据，甚至在必要的时候会回调环境(Context)的方法，因此，通常将环境(Context)自身当作一个参数传递给具体的状态处理类。 客户端一般只和环境(Context)交互。客户端可以用状态对象来配置一个环境(Context)，一旦配置完毕，就不再需要和状态对象打交道了。客户端通常不负责运行期间状态的维护，也不负责决定后续到底使用哪一个具体的状态处理对象。 参考 状态模式（详解版） 《JAVA与模式》之状态模式","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"状态模式","slug":"设计模式/状态模式","permalink":"https://gwq5210.com/categories/设计模式/状态模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/tags/设计模式/"},{"name":"状态模式","slug":"状态模式","permalink":"https://gwq5210.com/tags/状态模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"https://gwq5210.com/categories/设计模式/"},{"name":"状态模式","slug":"设计模式/状态模式","permalink":"https://gwq5210.com/categories/设计模式/状态模式/"}]},{"title":"STL容器之vector","slug":"STL容器之vector","date":"2021-10-22T12:02:02.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2021/10/22/STL容器之vector/","link":"","permalink":"https://gwq5210.com/2021/10/22/STL容器之vector/","excerpt":"","text":"vector概述vector是动态连续数组，这不仅意味着vector中的元素在逻辑上相邻，而且也意味着它们在物理上也是相邻的 vector的底层是数组，这也说明必要的时候，vector的元素指针可以当做数组指针来使用 一般的实现中，vector的迭代器就是指针本身 vector元素访问复杂度 随机访问——常数 O(1) 在末尾插入或移除元素——均摊常数 O(1) 插入或移除元素——与到 vector 结尾的距离成线性 O(n) vector有两个特点 数据连续存储 空间动态分配 下边主要针对空间动态分配进行介绍 vector的实现vector的空间是动态分配的，随着元素的增加，vector会自动扩充空间以容纳新元素 当需要扩充空间时，vector内部会进行如下操作 分配一块更大的空间 将原有的数据移动到新的位置 释放原有空间 可以看到自动扩充空间涉及到内存分配和元素移动，时间成本很高，需要设计一个合理的数据结构和空间配置策略 数据结构vector需要表示一块连续存储空间，因此我们需要知道内存的位置，内存的大小和已存储元素的个数 一个简单的结构如下 1234567template&lt;class T&gt;class vector &#123;private: T* start_; size_t size_; size_t capacity_;&#125;; 为了降低内存分配的时间成本，vector的实际空间要比使用的空间要大一些，为将来的元素增加做好准备，为此就需要一个容量来表示当前内存的最大大小 空间配置策略当vector空间满时，新添加元素，会触发自动空间分配，这个时候再分配多少合适呢 选的扩容太小比如新的大小是当前大小的1.1倍，可能会频繁导致空间分配，如果新的大小是当前大小的3或4倍，可能会导致内存的浪费 我们先看下主流的实现，gcc新的大小是当前空间大小的2倍，vs是新大小是当前空间大小的1.5倍 如果选择增长因子为2，可能是最坏的可能，因为它不允许vector重用先前分配好的任何内存，因此选择1.5是一个更好的选择 如果增长因子为k，则每次分配的内存为，当为2的时候每次分配的内存都比先前分配的所有内存和都大，选择1.5时，则可以在4次分配后重用 12C, C*k, C*k^2, C*k^3, ...1 + 2^1 + 2^2 + 2^3... + 2^n = 2^(n+1) - 1 内存的释放vector删除元素并不会删除已经申请好的内存，即使vector里已经不包含任何元素 C++11增加公共成员函数shrink_to_fit，允许释放未使用的内存 或者通过swap临时变量的方式释放内存 1vector&lt;int&gt;().swap(v); vector的迭代器失效对容器的操作影响了元素的存放位置，称为迭代器失效 由于vector的实现特点，在发生以下情况时，迭代器和引用都会失效 容量发生改变 插入或移除元素后的迭代器(插入或移除元素前的迭代器和引用不会失效) vector原位构造元素C++11提供以下两个函数来原位构造元素 emplace emplace_back 这两个函数通过完美转发实现原位构造，相比push_back这一类函数，少了一次拷贝的动作 实际上，当前的push_back实现会使用move语义，不会进行拷贝 vector的特化STL针对vector进行了特化，可以提供更优的存储空间，实际上它实现了一个动态bitmap 参考 容器库 STL源码剖析 fbvector vector实现原理","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"},{"name":"顺序容器","slug":"顺序容器","permalink":"https://gwq5210.com/tags/顺序容器/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"STL容器概述","slug":"STL容器概述","date":"2021-10-22T11:59:54.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2021/10/22/STL容器概述/","link":"","permalink":"https://gwq5210.com/2021/10/22/STL容器概述/","excerpt":"","text":"STL容器概述容器被设计来存储数据，可以使程序员简单的访问常见的数据结构 每种不同的容器底层使用不同的数据结构，并拥有不同的特征，可在特定场景提供高效的数据存储和访问的方式 每种容器提供迭代器来访问存储在其中的元素 容器一般分为以下几种类别 顺序容器顺序容器实现能按顺序访问的数据结构 array：静态连续数组 vector：动态连续数组 deque：双端队列 forward_list：单链表 list：双链表 关联容器关联容器实现能快速查找（ O(log n) 复杂度）的数据结构。 set：有序集合，键唯一 map：键值对集合，键唯一 multiset：键集合，键不唯一 multimap：键值对集合，键不唯一 无序关联容器无序关联容器提供能快速查找（均摊 O(1) ，最坏情况 O(n) 的复杂度）的无序（哈希）数据结构。 unordered_set：无序集合，键唯一 unordered_map：无序键值对集合，键唯一 unordered_multiset：无序集合，键不唯一 unordered_multimap：无序键值对集合，键不唯一 容器适配器容器适配器提供顺序容器的不同接口 stack：栈 queue：队列 priority_queue：优先队列 参考 容器库 STL源码剖析","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}],"tags":[{"name":"STL","slug":"STL","permalink":"https://gwq5210.com/tags/STL/"},{"name":"容器库","slug":"容器库","permalink":"https://gwq5210.com/tags/容器库/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"STL","slug":"编程/STL","permalink":"https://gwq5210.com/categories/编程/STL/"}]},{"title":"Lambda表达式","slug":"Lambda表达式(匿名函数)","date":"2019-03-28T11:35:53.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2019/03/28/Lambda表达式(匿名函数)/","link":"","permalink":"https://gwq5210.com/2019/03/28/Lambda表达式(匿名函数)/","excerpt":"","text":"前言最近在看Elasticsearch的相关内容，在Java中遇到了Lambda表达式，因此想了解一下Lambda表达式，这里主要了解Java，C++，Python中的Lambda表达式 什么是Lambda表达式在编程中，Lambda表达式就是指匿名函数（anonymous function），它是一类无需定义标识符（函数名）的函数匿名函数通常作为参数传递给高阶函数或者作为高阶函数的返回值如果函数只使用一次或者有限的次数，则使用匿名函数会比较方便现在越来越多的编程语言支持匿名函数 闭包常常被用作匿名函数的同义词，严格来说，匿名函数仅仅是没有名字的函数，闭包是任何能够访问自由变量（free variable or non-local variable，不在局部和参数列表里定义的变量）的函数实例 Java中的Lambda表达式语法Java 中的 Lambda 表达式通常使用 (argument) -&gt; (body) 语法书写，例如：12(arg1, arg2...) -&gt; &#123; body &#125;(type1 arg1, type2 arg2...) -&gt; &#123; body &#125; 在Lambda表达式中引用的自由变量，必须是final或者是实际上不会修改的变量 结构 一个 Lambda 表达式可以有零个或多个参数 参数的类型既可以明确声明，也可以根据上下文来推断。例如：(int a)与(a)效果相同 所有参数需包含在圆括号内，参数之间用逗号相隔。例如：(a, b) 或 (int a, int b) 或 (String a, int b, float c) 空圆括号代表参数集为空。例如：() -&gt; 42 当只有一个参数，且其类型可推导时，圆括号（）可省略。例如：a -&gt; return a*a Lambda 表达式的主体可包含零条或多条语句 如果 Lambda 表达式的主体只有一条语句，花括号{}可省略。匿名函数的返回类型与该主体表达式一致 如果 Lambda 表达式的主体包含一条以上语句，则表达式必须包含在花括号{}中（形成代码块）。匿名函数的返回类型与代码块的返回类型一致，若没有返回则为空 一些例子1234567891011121314// 不需要参数，返回值为int的42() -&gt; 42// 不需要参数，返回值为float的3.1415() -&gt; &#123; return 3.1415 &#125;;// 接受两个int参数，返回值为它们的和(int a, int b) -&gt; &#123; return a + b; &#125;// 不需要参数，没有返回值，输出一个字符串() -&gt; System.out.println(\"Hello World\");// 接受一个String参数，没有返回值，打印该字符串(String s) -&gt; &#123; System.out.println(s); &#125; 函数式接口Java中只有一个方法声明的接口叫做函数式接口，例如java.lang.Runnable接口只声明了一个void run()方法不指明函数式接口时，编译器可以进行自动转化123Runnable r = () -&gt; System.out.println(\"Hello Java!\");new Thread(r).start();new Thread(() -&gt; System.out.println(\"Hello Java!\")).start(); C++中的Lambda表达式在C++ 11中支持Lambda表达式 语法Lambda表达式的语法如下 []中可以以值或引用捕获变量，来实现闭包 捕获变量时需要注意，如果调用闭包时，引用了生存周期结束的变量，则发生未定义行为，C++的闭包不会延长被捕获引用的生存周期 Lambda表达式是纯右值表达式，其类型是独有的无名非联合非聚合类类型，被称为闭包类型 this是一个特殊的捕获，必须定义在类的非静态成员函数中，该Lambda具有访问该类的保护和私有成员的权限，在Lambda中访问该类的成员，不需要显式使用this-&gt;，即this-&gt;a和a等价 不捕获变量的Lambda可以将函数赋值给对应的函数指针 Lambda表达式可以赋值给std::function Boost库提供了自己的Lambda表达式语法，参见Boost.Lambda12345[ captures ] ( params ) -&gt; return_type &#123; body &#125;// 忽略返回值，返回值的类型使用自动推断[ captures ] ( params ) &#123; body &#125;// 不接受任何参数[ captures ] &#123; body &#125; 例子12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667// 接受x，y参数，返回它们的和[](int x, int y) -&gt; int &#123; return x + y; &#125;// 下面是捕获的例子[] //no variables defined. Attempting to use any external variables in the lambda is an error.[x, &amp;y] //x is captured by value, y is captured by reference[&amp;] //any external variable is implicitly captured by reference if used[=] //any external variable is implicitly captured by value if used[&amp;, x] //x is explicitly captured by value. Other variables will be captured by reference[=, &amp;z] //z is explicitly captured by reference. Other variables will be captured by value// Variables captured by value are constant by default. Adding mutable after the parameter list makes them non-constant.// 按值捕获到的变量不能被改变，需要改变的话要在参数列表后加上mutalbe，按值捕获不会改变原值a = 0;auto f = [=] () mutable &#123; printf(\"a = %d\\n\", a); a = 3; printf(\"a = %d\\n\", a);&#125;;printf(\"a = %d\\n\", a);f();printf(\"a = %d\\n\", a);// 按引用捕获可以修改原值，a值会被改变成3auto r = [&amp;] &#123; printf(\"a = %d\\n\", a); a = 3; printf(\"a = %d\\n\", a);&#125;;printf(\"a = %d\\n\", a);r();printf(\"a = %d\\n\", a);class ClosureTest&#123;public: ClosureTest() &#123; r = 0; &#125; int test(); int result() &#123; return r; &#125;private: int r;&#125;;// 捕获thisint ClosureTest::test()&#123; auto f = [&amp;]&#123; printf(\"%d, %d\\n\", this-&gt;r, r); &#125;; f(); return 0;&#125;// 将Lambda赋值给函数指针，不能捕获变量void (*p)() = []&#123;printf(\"test\\n\");&#125;;p();// 将Lambda赋值给std::function对象，可以进行捕获，void不能省略a = 10;std::function&lt;int(int, int)&gt; add = [](int a, int b)&#123;return a+b;&#125;;std::function&lt;void(int)&gt; print = [](int a)&#123;printf(\"%d\\n\", a);&#125;;std::function&lt;void()&gt; print = [&amp;]()&#123;printf(\"%d\\n\", a);&#125;;print(add(1, 2));test(); Python中的Lambda表达式Python中可以使用lambda关键字定义匿名函数，它能用在任何需要函数的地方，在语法上它被限制只能有单个语句12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849lambda parameter_list: expression// 例如参数x，返回x*xlambda x: x * x// 以上等价于def f(x): return x * x// 参数x，y，返回它们的和lambda x, y: x + y// 可以使用自由变量def f(x): def g(y): return x + y return g # Return a closure.def h(x): return lambda y: x + y # Return a closure.# Assigning specific closures to variables.a = f(1)b = h(1)# Using the closures stored in variables.assert a(5) == 6assert b(5) == 6# Using closures without binding them to variables first.assert f(1)(5) == 6 # f(1) is the closure.assert h(1)(5) == 6 # h(1) is the closure.// x是全局的// 修改x后，会修改函数f的结果x = 1nums = [1, 2, 3]def f(y): return x + y// [2, 3, 4]map(f, nums)map(lambda y: x + y, nums)x = 3// [4, 5, 6]map(f, nums)map(lambda y: x + y, nums) Go的匿名函数Go的匿名函数是闭包，他们可以引用自由变量1234567891011121314151617181920// 分别打出11，102，111package mainimport \"fmt\"func main() &#123; num := 10 f := func(x int) int &#123; return num + x &#125; fmt.Println(f(1)) num = 101 fmt.Println(f(1)) fmt.Println(test(f))&#125;func test(f func(int) int) int &#123; return f(10)&#125; 闭包的实现闭包通常用一个包含函数代码的指针和创建闭包时函数词法环境（一系列可用的变量）的数据结构来实现也就是说闭包引用的自由变量，需要在闭包调用的时候仍然能够访问 只在栈上分配变量的语言很难容易的实现完全的闭包，这些语言中，自动变量会在函数返回后自动的销毁这也可以解释为什么通常支持闭包的语言也使用垃圾回收机制替代方案是非局部变量的手动内存管理，不过这种方式可能会产生野指针的问题，C++ 11中的Lambda表达式和GNU C中的嵌套函数都可能会产生这个问题 参考1) Anonymous_function2) Closure_(computer_programming)3) Java中的闭包之争4) Free_variables_and_bound_variables5) 深入浅出 Java 8 Lambda 表达式6) Lambda expressions","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"https://gwq5210.com/tags/Java/"},{"name":"C++","slug":"C","permalink":"https://gwq5210.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"https://gwq5210.com/tags/Python/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"https://gwq5210.com/tags/Lambda表达式/"},{"name":"匿名函数","slug":"匿名函数","permalink":"https://gwq5210.com/tags/匿名函数/"}],"keywords":[]},{"title":"Git简介及常用命令","slug":"Git简介及常用命令","date":"2019-03-25T20:31:11.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2019/03/25/Git简介及常用命令/","link":"","permalink":"https://gwq5210.com/2019/03/25/Git简介及常用命令/","excerpt":"前言最近想深入了解一下Git，阅读了一下Pro Git的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅 Git介绍Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。","text":"前言最近想深入了解一下Git，阅读了一下Pro Git的前两章，前两章几乎涵盖了Git的大部分功能，在此做个记录，以便后续查阅 Git介绍Git实际上是一个版本控制系统，本质上，版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 版本控制经历了本地版本控制系统（RCS，我没听过），集中化版本控制系统（CVS，Subversion等）和分布式版本控制系统（Git等）的演变。本地版本控制系统无法实现协同工作，集中化的版本控制系统解决了协同工作的问题，但中央服务器的单点故障会影响所有人的工作，分布式版本控制系统采用快照的方式，每个开发者电脑上都有一份代码的完整拷贝，故障恢复起来就比较容易。 Git是Linux开源社区的杰作，他们开发Git之初就对其有以下目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全的分布式 有能力高效管理类似Linux内核一样的超大规模项目（速度和数据量） Git和其他版本控制系统（如Subversion）的主要差别在于对待数据的方法。不像其他版本控制系统保存基本文件和基于基本文件的差异，Git直接保存每个文件的快照。 存储每个文件和基础版本的差异 存储项目随时间变化的快照 正因为如此，Git中的大多数操作只需要访问本地资源，而不需要与服务器进行通信，保证了操作的速度。 Git基础Git的三种状态在Git中，你的文件处于以下三种状态之一： 已提交（committed），表示数据已经安全的保存在本地数据库中。 已修改（modified），表示已经修改了文件，但还没保存在数据库中。 已暂存（staged），表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入Git项目的三个工作区的概念：Git仓库，工作目录以及暂存区域。 Git仓库，工作目录以及暂存区域 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 Git常用命令Git帮助有三种方式获取Git的帮助：123git help &lt;verb&gt;git &lt;verb&gt; --helpman git-&lt;verb&gt; Git配置Git的配置信息存放在三个不同的位置 /etc/gitconfig文件，系统上每一个用户及他们仓库的配置，使用–system选项会读写此配置文件 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。使用–global选项会读写此配置文件 当前仓库中使用的配置（.git/config），需要在当前仓库进行修改，不需要加选项。 每一个级别的配置会覆盖上一个级别的配置。 以下是常用的配置12345678910111213141516171819202122232425262728// 查看用户配置git config --global -l// 设置全局的用户名和邮箱git config --global user.name \"gwq5210\"git config --global user.email \"gwq5210@qq.com\"// 设置使用的编辑器git config --global core.editor \"vim\"// 设置常用的别名，以下命令会在稍候介绍git config --global alias.co checkoutgit config --global alias.ci commitgit config --global alias.br branchgit config --global alias.st statusgit config --global alias.unstage reset HEAD --git config --global alias.last log -l HEAD// 为Git设置代理git config --global http.http http://127.0.0.1:8080git config --global http.https http://127.0.0.1:8080// 为不同的网址设置不同的代理git config --global http.https://github.com.proxy http://127.0.0.1:8081git config --global https.https://github.com.proxy http://127.0.0.1:8081// 避免每次都输入账号密码，将账号密码保存在内存中几分钟git config --global credential.helper cache 获取Git仓库有两种方式获取Git仓库：从现有目录初始化仓库和从服务器克隆一个现有的Git仓库。12345// 从现有目录初始化仓库git init// 从服务器克隆一个现有的仓库git clone [url] [name] Git仓库里存在着.git目录，保存着Git仓库的必要信息。 查看当前文件状态、跟踪新文件和暂存已修改的文件工作目录的文件状态不外乎：已跟踪和未跟踪。已跟踪是已纳入版本控制的文件，在上一次快照中有他们的记录，工作过一段时候后，他们的状态可能是未修改，已修改，已暂存状态。除此之外其他文件都属于未跟踪文件 文件状态变化生命周期 12345678910111213141516171819// 查看当前文件状态git status// 之前设置的status别名为stgit st// 显式简介的状态git status -sgit status --short// 第一列表示在暂存区域的状态，第二列表示在工作区域的状态------------------- M READMEMM RakefileA lib/git.rbM lib/simplegit.rb?? LICENSE.txt -------------------// 跟踪新文件或暂存已修改的文件git add [path] 我们可以使用.gitignore文件来忽略我们不想跟踪的文件，这里有.gitignore文件的列表，可供查阅https://github.com/github/gitignore 查看已暂存和未暂存的修改123456// 查看未暂存的修改，即工作区域和已暂存区域的修改git diff// 查看已提交和已暂存的修改git diff --cached// Git 1.6.1及更高版本git diff --staged 提交更新使用如下命令将暂存区域的内容提交1234567git commit// 命令行指定提交消息git commit -m \"commit message\"// 跳过暂存，进行提交git commit -a -m \"commit message\"// commit的别名git ci 移除或修改文件要移除文件，需要从已跟踪清单中（确切的说是从暂存区域）移除，然后提交。123456789101112131415161718192021git rm [path]-------------// git rm类似如下命令rm [path]git add [path]-------------// 从暂存区域移除，仍然保留在工作区域git rm --cached [path]// 如果已经修改了文件或者已经暂存了该文件，则需要使用-f进行删除，防止误操作删除了不可恢复的文件git rm -f [path]// 重命名文件git mv file_from file_to-------------// git mv相当于下边的操作mv file_from file_togit rm file_fromgit add file_to------------- 查看提交历史提交若干更新或者克隆一个仓库之后，我们可以查看提交历史1234567891011121314151617// 默认会列出所有的提交历史，最近的更新会排在最上边git log// 显示最新的n条记录git log -n// 显示每次提交的内容差异git log -p// 查看每次提交的简略统计信息git log --stat// 单行显示提交历史git log --oneline// 使用图形提交历史git log --graph 撤销操作12345678910// 修改最后一次提交，使用这个选项会覆盖上一次的提交git ci --amend// 取消暂存文件git reset HEAD &lt;file&gt;...// 别名git unstage &lt;file&gt;...// 撤销对文件的修改，此操作会丢失对文件的修改，很危险git checkout -- &lt;file&gt;... 使用远程仓库克隆一个仓库，会自动给远程仓库添加origin的名称1234567891011121314151617// 显示远程仓库git remote -vgit remote show &lt;remote-name&gt;// 添加远程仓库git remote add &lt;shortname&gt; &lt;url&gt;// 拉取远程仓库的信息，不会自动合并或修改你当前的工作// 分支设置了跟踪一个远程分支的话git pull会自动抓取然后合并git fetch &lt;remote-name&gt;// 推送到远程仓库git push &lt;remote-name&gt; &lt;branch-name&gt;// 远程仓库重命名和移除git remote rename &lt;old-name&gt; &lt;new-name&gt;git remote rm &lt;remote-name&gt; 使用标签Git可以给历史中的某一个提交打上标签，表示重要Git标签有两种标签，轻量标签和附注标签轻量标签很像一个不会改变的分支，它只是一个特定提交的引用附注标签是存储在Git数据库中的完整对象，可以包含打标签者的名字，邮件，日期等信息通常建议创建附注标签1234567891011121314151617181920212223242526272829303132333435// 列出标签git taggit tag -l \"v1.8*\"// 创建附注标签，指定存储在标签中的信息git tag -a v1.0 -m \"create tag v1.0\"// 查看标签的信息和对应的提交信息，轻量标签只会显示提交信息git show v1.0// 创建轻量标签，只需要提供标签名字git tag v1.0-lw// 对过去的提交打标签git tag -a v0.9 9fceb02// 共享标签，将标签推送到远程仓库，类似共享远程分支git push &lt;remote-name&gt; &lt;tag-name&gt;// 将所有不在远程服务器的标签都推送过去git push &lt;remote-name&gt; --tags// 删除标签，此命令不会删除远程服务器的标签git tag -d v1.0// 删除远程服务器的标签git push &lt;remote-name&gt; :refs/tags/&lt;tag-name&gt;git push &lt;remote-name&gt; --delete &lt;tag-name&gt;// 检出标签，此命令会使你的仓库处于分离头指针（detached HEAD）状态// 在分离头指针状态你进行某些更改然后提交他们，标签不会发生变化，你的提交不属于任何分支，只能使用确切的哈希来访问git checkout &lt;tag-name&gt;git co &lt;tag-name&gt;// 因此，需要修复旧版本的错误，通常需要创建一个新的分支，在新分支上进行修改，并提交，该分支就和此标签不同了git co -b &lt;branch-name&gt; &lt;tag-name&gt; Git分支几乎所有的版本控制系统都支持分支，你可以把工作从开发主线上分离出来，以免影响开发主线Git处理分支的方式十分轻量，创建和切换分支操作都十分便捷，因此Git鼓励使用分支 进行提交操作时，Git会保存一个提交对象，该提交对象包含一个指向暂存内容快照的指针，还包括作者的姓名，邮箱等信息，以及它的父对象信息（一个或多个） Git的默认分支是master分支，master分支不是一个特殊的分支，与其他分支没有差别，git init命令会默认创建它 这些分支操作全部都保存在本地，没有与服务器发生交互123456789101112131415161718192021222324252627282930313233// 创建分支，会在当前所的提交对象上创建一个指针，Git有一个HEAD的特殊指针，指向当前分支，可以理解为当前分支的别名git branch &lt;branch-name&gt;git br &lt;branch-name&gt;// 切换分支，分支切换会改变工作目录的内容，如果Git不能干净利落的完成这个任务，它将禁止切换分支git checkout &lt;branch-name&gt;git co &lt;branch-name&gt;// 新建分支并切换git checkout -b &lt;branch-name&gt;git co -b &lt;branch-name&gt;// 合并分支，将&lt;branch-name&gt;分支合并到当前分支// 合并两个分支时，如果顺着一个分支能够到达另外一个分支，那么就进行快进（fast-forward）// 有分叉的合并会产生一个合并提交，该提交使用三方（两个分支末端的快照和它们的公共祖先）合并的结果// 如果合并时遇到对同一个文件同一处的修改，则会发生冲突，等你解决冲突后，使用git add命令将冲突的文件标记为已解决冲突git merge &lt;branch-name&gt;// 删除分支git branch -d &lt;branch-name&gt;git br -d &lt;branch-name&gt;// 查看分支，*号代表当前所在分支git branchgit br// 查看分支最后一个提交git branch -vgit br -v// 显示列表中已经合并或尚未合并到当前分支的分支git branch --mergedgit br --no-merged 一个和并提交 远程分支远程引用是对远程仓库的引用，包括分支标签等。我们经常利用远程跟踪分支，它是远程分支状态的引用，它们是你不能移动的本地引用，当你进行任何网络操作时，它们会自动移动远程跟踪分支像是你上次连接到远程仓库时，那些分支所处状态的书签，以/命名，如origin/master origin和master没有特殊含义，origin是git clone创建的远程仓库的默认名字，master是git init时默认的起始分支的名字123// 查看完整远程引用列表git ls-remotegit remote show &lt;remote-name&gt; 本地与远程的工作可以分叉 推送到远程分支你想分享一个分支，必须要将其推送到有写入权限的远程仓库，本地的分支不会自动与远程仓库同步，必须显式的推送1234567891011// 将分支推送到远程仓库git push &lt;remote-name&gt; &lt;branch-name&gt;// 本地分支与远程分支采用不同的名字git push &lt;remote-name&gt; &lt;branch-name&gt;:&lt;remote-branch-name&gt;// 其他人可以获取到远程分支git fetch &lt;remote-name&gt;// 合并远程分支到当前分支git merge &lt;remote-name&gt;/&lt;branch-name&gt;// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支git co -b &lt;branch-name&gt; &lt;remote-name&gt;/&lt;branch-name&gt; 跟踪分支从一个远程仓库检出一个本地分支会自动创建一个做跟踪分支（上游分支），跟踪分支是与远程分支有直接关系的本地分支如果在跟踪分支上输入git pull，则Git能自动识别去哪个服务器抓取、合并到哪个分支克隆仓库时，会自动创建一个跟踪origin/master的master分支1234567891011121314151617181920212223// 本地创建新的分支，起点为远程分支，该分支跟踪远程分支git checkout -b &lt;branch-name&gt; &lt;remote-name&gt;/&lt;branch-name&gt;git checkout --track &lt;remote-name&gt;/&lt;branch-name&gt;// 当前分支设置跟踪的远程分支git branch -u &lt;remote-name&gt;/&lt;branch-name&gt;git branch --set-upstream-to &lt;remote-name&gt;/&lt;branch-name&gt;// 设置好跟踪分支后，可以通过@&#123;u&#125;或@&#123;upstream&#125;快捷方式来引用它git merge origin/mastergit merge @&#123;u&#125;// 查看分支跟踪的远程分支git branch -vv// 获取远程分支，并不会修改本地工作目录中的内容，需要自己合并git fetch origin mastergit merge origin/master// git pull会查找当前分支的跟踪分支，从服务器抓取数据然后尝试合并入那个远程分支git pull// 删除远程分支git push &lt;remote-name&gt; --delete &lt;branch-name&gt; 变基Git中整合来自不同分支的修改主要有两种方法：merge和rebase合并进行一次三方合并，产生一个新的快照并提交变基首先找到两个分支的共同祖先，对比当前分支的历次提交，提取相应的修改，然后在新的分支上进行重新播放，最后进行一次快速合并一般进行变基的目的是确保向远程分支推送时，保持提交历史的整洁这两种方式整合的最终快照是一样的 123456// 将当前分支变基到master分支git rebase master// 将在client分支里但不在server分支里的修改，在master分支里重放git rebase --onto master server client// 无需切换分支进行变基git rebase master server 变基然后进行快进合并 通过合并操作来整合分叉的历史 变基存在风险，使用变基的准则是不要对在你的仓库外有副本的分支执行变基变基的操作实际上是丢弃一些现有的提交，然后相应的新建一些内容一样的但是实际上不同的提交如果别人在该分支上进行了工作，你对此分支进行了变基，那么就会出现问题出现类似的情况可以使用变基来解决变基1git pull --rebase 总结以上的命令和知识可以应付大部分Git的使用场景了如果遇到其他的困难问题，可以后续再补充 参考1) Pro Git","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://gwq5210.com/tags/Git/"}],"keywords":[]},{"title":"Cpp-Primer-Plus读书笔记（四）","slug":"Cpp-Primer-Plus读书笔记（四）","date":"2018-04-12T22:26:26.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2018/04/12/Cpp-Primer-Plus读书笔记（四）/","link":"","permalink":"https://gwq5210.com/2018/04/12/Cpp-Primer-Plus读书笔记（四）/","excerpt":"","text":"第十四章 C++中的代码重用C++的一个主要目标是促进代码重用。 包含对象成员的类valarray是由头文件valarray定义，其用于处理数值通常用于建立has-a关系的C++技术是组合(包含)，即创建一个包含其他类对象的类使用组合可以获得实现，但不获得接口，共有继承可以获得接口，可能还有实现 对于模板类我们可以使用typedef简化其描述 使用成员初始化列表来初始化包含的类对象。 私有继承C++还有另一种实现has-a关系的途径——私有继承。使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员。基类方法不会成为派生对象公有接口的一部分，但可以在派生类的成员函数中使用它们。这种关系是has-a关系。 包含将对象作为一个命名的成员对象添加到类中，而私有继承将对象作为一个未被命名的继承对象添加到类中。我们将使用术语子对象(subobject)来表示通过继承或包含添加的对象。 使用包含时使用对象名来调用方法，而使用私有继承时，将使用类名和作用域解析运算符来调用方法 私有继承如果希望访问基类对象，可以使用强制类型转换。同样，可以通过强制类型转换来使用基类的友元函数。 在私有继承中，在不进行显式类型转换的情况下，不能将指向派生类的引用或指针赋给基类引用或指针。在多重继承情况下，不进行强制类型转换也无法确定应转换成哪个类。然而即使公有继承也必须进行强制类型抓换。 使用包含还是私有继承使用包含更容易理解，继承会引起多个问题，尤其是使用多重继承的情况下，另外还可能需要包含类的多个子对象 通常应使用包含来实现has-a，如果新类要访问原有类的保护成员，或需要重新定义虚函数，则应使用私有继承 保护继承保护继承是私有继承的变体，其使用关键字protected在使用保护继承时，基类的共有成员和保护成员都将成为派生类的保护成员。和私有继承一样，基类的接口在派生类中也是可用的，但在继承层次结构之外是不可用的，当从派生类派生出另一个类时，私有继承和保护继承之间的主要区别就呈现出来了，使用私有继承时，第三代类将不能使用基类的接口，这是因为基类的共有方法在派生类中将变成私有方法，使用保护继承时，基类的共有方法在第二代类中将变成受保护的，因此第三代类可以使用它们。隐式向上转换(implicit upcasting)意味着无需进行显式类型转换，就可以将基类指针或引用指向派生类对象。如下表| 特征 | 共有继承 | 保护继承 | 私有继承 || —- | —- | —- | —- || 公有成员变成 | 派生类的公有成员 | 派生类的保护成员 | 派生类的私有成员 || 保护成员变成 | 派生类的保护成员 | 派生类的保护成员 | 派生类的私有成员 || 私有成员变成 | 只能通过基类接口访问 | 只能通过基类接口访问 | 只能通过基类接口访问 || 能否隐式向上转换 | 是 | 是(但只能在派生类中) | 否 | 使用using重新定义访问权限使用保护派生或私有派生时，假设要使基类的方法在派生类外可用，方法之一是定义一个使用该基类方法的派生类方法，如 1234double Student::sum() const&#123; return std::valarray&lt;double&gt;::sum();&#125; 另一种方法是，将函数调用包装在另一个函数调用中，即使用一个using声明来指出派生类可以使用基类特定的基类成员，即使采用的是私有派生，注意，using声明只使用成员名，没有圆括号，函数特征标和返回值，这使得所有成员名的方法都可用，其只适用于继承，不适用于包含。 123456class Student: private std::string, private std::valarray&lt;double&gt;&#123;public: using std::valarray&lt;double&gt;::min; using std::valarray&lt;double&gt;::max;&#125;; 多重继承","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://gwq5210.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"Cpp Primer Plus","slug":"Cpp-Primer-Plus","permalink":"https://gwq5210.com/tags/Cpp-Primer-Plus/"}],"keywords":[]},{"title":"mathjax简单教程（翻译）","slug":"mathjax简单教程（翻译）","date":"2018-02-04T00:36:22.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2018/02/04/mathjax简单教程（翻译）/","link":"","permalink":"https://gwq5210.com/2018/02/04/mathjax简单教程（翻译）/","excerpt":"mathjax简单教程（翻译）原文地址：mathjax basic tutorial and quick reference 在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。 使用\\$…\\$来产生行内公式，使用\\$\\$…\\$\\$来产生多行公式。公式$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\\tag{displayed}$是不一样的。 使用\\alpha,\\beta,…,\\omega来产生希腊字母：$\\alpha$,$\\beta$,$\\omega$。使用\\Gamma,\\Delta,…,\\Omega来产生大写的：$\\Gamma$,$\\Delta$,…,$\\Omega$。 使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。","text":"mathjax简单教程（翻译）原文地址：mathjax basic tutorial and quick reference 在任何的mathjax公式上，都可以使用右键点击公式选择”Show Math As &gt; TeX Commands”来查看公式是怎么写出来的（包括这里）。 使用\\$…\\$来产生行内公式，使用\\$\\$…\\$\\$来产生多行公式。公式$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}$（行内）和公式$\\sum_{i=0}^n i^2 = \\frac{(n^2+n)(2n+1)}{6}\\tag{displayed}$是不一样的。 使用\\alpha,\\beta,…,\\omega来产生希腊字母：$\\alpha$,$\\beta$,$\\omega$。使用\\Gamma,\\Delta,…,\\Omega来产生大写的：$\\Gamma$,$\\Delta$,…,$\\Omega$。 使用^和_来产生下标和上标。如x_i^2产生：$x_i^2$。 组。下标，上标和其他运算符只能应用到下一个”组”。单个符号或者被大括号{…}包含起来的公式被视为一个组。如10^10产生$10^10$，而不是$10^{10}$，这样写可以得到预期的结果：10^{10}。使用大括号可以界定公式中那些是上标或者下标：x^5^6是错误的，{x^y}^z是${x^y}^z$，x^{y^z}是$x^{y^z}$。显然x_i^2：$x_i^2$和x_{i^2}：$x_{i^2}$是不同的。 符号()[]产生对应的符号，如(3+4)[4+4]产生：$(3+4)[4+4]$。但使用{和}来产生大括号：${}$。但上边的不会自动适应公式的大小，所以如果你写下(\\frac12)，那么括号会很小：$(\\frac12)$，使用\\left(…\\right)来使括号自动适应公式的大小：\\left(\\frac12\\right)产生$\\left(\\frac12\\right)$。\\left和\\right可以作用于下边种类的括号：(和)：$\\left(x\\right)$，[和]：$\\left[x\\right]$，{和} ：$\\left{x\\right}$，|：$\\left|x\\right|$，\\langle和\\ rangle：$\\left\\langle{x}\\right\\rangle$，\\lceil和\\rceil：$\\left\\lceil{x}\\right\\rceil$，\\lfloor和\\rfloor：$\\left\\lfloor{x}\\right\\rfloor$。还有一种不可见的括号，用.来指代：\\left.\\frac12\\right}表示$\\left.\\frac12\\right}$。 使用\\sum和\\int来代表求和，积分。下标表示下限，上标表示上限，所以\\sum_1^n表示$\\sum_1^n$。上限和下限超过一个符号不要忘记加上{…}。如\\sum_{i=0}^\\infty i^2表示$\\sum_{i=0}^\\infty{i^2}$。类似的还有：\\prod$表示\\prod$，\\int表示$\\int$，\\bigcup表示$\\bigcup$，\\bigcap表示$\\bigcap$，\\iint表示$\\iint$。 分数有两种产生方式。\\frac作用于下边紧邻的两个组；如\\frac ab产生$\\frac ab$。可以使用{…}来产生更复杂的表达式；如\\frac{a+1}{b+1}产生$\\frac{a+1}{b+1}$。如果分子和分母很复杂，你可能更喜欢\\over，它分割一个组内的两部分产生分数；如{a+1 \\over b+1}产生${a+1 \\over b+1}$。 字体。 使用\\mathbb或\\Bbb产生”blackboard bold”：$\\mathbb{CHNQRZ}$ 使用\\mathface产生blodface：$\\mathbf{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathbf{abcdefghijklmnopqrstuvwxyz}$ 使用\\mathtt产生”typewriter”字体：$\\mathtt{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathtt{abcdefghijklmnopqrstuvwxyz}$ 使用\\mattrm产生roman字体：$\\mathrm{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathrm{abcdefghijklmnopqrstuvwxyz}$ 使用\\mathcal产生”calligraphic”字母：$\\mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathcal{abcdefghijklmnopqrstuvwxyz}$ 使用\\mathsrc产生script字母：$\\mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathscr{abcdefghijklmnopqrstuvwxyz}$ 使用\\mathfrak产生”Fraktur”(老式德国风格)字母：$\\mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ}$$\\mathfrak{abcdefghijklmnopqrstuvwxyz}$ 使用\\sqrt产生根号，它会自动适应公式的大小。如\\sqrt{x^3}产生$\\sqrt{x^3}$；\\sqrt[3]{\\frac xy}产生$\\sqrt[3]{\\frac xy}$。对于复杂的表达式可以使用{…}^{1/2}。 一些如lim，sin，max，ln的特殊函数可以使用\\lim，\\sin等产生。如\\sin x产生$\\sin x$，而不是sin x产生$sin x$。\\lim使用下标产生趋近符号：\\lim_{x\\to 0}产生$\\lim_{x\\to 0}$。 有大量的特殊符号和记号，可以参考this shorter listing或this exhaustive listing。一些常用的列在下边： \\lt,\\gt,\\le,\\ge,\\neq分别表示$\\lt$,$\\gt$,$\\le$,$\\ge$,$\\neq$。你可以使用\\not来在大多数符号上画上斜线，但通常看起来很差劲，如\\not\\lt表示$\\not\\lt$。 \\times,\\div,\\pm,\\mp分别表示$\\times$,$\\div$,$\\pm$,$\\mp$。\\cdot表示一个居中的点：$x\\cdot y$。 \\cup,\\cap,\\setminus,\\subset,\\subseteq,\\subsetneq,\\supset,\\in,\\notin,\\emptyset,\\varnothing分别表示$\\cup\\, \\cap\\, \\setminus\\, \\subset\\, \\subseteq \\,\\subsetneq \\,\\supset\\, \\in\\, \\notin\\, \\emptyset\\, \\varnothing$。 {n+1 \\choose 2k}或者\\binom{n+1}{2k}表示${n+1 \\choose 2k}$。 \\to,\\rightarrow,\\leftarrow,\\Rightarrow,\\Leftarrow,\\mapsto分别表示$\\to\\, \\rightarrow\\, \\leftarrow\\, \\Rightarrow\\, \\Leftarrow\\, \\mapsto$。 \\land,\\lor,\\lnot,\\forall,\\exists,\\top,\\bot,\\vdash,\\vDash分别表示$\\land\\, \\lor\\, \\lnot\\, \\forall\\, \\exists\\, \\top\\, \\bot\\, \\vdash\\, \\vDash$。 \\star\\, \\ast\\, \\oplus\\, \\circ\\, \\bullet分别表示$\\star\\, \\ast\\, \\oplus\\, \\circ\\, \\bullet$。 \\approx\\, \\sim \\, \\simeq\\, \\cong\\, \\equiv\\, \\prec分别表示$\\approx\\, \\sim \\, \\simeq\\, \\cong\\, \\equiv\\, \\prec$。 \\infty\\, \\aleph_0, \\nabla\\, \\partial, \\Im\\, \\Re分别表示$\\infty\\, \\aleph_0, \\nabla\\, \\partial, \\Im\\, \\Re$。 可以使用\\pmod来产生同余式，如a\\equiv b\\pmod n产生$a\\equiv b\\pmod n$。 \\ldots可以产生这里的点：$a_1, a_2, \\ldots ,a_n$；\\cdots产生这里的点：$a_1+a_2+\\cdots+a_n$。 一些希腊字母具有不同的形式：\\epsilon\\, \\varepsilon分别表示$\\epsilon\\, \\varepsilon$，\\phi\\, \\varphi分别表示$\\phi\\, \\varphi$，\\ell表示$\\ell$等。 在mathjax的公式中加入空格，不会改变公式中空格的数量。如a␣b和a␣␣␣␣b都产生$a b$。可以使用\\,加入一个空格$a\\,b$，使用\\;加入一个宽空格$a\\;b$，使用\\quad和\\qquad产生大量的空格$a\\quad b,a\\qquad b$。可以使用\\text{…}在公式中加入普通文本：${x\\in s\\mid x\\text{ is extra large}}$。还可以在\\text{…}中嵌套\\$…\\$。 强调和区别标志。\\hat用于单个符号：$\\hat x$,\\widehat用于一个公式：$\\widehat{xy}$。如果将它弄的特别宽，看起来就十分丑。类似的，\\bar产生$\\bar x$，\\overline产生$\\overline{xyz}$，\\vec产生$\\vec x$，\\overrightarrow产生$\\overrightarrow{xy}$。可以使用\\dot和\\ddot产生点和双点，如\\frac d{dx}x\\dot x = \\dot x^2 + x\\ddot x产生$\\frac d{dx}x\\dot x = \\dot x^2 + x\\ddot x$。 使用\\来转义mathjax中使用的特殊字符，如\\$表示$\\$$，{表示${$，_表示$_$等等。教程到此结束。","categories":[],"tags":[{"name":"mathjax教程","slug":"mathjax教程","permalink":"https://gwq5210.com/tags/mathjax教程/"},{"name":"LaTeX","slug":"LaTeX","permalink":"https://gwq5210.com/tags/LaTeX/"}],"keywords":[]},{"title":"Redis中的geo功能","slug":"Redis中的geo功能","date":"2018-02-03T17:37:12.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2018/02/03/Redis中的geo功能/","link":"","permalink":"https://gwq5210.com/2018/02/03/Redis中的geo功能/","excerpt":"Redis简介Redis是一个开源的（BSD协议），基于内存的kv存储数据库。它支持很多数据结构。目前Redis还支持部署集群。 从Redis 3.2开始，Redis提供了geo的功能，也就是地理位置相关的命令，今天我们主要来了解这个功能。","text":"Redis简介Redis是一个开源的（BSD协议），基于内存的kv存储数据库。它支持很多数据结构。目前Redis还支持部署集群。 从Redis 3.2开始，Redis提供了geo的功能，也就是地理位置相关的命令，今天我们主要来了解这个功能。 geo相关命令简介跟geo相关的命令有六个：1234567891011GEOADD key longitude latitude member [longitude latitude member ...]GEODIST key member1 member2 [unit]GEOHASH key member [member ...]GEOPOS key member [member ...]GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] 通过名字我们大概可以知道命令的功能。 geoadd添加地理位置 geodist计算地理位置之间的距离 geohash计算地理位置的geohash(有关geohash的内容可以参考geohash简介) geopos获取地理位置 georadius和georadiusbymember获取某个地理位置附近的所有位置点 下面我们分别对其进行介绍。 添加和获取地理位置添加地理位置我们通过GEOADD来添加位置。1GEOADD key longitude latitude member [longitude latitude member ...] 可以看到GEOADD每次可以添加多个位置。key是地理位置的集合。 下面是例子，首先添加一个地点清远，后边一次添加多个地点。12345// 添加一个地点GEOADD Guangdong-cities 113.2099647 23.593675 Qingyuan// 添加多个地点GEOADD Guangdong-cities 113.2278442 23.1255978 Guangzhou 113.106308 23.0088312 Foshan 113.7943267 22.9761989 Dongguan 114.0538788 22.5551603 Shenzhen 获取地理位置我们通过GEOPOS来获取对应的地理位置信息。1GEOPOS key member [member ...] 例如我们通过如下命令来获取刚刚添加进去的地理位置1GEOPOS Guangdong-cities Qingyuan Guangzhou Foshan 其返回是一个数组，每个数组包含两个元素：经度和维度1234561) 1) \"113.20996731519699\" -- 清远的经度 2) \"23.593675019671288\" -- 清远的纬度2) 1) \"113.22784155607224\" -- 广州的经度 2) \"23.125598202060807\" -- 广州的纬度3) 1) \"113.10631066560745\" -- 佛山的经度 2) \"23.008831202413539\" -- 佛山的纬度 计算距离和geohash针对地理位置的操作，Redis提供了计算两点间距离和获取该地理位置geohash的方法 计算距离我们使用GEODIST获取两个位置之间的距离1GEODIST key member1 member2 [unit] 我们需要制定一个地点集合中的两个地理位置unit指定返回的距离单位（默认为m），可用值如下 m 表示单位为米。 km 表示单位为千米。 mi 表示单位为英里。 ft 表示单位为英尺。 例如，计算清远和广州之间的距离12GEODIST Guangdong-cities Qingyuan Guangzhou km\"52.094433840356309\" -- 两地相距 52 公里 计算geohash相关geohash的资料可以参考这里 在Redis中我们使用GEOHASH获取一个地点的geohash值1GEOHASH key member [member ...] geohash返回一个数组，数组中每个元素都是一个geohash字符串，Redis返回的字符串为11个字符。 例子123456redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"(integer) 2redis&gt; GEOHASH Sicily Palermo Catania1) \"sqc8b49rny0\"2) \"sqdtr74hyu0\"redis&gt; 获取附近的点在我们使用的许多应用中，都有获取附近美食等的能力，Redis也提供了类似的功能，获取附近范围内的地理位置。有两个命令GEORADIUS和GEORADIUSBYMEMBER，前者用经纬度指定中心点，后者使用存储在Redis中的某个点作为中心点123GEORADIUS key longitude latitude radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key]GEORADIUSBYMEMBER key member radius m|km|ft|mi [WITHCOORD] [WITHDIST] [WITHHASH] [COUNT count] [ASC|DESC] [STORE key] [STOREDIST key] 其中 m|km|ft|mi 指定的是计算范围时的单位； 如果给定了可选的 WITHCOORD ， 那么命令在返回匹配的位置时会将位置的经纬度一并返回； 如果给定了可选的 WITHDIST ， 那么命令在返回匹配的位置时会将位置与中心点之间的距离一并返回； 在默认情况下， GEORADIUS 和 GEORADIUSBYMEMBER 的结果是未排序的， ASC 可以让查找结果根据距离从近到远排序， 而 DESC 则可以让查找结果根据从远到近排序； COUNT 参数指定要返回的结果数量。 例子12345678910111213141516171819202122redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"(integer) 2redis&gt; GEORADIUS Sicily 15 37 200 km WITHDIST1) 1) \"Palermo\" 2) \"190.4424\"2) 1) \"Catania\" 2) \"56.4413\"redis&gt; GEORADIUS Sicily 15 37 200 km WITHCOORD1) 1) \"Palermo\" 2) 1) \"13.36138933897018433\" 2) \"38.11555639549629859\"2) 1) \"Catania\" 2) 1) \"15.08726745843887329\" 2) \"37.50266842333162032\"redis&gt; GEOADD Sicily 13.583333 37.316667 \"Agrigento\"(integer) 1redis&gt; GEOADD Sicily 13.361389 38.115556 \"Palermo\" 15.087269 37.502669 \"Catania\"(integer) 2redis&gt; GEORADIUSBYMEMBER Sicily Agrigento 100 km1) \"Agrigento\"2) \"Palermo\" 小结Redis提供了地理位置相关的命令，我们可以使用这些特性方便的时间地理位置查找等相关的功能。 参考1) Redis 命令参考2) Redis GEO 特性简介","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://gwq5210.com/tags/Redis/"},{"name":"geohash","slug":"geohash","permalink":"https://gwq5210.com/tags/geohash/"},{"name":"Redis地理位置功能","slug":"Redis地理位置功能","permalink":"https://gwq5210.com/tags/Redis地理位置功能/"}],"keywords":[]},{"title":"geohash简介","slug":"geohash简介","date":"2018-02-03T17:35:38.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2018/02/03/geohash简介/","link":"","permalink":"https://gwq5210.com/2018/02/03/geohash简介/","excerpt":"前言最近项目需要使用到通过用户的经纬度查询附近的地理位置，了解到geohash可以快速的查找附近的地点，就找时间了解下是geohash的实现方式。 geohash介绍geohash能将地理位置编码成字母和数字组成字符串。每个字符串表示一个地图上的矩形区域，举行区域的大小取决于字符串的长度，长度越长，矩形区域越小。每个矩形区域中的位置都共享相同的geohash字符串。正因为如此，我们可以将geohash的字符串当做key，来存储所有的地理位置坐标。 上边提到字符串越长，表示的区域越小，也就是位置越精确。我们可以从geohash字符串的后边移除字符串来增大矩形区域的位置，当然也降低了经度。 geohash字符串相近的地点其距离也越近，相似前缀越长，两个地点越近。但也有特殊情况，地理位置近但其geohash字符串差别很大，这种情况在下边介绍。","text":"前言最近项目需要使用到通过用户的经纬度查询附近的地理位置，了解到geohash可以快速的查找附近的地点，就找时间了解下是geohash的实现方式。 geohash介绍geohash能将地理位置编码成字母和数字组成字符串。每个字符串表示一个地图上的矩形区域，举行区域的大小取决于字符串的长度，长度越长，矩形区域越小。每个矩形区域中的位置都共享相同的geohash字符串。正因为如此，我们可以将geohash的字符串当做key，来存储所有的地理位置坐标。 上边提到字符串越长，表示的区域越小，也就是位置越精确。我们可以从geohash字符串的后边移除字符串来增大矩形区域的位置，当然也降低了经度。 geohash字符串相近的地点其距离也越近，相似前缀越长，两个地点越近。但也有特殊情况，地理位置近但其geohash字符串差别很大，这种情况在下边介绍。 主要用途geohash主要用在如下两个场景： 将geohash字符串当做一个唯一的标识 用来表示地点数据，将其存储到数据库中 geohash也经常用于地理标记。 使用geohash有两个优点：一是用geohash索引的数据表示的是一个矩形区域中所有的点，在数据库中单个索引的效率也比多个索引高；二是我们可以使用geohash来进行快速但不精确的查询：geohash相近的字符串也有相近的距离。 算法和例子geohash的字符串其实是base32的结果。我们用ws104来作为例子说明如何从geohash解析成经纬度。 先使用base32对字符串ws104进行解码。下面是base32的字符表： 十进制 0 1 2 3 4 5 6 7 base32 0 1 2 3 4 5 6 7 十进制 8 9 10 11 12 13 14 15 base32 8 9 b c d e f g 十进制 16 17 18 19 20 21 22 23 base32 h j k m n p q r 十进制 24 25 26 27 28 29 30 31 base32 s t u v w x y z 由此可以得到ws104对应的二进制串是：11100 11000 00001 00000 00100 从左边开始数从0开始，偶数位是经度(1101 0001 0001 0)，奇数位是维度(1010 0000 0000) 这些二进制数从左到右对经纬度进行一系列分解，对于维度其范围在-90到90度，对于经度其范围在-180到180度。0表示较小的部分，1表示较大的部分。经度第一位是1，因此经度的范围在0到180度的范围内。我们依次进行此操作，对于维度的操作一样。 这样我们也可以理解为什么geohash字符串长度越长，表示的数据越准确。 下面是对维度进行分解的数据： 位置 二进制值 最小值 中间值 最大值 平均值 最大误差 0 1 -90.000 0 90.000 45.000 45.000 1 0 0 45.000 90.000 22.500 22.500 2 1 0 22.500 45.000 33.750 11.250 3 0 22.500 33.750 45.000 28.125 5.625 4 0 22.500 28.125 33.750 25.3125 2.8125 5 0 22.500 25.3125 28.125 23.90625 1.40625 6 0 22.500 23.90625 25.3125 23.203125 0.703125 7 0 22.500 23.203125 23.90625 22.8515625 0.3515625 8 0 22.500 22.8515625 23.203125 22.67578125 0.17578125 9 0 22.500 22.67578125 22.8515625 22.587890625 0.087890625 10 0 22.500 22.587890625 22.67578125 22.5439453125 0.0439453125 11 0 22.500 22.5439453125 22.587890625 22.52197265625 0.02197265625 因此这个位置的维度在范围22.500到22.5439453125之间，误差为0.02197265625。 同理可以算出经度范围在113.994140625到114.0380859375之间，误差为0.02197265625。 位置 二进制值 最小值 中间值 最大值 平均值 最大误差 0 1 -180.000 0 180.000 90.000 90.000 1 1 0 90.000 180.000 135.000 45.000 2 0 90.000 135.000 180.000 112.500 22.500 3 1 90.000 112.500 135.000 123.750 11.250 4 0 112.500 123.750 135.000 118.125 5.625 5 0 112.500 118.125 123.750 115.3125 2.8125 6 0 112.500 115.3125 118.125 113.90625 1.40625 7 1 112.500 113.90625 115.3125 114.609375 0.703125 8 0 113.90625 114.609375 115.3125 114.2578125 0.3515625 9 0 113.90625 114.2578125 114.609375 114.08203125 0.17578125 10 0 113.90625 114.08203125 114.2578125 113.994140625 0.087890625 11 1 113.90625 113.994140625 114.08203125 114.0380859375 0.0439453125 12 0 113.994140625 114.0380859375 114.08203125 114.01611328125 0.02197265625 下面我们给出geohash字符串长度跟精度的关系 geohash长度 维度位数 经度位数 维度误差 经度误差 距离误差（km） 1 2 3 $\\pm$23 $\\pm$23 $\\pm$2500 2 5 5 $\\pm$2.8 $\\pm$5.6 $\\pm$630 3 7 8 $\\pm$0.70 $\\pm$0.70 $\\pm$78 4 10 10 $\\pm$0.087 $\\pm$0.18 $\\pm$20 5 12 13 $\\pm$0.022 $\\pm$0.022 $\\pm$2.4 6 15 15 $\\pm$0.0027 $\\pm$0.0055 $\\pm$0.61 7 17 18 $\\pm$0.00068 $\\pm$0.00068 $\\pm$0.076 8 20 20 $\\pm$0.000085 $\\pm$0.00017 $\\pm$0.019 使用上的限制边界情况前面提到我们可以通过前缀匹配来大致的寻找附近的点。但是，这不是总能够成立的。 南极和北极的地点相近但是它们的经度差别很大，没有相同的前缀；在180度子午线(经线)两侧的地点，距离很近，但是在不同的区域内，也不会有相同的前缀。同样的，划分的区域边界，也存在类似的情况。 非线性的距离由于geohash是基于经纬度坐标的距离进行计算，两个geohash点映射出来的距离并不是真实的距离。这是因为我们很难将球体上的坐标映射到一个均匀的二维空间。 尽管存在许多问题，但仍有可能的解决办法，这些算法已经成功的在Elasticsearch，MongoDB，HBase中实现用于近似查找。 参考1) GeoHash核心原理解析2) Geohash-Wikipedia","categories":[],"tags":[{"name":"geohash","slug":"geohash","permalink":"https://gwq5210.com/tags/geohash/"},{"name":" 地理位置hash","slug":"地理位置hash","permalink":"https://gwq5210.com/tags/地理位置hash/"}],"keywords":[]},{"title":"hiredis的使用","slug":"hiredis的使用","date":"2018-01-27T16:39:49.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2018/01/27/hiredis的使用/","link":"","permalink":"https://gwq5210.com/2018/01/27/hiredis的使用/","excerpt":"前言近期开发的项目使用到了Redis，本文主要记录下使用Redis API遇到的一些问题。如果想了解Redis相关的细节，可以看《Redis设计与实现》。想了解Redis相关的命令，可以参考Redis命令参考 hiredis简介hiredis是Redis的一个极简c客户端库。它实现了Redis协议的最小集，但同时也提供类printf的API，使用既方便有简介。hiredis提供了多种API，它同时支持同步，异步和回复解析API。在此基础上，能够实现Redis的流水线操作。","text":"前言近期开发的项目使用到了Redis，本文主要记录下使用Redis API遇到的一些问题。如果想了解Redis相关的细节，可以看《Redis设计与实现》。想了解Redis相关的命令，可以参考Redis命令参考 hiredis简介hiredis是Redis的一个极简c客户端库。它实现了Redis协议的最小集，但同时也提供类printf的API，使用既方便有简介。hiredis提供了多种API，它同时支持同步，异步和回复解析API。在此基础上，能够实现Redis的流水线操作。 数据结构首先来看数据结构，主要分为两部分。保存Redis连接上下文的redisContext和保存Redis命令回复的RedisReply。下边分别介绍： 连接上下文redisContext首先看结构定义：1234567891011121314151617181920212223/* Context for a connection to Redis */typedef struct redisContext &#123; int err; /* Error flags, 0 when there is no error */ char errstr[128]; /* String representation of error when applicable */ int fd; int flags; char *obuf; /* Write buffer */ redisReader *reader; /* Protocol reader */ enum redisConnectionType connection_type; struct timeval *timeout; struct &#123; char *host; char *source_addr; int port; &#125; tcp; struct &#123; char *path; &#125; unix_sock;&#125; redisContext; 可以看到结构体中包含了一些必要的字段。obuf保存的是格式化后的Redis协议字符串，我们可以把这个字段打出来，可以理解Redis协议。后边介绍到具体接口再来看这个结构体。 回复结构体redisReply结构定义如下：123456789/* This is the reply object returned by redisCommand() */typedef struct redisReply &#123; int type; /* REDIS_REPLY_* */ long long integer; /* The integer when type is REDIS_REPLY_INTEGER */ size_t len; /* Length of string */ char *str; /* Used for both REDIS_REPLY_ERROR and REDIS_REPLY_STRING */ size_t elements; /* number of elements, for REDIS_REPLY_ARRAY */ struct redisReply **element; /* elements vector for REDIS_REPLY_ARRAY */&#125; redisReply; 从结构体定义可以看出，它可以表示不同类型的消息。最常用的包括：字符串，数组，整数。具体的在后边介绍。 总结以上两个结构体可以帮助我们理解hiredis库的内部实现，我们总会遇到库的一些坑。只有理解库的实现，才能够避免踩到这些坑。 同步接口hiredis提供了如下三个同步API：123redisContext *redisConnect(const char *ip, int port);void *redisCommand(redisContext *c, const char *format, ...);void freeReplyObject(void *reply); 可以看出使用同步接口分为三个步骤，创建连接，发送Redis命令，得到结果后释放回复类。 连接RedisredisConnect函数使用之前提到的redisContext来保存连接的状态。结构体redisContext的成员err非零表示连接出错，errstr保存具体的错误信息。调用redisConnect函数后，应该检查err来确认连接是否真的建立。123456789redisContext *c = redisConnect(\"127.0.0.1\", 6379);if (c == NULL || c-&gt;err) &#123; if (c) &#123; printf(\"Error: %s\\n\", c-&gt;errstr); // handle error &#125; else &#123; printf(\"Can't allocate redis context\\n\"); &#125;&#125; 值得注意的是redisContext不是线程安全的。 向Redis发送命令redisCommand是类printf的，可以向已经建立连接的Redis发送命令。 这个函数使用空格来区分Redis的参数。%s指明一个参数，该参数是一个\\0结尾的字符串。如果想使用二进制安全的版本，则可以使用%b，其需要两个参数，一个字符指针，一个表明这个字符串长度的size_t参数。 值得注意的是%s表明一个Redis命令的参数，即使这个字符串中包含空格，回车等字符。仔细阅读hiredis的代码你就会发现这一点。 下面是一些例子：1234567reply = redisCommand(context, \"SET foo bar\");reply = redisCommand(context, \"SET foo %s\", value);reply = redisCommand(context, \"SET foo %b\", value, (size_t) valuelen);reply = redisCommand(context, \"SET key:%s %s\", myid, value);// 这个将会出错，因为%s被解释为一个参数，所以Redis收到的就是一个参数的命令‘SET foo bar’，这当然会出错reply = redisCommand(context, \"%s\", \"SET foo bar\"); 获得命令的回复redisCommand返回值是一个redisReply的结构体，保存了命令的回复。如果出错，则返回值为NULL并且redisContext的err字段设置为非0。Once an error is returned the context cannot be reused and you should set up a new connection. redisReply结构体中的type字段表明了返回的数据类型。有如下几种枚举123456789101112// 表明回复是一个状态，状态的具体信息在str和len中REDIS_REPLY_STATUS// 表明回复是一个错误，错误信息在str和len中REDIS_REPLY_ERROR:// 表明回复是一个整数，整数保存在interger中，其实long long类型REDIS_REPLY_INTEGER:// 返回一个nil对象，表明没有数据REDIS_REPLY_NIL:// 回复一个字符串，字符串在str和len中REDIS_REPLY_STRING:// 表明回复是一个数组，保存在elements，element表明了数组的大小。可能回复是嵌套数组REDIS_REPLY_ARRAY: redisCommand获得的reply应该使用freeReplyObject函数释放内存。 Important: the current version of hiredis (0.10.0) frees replies when the asynchronous API is used. This means you should not call freeReplyObject when you use this API. The reply is cleaned up by hiredis after the callback returns. This behavior will probably change in future releases, so make sure to keep an eye on the changelog when upgrading (see issue #39). 断开连接使用完Redis后，使用redisFree来断开网络连接和释放对应的内存1void redisFree(redisContext *c); 变种的redisCommand由于redisCommand使用了可变参数技术，其就会有对应的va_list版本。下边是这一系列参数的原型1234567891011121314/* Write a command to the output buffer. Use these functions in blocking mode * to get a pipeline of commands. */int redisvAppendCommand(redisContext *c, const char *format, va_list ap);int redisAppendCommand(redisContext *c, const char *format, ...);int redisAppendCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen);/* Issue a command to Redis. In a blocking context, it is identical to calling * redisAppendCommand, followed by redisGetReply. The function will return * NULL if there was an error in performing the request, otherwise it will * return the reply. In a non-blocking context, it is identical to calling * only redisAppendCommand and will always return NULL. */void *redisvCommand(redisContext *c, const char *format, va_list ap);void *redisCommand(redisContext *c, const char *format, ...);void *redisCommandArgv(redisContext *c, int argc, const char **argv, const size_t *argvlen); 我们暂时忽略redisAppendCommand这一系列函数，我们在讲到流水线操作时会讲解它们。 可以看到这些函数与我们使用的其他可变参数函数没有什么区别。 另外一个需要介绍的函数是redisCommandArgv。它不再使用类printf的方法来指定参数，而使用argc和argv来指明参数。另外argvlen参数还给该函数提供了使用二进制字符串的方法。如果argvlen是NULL，那么该函数将使用strlen来确定每个参数的长度。再该函数中Redis命令总是第一个参数。 流水线操作我们下边解释hiredis的内部执行流程来理解为什么可以在同步的API中实现流水线操作。 当我们调用redisCommand等函数时，hiredis首先讲这些命令转化成Redis的协议。然后将转化后的命令写入输出缓冲区中，写入完成后，调用redisGetReply来获取命令的结果。该函数的流程如下： 输入缓冲区非空，尝试解析单个回复并返回。如果不能解析则进行2 输入缓冲区是空，将输出缓冲区的所有内容发送到Redis，然后从socket读取单个回复并返回 为了实现流水线操作，第一步就是使用redisAppendCommand或redisAppendCommandArgv填充输出缓冲区，函数原型参见上小结。 第二步我们需要调用redisGetReply，当然我们可以调用redisGetReply多次来获取多个命令的回复。我们需要判断redisGetReply的返回值来确定是否调用成功。成功返回REDIS_OK，失败返回REDIS_ERR。 下面是一个简单的例子：1234567redisReply *reply;redisAppendCommand(context,\"SET foo bar\");redisAppendCommand(context,\"GET foo\");redisGetReply(context,&amp;reply); // reply for SETfreeReplyObject(reply);redisGetReply(context,&amp;reply); // reply for GETfreeReplyObject(reply); 错误当函数返回NULL或REDIS_ERR的时候，redisContext的err字段将会设置成如下枚举：1234567REDIS_ERR_IO: There was an I/O error while creating the connection, trying to write to the socket or read from the socket. If you included errno.h in your application, you can use the global errno variable to find out what is wrong.REDIS_ERR_EOF: The server closed the connection which resulted in an empty read.REDIS_ERR_PROTOCOL: There was an error while parsing the protocol.REDIS_ERR_OTHER: Any other error. Currently, it is only used when a specified hostname to connect to cannot be resolved. redisContext的errstr字段将会指明具体的错误信息。 异步APITODO","categories":[],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://gwq5210.com/tags/Redis/"},{"name":"hiredis","slug":"hiredis","permalink":"https://gwq5210.com/tags/hiredis/"},{"name":"Redis API","slug":"Redis-API","permalink":"https://gwq5210.com/tags/Redis-API/"}],"keywords":[]},{"title":"Cpp-Primer-Plus读书笔记（三）","slug":"Cpp-Primer-Plus读书笔记（三）","date":"2017-08-02T22:25:37.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2017/08/02/Cpp-Primer-Plus读书笔记（三）/","link":"","permalink":"https://gwq5210.com/2017/08/02/Cpp-Primer-Plus读书笔记（三）/","excerpt":"","text":"第十章 对象和类面向对象编程是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，下边是最重要的OOP特性： 抽象 封装和数据隐藏 多态 继承 代码的可重用性 采用OOP方法时，首先从用户的角度考虑对象，描述对象所需的数据以及描述用户与数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据存储。 抽象和类对于基本类型，编译器需要维护如下内容： 决定数据对象需要的内存数量 决定如何解释内存中的位 决定可使用数据对象执行的操作或方法 对于C++中自定义的类，我们需要自己提供这些信息。 类中可以声明public和private及protected的成员。类设计尽可能的将公有接口与实现细节分开。公有接口表示设计的抽象组件，将实现细节放在一起并将它们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现的细节隐藏在私有部分中，也是封装，封装的另一个例子是将类定义和类声明放在不同的文件中。 数据隐藏可以防止直接访问数据，还让开发者无需了解数据是如何被表示的。这样，只要接口不变，我们就可以对程序的细节进行修改。 数据项一般来说是私有对象，接口成员一般放在公共部分。对于实现的细节相关的函数，我们可以作为私有成员函数。对于类来说，成员默认是私有的。一般我们显式的指出private。 C++对于C的结构进行了扩充，与类的功能类似，唯一的区别是结构的默认访问方式是公有的。 对于类成员函数的定义，与普通函数有两点不同： 定义成员函数时，使用作用域解析运算符来标识函数所属的类 类方法可以访问类的private组件 对于类中的函数或成员，我们说这些标识符具有类作用域。 定义位于类声明中的函数都将自动成为内联函数。除此之外还可以在类函数声明中使用inline。 内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。确保内联定义对多文件程序中的所有文件都可用。最简便的方法是：将内联定义放在定义类的头文件中。顺便说一句，根据改写规则，在类声明中定义方法，等同于用原型替换方法定义，然后在类声明的后边将定义改写为内联函数。 调用成员函数时，它将使用被用来调用它的对象的数据成员。 所创建的每个新对象都有自己的存储空间，用于存储其他内部变量和类成员。但同一个类的所有对象共享同一组类方法，即每种方法只有一个副本。 指定类设计的第一步是提供类声明。类声明类似结构声明，可以包含数据成员和函数成员。声明有私有部分，在其中声明的成员只能通过成员函数进行访问；声明还具有公有部分，在其中声明的成员可被使用类对象的程序直接访问，通常数据成员函数被放在私有部分中。 第二步是实现类成员函数。 类的构造函数和析构函数构造函数构造函数没有声明类型，其名字和类的名字一样。有两种方式使用构造函数，显式和隐式的调用，如下： 12Student s = Student(\"name\");Student t(\"name\"); 每次创建类对象，C++都使用构造函数。构造函数的使用不同于其他方法。 默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，C++将提供默认构造函数，它是默认构造函数的显式版本，不做任何工作。我们可以通过显式的方式重载一个构造函数。 析构函数对象过期时，程序将自动调用一个特殊的成员函数——析构函数。析构函数完成清理工作。析构函数的名字是在类名前面加上~。析构函数没有参数。如果没有提供析构函数，编译器将隐式的声明一个默认析构函数。 C++11的列表初始化可以用来初始化类。 有一种成员函数叫做const成员函数，这种函数不会修改调用对象，我们将const关键字放在函数括号的后边来实现这种函数。 123456void show() const;void show() const&#123; &#125; 只要类方法不修改调用对象，就应将其声明为const 初始化对象有三种方式 123Student a = Student(\"name\");Student b = Student(\"name\");Student c = \"name\"; 接受一个参数的构造函数允许使用赋值语法将对象初始化为一个值。这种特性可能会导致问题，我们可以关闭这种特性。 this指针每个成员函数都包含一个this指针。this指针指向用来调用成员函数的对象，其作为隐藏参数传递给方法。const成员方法中的this不能用来修改调用对象的值。 对象数组我们可以声明一个对象数组。并对其进行初始化，如果不进行初始化，则使用默认构造函数进行初始化。还可以使用初始化列表对对象数组进行初始化。 初始化对象数组的方案是首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的内容复制到相应的元素中，这就说明要想创建对象数组，这个对象必须有默认构造函数。 类作用域类作用域是c++特有的。其不同于全局作用域和局部作用域。在类中定义的名称的作用域都为类，作用域为整个类的名称只在类中是已知的，在类外不可知。不能从外部直接访问类的成员(必须通过类对象)。 使用类成员名时，必须根据上下文使用直接成员运算符(.)，间接成员运算符(-&gt;)或作用域解析运算符。 作用域为类的常量有两种方式，一种是在类内声明一个枚举。在类声明中声明的枚举的作用域为整个类，可以用枚举为整型常量提供作用域为整个类的符号名称。这种方式声明枚举并不会创建类数据成员。这种方式不比创建枚举类型的变量，因此不需要提供枚举名。 另一种方式是使用static关键字。这创建一个常量，其与其他静态变量存储在一起，而不是存储在对象中。如果不是const的方式，需要在类外进行初始化。在C++ 98中只能使用这种技术声明值为整数或枚举的静态常量，而不能存储double常量，C++ 11取消了这种限制。 12345class Test&#123;public: static const int num = 12;&#125;; 作用域内枚举(C++ 11)传统枚举可能会存在名称冲突，C++提供的新枚举，其枚举量的作用域为类。 12enum class egg &#123;Small, Large&#125;;enum class t_shirt &#123;Small, Large&#125;; 其中class可以替换为struct。使用时需要使用枚举名限定枚举量。如egg::Small。 C++ 11还提高了作用域内枚举的类型安全。在有些情况下常规枚举自动转换为整型，如将其赋值给int变量或用于比较表达式时，但作用域内枚举不能隐式地转换为整型。但可以进行显式转换。 枚举用某种底层整型类型表示，在C++ 98中如何选择取决于实现，其长度可能因系统而异。对于作用域内枚举，C++ 11消除了这种依赖性，默认情况下，C++ 11作用域内枚举的底层类型为int，另外，还提供了一种语法，可用于做出不同选择： 1enum class: short pizza &#123;Small, Large&#125;; 其底层类型为short。底层类型必须为整形。在C++ 11中也可以使用这种语法来指定常规枚举的底层类型，如果没有指定，编译器选择的底层类型将随实现而异。 抽象数据类型ADT(abstract data type)以通用的方式描述数据类型，而没有引入语言或实现细节。类的概念非常适用于ADT方法。私有部分隐藏实现的细节，共有的方法提供相应的接口。 第十一章 使用类学习C++的难点之一是需要记住大量的东西，但在拥有丰富的时间经验之前，根本不可能全部记住这些东西。“轻松的使用这种语言，不要觉得必须使用所用特性，不要在第一次学习时就试图使用所有特性”。 运算符重载运算符重载是一种形式的C++多态。函数重载是使用同名的函数来完成相同的基本操作。同样C++允许运算符有用多种不同的含义。C++(C)很多运算符已经被重载。 重载运算符op的格式如下 1operatorop(argument-list) op必须是有效的C++运算符。编译器使用重载的运算符op时使用这种格式obj1.operatorop(obj2) 不要返回局部变量或临时变量的引用，函数执行完毕后，局部变量或临时引用将会消失 我们可以首先定义一个sum函数，然后将sum换成operator+就可以重载+运算符，其他运算符同理有两种形式可以使用重载运算符 12sum = a.operator+(b);sum = a + b 可以使用重载运算符对多个操作数进行相加 重载限制 重载后的运算符必须至少有一个是用户定义的类型，这防止用户为标准类型重载运算符 使用运算符时不能违反运算符原来的句法规则，不能修改运算符的优先级 不能创建新的运算符 不能重载一些运算符，sizeof，.成员运算符，.*成员指针运算符，::作用域解析运算符，typeid一个RTTI运算符，const_cast，dynamic_cast，reinterpret_cast，static_cast强制类型转换运算符 大多数运算符都可以通过成员或非成员函数进行重载，下边的运算符只能通过成员函数进行重载，=赋值运算符，()函数调用运算符，[]下标运算符，-&gt;通过指针访问类成员运算符 友元C++提供了另外一种形式的访问权限友元。分为三种友元函数，友元类，友元成员函数，通过让函数称为类的友元，可以赋予该函数与类成员函数相同的权限。 在重载二元运算符时，常常需要友元。对于重载了+的类来说，a+1和1+a是一样的。但我们无法将1+a转换为1.operator+(a)的形式。这时候我们需要使用非成员函数来重载运算符，这种运算符的参数都是显式参数。这样就可以把1+a转换为operator+(1, a)。非成员函数不能访问a对象的私有成员，这时候就需要使用友元函数了。 创建友元的第一步是将函数原型放在类声明中，并在函数原型声明前加上关键字friend。它说明虽然其实在函数中声明的，但它不是成员函数，因此不能使用成员运算符来调用虽然它不是成员函数，但是它与成员函数的访问权限相同不要在函数定义中使用关键字friend 友元和类方法都是表达类接口的两种不同机制。友元必须在类声明中出现，所以类声明仍然控制着哪些函数可以访问私有数据。 如果要为类重载运算符，并将非类的项作为第一个操作数，则可以用友元函数来反转操作数的顺序。 常用的友元是重载&lt;&lt;运算符，重载后可以将其与cout结合输出对象的内容。通用格式 12345ostream &amp;operator&lt;&lt;(ostream &amp;os, const c_name &amp;obj)&#123; os &lt;&lt; ...; return os;&#125; 只有在类声明中的原型中才能使用friend关键字，除非函数定义也是原型，否则不能在函数定义中使用该关键字 重载运算符：作为成员函数还是非成员函数非成员函数版本的重载运算符函数所需要的形参数目与运算符使用的操作数数目相同，成员函数版本的参数少一个，因为其中一个操作数是被隐式的传递的调用对象。 定义运算符时，必须选择其中的一种格式，不能同时选用这两种格式。某些情况下成员函数是唯一的选择，其他情况下，这两种方式没有太大区别。有时使用友元的版本更好一点。 运算符重载是通过函数实现的，所以只要运算符函数的特征标不同，使用的运算符数量与相应的内置C++运算符相同，就可以多次重载同一个运算符 类的自动转换和强制类型转换将一个标准的类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则C++自动将这个值转换为接收变量的类型。但不进行转换不兼容的类型 可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的。这种情况下，程序员可以指示C++如何自动进行转换，或通过强制类型转换来完成。 在C++中接受一个参数的构造函数为将类型与该参数相同的值转换为类提供了蓝图。这种转换是自动进行的，而不需要显式强制类型转换。只有接受一个参数的构造函数才能作为转换函数（其他参数可以是默认值）。 1Student c = \"name\"; 我们也提供了explicit关键字用于关闭这种自动特性。但仍然允许显式转换。隐式转换在下列情况下出现 将对象初始化为构造函数参数类型时 将构造函数参数类型赋值给对象时 将构造函数类型传递给接受对象参数的函数时 返回值被声明为对象的函数试图返回构造函数参数类型时 在上述任意情况下，使用可自动转换为double类型的内置类型时 最后一点当且仅当不存在二义性时，才会进行这种转换 转换函数可以将用户定义的类型转换成某种类型，这是用户定义的强制类型转换，可以像使用强制类型转换一样使用它们。 1operator typeName(); 转换函数必须是类方法转换函数不能指定返回类型转换函数不能有参数 如果存在二义性转换，编译器不会进行自动转换。但我们可以通过强制类型转换来指出需要使用哪个转换函数 12long gone = (double)a;long gone = double(a); 在C++98中，explicit关键字不能用于转换函数，C++11消除了这种限制，在C++11中可以将转换函数声明为显式的 1explicit operator int() const; 这样就必须使用强制类型转换来使用。另一种方式是定义一个功能相同的非转换函数替代，其必须被显式的调用。 C++提供了如下类型转换 只有一个参数的构造函数用于将类型与该参数相同的值转换为类类型，使用explicit可以防止隐式转换，只能使用显式转换 被称为转换函数的特殊类成员运算符函数，用于将类对象转换为其他类型。 实现加法的选择，可以使用友元+一个参数的构造函数，或者将加法运算符进行重载，它们各有优点，前者程序简短，但依赖隐式转换，出错少，但调用时间和效率不高，后者正好相反。具体要看使用场景 经验表明，最好不要依赖这种隐式转换函数。 第十二章 类和动态内存分配C++使用new和delete运算符来动态控制内存，但在类中使用这些运算符将导致许多新的编程问题，这种情况下，析构函数将是必不可少的，有时候还必须重载赋值运算符，保证程序的正确性。 静态类成员只创建一个静态类变量副本。不能在类声明中初始化静态成员变量，静态类成员可以在类声明外用单独的语句进行初始化，初始化语句中指出了类型，并使用了作用域运算符，但没有使用关键字static。初始化不能放在头文件中。静态数据成员为整型或枚举型const可以在类声明中初始化。 在构造函数中使用new来分配内存时，必须在相应的析构函数中使用delete来释放内存，如果使用new[]来分配内存，则应使用delete[]来释放内存。 具体来说，C++自动提供了下面这些成员函数 默认构造函数，如果没有定义构造函数 默认析构函数，如果没有定义 复制构造函数，如果没有定义 赋值运算符，如果没有定义 地址运算符，如果没有定义，返回this的值 C++11还提供了另外两个特殊成员函数：移动构造函数(move constructor)和移动赋值运算符(move assignment operator) 带有参数的构造函数也可以是默认构造函数，只要所有参数都有默认值 复制构造函数复制构造函数用于将一个对象复制到新创建的对象中，它用于初始化过程中，包括按值传递参数，而不是常规的赋值过程，其原型如下 1class_name(const class_name &amp;c); 需要知道何时调用和有何功能 何时调用复制构造函数新建一个对象并将其初始化为同类现有对象时，复制构造函数都将被调用 12345string a;string s(a);string s = a;string s = string(a);string s = new string(a); 中间的两种声明可能会使用复制构造函数直接创建对象，也可能使用复制构造函数生成一个临时对象，然后将临时对象内容赋给变量，这取决于具体实现。 每当程序生成了对象副本时，编译器都将使用复制构造函数。例如函数按值传递对象，函数返回对象，生成临时对象（如将对象相加）时。 按引用传递可以节约时间和存储空间。 默认的复制构造函数的功能默认的复制构造函数逐个复制非静态成员(成员复制也叫浅复制)，复制的是成员的值。如果成员本身就是类对象，则使用这个类的复制复制函数来复制成员对象。静态函数不受影响，因为它们属于整个类，而不是各个对象。 如果类中包含这样的静态数据成员，即其值将在新对象创建时发生变化，则应该提供一个显式复制构造函数来处理计数问题。 处理类遇到常用的问题就是进行深度复制(deep copy)。应该复制内容（new初始化的，指向数据的指针）而不是地址。 赋值运算符赋值运算符的原型如下 1class_name &amp;class_name::operator=(const class_name &amp;c); 它接受并返回一个指向类对象的引用。 赋值运算符的功能以及何时使用它将已有的对象赋值给另一个对象时，将使用赋值运算符，初始化对象时不一定会使用赋值运算符。与复制构造函数相似，赋值运算符的隐式实现也对成员进行逐个复制，如果成员本身就是类对象，则程序将使用为这个类定义的赋值运算符来复制该成员，但静态数据成员不受影响。 解决赋值运算符的问题仍然是提供赋值运算符的定义，进行深度复制，需要注意的是 由于目标对象可能引用了以前分配的数据，所以可能需要释放之前的内存 函数应该避免将对象赋给自身，需要进行特别判定 函数返回一个指向调用对象的引用 C++空指针，在C++98中，字面值0有两个含义：可以表示数字值零，也可以表示空指针。C语言用NULL表示空指针，C++11提供了关键字nullptr，表示空指针。但仍保留了使用0的方式 对于操作符[]，有两个操作数。重载[]时，C++将区分常量和非常量函数的特征标。后者就可以读const对象了 12char &amp;opeartor[](int idx);const char &amp;operator[](int idx) const; 静态类成员函数不能通过对象调用静态成员函数；静态成员函数不能使用this指针，可以通过类名和作用域解析运算符来调用它。静态类成员函数只能使用静态数据成员。 在构造函数中使用new时应注意的事项 如果在构造函数中使用new([])来初始化指针成员，则应该在析构函数中使用delete([]) 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象 应定义一个赋值运算符，通过深度复制想一个对象复制给另一个对象 返回对象的说明 返回指向const对象的引用 返回指向非const对象的引用 返回对象 返回const对象，使用+运算符的时，否则可能出现a+b=c情况 使用指向对象的指针析构函数的调用 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数 如果对象是静态变量(外部，静态，静态外部或来自名称空间)，则在该程序结束时将调用该对象的析构函数 如果对象是new创建的，则仅当您显式的使用delete删除对象时，其析构函数才会被调用 定位new运算符delete不能与定位new运算符配合使用，因此在使用定位new运算符时，不能使用delete来删除对象，进而调用析构函数。解决方案是显式的为定位new运算符创建的对象调用析构函数。需要注意的一点是正确的删除顺序，对于使用定位new运算符创建的对象，应以创建顺序相反的顺序进行删除，原因在于晚创建的对象可能依赖于早创建的对象，另外，仅当所有对象被销魂后，才能释放用于存储这些对象的缓冲区。 其他我们可以在类中嵌套结构或类声明。其作用域为整个类。公共的定义还可以通过类名和作用域解析运算符来使用。 在类中初始化非静态const或引用对象时，我们需要使用成员初始化列表(member initializer list)，只有构造函数可以使用这种方式。对于本身就是类对象的成员来说，使用初始化列表效率更高。初始化的顺序与他们在类声明中出现的顺序相同，与初始化列表中的排列顺序无关。 C++11可以使用类内初始化初始化非静态const成员，在类中可以使用这样的语句int a = 10;在构造函数中的成员初始化列表会覆盖其值。 第十三章 类继承C++提供了类继承，能够从已有的类派生出新的类，而派生类继承了原有类（称为基类）的特征，包括方法。通过继承可以在已有类的基础上添加功能。可以给类添加数据。可以修改类方法的行为。 派生类对象将包含基类对象，使用共有派生，基类的共有成员将成为派生类的共有成员，基类的私有部分也将成为派生类的一部分，但只能通过基类的共有或保护方法访问。派生类需要自己的构造函数，派生类可以根据需要添加额外的数据成员和成员函数。 派生类构造函数必须使用基类构造函数，创建派生类对象时，程序首先创建基类对象。基类对象应该在程序进入派生类构造函数之前被创建，在C++中成员初始化列表语法来完成这种工作。如果不调用基类构造函数将调用默认的基类构造函数，派生类构造函数应该初始化派生类新增的数据成员。派生类对象过期时，程序将首先调用派生类析构函数，然后再调用基类析构函数。 派生类对象可以使用基类的方法，条件是方法不是私有的。基类指针可以在不进行显式类型转换的情况下指向派生类对象；基类引用可以在不进行显式类型转换的情况下引用派生类对象。但是基类指针或引用只能调用基类方法。 有三种继承方式：共有继承，保护继承，私有继承。共有继承是一种is-a关系，派生类对象也是一个基类对象。其他需要区分的是has-a，is-like-a，is-implemented-as-a，uses-a关系。 多态共有继承如果希望同一个方法在派生类和基类中的行为是不同的，方法的行为取决于调用该方法的对象，这种较复杂的行为称为多态——具有多种形态，即同一个方法的行为随上下文而异。可以通过两种重要的机制用于实现多态共有继承。在派生类中重新定义基类的方法或使用虚方法。 如果要在派生类中重新定义基类的方法，通常应将基类方法声明为虚的，这样程序将根据对象类型而不是引用或指针的类型来选择方法版本。为基类声明一个虚析构函数也是一种惯例。 为何需要虚析构函数。如果析构函数不是虚的，则将只调用对应于指针类型的析构函数。因此使用虚析构函数可以保证正确的析构函数序列被调用。 静态联编和动态联编将源代码中的函数调用解释为执行特定函数代码块被称为函数名联编(binding)。C或C++编译器可以在编译过程完成这种联编。在编译过程中进行联编称为静态联编(static binding)。然而虚函数必须使用动态联编(dynamic binding)，必须生成能够在程序运行过程中选择正确虚函数方法的代码。 将派生类引用或指针转换为基类引用或指针被称为向上强制转换(upcasting)，这使得共有继承不需要进行显式类型转换。相反的过程，将基类指针或引用转换为派生类指针或引用称为向下强制转换(downcasting)。 为什么有两种类型的联编以及为什么默认为静态联编我们需要考虑效率和概念模型。为了能使程序能够在运行阶段进行决策，必须采取一些方法来跟踪基类指针或引用指向的对象类型，这增加了额外的开销。如果不需要重新定义方法，则使用静态联编更合理。因为其效率更高，因此被设置为C++的默认选择。一个原则是不要为不使用的特性付出代价(内存或处理时间)。仅当程序设计确实需要使用虚函数时，才使用他们。 另外在类设计时，可能包含一些不在派生类中重新定义的成员函数，不设置该函数为虚函数效率更高，另外也指出不要重新定义该函数。这表明仅将那些预期将被重新定义的方法声明为虚的。 虚函数的工作原理通常编译器处理虚函数的方法是给每个对象添加一个隐藏成员。隐藏成员保存了一个指向函数地址数组的指针，这种数组被称为(虚函数表，virtual function table，vtbl)。虚函数表中存储了为类对象进行声明的虚函数的地址。如果派生类没有重新定义虚函数，该vtbl将保存函数原始版本的地址。如果派生类定义了新的虚函数，则该函数地址也将被添加到vtbl中。其成本包括 每个对象都将增大，增大为存储地址的空间 对于每个类，编译器都创建一个虚函数地址表(数组) 对于每个函数调用，都要执行一项额外的操作，即到表中查找地址 虚函数的要点 在基方法的生命中使用关键字virtual可使该方法在基类以及在所有的派生类(包括从派生类派生出来的类)中是虚的 如果使用指向对象的引用或指针来调用虚方法，程序将使用为对象类型定义的方法，而不使用为引用或指针类型定义的方法。这称为动态联编或晚期联编。这种行为非常重要，因为这样基类指针或引用可以指向派生类对象 如果定义的类将被用作基类，则应将那些要在派生类中重新定义的类方法声明为虚的 构造函数不能是虚函数，创建派生类对象时，将调用派生类的构造函数，而不是基类的构造函数，然后派生类的构造函数将使用基类的一个构造函数，这不同于继承。 析构函数应当是虚函数，除非类不用作基类。 友元不能是虚函数，因为友元不是成员函数 如果派生类没有重新定义函数，则将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本，例外的情况是基类版本是隐藏的。 重新定义将隐藏方法重新定义继承的方法并不是重载，如果在派生类中重新定义函数，将不是使用相同的函数特征标覆盖基类声明，而是隐藏同名的基类方法，不管参数特征标如何。 如果重新定义继承的方法，应确保与原来的原型完全相同，但如果返回类型是基类引用指针，则可以修改为指向派生类的引用或指针，这种特性被称为返回类型协变(covariance of return type)，因为允许返回类型随类类型的变化而变化。这种例外只适用于返回值，而不适用于参数。 如果基类声明重载了，则应在派生类中重新定义所有的基类版本。如果只重新定义一个版本，则其他的版本将被隐藏。如果不需要修改，则新定义可只调用基类版本。 访问控制：protected关键字protected与private相似，在类外只能用共有类成员来访问protected部分中的类成员，private和protected之间的区别只有在基类派生的类中才会表现出来。派生类的成员可以直接访问基类的保护成员。因此，对于外部世界来说保护成员的行为与私有成员类似，但对于派生类来说，保护成员的行为与共有成员相似。 最好对类数据成员采用私有访问控制，不要使用保护访问控制，同时通过基类方法使派生类能够访问基类数据。对于成员函数来说，保护访问控制很有用，他让派生类能够访问公众不能使用的内部函数。 抽象基类抽象基类比较复杂(abstract base class)。C++通过使用纯虚函数(pure virtual function)提供未实现的函数。纯虚函数声明的结尾处为=0 当类声明中包含纯虚函数的时候，则不能创建类对象。这里的理念是，包含纯虚函数的类只用作基类。在原型中使用=0指出类是一个抽象基类，再类中可以不定义该函数。但也可以定义不过好像没什么作用。 可以将ABC看作是一种必须实施的接口。ABC要求具体派生类覆盖其纯虚函数——迫使派生类遵循ABC设置的接口规则。 继承和动态内存分配在继承中使用动态内存分配需要注意一些情况。 第一种情况：派生类不使用new假设基类使用了动态内存分配，并且正确实现了析构函数，复制构造函数和重载赋值运算符。如果其派生类不使用动态内存分配，其是否需要显式的定义析构函数，复制构造函数，赋值运算符。答案是不用。 派生类的析构函数总要执行自身的代码后调用基类析构函数，因为派生类的析构函数不需要进行任何操作，所以不用显式提供析构函数。 默认复制构造函数执行成员复制，对于派生类来说没有问题。我们要考虑从基类继承过来的组件，复制类成员或继承的类组件时，则是使用该类的复制构造函数完成的。所以默认构造函数对于派生了也是合适的。赋值运算符也类似。 第二种情况：派生类使用了new派生类使用了动态内存分配，则必须为派生类定义显式析构函数，复制构造函数，赋值运算符。 派生类析构函数自动调用基类的析构函数，故其职责是对派生类构造函数执行工作的进行清理，因此派生类的析构函数需要释放派生类分配的内存。复制构造函数需要深度复制派生类的动态内存分配部分，同时也要调用基类的复制构造函数，方法是使用成员初始化列表调用基类的复制构造函数。基类引用可以指向派生类对象。 赋值运算符需要处理派生类的动态内存分配，同时也需要调用基类的赋值运算符，我们必须显式调用基类的赋值运算符，BaseClass::operator=(c)。必须使用这种函数表示法，否则可能会造成递归调用。 友元函数并非类成员，因此不能继承，然而，您可能希望派生类的友元函数能够使用基类的友元函数，为此，可以通过强制类型转换，派生类引用或指针转换为基类的引用或指针，然后使用转换后的指针或引用来调用基类的友元函数。","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://gwq5210.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"Cpp Primer Plus","slug":"Cpp-Primer-Plus","permalink":"https://gwq5210.com/tags/Cpp-Primer-Plus/"}],"keywords":[]},{"title":"APUE笔记(一)","slug":"APUE笔记-一","date":"2017-07-12T01:22:08.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2017/07/12/APUE笔记-一/","link":"","permalink":"https://gwq5210.com/2017/07/12/APUE笔记-一/","excerpt":"","text":"第一章 UNIX基础知识所有的操作系统都为它们所运行的程序提供服务。典型的服务包括：执行新程序、打开文件、读文件、分配存储区以及获得当前时间等。 从严格意义上说，可以将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境。从广义上说，操作系统包含了内核和一些其他软件，这些软件使得计算机能够发挥作用，并使计算机具有自己的特性。 我们通常将这种软件成为内核（kernel），因为它相对较小，而且位于环境的核心。 内核的接口称之为系统调用（system call）。公共函数库构建在系统调用接口之上，应用程序既可使用公共函数库，也可以使用系统调用。shell是一个特殊的应用程序， 为运行其他应用程序提供了一个接口。 系统的口令文件由7个以冒号分割的字段组成，依次是：登录名、加密口令、数字用户ID、数字组ID、注释字段、起始目录以及shell程序。目前所有已知的系统已将加密口令移到另一个文件中。 shell是一个命令解释器，它读取用户输入，然后执行命令。 UNIX文件系统是目录和文件的一种层次结构，所有的目录或文件以根（root，/）为起点。 目录是一个包含目录项的文件。每个目录项都包含文件名和文件属性。目录中的各个名字称为文件名。斜线（分割路径）和空字符（标记路径名结尾）不能出现在文件名中。创建新目录会自动创建点和点点目录，分别表示当前目录和上一级目录。根目录中，点点和点相同。 以斜线开头的路径名成为绝对路径，否则称为相对路径。 每个进程都有工作目录（working directory），有时称其为当前工作目录（current working directory）。所有相对路径都从工作目录开始解释。登录时，工作目录设置为起始目录（home direcotry）。 文件描述符（file descriptor）通常是一个小的非负整数，内核用于标识一个特定进程正在访问的文件。 当运行一个新程序时，所有的shell都为其打开3个文件描述符，即标准输入，标准输出，标准错误。 函数open，write，read，lseek和close提供了不带缓冲的IO。标准IO函数为那些不带缓冲的函数提供了一个带缓冲的接口，我们无需担心如何选取最佳的缓冲区大小。 程序（program）是一个存储在磁盘上某个目录中的可执行文件。程序的执行实例被称为进程（process）。UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，它是一个非负整数。 通常一个进程只有一个线程（thread）。但进程中可以有多个线程。一个进程内的所有线程共享同一地址空间，文件描述符，栈及进程相关属性。线程也使用线程ID标识。 UNIX系统函数出错时，函数通常返回一个负值， 而且整型变量errno通常被设置为具有特定信息的值。在支持线程的环境中，多个线程共享进程地址空间，每个线程都有属于它自己的局部errno。 使用errno需要注意，如果没有出错，其值不会被任何例程清除。因此仅当函数的返回值指明出错时，才检验其值。任何函数都不会将errno值设置为0。 errno定义的错误可以分为两类，致命的和非致命的。对于致命的错误无法进行恢复动作。对于非致命的错误，有时可以进行妥善的处理。与资源相关的非致命错误包括：EAGAIN、ENFILE、ENOBUFS、ENOLCK、ENOSPC、EWOULDBLOCK，有时ENOMEM也是非致命错误。当EBUSY指明共享资源正在使用时，也可将它作为非致命性出错处理。当EINTR中断一个慢速系统调用时，可将它作为非致命性错误处理。 口令文件登录项中的用户ID是一个数值，用来标识各个不同的用户。用户ID为0的用户为根用户或超级用户。我们称超级用户的特权为超级用户特权。 组被用于将若干用户集合到一起，便于共享资源。我们用组ID来标识用户组。组文件为/etc/group，它将组ID映射为组名。 使用数值的用户ID和组ID是历史原因，它们更节省磁盘空间，在权限校验时，更加节省资源。 多数UNIX系统还允许用户属于另外一个组，我们称之为附属组（supplementary group）。 信号（signal）用来通知进程发生了某种情况。对于信号，进程有三种方式处理： 忽略信号 按照系统默认方式处理 提供一个函数，信号发生时调用该函数，这被称为捕捉该信号 在进程中，我们可以调用kill函数向另一个进程发送信号，前提是我们必须是这个进程的所有者或者超级用户。 UNIX使用两种不同的时间值。一是日历时间，该值是自协调世界时（Coordinated Universal Time，UTC）1970年1月1日00:00:00这个特定时间以来所经历的秒数累计值。系统基本数据类型使用time_t保存这个时间。二是进程时间。也被称为CPU时间，用于度量进程使用的中央处理器资源。进程时间以时钟时间为单位。系统基本数据类型clock_t保存这种时间值。我们可以通过sysconf函数得到每秒的时钟滴答数。UNIX为一个进程维护了三个进程时间： 时钟时间，是进程运行的时间总量，其值与系统同时运行的进程数有关。 用户CPU时间，是执行用户指令所用的时间量。 系统CPU时间，是为该进程执行内核程序所经历的时间。 我们可以简单的使用命令time获取程序的执行时间。 所有的操作系统都提供多种服务的入口点，由此程序向内核请求服务。各种版本的UNIX实现都提供良好定义、数量有限、直接进入内核的入口点，这些入口点被称为系统调用。系统还定义了通用库函数，这些函数可能会使用一个或多个系统调用，但是它们并不是内核的入口点。 从实现者的角度，系统调用和库函数之间有根本的区别，但从用户角度看，其区别并不重要。我们应该理解，如果希望的话，我们可以替换库函数，但是系统调用通常是不能被替换的。 应用程序既可以调用系统调用也可以调用库函数。很多库函数则会调用系统调用。系统调用通常提供一种最小接口，而库函数通常提供比较复杂的功能。 第二章 UNIX标准及实现人们在UNIX环境编程和C程序设计语言的标准化方面做已经做了很多工作。 UNIX系统实现定了了很多幻数和常量。其中很多已经被硬编码到程序中，或用特定的技术确定。以下两种类型的限制是必须的： 编译时限制，可以在头文件中定义，程序在编译时可以包含这些头文件 运行时限制，要求程序调用一个函数获得限制值 某些限制在给定的实现中是确定的，但在另一个实现中可能是变动的。为了解决这类问题，提供了如下三种限制： 编译时限制(头文件) 与文件或目录无关的运行时限制(sysconf函数) 与文件或目录有关的运行时限制(pathconf或fpathconf函数) ISO C定义的所有编译时限制都在头文件&lt;limits.h&gt;中。这些限制在一个给定的系统中并不会改变。我们将会遇到的一个问题是系统是否提供带符号或无符号的字符值，可以通过其中定义的值确定。另一个ISO C的常量是FOPEN_MAX，这是具体实现保证可同时打开的标准IO流的最小个数，其在头文件&lt;stdio.h&gt;中定义，最小值是8。POSIX.1中的STREAM_MAX则应与其相同。头文件stdio.h中还定义了TMP_MAX，这是由tmpnam函数产生的唯一文件名的最大个数。在ISO C中虽然定义了常量FILENAME_MAX，但我们应该避免使用。POSIX.1提供了更好的代替常量NAME_MAX和PATH_MAX。 POSIX可以分为7类： 数值限制：LONG_BIT，SSIZE_MAX，WORD_BIT 最小值 最大值，_POSIX_CLOCKRES_MIN 运行时可以增加的值：CHARCLASS_NAME_MAX，COLL_WEIGHTS_MAX，LINE_MAX，NGROUPS_MAX，RE_DUP_MAX 运行时不变值 其他不变值 路径名可变值：FILESIZEBITS，LINK_MAX，MAX_CANON，MAX_INPUT,MAX_INPUT，NAME_MAX，PATH_MAX，PIPE_BUF，SYMLINK_MAX 最小值是不变的，它们不随系统改变。它们指定了这些特征最具约束性的值。一个符合POSIX.1的实现应当至少提供这样的值。为了保证移植性，严格符合标准的应用程序不应要求更大的值 不过某些最小值在实际中太小了。 运行时限制可以通过下面3个函数获得： 123456#include &lt;unistd.h&gt;long sysconf(int name);long pathconf(const char *pathname, int name);long fpathconf(int fd, int name);若成功，返回相应值；若出错，返回-1 我们讨论这三个函数不同的返回值： 如果name参数并不是一个合适的常量，这三个函数都返回-1，并把errno设置为EINVAL 有些name返回一个变量值(大于等于0)，或者提示该值是不确定的，不确定的值通过返回-1来体现，但不改变errno的值 _SC_CLK_TCK返回值是每秒的时钟滴答数，用于times函数的返回值 对于后两个函数的第一个参数有很多限制。可以通过手册查询。 不确定的运行时限制： 路径名，可以通过PATH_MAX来获得，但是结果可能是不确定的 最大打开文件数，守护进程中一个常见的代码就是关闭所有打开的文件 12345#include &lt;sys/param.h&gt;for (int i = 0; i &lt; NOFILE; ++i)&#123; close(i);&#125; 但这种方式是不可移植的，所以可以通过sysconf来获取，尽可能提高移植性 如果我们需要编写可以移植的程序，这些程序可能依赖一些可选的支持的功能，我们需要一个可移植的方法来确定实现是否支持一个给定的选项 有三种处理选项的方法： 编译时选项定义在unistd.h中 与文件或目录无关的选项使用sysconf确定 与文件或目录有关的选项使用pathconf或fpathconf确定 对于每一个选项，有三种可能的平台支持状态。 如果符号常量没有定义或者定义值为-1，那么该平台在编译时不支持相应选项。但是有一种可能，在已支持该选项的新系统上运行老应用时，即使该选项在应用编译时未被支持，但如今新系统运行时检查会显示该选项已经支持 如果符号常量的定义值大于0，那么支持该选项 如果符号常量的值为0，则必须调用三个函数来确定是否支持相应的选项 如果在编译程序时，希望它只与POSIX的定义有关，而不与任何实现定义的常量冲突，那么需要定义常量_POSIX_C_SOURCE，一旦定义了该常量，所有POSIX.1的头文件都是用此常量来排除任何实现专有的定义。可以在编译时指定该常量 头文件sys/types.h中定义了某些与实现有关的数据类型，它们被称为基本系统数据类型(primitive system data type)，它们使用C语言的typedef定义，大多使用_t结尾，用这种方式定义了这些数据类型时，就不需要考虑因系统不同而变化的程序实现细节。 类型 说明 clock_t 时钟滴答计数器 comp_t 压缩的时钟滴答 dev_t 设备号，主和次 fd_set 文件描述符集 fpos_t 文件位置 gid_t 数值组ID ino_t i节点编号 mode_t 文件类型，文件创建模式 nlink_t 目录项的链接计数 off_t 文件长度和偏移量，带符号的 pid_t 进程ID和进程组ID，带符号的 pthread_t 线程ID ptrdiff_t 两个指针相减的结果 rlim_t 资源限制 sig_atomic_t 能原子性访问的数据类型 sigset_t 信号集 size_t 对象长度，如字符串，不带符号的 ssize_t 返回字节计数器的函数，带符号的 time_t 日历时间的秒计数器 uid_t 数值用户ID wchar_t 能表示所有不同的字符码 第三章 文件IOUNIX系统大多数的文件IO只需要5个函数：open，read，write，lseek，close。对于read和write不同缓冲区对读取性能有一定影响。这些函数常被称为不带缓冲的IO。属于不带缓冲指的是每个read和write都调用内核中的一个系统调用。如果在多个进程之间共享资源，我们需要了解原子操作。 对内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。 open函数调用open或openat可以打开或创建一个文件： 123456#include &lt;fcntl.h&gt;int open(const char *path, int oflag, ... /* mode_t mode */);int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);若成功，返回文件描述符；若出错，返回-1 path参数时要打开或创建的文件的名字。oflag参数可用来说明此函数的多个选项。用下面一个或多个常量进行或来构成oflag参数。 O_RDONLY，只读打开 O_WRONLY，只写打开 O_RDWR，读写打开 O_EXEC，只执行打开 O_SEARCH，只搜索打开(应用于目录) 以上5个常量中必须指定一个且只能指定一个。下列常量是可选的： O_APPEND，每次写都追加到文件的结尾 O_CLOEXEC，把FD_CLOEXEC常量设置为文件描述符标志。 O_CREAT，若此文件不存在则创建它。使用此选项open或openat函数需同时说明mode参数，用mode指定该新文件的访问权限位。 O_DIRECTORY，如果path引用的不是目录，则出错。 O_EXCL，如果同时指定了O_CREAT，而文件已经存在，则出错。用此可以测试一个文件是否存在，如果不存在则创建文件，这使得测试和创建两者成为一个原子操作。 O_NOCTTY，如果path引用的是终端设备，则不将该设备分配作为此进程的控制终端。 O_NOFOLLOW，如果path引用的是一个符号链接，则出错。 O_NOBLOCK，如果path引用的是一个FIFO，一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的IO操作设置非阻塞方式。 O_SYNC，使每次write等待物理IO操作完成，包括由该write操作引起的文件属性更新所需的IO。 O_TRUNC，如果此文件存在，而且为只写或读写成功打开文件，则将其长度截断为0。 O_TTY_INIT，如果打开一个还未打开的终端设备，设置非标准的termios参数值，使其符合single UNIX Specification。 O_DSYNC，使每次write要等待物理IO操作完成，但是如果该写操作并不影响读取刚写的数据，则不需要等待文件属性被更新。文件属性包括文件大小等信息。 O_RSYNC，使每一个以文件描述符作为参数进行的read操作等待，直至所有对文件同一部分挂起的写操作都完成。 对于每一个选项，具体可以阅读man手册。 由open或openat函数返回的文件描述符一定是最小的未被使用的描述符的值。 fd参数把open和openat参数区分开： path参数指定的是绝对路径名，在这种情况下，fd参数被忽略，openat函数相当于open函数。 path参数指定的是相对路径名，fd参数指出了相对路径名在文件系统中的开始地址。fd参数时通过打开相对路径名所在的目录来获取。 path参数指定了相对路径名，fd参数具有特殊值AT_FDCWD。在这种情况下，路径名在当前工作目录获取，open函数在操作上与open函数类似。 openat函数希望解决两个问题，一是让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。二是可以避免time-of-check-to-time-of-use(TOCTTOU)错误，其基本思想是，如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的，因为两个调用并不是原子操作，在两个函数调用之间的文件可能改变了，这样也就造成了第一个调用的结果不再有效，使得最终程序的结果是错误的。 使用open需要注意文件名截断。现在大多数系统支持的文件名长度可以为255。 creat函数另外，creat函数也可以创建一个文件： 1234567#include &lt;fcntl.h&gt;int creat(const char *path, mode_t mode);// 等效于open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);若成功，返回只为写打开的文件描述符；若出错，返回-1 它只以写的方式打开所创建的文件, 可以使用open代替, 以读写方式打开创建的文件 1open(path, O_RDWR | O_CREAT | O_TRUNC, mode); close函数函数close关闭一个打开的文件： 12345#include &lt;unistd.h&gt;int close(fd);若成功，返回0；若出错，返回-1 关闭一个文件时，还会释放该进程加在该文件上的所有记录锁。当一个进程终止，内核自动关闭它所有的打开文件。 lseek函数每个打开的文件都有一个与其相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用于度量从文件开始处计算的字节数。通常读写操作都从当前文件便宜量开始，并使偏移量增加所读写的字节数。按照系统默认情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0。 lseek可以显式的设置偏移量： 12345#include &lt;unistd.h&gt;off_t lseek(int fd, off_t offset, int whence);若成功，返回新的文件偏移量；若出错，返回-1 对offset参数的解释与whence的值有关： 若whence是SEEK_SET，则将该文件的偏移量设置为距文件开始处offset个字节 若whence是SEEK_CUR，则将该文件偏移量设置为其当前值加上offset，offset可正可负 若whence是SEEK_END，则该文件偏移量设置为文件长度加上offset，offset可正可负 lseek成功执行返回新的文件偏移量： 12off_t curr_pos;curr_pos = lseek(fd, 0, SEEK_CUR); 这种方法可以确定打开文件的当前偏移量，也可以来确定涉及的文件是否可以设置偏移量。如果文件描述符指向的是一个管道，FIFO，或网络套接字，则lseek返回-1，并将errno设置为ESPIPE。 通常文件的当前偏移量应该是一个非负整数，但是某些设备也可能允许负的偏移量，但对于普通文件，必须是非负值。在比较lseek返回值时应该注意，不要测试它是否小于0，而要测试它是否等于-1。 lseek仅将当前的文件偏移量记录在内核中，它并不引起任何IO操作，该偏移量用于下一次读或写。 文件的偏移量可以大于当前文件大小，这种情况下，将会引起文件空洞，没被写过的字节都被读为0，文件中的空洞并不要求在磁盘上占用存储区，具体与实现有关。 lseek使用的偏移量用off_t类型表示，允许具体实现根据各自的平台自行选择合适的数据类型。 read函数read函数从打开的文件中读取数据： 12345#include &lt;unistd.h&gt;ssize_t read(int fd, void *buf, size_t nbytes);返回已读到的字节数，若已到文件尾，返回0；若出错，返回-1 如果read成功，返回读取到的字节数。如已到达文件末端，返回0。多种情况使得实际读取到的字节数少于要求读取的字节数： 读取普通文件时，在读到要求字节数之前已经达到了文件尾端。 当从终端设备读时，通常依次最多读取一行。 当从网络读时，网络中的缓冲机制可能造成返回值小于所要求读的字节数。 当从管道或FIFO读时，如果管道包含的字节少于所需的数量，那么read将返回实际可用的字节数。 当从某些面向记录的设备(如磁带)读时，一次最多返回一个记录 当一信号造成中断，而已经读了部分数量时。 读操作从当前文件偏移量开始，在成功返回之前，该偏移量将增加实际读到的字节数。 write函数write函数向打开的文件写入数据。 12345#include &lt;unistd.h&gt;ssize_t write(int fd, const void *buf, size_t nbytes);若成功，返回已写的字节数；若出错，返回-1 返回值通常与nbytes相同，否则表示出错，write出错的一个常见错误是磁盘已经写满，或者超过了一个给定进程的文件长度限制。 对于普通文件，写操作从文件的当前偏移量处开始。如果在打开文件时指定了O_APPEND选项，则在每次写操作前，将文件的偏移量设置在文件的结尾处，因此这种方式不能写中间的某个部分。在一次写成功后，文件偏移量增加实际写入的字节数。指定O_APPEND选项时，文件偏移量调整和写入操作合并为原子操作。 IO的效率read函数和write的函数选出合适的buf大小是很重要的。一般来说在4096字节(磁盘块长度)效率比较高。大多数文件系统为改善性能都采取某种预读技术。检测到正在顺序读取时，系统就试图读取比应用所要求更多的数据，并假想应用很快就会读这些数据。 文件共享UNIX支持在不同进程间共享打开文件。 内核使用三种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。 每个进程在进程表项中都有一个记录项，记录项包含一张打开文件描述符表，可将其视为一个矢量，每个描述符占用一项。与文件描述符相关联的是文件描述符标志(close_on_exec)和指向一个文件表项的指针。 内核为所有打开文件维持一张文件表。每个文件表项包含：文件状态标志(读，写，添写，同步和非阻塞等)、当前文件偏移量、指向该文件的v节点指针。 每个打开文件(或设备)都有一个v节点结构。v节点包含了文件类型和对此文件进行各种操作的函数指针。对于大多数文件，v节点还包含了该文件的i节点(索引节点)。这些信息是在打开文件时从磁盘读入内存的。对于不同的实现可能不同，例如linux不包含v节点，而是使用了通用的i节点。 不同实现可能有不同，但是是有必要保存这些信息。 打开文件的内核数据结构 不同进程都有自己的文件表项（使得不同进程可以有不同的当前文件偏移量），两个进程可以打开同一个文件，但同一个文件只有一个v节点表项。 两个独立进程各自打开同一个文件 同时也可能有多个文件描述符指向同一个文件表项，例如dup函数和fork函数（fork之后，父进程和子进程各自的每一个打开文件描述符共享同一个文件表项） 文件描述符标志和文件状态标志在作用范围方面有区别，前者只用于一个进程的某一个描述符，而后者则应用于指向该给定文件表项的任何进程中所有的描述符。可以通过fcntl函数获取和修改文件描述符标志和文件状态标志。 多个进程读取同一个文件都能正确的工作，每个进程都有它自己的文件表项，也有自己的当前文件偏移量。但多个进程写同一个文件时，则可能产生预想不到的结果。为了避免这种情况，我们需要了解原子操作。 原子操作一般而言，原子操作(atomic operation)是由多步操作组成的一个操作。如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。 多个进程对同一个文件追加数据，可以在打开文件时指定O_APPEND标志。这使得每次写操作之前内核都将进程的当前文件偏移量设置到该文件的末尾。对于这种write操作在不同进程间是不是原子的，后续有文章来验证。 open函数可以使用O_CREAT和O_EXCL来原子的创建一个不存在的文件，如果文件已存在，则会创建失败 pread和pwrite允许原子性的定位并执行IO。 123456789#include &lt;unistd.h&gt;ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);返回读到的字节数，若已到文件结尾，返回0；若出错，返回-1size_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);若成功返回已写的字节数；若出错，返回-1 调用pread相当于调用lseek后调用read，但是pread又与这种顺序调用有如下重要区别： 调用pread时，无法中断其定位和读操作 不更新当前文件偏移量 pwrite也有类似的问题 函数dup和dup2这两个函数可用来复制一个现有的文件描述符： 123456#include &lt;unistd.h&gt;int dup(int fd);int dup2(int fd, int fd2);若成功，返回新的文件描述符；若出错，返回-1 由dup返回的新文件描述符一定是当前可用文件描述符中的最小数值。对于dup2，可以用fd2参数指定新描述符的值，如果fd2已经打开，则先将其关闭。如若fd等于fd2，则dup2返回fd2而不关闭它。否则，fd2的FD_CLOEXEC文件描述符就被清除，这样fd2在进程调用exec时是打开状态。 这些函数返回的新描述符与参数fd共享同一个文件表项。 dup后的内核数据结构 赋值描述符的另一个方法是使用fcntl函数 12dup(fd); // fcntl(fd, F_DUPFD, 0);dup2(fd, fd2); // close(fd2); fcntl(fd, F_DUPFD, fd2); 后一种情况，dup2并不完全等同于close加上fcntl dup2是一个原子操作 dup2和fcntl有一些不同的errno 函数sync，fsync和fdatasync传统的UNIX系统实现在内核中设有高速缓冲区高速缓存或页高速缓存，大多数磁盘IO都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲中，然后排入队列，晚些时候再写入磁盘。这种方式被称为延迟写 通常，当内核需要重用缓冲区来存放其他磁盘块数据时，它会把所有延迟写数据块写入磁盘。为了保证磁盘实际文件与缓冲区中内容的一致性，UNIX提供了sync，fsync和fdatasync三个函数： 12345678#include &lt;unistd.h&gt;int fsync(int fd);int fdatasync(int fd);若成功，返回0；若出错，返回-1void sync(void); sync只是将所有修改过的缓冲块排入写队列，然后就返回，它并不等待实际写磁盘结束。通常称为update的系统守护进程周期性的调用(一般30s)sync函数。这就保证了定期冲洗内核的块缓冲区。sync命令也调用sync函数 fsync函数只对由文件描述符fd指定的一个文件起作用，并且等待磁盘操作结束才返回。fdatasync函数类似于fsync，但它只影响文件的数据部分。fsync还会同时更新文件属性的更新。 函数fcntlfcntl可以改变已经打开文件的属性： 12345#include &lt;unistd.h&gt;int fcntl(int fd, int cmd, ... /* int arg */);若成功，返回值依赖cmd；若出错，返回-1 fcntl函数有如下5个功能： 复制一个已有的文件描述符(F_DUPFD或F_DUPFD_CLOEXEC) 获取或设置文件描述符标志(F_GETFD或F_SETFD) 获取或设置文件状态标志(F_GETFL或F_SETFL) 获取或设置异步IO所有权(F_GETOWN或F_SETOWN) 获取或设置记录锁(F_GETLK，F_SETLK或F_SETLKW) F_DUPFD，复制文件描述符fd。新的描述符作为函数返回值返回。它是尚未打开的各描述符中大于或等于第三个参数值中各值得最小值。FD_CLOEXEC参考dupF_DUPFD_CLOEXEC，复制文件描述符，设置文件描述符关联的FD_CLOEXEC文件描述符的值，返回新文件描述符。F_GETFD，对应于fd的文件描述符标志作为函数值返回，当前只定义了一个文件描述符标志FD_CLOEXECF_SETFD，对于fd设置文件描述符标志F_GETFL，对应于fd的文件状态标志作为函数值返回。可以参考open函数。5个访问方式标志(O_RDONLY，O_WRONLY，O_RDWR，O_EXEC以及O_SEARCH)并不各占一位，这5个值互斥。因此首先必须使用屏蔽字O_ACCMODE取得访问方式，然后再进行比较。 文件状态标志 F_SETFL，将文件状态标志设置为第三个参数的值，可以更改的标志是：O_APPEND，O_NONBLOCK，O_SYNC，O_DSYNC，O_RSYNC，O_FSYNC和O_ASYNC。F_GETOWN，获取当前接收SIGIO和SIGURG信号的进程ID或进程组ID。F_SETOWN，设置接收SIGIO和SIGURG信号的进程ID或进程组ID。正的arg指定一个进程ID，负的arg表示等于arg绝对值的一个进程组ID。 fcntl如果出错返回-1，如果成功返回相应的值。 我们必须小心的使用设置标志，我们需要先取出现有的，设置想要设置的标志，然后再进行设置。 函数ioctlioctl函数一直是IO操作的杂物箱。终端IO是使用ioctl最多的地方。 123456#include &lt;unistd.h&gt;// #include &lt;sys/ioctl.h&gt;int ioctl(int fd, int request, ...);若成功，返回0；若出错，返回其他值 不能用本章其他io函数表示的IO操作通常都能用ioctl表示。 /dev/fd较新的系统都提供名为/dev/fd的目录，打开文件/dev/fd/n等效于复制描述符n。 在linux系统中，它把文件描述符映射成指向物理底层文件的符号链接。 第四章 文件和目录对于文件除了文件本身，还有和文件相关的其他属性。另外还有函数能够修改这些属性 函数stat，fstat，fstatat和lstat12345678#include &lt;sys/stat.h&gt;int stat(const char *restrict pathname, staruct stat *restrict buf);int fstat(int fd, struct stat *buf);int lstat(const char *restrict pathname, struct stat *restrict buf);int fstatat(int fd, const char *restrict pathname, struct stat *restrict buf, int flag);若成功，返回0；若出错，返回-1 stat将返回与文件pathname有关的信息结构。fstat函数获得已在描述符fd上打开文件的有关信息。lstat函数类似stat，但是当命名文件是一个符号链接时，lstat返回符号链接本身的有关信息，而不是由符号链接引用的文件的信息。fstatat函数为一个相对于当前打开目录（由fd参数指向）的路径名返回文件统计信息。flag参数控制着是否跟随着符号链接。当AT_SYMLINK_NOFOLLOW标志被设置时，fstatat函数不会跟随符号链接，而是返回符号链接本身的信息。否则，在默认情况下，返回的是符号链接所指向的文件的信息。如果fd参数的值是AT_FDCWD，并且pathname参数是一个相对路径名，fstatat会计算相对于当前目录的pathname参数。如果pathname是一个绝对路径名，fd参数就会被忽略。这两种情况下，根据flag的取值，fstatat函数的作用就跟stat或lstat函数一样。 第二个参数buf是一个指针，它指向一个我们必须提供的结构。函数来填充buf指向的结构。结构的实际定义可能随系统具体实现不同，但其基本形式是： 12345678910111213141516171819202122struct stat&#123; mode_t st_mode; // file type &amp; mode (permissions) ino_t st_ino; // i-node number (serial number) dev_t st_dev; // device number (file system) dev_t st_rdev; // device number for special files nlink_t st_nlink; // number of links uid_t st_uid; // user ID of owner gid_t st_gid; // group ID of owner off_t st_size; // size in bytes, for regular files struct timespec st_atime; // time of last access struct timespec st_mtime; // time of last modification struct timespec st_ctime; // time of last file status change blksize_t st_blksize; // best IO block size blkcnt_t st_blocks; // number of disk blocks allocated&#125;;// timespec按照秒和纳秒定义了时间struct timespec&#123; time_t tv_sec; long tv_nsec;&#125;; stat结构中的大部分成员都是基本系统数据类型。我们将说明此结构的每个成员以了解文件属性。ls命令使用stat函数。 文件类型文件类型包括 普通文件（regular file）。这是最常用的文件类型。UNIX系统并不区分文本文件和二进制文件。但是对于可执行文件，内核必须理解其格式，以便能够确定程序文本和数据的加载位置。 目录文件（direcory file）。这种文件包含了其他文件的名字与指向这些文件的有关信息。通常只有内核可以直接写目录文件。 块特殊文件（block special file）。这种类型的文件提供对设备的带缓冲的访问，每次访问以固定的长度为单位进行。 字符特殊文件（character special file）。这种类型的文件提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是字符特殊文件，要么是块特殊文件。 FIFO。可用于进程间通信，又被称作命名管道（named pipe）。 套接字（socket）。这种类型的文件用用于进程间的网络通信。也可以用于在一台宿主机上进程间的非网络通信。 符号链接（symbolic link）。这种类型的文件指向另一个文件。 文件类型信息包含在stat结构的st_mode成员中。可以使用宏来确定文件类型。 宏 文件类型 S_ISREG() 普通文件 S_ISDIR() 目录文件 S_ISCHR() 字符特殊文件 S_ISBLK() 块特殊文件 S_ISFIFO() 管道或FIFO S_ISLNK() 符号链接 s_ISSOCK() 套接字 POSIX.1允许将进程间通信的对象说明为文件。例如消息队列，信号量，共享内存对象。 对于宏的实现，一般是将st_mode与屏蔽字S_IFMT进行&amp;运算，然后与对应常量比较，判断是否为特定文件类型。 1#define S_ISDIR(mode) (((mode) &amp; SIFMT) == SIFDIR) 设置用户ID和设置组ID与一个进程相关的ID有6个或更多： 实际用户ID、实际组ID——我们实际上是谁，在登录时取自口令文件。在一个登录会话期间并不会改变，但是超级用户进程可以改变它们。 有效用户ID、有效组ID、附属组ID——用于文件访问权限检查 保存的设置用户ID、保存的设置组ID——由exec函数保存 每个文件有一个所有者和组所有者，分别由st_uid和st_gid指出。 执行一个程序文件时，进程的有效用户ID通常就是实际用户ID，有效组ID通常就是实际组ID。但是可以st_mode中设置一个特殊标志，含义为当执行此文件时，将进程的有效用户ID设置为文件所有者的用户ID。同样还有类似的设置组ID。分别被称为设置用户ID位和设置组ID位。 例如passwd修改登录口令，是一个设置用户ID程序。因为口令文件只有超级用户才有写入权限。这种程序会获得额外权限，需要谨慎处理。 设置用户ID和设置组ID可以使用S_ISUID和S_ISGID测试。 文件访问权限st_mode也包含了对文件的文件权限位。这里的文件是前面提到的任何类型的文件。所有文件类型都有访问权限。 每个文件有9个访问权限位，可以分为三组 st_mode屏蔽 含义 S_IRUSR 用户读 S_IWUSR 用户写 S_IXUSR 用户执行 S_IRGRP 组读 S_IWGRP 组写 S_IXGRP 组执行 S_IROTH 其他读 S_IWOTH 其他写 S_IXOTH 其他执行 前三行用户指的是文件的所有者。我们可以使用chmod来修改文件的访问权限。 对于访问权限以各种方式由不同函数使用。 第一个规则是我们用名字打开任一类型的文件时，对该名字包含中的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限。这也是为什么对于目录其执行权限位常被称为搜索位的原因。注意目录读权限和执行权限的区别 对于一个文件的读权限决定了我们是否能够打开现有文件进行读操作，对应了open函数的o_RDONLY和O_RDWR标志 对于一个文件的写权限决定了我们是否能够打开现有文件进行写操作，对应了open函数的O_WRONLY和O_RDWR标志 为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限 为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限 为了删除一个现有文件，必须对包含该文件的目录具有写权限和执行权限。对该文件本身则不需要有读写权限 如果7个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限，该文件必须是一个普通文件 进程每次打开，创建或删除一个文件，内核就进行文件访问权限测试，这种测试可能涉及文件的所有者，进程的有效ID及进程的附属组ID。 若进程的有效ID是0（超级用户），则允许访问。 若进程的有效用户ID等于文件的所有者ID，那么如果所有者适当的访问权限位被设置，则允许访问，否则拒绝访问。 若进程的有效组ID或进程的附属组ID之一等于文件的组ID，那么如果组适当的访问权限位被设置，则允许访问，否则拒绝访问。 若其他用户适当的访问权限位被设置，则允许访问；否则拒绝访问。 按照顺序执行以上4步 新文件和目录的所有权进程创建的新文件的用户ID设置为进程的有效用户ID。对于组ID，POSIX.1允许实现选择以下之一作为新文件的组ID： 新文件的组ID可以是进程的有效组ID 新文件的组ID可以是它所在目录的组ID 有些实现默认使用第二种方式，例如Mac OS 10.6.8。linux 3.2.0默认情况下新文件的组ID取决于它所在目录的设置组ID位是否被设置，如果设置，则使用第二种方式，否则使用第一种方式。 因此，mkdir需要传递目录的设置组ID 函数access和faccessat当打开一个文件时，内核使用进程的有效用户ID和有效组ID为基础执行权限访问测试。进程有时候也希望按照实际用户ID和实际组ID来测试其访问能力。access和faccessat函数按照实际用户ID和实际组ID进行访问权限测试。 123456#include &lt;unistd.h&gt;int access(const char *pathname, int mode);int faccess(int fd, const char *pathname, int mode, int flag);若成功，返回0；若出错，返回-1 如果mode设置为F_OK，则测试文件是否存在。否则是三个常量的按位或：R_OK，W_OK、X_OK。 faccessat函数在下列情况的作用于access函数相同：一种是pathname参数为绝对路径，另一种是fd参数的取值为AT_FDCWD且参数pathname为相对路径。否则，faccessat计算相对于打开目录（fd指定）的pathname。 flag参数可以改变faccessat的行为，如果flag设置为AT_EACCESS，访问检查用的是调用进程的有效用户ID和有效组ID。 函数umask每个进程都有一个相关联的文件模式创建屏蔽字，umask函数可以为进程设置文件模式创建屏蔽字，返回之前的值 12345#include &lt;sys/stat.h&gt;mode_t umaks(mode_t mode);返回之前的文件模式创建屏蔽字 进程创建一个文件或目录时就一定会使用文件模式创建屏蔽字，在其中为1的位，在文件mode中相应的位一定会被关闭。 在shell中，我们可以使用umask命令来修改这个值。以便修改创建文件的默认权限。 函数chmod、fchmod和fchmodat这三个函数用来修改现有文件的访问权限 1234567#include &lt;sys/stat.h&gt;int chmod(const char *pathname, mode_t mode);int fchmod(int fd, mode_t mode);int fchmodat(int fd, const char *pathname, mode_t mode, int flag);若成功，返回0；若出错，返回-1 fchmodat函数在两种情况下与chmod函数一样：一种是pathname参数为绝对路径；另一种是fd参数取值为AT_FDCWD且pathname参数为相对路径。否则fchmodat相对于fd打开的目录来计算pathname。flag参数可以改变fchmodat的行为，当设置了AT_SYMLINK_NOFOLLOW时，fchmodat不跟随符号链接。 为了改变一个文件的权限位，进程的有效用户ID必须等于文件所有者ID，或者该进程具有超级用户权限 参数mode由以下值按位或 mode 说明 S_ISUID 执行时设置用户ID S_ISGID 执行时设置组ID S_ISVTX 保存正文（粘着位） S_IRWXU 用户读写执行 S_IRUSR 用户读 S_IWUSR 用户写 S_IXUSR 用户执行 S_IRWXG 组读写执行 S_IRGRP 组读 S_IWGRP 组写 S_IXGRP 组执行 S_IRWXO 其他读写执行 S_IROTH 其他读 S_IWOTH 其他写 S_IXOTH 其他执行 chmod函数在下列条件下自动清除两个权限位： Solaris等系统对于普通文件的粘着位赋予了特殊含义在这些系统上，如果我们尝试设置普通文件的粘着位(S_ISVTX)，而且又没有超级用户权限，那么mode中的粘着位自动被关闭。这意味着只有超级用户才能设置普通文件的粘着位。这样做是防止恶意用户设置粘着位，影响系统性能。 新创建文件的组ID可能不是调用进程所属的组。新文件的组ID可能是父目录的组ID，特别的如果新文件的组ID不等于进程的有效组ID或附属组ID中的一个，而且进程没有超级用户权限，那么设置组ID位会被自动关闭。这就防止了用户创建了一个设置组ID文件，而该文件是并非该用户所属的组拥有的。 有的系统，如Linux 3.2.0等增加了另一个安全性功能试图阻止误用某些保护位。如果没有超级用户权限的进程写一个文件，则设置用户ID位和设置组ID位会被自动清除。如果恶意用户找到一个它们可以写的设置用户ID位和设置组ID位文件，即使它们可以修改此文件，它们也失去了特殊的授权。 粘着位粘着位（S_ISVTX，sticky bit）有着有趣的历史，在早期版本的UNIX中，如果一个可执行程序的这一位被设置了，那么当程序第一次执行，在其终止时，程序正文部分的一个副本仍然保存在交换区中，正文指指令部分。这样程序下次执行就能较快的载入内存。原因是：通常的UNIX文件系统中，文件的各数据块可能是随机存放的，相比较而言，交换区是被作为一个连续文件来存放的。后来的UNIX系统将其称为保存正文位(saved-text bit)。现在的系统大多数都配置了虚拟存储系统以及快速文件系统，所以不再需要此技术。 现在，我们扩展了粘着位的使用范围。如果对一个目录设置了粘着位，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或重命名该目录下的文件： 拥有此文件 拥有此目录 是超级用户 例如目录/tmp就是这种目录，这样，一个用户就无法删除或重命名其他用户的文件。 chown、fchown、fchownat和lchown下列函数用来修改文件的用户ID和组ID，如果参数中任意一个是-1，则对应ID不变： 12345678#include &lt;unistd.h&gt;int chown(const char *pathname, uid_t owner, gid_t group);int fchown(int fd, uid_t owner, gid_t group);int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);int lchown(const char *pathname, uid_t owner, gid_t group);若成功，返回0；若出错，返回-1 除了引用的文件时符号链接外，4个函数都类似。在符号链接的情况下，lchown和fchownat(设置了AT_SYMLINK_NOFOLLOW)更改符号链接本身的所有者，而不是符号链接指向的文件的所有者。 fchown用于改变fd参数指向的打开文件的所有者，它在一个已打开的文件上操作，因此它不能用于改变符号链接的所有者。 fchownat函数与chown或和lchown函数在下列情况下相同：一种是pathname是绝对路径，另一种是fd参数值取值为AT_FDCWD且pathname参数为相对路径。在这两种情况下，如果flag参数设置了AT_SYMLINK_NOFOLLOW，fchownat与lchown函数相同，否则与chown函数相同。其他情况下，fchownat函数计算相对于打开目录的pathname。 一般来说，只有超级用户或文件所有者才能更改一个文件的所有者。POSIX.1允许两种操作中选择一种。可以使用_POSIX_CHOWN_RESTRICTED常量来确定是否有限制，我们可以根据pathconf或fpathconf查询。此选项与文件有关，对于不同的文件可能值不一样。 如果其对指定的文件生效： 只有超级用户才能更改此文件的用户ID 如果进程拥有此文件，参数owner等于-1或文件的用户ID，并且参数group等于进程的有效组ID或进程的附属组ID之一，那么一个非超级用户进程可以更改此文件的组ID。 如果这些函数由非超级用户进程调用，那么在成功返回时，该文件的设置用户ID位和设置组ID位都被清除。 文件长度stat结构成员st_size表示以字节为单位的长度。此字段只对普通文件、目录文件和符号链接有意义。 对于普通文件，长度可以是0，在开始读这种文件时，将得到文件结束指示。对于目录，文件长度通常是一个数的整数倍。对于符号链接，文件长度是在文件名中的实际字节数。 现今大多数现在的UNIX系统提供字段st_blksize和st_blocks，其中，第一个是对文件IO比较适合的块长度，第二个是所分配的实际512字节(不同系统单位可能不同)的块数。标准IO库一次也尝试读写st_blksize个字节。 我们可以在文件中建立空洞，这些空洞并不占用磁盘空间，读取空洞导致读取到的内容为0。 文件截断有时我们需要在文件尾端处截去一些数据以缩短文件。将一个文件长度截断为0是一个特例，在打开文件时使用O_TRUNC标志可以做到这一点。为了截断文件可以调用函数truncate和ftruncate函数。 123456#include &lt;unistd.h&gt;int truncate(const char *pathname, off_t length);int ftruncate(int fd, off_t length);若成功，返回0；若出错，返回-1 这两个函数将一个现有文件截断到长度length。要么缩短文件，要么产生一个空洞。 文件系统UNIX文件系统有多种不同的实现。每一种文件系统都有它各自的特征。大部分UNIX文件系统支持大小写敏感的文件名。在Mac OS上，HFS是大小写保留的，但是大小写不敏感。 我们可以把磁盘分成一个或多个分区。每个分区可以包含一个文件系统。i节点是固定长度的记录项，它包含有关文件的大部分信息。 磁盘、分区和文件系统 下面是比较详细的i节点和数据块图 i节点和数据块详细图 在图中，我们注意到： 有两个目录项指向同一个i节点，每个i节点中都有一个链接计数，其值是指向该i节点的目录项数。只有当链接计数减少到0时，才可删除该文件。这就是为什么解除一个文件的链接操作并不总是意味着释放该文件占用的磁盘块的原因。在stat结构中，链接计数包含在st_nlink成员中，其基本系统数据类型是nlink_t。这种链接类型称为硬链接。LINK_MAX指定了一个文件链接数的最大值。 另外一种类型链接称为符号链接（symbolic link）。符号链接的实际内容包含了该符号链接所指向的文件的名字。 i节点包含了文件有关的所有信息：文件类型，文件访问权限位，文件长度和指向文件数据块的指针。stat结构中的大多数信息都取自i节点。只有两项重要数据存放在目录中：文件名和i节点编号。还有其他记录项，我们并不关心，如文件名长度等 因为目录项中的i节点编号指向同一个文件系统中相应的i节点，一个目录项不能指向另一个文件系统的i节点。这就是为什么ln命令构造一个现有文件的新目录项不能跨越文件系统的原因。 当在不更换文件系统的情况下为一个文件重命名时，该文件的实际内容并未移动，只需要构造一个指向现有i节点的目录项，并删除老的目录项。链接计数不会改变。这一般是mv命令的通常操作方式。 任何一个不包含任何其他目录的目录的链接计数总是2。即.和..。 函数link，linkat，unlink，unlinkat和remove创建一个指向现有文件的链接的方法是使用link或linkat函数： 123456#include &lt;unistd.h&gt;int link(const char *existingpath, const char *newpath);int linkat(int efd, const char *existingpath, int nfd, const char *newpath, int flag);若成功，返回0；若出错，返回-1 这两个函数创建一个新目录项newpath，它引用现有文件existingpath，如果newpath已经存在，则返回出错。只创建newpath中的最后一个分量，路径中的其他部分应该已经存在。 对于linkat函数，现有文件是通过efd和existingpath参数指定的，新的路径名是通过nfd和newpath指定的。默认情况下，如果两个路径名中的任意一个是相对路径，那么他需要通过相对于对应的文件描述符进行计算，如果两个文件描述符中的任一个设置为AT_FDCWD，那么相应的路径名就通过相对于当前目录计算。如果任一路径名是绝对路径，相应的文件描述符参数就会被忽略。 当现有文件名是符号链接时，由参数flag来控制linkat函数是创建指向现有符号链接的链接还是创建指向现有符号链接指向的文件的链接。如果在flag中设置了AT_SYMLINK_FOLLOW标志，就创建指向符号链接目标的链接。如果这个标志被清除了，则创建一个指向符号链接本身的链接。创建新目录项和增加链接计数应当是一个原子操作。 虽然POSIX.1允许实现支持跨越文件系统的链接，但是大多数现有系统要求现有的和新建的两个文件路径名在同一个文件系统中。只有超级用户才能够创建指向一个目录的硬链接。是因为这样可能在系统中形成循环，并且程序很难处理这种情况。linux不支持目录硬链接。 为了删除一个现有的目录项（文件），可以调用unlink函数： 123456#include &lt;unistd.h&gt;int unlink(const char *pathname);int unlinkat(int fd, const char *path, int flag);若成功，返回0；若出错，返回-1 这两个函数删除目录项，并将由pathname所引用文件的链接计数减1，如果该文件还有其他链接，则仍可通过其他链接访问该文件的数据。如果出错，则不对文件进行任何修改。 需要注意unlink函数无法用于目录 删除目录内文件的权限，参考粘着位 当链接计数为0时，该文件的内容才可被删除。另一个条件也会阻止删除文件的内容——只要有进程打开了文件。关闭一个文件时，内核首先检查打开该文件的进程个数；如果这个计数达到0，内核再去检查其链接计数，如果计数也是0，那么就删除该文件的内容。 unlinkat使用fd作为相对路径起点。或者设置为AT_FDCWD，则相对于当前路径。 当flag为AT_REMOVEDIR时，unlinkat可以类似于rmdir一样删除目录，如果这个标志被清除，unlinkat与link执行相同的操作。 如果pathname是符号链接，那么unlink函数删除该符号链接，而不是删除由符号链接所引用的文件，给出符号链接名的情况下，没有一个函数能够删除由该符号链接引用的文件。 我们也可以使用remove函数接触一个函数或目录的链接。对于文件remove的功能与unlink相同，对于目录，remove的功能与rmdir相同： 12345#include &lt;stdio.h&gt;int remove(const char *pathname);若成功，返回0；若出错，返回-1 ISO C使用remove的原因是实现C标准的大多数非UNIX系统不支持文件链接 函数rename和renameat文件或目录可以使用rename或renameat函数进行重命名。 123456#include &lt;stdio.h&gt;int rename(const char *oldname, const char *newname);int renameat(int oldfd, const char *oldname, int newfd, const char *newname);若成功，返回0；若出错，返回-1 根据对oldname是指文件，目录还是符号链接或者newname已经存在我们需要说明： 如果oldname指的是文件而不是目录，那么为该文件或符号链接重命名。在这种情况下，如果newname已经存在，则它不能引用一个目录。如果newname已经存在，而且不是一个目录，则先将该目录项删除然后将oldname重命名为newname。对包含oldname的目录以及包含newname的目录，调用进程必须具有写权限，因为将更改这两个目录。 如果oldname是一个目录，那么为该目录重命名。如果newname已经存在，则它必须引用一个目录，而且该目录应当是空目录(只有.和..)。如果newname存在而且是一个空目录，则先将其删除，然后将oldname重命名为newname。newname不能包含oldname的前缀。 如果oldname或newname引用符号链接，则处理的是符号链接本身，而不是它引用的文件。 不能对.和..重命名。 作为一个特例，如果oldname和newname引用同一个文件，则函数不做任何修改而成功返回。 除了当oldname或newname指向相对路径时，其他情况renameat和rename函数功能相同。 符号链接符号链接是对一个文件的间接指针。引入符号链接是为了避开硬链接的一些限制。 硬链接通常要求链接和文件在同一个文件系统上 只有超级用户才能创建指向目录的硬链接 对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可以创建指向目录的符号链接。 当使用以名字引用文件的函数时，应当了解函数是否处理符号链接。也就是是否跟随符号链接到达它所链接的文件。 函数 是否跟随符号链接 access 是 chdir 是 chmod 是 chown 是 creat 是 exec 是 lchown 否 link 是 lstat 否 open 是 opendir 是 pathconf 是 readlink 否 remove 否 rename 否 stat 是 truncate 是 unlink 否 open的一个例外是，如果同时用O_CREAT和O_EXCL两个标志，如果路径引用符号链接，open函数将出错，errno设置为EEXIST，这种处理是意图堵塞一个安全漏洞，以防止具有特权的进程被诱骗编写错误的文件 创建和读取符号链接可以使用symlink或symlinkat函数创建一个符号链接 123456#include &lt;unistd.h&gt;int symlink(const char *actualpath, const char *sympath);int symlink(const char *actualpath, int fd, const char *sympath);若成功，返回0；若出错，返回-1 函数创建了一个指向actualpath的新目录项sympath，在创建符号链接时，并不要求actualpath存在，也不需要在同一个文件系统中。 symlinkat函数类似，sympath根据fd作为相对路径进行计算。如果sympath的参数是绝对路径或fd参数设置了AT_FDCWD，那么symlinkat和symlink作用相同 open函数跟随符号链接，所以提供了readlink和readlinkat函数来读取符号链接本身（即符号链接指向的文件名称） 123456#include &lt;unistd.h&gt;ssize_t readlink(const char *restrict pathname, char *restrict buf, size_t bufsize);ssize_t readlinkat(int fd, const char *restrict pathname, char *restrict buf, size bufsize);若成功，返回读取的字节数；若出错，返回-1 两个函数组合了open，read，close的所有操作，在buf中返回的符号链接的内容不以null字节终止。readlinkat以fd作为相对路径。 文件的时间对于每个文件维护三个时间 字段 说明 例子 ls选项 st_atim 文件数据的最后访问时间 read -u st_mtim 文件数据的最后修改时间 write 默认 st_ctim i节点状态的最后更改时间 chmod，chown -c 注意文件数据修改时间和i节点最后更改时间，i节点信息和文件数据是分开存放的 各种函数对三种时间的影响 函数futimens，utimensat和utimes一个文件的访问和修改时间可以通过一下几个函数修改。 123456#include &lt;sys/stat.h&gt;int futimens(int fd, const struct timespec times[2]);int utimensat(int fd, const char *path, const struct timespec times[2], int flag);若成功，返回0；若出错，返回-1 times数组参数的第一个元素包含访问时间，第二个元素包含修改时间，这两个值是日历时间。 时间戳可以按下列4中方式之一指定 如果times是空指针，则访问时间和修改时间两者都设置为当前时间 如果times参数指向两个timespec结构的数组，任一数组元素的tv_nsec字段的值为UTIME_NOW，则相应的时间戳就设置为当前时间，忽略相应的tv_sec字段 如果times参数指向两个timespec结构的数组，任意数组元素的tv_nsec字段的值为UTIME_OMIT，相应的时间戳保持不变，忽略相应的tv_sec字段 如果times参数执行两个timespec结构的数组，且tv_nsec字段的值不是上述两者，这种情况下，设置为对应的值 执行函数的所需的权限取决于times的值，如果不修改时间戳，则不进行权限检查；如果修改，则除了对文件有写权限，进程的有效用户ID必须等于文件的所有者ID utimensat提供了使用文件名来设置时间的功能，flag可以决定是否跟随符号链接(是否设置了AT_SYMLINK_NOFOLLOW标志)，默认行为是跟随符号链接。 前两个函数都包含在POSIX.1中，第3个函数包含在Single UNIX Specsification的XSI扩展选项中 12345#include &lt;sys/time.h&gt;int utimes(const char *pathname, const struct timeval times[2]);若成功，返回0；若出错，返回-1 utimes函数对路径名进行操作。结构timeval包含两个时间戳，用秒和微妙来表示 12345struct timeval&#123; time_t tv_sec; long tv_usec;&#125; 我们不能对状态更改时间指定一个值，这在调用utimes（及以上3个）函数时自动被更新。 函数mkdir，mkdirat和rmdir我们用mkdir、mkdirat创建目录，用rmdir来删除目录 123456#include &lt;sys/stat.h&gt;int mkdir(const char *pathname, mode_t mode);int mkdirat(int fd, const char *pathname, mode_t mode);若成功，返回0；若出错，返回-1 这两个函数创建一个空目录，其中.和..是自动创建的。mode指定访问权限。通常我们需要目录的执行权限。 可以使用rmdir函数删除一个空目录，空目录是只包含.和..的目录 12345#include &lt;unistd.h&gt;int rmdir(const char *pathname);若成功，返回0；若出错，返回-1 如果调用此函数使得目录的链接计数为0，并且也没有其他进程打开目录，则释放由此目录占用的空间。如果在链接计数达到0时，有一个或多个进程打开此目录，则此函数返回前删除最后一个链接及.和..项。此目录中不能再创建任何文件，但是在最后一个进程关闭它之前并不释放此目录，即使另一些进程打开该目录，它在此目录下也不能执行其他操作。因为rmdir执行成功的前提是目录是空的。 读目录对某个目录具有读访问权限的任一用户都能读该目录，但是为了防止文件系统混乱，只有内核才能够写目录。一个目录的写权限位和执行权限位决定了在该目录中能否创建新文件以及删除文件，它们并不表示能否写目录本身 目录的实际格式依赖实现。我们使用下边的函数来屏蔽这种实现细节 12345678910111213141516171819202122#include &lt;dirnet.h&gt;DIR *opendir(const char *pathname);DIR *fdopendir(int fd);若成功，返回指针；若出错，返回NULLstruct dirent *readdir(DIR *dp);若成功，返回指针；若在目录尾或出错，返回NULLvoid rewinddir(DIR *dp);int closedir(DIR *dp);若成功，返回0；若出错，返回-1long telldir(DIR *dp);返回与dp关联的目录中的当前位置void seekdir(DIR *dp, long loc); dirent结构与实现有关，但是至少包含i节点编号和目录名字。 DIR是一个内部结构，用来维护正在读的目录的有关信息。 目录中各目录项的顺序与实现有关。它们通常并不按字母顺序排列。 ftw和nftw实现了目录的遍历 函数chdir，fchdir和getcwd进程都有一个当前工作目录，调用chdir或fchdir可以更改当前工作目录 123456#include &lt;unistd.h&gt;int chdir(const char *pathname);int fchdir(int fd);若成功，返回0；若出错，返回-1 当前工作目录是进程的一个属性，所以以上函数只影响调用进程本身，不影响其他进程 当前工作目录与进程相关，在shell中，cd命令是内建的命令，因为需要shell本身来调用chdir。 我们可以通过chdir一直转到上级目录来获取当前工作路径，getcwd提供了类似的功能 12345#include &lt;unistd.h&gt;char *getcwd(char *buf, size_t size);若成功，返回buf；若出错，返回NULL buf应该足以容纳绝对路径名和终止null字节，否则返回出错 chdir跟随符号链接。 设备特殊文件st_dev和st_rdev经常混淆，有关规则很简单 每个文件系统所在的存储设备都由其主次设备号表示。其系统基本数据类型是dev_t，主设备号标识设备驱动程序，有时编码为与其通信的外设板，次设备号标识特定的子设备。 我们使用major和minor来访问主、次设备号。大多数系统都定义了这两个宏。 系统中与每个文件名关联的st_dev是文件系统的设备号，该文件系统包含了这一文件名以及与其对应的i节点 只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号。 文件访问权限位小结 文件访问权限位小结","categories":[],"tags":[{"name":"unix","slug":"unix","permalink":"https://gwq5210.com/tags/unix/"},{"name":"linux","slug":"linux","permalink":"https://gwq5210.com/tags/linux/"},{"name":"读书笔记","slug":"读书笔记","permalink":"https://gwq5210.com/tags/读书笔记/"},{"name":"APUE","slug":"APUE","permalink":"https://gwq5210.com/tags/APUE/"}],"keywords":[]},{"title":"Cpp-Primer-Plus读书笔记（二）","slug":"Cpp-Primer-Plus读书笔记（二）","date":"2017-07-09T14:47:52.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2017/07/09/Cpp-Primer-Plus读书笔记（二）/","link":"","permalink":"https://gwq5210.com/2017/07/09/Cpp-Primer-Plus读书笔记（二）/","excerpt":"","text":"第五章 循环和关系表达式for循环for循环为执行重复的操作提供了循序渐进的步骤。for循环的组成部分完成下面这些步骤： 设置初始值 执行测试，看看循环是否应该继续执行 执行循环操作 更新用于测试的值 12for (initialization; test-expression; update-expression) body C++ 语法将for看做一条语句，——虽然循环体可以包括一条或多条语句。循环只执行一次初始化，测试表达式决定循环体是否被执行，通常，这个表达式是关系表达式，即对两个值进行比较。这里可以使用任何表达式，C++将把结果强制转换为bool类型。 for循环是入口条件循环，这意味着在每轮循环之前，都将计算测试表达式得值，当测试表达式为false时，将不会执行循环体。 更新表达式在每轮循环结束时执行，此时循环体已经执行完毕。通常，它用来对跟踪循环次数的变量的值进行递增。 for循环的控制部分使用了3个表达式，任何值或任何有效的值和运算符的组合都是表达式。赋值也是一个表达式，C++将赋值表达式的值定义为左侧成员的值。 当判定表达式的值这种操作改变了内存中数据的值时，我们说表达式有副作用。判定赋值表达式的值会修改被赋值者的值。 从表达式到语句的转变很容易，只需要加分号即可。因此a=100是表达式，a=100;是语句。更准确的说，这是一条表达式语句。只要加上分号，所有的表达式都可以成为语句，但不一定有编程意义。如a+6;是合法的语句，但它没完成任何有用的工作，智能编译器甚至可能跳过这条语句 对任何表达式加上分号都可以成为语句，但是这句话反过来说就不对了。也就是说，从语句中删除分号并不一定能将它转换为表达式。对于返回语句，声明语句和for语句都不满足这种情况 C++在C的基础上添加了一项特性，要求对for循环语句做一些微妙的调整，原来的语法： 12for (expression; expression; expression) statement 但是C++的for循环允许这样做： 12for (int i = 0; i &lt; 5; i++) printf(\"%d\\n\", i); 这很方便，但是不符合原来的语法，因为声明不是表达式。现在则使用下边的语句： 12for (for-init-statement condition; expression) statement 在for-init-statement中声明变量其实还有有用的一面，这也是该知道的。这种变量只存在与for循环中，当程序离开循环，这种变量将消失 在循环中经常使用递增运算符（++）和递减运算符（–）。这两种运算符执行两种极其常用的循环操作：将循环计数器加1或减1。这两个运算符都有两种变体。前缀版本位于操作数前面，如++x；后缀版本位于操作数后面，如x++。两个版本对操作数的影响是一样的，但是影响的时间不同。粗略的讲a++意味着使用a的当前值计算表达式，然后将a的值加1；而++b的意思是先将b的值加1，然后使用新的值来计算表达式。 递增运算符和递减运算符都是漂亮的小型运算符，不过千万不要失去控制，在同一条语句对同一个值递增或递减多次。问题在于规则使用后修改和修改后使用可能会变得模糊不清。也就是说，下面这条语句在不同的系统上将生成不同的结果： 1x = 2 * x++ * (3 - ++x); 对于这种语句，C++没有定义正确的行为 副作用是指在计算表达式时对某些东西进行了修改；顺序点是程序执行过程中的一个点，在这里，进入下一步之前将确保所有的副作用都进行了评估。在C++中语句中的分号就是一个顺序点，这意味着程序在处理下一条语句之前，赋值运算符、递增运算符和递减运算符执行的所有修改都必须完成。本章后边将讨论的有些操作也有顺序点。另外任何完整的表达式末尾都是一个顺序点。完整表达式是这样一个表达式：不是另一个更大表达式的子表达式 前缀格式和后缀格式的执行速度可能存在细微的差别，对于内置类型和当代的编译器而言，这看似不是什么问题。然而C++允许你针对类定义这些运算符，这种情况下，前缀格式的效率更高 可以将递增或递减运算符用于指针和基本变量。也可以结合使用这些运算符和*运算符来修改指针指向的值。前缀递增、前缀递减和解除引用运算符的优先级相同，以从右到左的方式结合。后缀递增和后缀递减的优先级相同，但比前缀运算符的优先级高，这两个运算符以从左到右的方式进行结合。*++p的含义如下：先将++应用于pt，然后将*应用于被递增后的pt，另一方面++*pt意味着先取得pt指向的值，然后将这个值加1。(*p)++，圆括号指出首先对指针解除引用，然后再进行递增。*pt++后缀运算符++的优先级更高，这意味着将运算符应用于pt而不是*pt。 可以使用组合赋值运算符来进行赋值： 操作符 操作数（L为左操作数，R为右操作数） += 将L+R赋值给L -= 将L-R赋值给L *= 将L*R赋值给L /= 将L/R赋值给L %= 将L%R赋值给L C++使用花括号来构造一条复合语句（代码块）。代码块由一对花括号和它们包含的语句组成，被视为一条语句，从而满足句法的要求 复合语句还有一个有趣的特性，如果在语句块中定义一个新的变量，则仅当程序执行该语句块中的语句时，该变量才存在。执行完毕该语句块后，变量将被释放。 在外部语句块中定义的变量在内部语句块中也是被定义了的。 如果在一个语句块中声明一个变量，而外部语句块中也有一个这种名称的变量，在声明位置到内部语句块结束的范围内，新的变量将隐藏旧变量，然后旧变量再次可见 逗号表达式允许将两个表达式放到C++句法只允许放一个表达式的地方。逗号并不总是逗号运算符，在声明中的逗号是分隔符 逗号表达式还有其他特性。首先，它确保先计算第一个表达式，然后计算第二个表达式，即逗号运算符是一个顺序点；其次，C++规定逗号表达式的值是第二部分的值 C++提供了6种关系运算符来对数字进行比较： 操作符 含义 &lt; 小于 &lt;= 小于或等于 == 等于 &gt; 大于 &gt;= 大于或等于 != 不等于 关系运算符的优先级比算符运算符低 不要混淆等于运算符（==）与赋值运算符（=） C风格字符串比较，不能直接使用等于运算符进行比较，这样比较的是两个字符串的地址。对于string类字符串，可以直接使用等于运算符进行比较 while循环while循环是没有初始化和更新部分的for循环： 12while (test-condition) body while也是一种入口条件循环，因此如果测试条件一开始就是false，则程序将不会执行循环体 while循环和for循环可以进行相互转换；省略for循环中的测试表达式时，测试结果将为true 在设计循环时，记住如下的原则： 指定循环终止的条件 在首次测试之前初始化条件 在条件再次被测试之前更新条件 在循环中，不要使用错误的分号，如： 123456int i = 0;int cnt = 10;while (i &lt; cnt); // 多了一个分号&#123; printf(\"%d\\n\", i);&#125; C++为类型建立别名的方式有两种，一种是使用预处理器： 1#define BYTE char 这样程序将使用char替换BYTE第二种方式是使用C++的关键字typedef 1typedef char byte; // typedef type_name alias_name; 使用define和使用typedef的区别在于，在声明一系列变量时，define不在有效 do while循环不同于for循环和while循环，它是出口条件循环。这意味着这种循环将首先执行循环体，然后再判定测试表达式，决定是否继续执行循环。 123do bodywhile (test-expression); 三种循环各有应用场景，需要合适选择 C++新增了基于范围的for循环。这简化了一种常见的循环任务：对数组或容器的每个元素执行相同的操作，后者提供了修改元素的方法。 123456789vector&lt;int&gt; v = &#123;1, 2, 3&#125;;for (int x: v)&#123; printf(\"%d\\n\", x);&#125;for (int &amp;x: v)&#123; x = 1;&#125; cin对象支持三种不同模式的单字符输入： 1234char ch;cin &gt;&gt; ch; // 忽略空白ch = cin.get(); // return charcin.get(ch); // return istream 可以使用文件尾条件（EOF）来表示输入的结束。检测到EOF后，cin将两位（eofbit和failbit）都设置为1，可以通过成员函数eof()来查看eofbit，如果eofbit或failbit被设置，fail函数返回true。eof和fail方法报告最近读取的结果，也就是说它们在事后报告，而不是预先报告。因此应将这两个测试放在读取后 istream提供了一个可以将istream转换为bool的函数，当cin出现在bool需要的地方时，该转换函数将被调用。如果最后一次读取成功，则转换得到的bool值为true；否则为false。因此输入可以如下： 1234while (cin.get(ch))&#123; &#125; 二维数组更像是一个表格——既有数据行又有数据列。 第六章 分支语句和逻辑运算符if语句让程序能够决定是否执行特定的语句块 12if (test-condition) statement if else语句让程序决定执行两条语句中的哪一个 1234if (test-condition) statement1else statement2 if else中的两个操作必须都是一条语句，如果需要多条语句，则需要使用大括号将它们括起来，组成一个语句块 if else语句可以互相嵌套，组成多种选择 可以将variable == value转换成value == variable，以此来捕获将相等运算符误写为赋值运算符的错误 逻辑运算符分为逻辑或，逻辑与，逻辑非 C++可以采用逻辑或运算符(||)，将两个表达式组合起来。如果原来表达式中的任何一个或全部都为true，则得到的表达式的值为true；否则，表达式的值为false ||运算符的优先级低于算术运算符 C++规定，||是一个顺序点，也就是说先修改左边的值，再对右侧的值进行判定。当能够确定整个表达式的值时，就不再往下运算了，也就是说||运算符有短路特性 对于逻辑与，仅当所有的表达式都为true时，得到的表达式才为true &amp;&amp;运算符的优先级低于算术运算符 和||运算符一样，&amp;&amp;运算符也是顺序点，同样&amp;&amp;也有短路特性 对于取值范围，不要写成3&lt;a&lt;5，这样不能正确表示范围，编译器不会捕获这种错误，因为它仍然是合法的C++语句 逻辑非(!)对它后边的表达式取反 C++逻辑与和逻辑或运算符的优先级低于算术运算符，!运算符的优先级高于所有的关系运算符和算术运算符。因此如果对表达式取反，必须使用括号将其括起来 编写复杂的逻辑表达式，还是加上括号，降低出现错误的可能性 C++确保程序从左到右进行计算逻辑表达式，并在知道答案后立刻停止 并不是所有键盘都提供了用作逻辑运算符的符号，因此C++标准提供了另一种表示方式。标识符and，or，not都是C++保留字，这意味着不能将它们用作变量名等。它们不是关键字，因为它们都是已有语言特性的另一种表示方式。另外它们不是C的保留字。但C语言可以将它们用作运算符，只要包含了iso646.h头文件，C++并不要求头文件 C++从C语言继承了一个与字符相关的、非常方便的函数软件包，可以简化确定字母，数字等的工作。函数原型在cctype中。使用这些函数更加通用，例如在有的系统上，可能字母并不是连续编码的 函数名称 返回值 isalum() 如果参数是字母或数字，返回true isalpha() 如果参数是字母，返回true iscntrl() 如果参数是控制字符，返回true isdigit() 如果参数是数字，返回true isgraph() 如果参数是除空格外的打印字符，该函数返回true islower() 如果参数是小写字母，返回true isprint() 如果参数是打印字符(包括空格)，该函数返回true ispunct() 如果参数是标点符号，返回true isspace() 如果参数是标准空白符，如空格，进纸，换行符，回车，水平制表符，或者垂直制表符，返回true issupper() 如果参数是大写字母，返回true isxdigit() 如果参数是16进制数字，0-9，a-f,A-F，返回true tolower() 如果参数是大写字母，则返回小写，否则返回该参数 toupper() 如果参数是小写字母，则返回大写，否则返回该参数 C++有一个常被用来代替if else语句的运算符，这个运算符被称为条件运算符(?:)，它是C++中唯一一个需要3个操作数的运算符 1expression1?expression2:expression3; 如果expression1为true，则整个表达式的值为expression2，否则，表达式的值为expression3 switch语句提供了分支选择的另一种方法 12345678switch(integer expression)&#123; case label1: statement(s) case label1: statement(s) case label1: statement(s) ... defaule: statement(s)&#125; 程序将跳到integer expression的值标记的那一行。integer expression必须是结果值为整数的表达式，每个标签必须是整数常量表达式。如果不匹配任何标签，则程序跳转到default的那一行。default是可选的，如果被省略，有没有匹配的标签，则程序直接跳转到switch后边的语句执行 跳转到switch语句中的标签后，将会依次执行后边的代码，除非有明确的其他指示，如break指令 如果既可以使用switch和if else，选项不少于3项时，则可以考虑使用switch break和continue语句都能使程序跳过部分代码。可以在switch语句中使用break，使程序跳转到switch后执行语句。continue和break都可以用到循环中。break使程序跳出循环，continue使程序跳过本次循环，开始一个新的循环，其不会跳过更新表达式 C++使得将读取屏幕输入输出的技巧应用于文件输入输出中。 可以使用ifstream和ofstream类创建对象，关联到相应的文件，对文件进行读取和写入。类似于使用cin和cout对象 第七章 函数——C++的编程模块使用函数，必须完成如下工作： 提供函数定义 提供函数原型 调用函数 函数可以分为有返回值的函数和没有返回值的函数 12345678910void func_name(parameter_list)&#123; statement(s); return;&#125;type_name func_name(parameter_list)&#123; statement return value; // value is type cast to type type_name&#125; 对于有返回值的函数，必须使用返回语句，以便将值返回给调用函数。结果的类型必须是type_name类型或者可以被转换成type_name类型。C++的函数返回值不能是数组。 通常函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回。 函数原型描述了函数到编译器的接口，也就是说，它将函数返回值的类型以及参数的类型和数量告诉编译器。通常在函数原型的参数列表中，可以包括变量名，也可以不包括。原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。 在C++中，括号为空与在括号中使用关键字void是等效的，但是在C中，括号意味着不指出参数——这意味着将在后边定义参数列表。但在C++中不指定参数列表时应使用省略号。 原型有以下几点作用： 编译器正确的处理函数返回值 编译器检查使用的参数数目是否正确 编译器检查使用的参数类型是否正确，如果不正确，则转换成正确的类型(如果可能的话) C++通常按值传递参数。在函数中声明的变量(包括参数)是该函数私有的。C++标准用参数(argument)表示实参，使用参量(parameter)来表示形参。 在C++中当且仅当用于函数头或函数原型中，int *arr和int arr[]的含义才是相同的。 可以用const来声明一个指针常量，让指针指向一个常量对象，这样可以防止使用指针来修改所指向的值。但是指针本身是可以修改的，即指向另外的常量对象。如果只涉及一级间接关系，则可以将非const指针赋值给const指针，但是进入两级间接关系时，这种方式是不允许的。在指针参数中，尽可能使用const，可以避免无意对数据的修改，使得能够处理const和非const参数另一种是声明一个常量指针，即指针本身的指向是不能修改的。 123456789const int *p = NULL;int * const p = NULL;const int **pp;int *p;const int a = 0;pp = &amp;p; 不允许，假设允许*pp = &amp;a; 合法，都是const，但是将p设置为a的地址*p = 1; 合法，但是修改了const a 对于在参数中的二维数组或多维数组，必须指出除第一维的数组长度。否则，函数将无法处理。因为整个数组的指针是需要指定数组长度的 可以通过三种方式将C-风格字符串传递给函数： char数组 用引号括起来的字符串常量 被设置为字符串地址的char指针 对于string字符串和模板类array，可以像使用基本类型一样使用。 使用结构作为参数时，可以像处理基本类型一样处理结构。然而，这种默认的按值传递结构的方式有一个缺点，如果结构比较大，则复制结构将增加内存消耗，我们可以通过传递结构指针来减少消耗。 C++函数可以调用自己(然而，与C语言不同的是C++不允许main函数调用自己)，这种功能被称为递归。递归需要在合适的条件下终止，否则函数将一直递归下去，直到耗尽内存。 与数据项相似，函数也有地址，函数的地址是存储其机器语言代码的内存的开始地址。 函数名就是函数的地址。 通常，如果要声明函数指针，可以首先编写这种函数的原型，然后使用(*pf)替换函数名，这样pf就是这类函数的指针。优先级要求使用括号，才能定义正确的函数指针。 如果pf是函数指针，可以有两种方式调用该函数(*pf)()和pf()，其实其中存在着逻辑冲突。但是C++允许这两种语法同时存在。 函数指针数组： 123int f();int (*pf)();int (*pf_arr[10])(); 可以使用typedef简化函数指针的定义 123typedef int *(*pf)();int *f();pf func = f; 第八章 函数探幽内联函数常规函数和内联函数的区别不在于编写方式，而在于C++编译器如何将它们组合到程序中。 使用函数需要一定的开销。执行到函数调用指令时，程序将在函数调用后立即存储该指令的内存地址，并将函数参数复制到堆栈中，跳到标记函数起点的内存单元，执行函数代码，也许还要将返回值放入寄存器中，然后跳跃到地址被保存的指令处。对于内联函数，编译器将使用相应的函数代码替换函数调用。这样程序无需来回跳跃，执行速度稍快，代价是需要占用更多的内存。应有选择性的使用内联函数。 为了定义内联函数，我们必须在函数声明前或者函数定义前加上关键字inline。但是编译器不一定会满足这种需求。 在C语言中使用宏也可以实现类似的功能，但是宏只是文本替换，可能造成问题。 引用变量引用是已定义的变量的别名。 必须在声明引用变量时进行初始化。引用实际上更接近const指针。 引用经常被作为函数参数，这种传递参数的方法叫做按引用传递。 引用变量作用函数参数，如果不需要修改参数的值，可以将其声明为const引用。 如果引用参数是const，则编译器将在下面两种情况下生成临时变量： 实参的类型正确，但不是左值 实参的类型不正确，但可以转换为正确的类型 左值参数是可以被引用的数据对象。常规变量和const变量都可以视为左值，一个可以被修改，一个不能被修改。 对于常量引用，将不会生成临时变量。如果是const引用参数，如果实参不匹配，则其行为类似于按值传递。 我们应尽可能的使用const： 可以避免无意修改数据 可以处理const和非const实参 能够正确的生成并使用临时变量 函数可以返回引用，其实际上是被引用变量的别名。应避免返回函数终止时不再存在的内存单元的引用。 返回引用类型的函数是左值，我们可以对其进行赋值，如果不希望这样做，可以将返回类型声明为const引用。但常规返回类型是右值，这种返回值位于临时内存单元中，运行到下一条语句，它们可能已经不存在了 1func() = 1; // 合法 C风格字符串可以传递给const string引用。 对于集成的对象，基类的引用可以指向派生类对象，无需进行强制转换。 使用引用参数的原因主要有两个： 能够修改调用函数中的数据对象 通过传递引用而不是整个数据对象，可以提高程序的运行速度 对于使用传递的值而不做修改的函数： 如果数据对象很小，如内置数据类型，则按值传递 如果数据对象是数组，则使用指针，这是唯一的选择，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或const引用，可以提高程序效率。节省复制结构所需的时间和空间 如果数据对象是类对象，则使用const引用。传递类对象参数的标准方式是按引用传递 对于修改调用函数中数据的函数： 如果数据对象是内置数据类型，则使用指针。当然也可以使用引用 如果数据对象是数组，则只能使用指针 如果数据对象是结构，则使用指针或引用 如果数据对象是类对象，则使用引用 默认参数默认参数指的是当函数调用中省略了实参时自动使用的一个值。 通过函数原型来设置默认参数。对于带参数列表的函数，必须从右往左添加默认值。如果不指定实参，则使用默认值，如果指定实参，则使用实参的值。 函数重载函数重载可以使用多个同名的函数。其关键是函数的参数列表，也称为函数的特征标。 如果两个函数的参数的个数和类型相同，同时参数的排列顺序也相同，则它们的特征标相同。函数重载的条件是函数的特征标不同。 我们可以对引用参数进行重载： 12345double x = 1.0;const double y = 2.0;void stove(double &amp;r); // 匹配可修改的左值，xvoid stove(const double &amp;r); // 匹配const左值，yvoid stove(double &amp;&amp;r); // 匹配右值，x+y，如果没有定义，将匹配上一个函数 仅当函数基本执行相同任务，但使用不同形式的数据时，才应该采用函数重载。 编译器对每个重载函数进行名称修饰，以此来定位每个重载的函数。 函数模板函数模板是通用的函数描述，它使用泛型来定义函数，其中的泛型可以用具体的类型替换。通过将类型作为参数传递给模板，可使编译器生成该类型的函数。 模板的一个用法是希望将一个算法应用到不同的数据类型中。例如排序算法。 12template &lt;typename T&gt; // template &lt;class T&gt;void swap(T &amp;a, T &amp;b); 在最终生成的代码里不包含模板，只包含实际生成的函数。 可以对模板定义进行重载，前提也是特征标不同。 编写的模板函数可能无法处理所有的类型。例如，可能有的类没有+运算符，但是我们在模板定义中使用了。一种解决方案是重载+号运算符，另一种是为特定类型提供具体化的模板定义。 我们可以对模板函数提供一个函数具体化的定义——称为显式具体化，其中包含所需要的代码。当编译器找到与函数调用匹配的具体化定义时，将使用该定义，而不再寻找模板。具体方法为： 对于给定的函数名，可以有非模板函数，模板函数和显式具体化模板函数以及它们的重载版本 显式具体化的原型和定义应该以template&lt;&gt;开头，并通过名称来指出类型 具体化优先于常规模板，而非模板函数优先于具体化和常规模板 123456template &lt;typename T&gt;void swap(T &amp;a, T &amp;b);// 一下两种方式都可以template &lt;&gt; swap&lt;int&gt;(int &amp;a, int &amp;b);template &lt;&gt; swap(int &amp;a, int &amp;b); 另外还必须理解实例化和具体化。在代码中包含函数模板本身并不会生成函数定义，它只是一个用于生成函数定义的方案。编译器使用模板为特定类型生成函数定义时，得到的是模板实例。这种方式被称为隐式实例化，编译器通过函数调用来知道如何进行实例化。 现在C++还允许显式实例化。这意味着可以直接命令编译器创建特定的实例。声明所需的种类——用&lt;&gt;符号指示类型，并在声明前加上关键字template。 1template void swap&lt;int&gt;(int &amp;a, int &amp;b); 要区别显式具体化和显式实例化，前者并不生成函数定义。试图在同一个文件或抓换单元中使用同一种类型的显式实例和显式具体化将出错。 可以在程序中使用函数来创建显式实例化： 123int x = 0;char m = 1;swap&lt;int&gt;(x, m); 隐式实例化，显式实例化，显式具体化统称为具体化。它们表示的都是使用具体类型的函数定义，而不是通用描述。 对于函数重载，函数模板和函数模板重载，C++需要一个定义良好的策略，来决定为函数调用使用哪一个函数定义，尤其是有多个参数时。这个过程称为重载解析。 第一步，创建候选函数列表。其中包含与被调函数的名称相同的函数和模板函数 第二步，使用候选函数列表创建可行函数列表。这些都是参数数目正确的函数，为此有一个隐式转换序列，其中包括实参类型与相应的形参类型完全匹配的情况。 第三步，确定是否有最佳的可行函数，如果有则使用它，否则该函数调用出错。 为了确定是否有最佳的可行函数，需要查看为使函数调用参数与可行的候选函数的参数匹配所需要进行的转换。通常，最佳到最差的顺序如下： 完全匹配，但常规函数优于模板 提升转换(char转换为int或float转换为double) 标准转换(int转换为char，long转换为double) 用户定义的转换，如类声明中定义的转换 进行完全匹配时，C++允许某些无关紧要的转换。Type本身可以是char &amp;这样的类型。Type(argument-list)意味着用作实参的函数名与用作形参的函数指针只要返回类型和参数列表相同，就是匹配的 从实参 到形参 Type Type &amp; Type &amp; Type Type [] *Type Type(argument-list) Type(*)(argument-list) Type const Type Type volatile Type Type * const Type Type * volatile Type* 例如： 1234567int a = 10;f(a);// 下面都是完全匹配的void f(int);void f(const int);void f(int &amp;);void (const int &amp;); 有的时候即使两个函数都完全匹配，仍可以完成重载解析。首先，指向非const数据的指针和引用优先与非const指针和引用参数匹配。在上面示例中，如果只定义了函数3和4，则使用函数3。这种区别只适用于指针和引用指向的数据，如果只定义了函数1和2，将出现二义性错误。 另一种情况是其中一个是非模板函数，而另一个不是。这种情况下非模板函数优先于模板函数(包括显式具体化)。如果两个完全匹配的函数都是模板函数，则较具体的模板函数优先。例如：显式具体化将优于使用模板隐式生成的具体化。 术语最具体不一定意味着显式具体化。而是指编译器推断使用哪种类型时执行的转换最少。 12345template &lt;typename T&gt; void f(T t);template &lt;typename T&gt; void f(T *t);int a = 10;f(&amp;a); 模板1将T解释为int *，模板2将T解释为int，因此两个隐式实例f&lt;int *&gt;(int *)和f&lt;int&gt;(int *)，后者被认为是更具体的，模板2已经指出函数参数时指向T的指针。 用于找出最具体模板的规则被称为函数模板的部分排序规则。 简而言之，重载解析将寻找最匹配的函数。如果只存在这样一个函数，则选择它；如果存在多个这样的函数，但其中只有一个是非模板函数，则选择该函数；如果存在多个合适的函数，且它们都为模板函数，但其中一个函数比其他函数更具体，则选择该函数。如果有多个同样合适的非模板或模板函数，但没有一个函数比其他函数更具体，则函数调用时不确定的，因此是错误的。当然，如果不存在匹配的函数，则也是错误的。 我们也可以显式的指出需要使用模板函数，即使已经有匹配的非模板函数了。 123int a = 0;f&lt;&gt;(a);f&lt;int&gt;(a); 将有多个参数的函数调用与有多个参数的原型进行匹配时，情况将非常复杂。编译器必须考虑所有参数的匹配情况。如果找到比其他可行函数都合适的函数，则选择该函数。一个函数要比其他函数都合适，其所有参数的匹配程度都必须不比其他函数差，同时至少有一个参数的匹配程度比其他函数都高 编写模板时，并不一定能知道使用的类型 12345template &lt;typename T1, typename T2void f(T1 a, T2 b)&#123; type? c = a + b;&#125; C++11提供了关键字decltype，给其的参数可以是表达式 1decltype(a + b) c = a + b; 编译器一般通过如下方式确定类型： 如果expression是一个没有用括号括起来的标识符，则类型与该标识符类型相同，包括const等限定符 如果expression是一个函数调用，则类型与函数的返回类型相同，这种情况并不会实际调用函数 如果expression是一个左值，则类型为指向其类型的引用。一种情况是expression是用括号括起来的标识符。括号并不会改变表达式的值和左值性 如果前面条件都不满足，则类型与expression的类型相同 可以结合typedef和decltype 12type decltype(a + b) type;type c; 另一中函数声明语法 123456template &lt;typename T1, typename T2? f(T1 a, T2 b)// auto f(T1 a, T2 b) -&gt; decltype(a + b)&#123; return a + b;&#125; 这种情况，并不能使用decltype解决，x，y并不在作用域内。新增的语法可以用作声明和定义： 12345auto f(int a, double b) - &gt; double;auto func(double a) -&gt; double&#123; return a;&#125; 第九章 内存模型和名称空间C++为在内存中存储数据方面提供了多种选择 单独编译和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。我们可以单独编译这些文件，然后将这些文件链接起来。 我们一般可以将程序分为三部分： 头文件：包含结构声明和使用这些结构的函数的原型 源代码文件：包含与结构有关的函数的代码 源代码文件：包含调用与结构相关的函数的代码 在头文件中，我们一般包含如下内容： 函数原型 使用#define或const定义的符号常量 结构声明 类声明 模板声明 内联函数 通常我们需要保证一个头文件只包含一次。 存储持续性、作用域和链接性C++使用3种(在C++11中是4种)不同的方案来存储数据，这些方案的区别在于数据保留在内存中的时间： 自动存储持续性：在函数定义中声明的包括参数的存储持续性为自动的 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量的存储持续性都为静态。 线程存储持续性(C++11)：我们使用关键字thread_local声明这种变量，其生命周期与所属的线程一样长 动态存储持续性：用new来分配，和delete来释放。也被称为堆或自由存储 作用域描述了名称在文件中的多大范围可见。链接性描述了名称如何在不同单元间共享。链接性为外部的名称可以在文件间共享，链接性为内部的名称只能由一个文件中的函数共享。 C++变量的作用于有多种，作用域为局部的变量只在定义它的代码块中可用。作用域为全局的变量在定义位置到文件结束之间都可用。在函数原型作用域中使用的名称只在包含参数列表的括号中可用。在类中声明的成员的作用域为整个类。在名称空间中声明的变量的作用域为整个名称空间。全局作用域是名称空间作用域的特例。 C++函数的作用域可以是整个类或整个名称空间(包括全局的)，但不能是局部的。不同的C++存储方式是通过存储持续性、作用域和链接性来描述的。 自动存储持续性默认情况下，在函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性。如果代码块中定义了变量，则该变量的存在时间和作用域将被限制在该代码块中。如果存在同名变量，则较小作用域的变量会覆盖较大作用域的变量。 C++11中的auto关键字用于自动类型推断。和之前的含义截然不同。C++11中的register关键字替代了之前的auto关键字，来指出变量是自动的，不再建议编译器使用CPU寄存器来存储自动变量。 自动变量一般存储在栈中，栈是LIFO。这种设计简化了参数传递，参数一般从右往左进入栈中，这样也实现了可变参数。 静态存储变量静态存储变量有三种链接性： 外部链接性，可在其他文件中访问，在代码块的外边声明它 内部链接性，只能在当前文件中访问，在代码块的外边声明它，并使用static限定符 无链接性，只能在当前函数或代码块中访问，在代码块中声明它，并使用static限定符 这三种链接性都在整个程序执行期间存在。编译器分配固定的内存块来存储所有的静态变量。如果静态变量没有显示的初始化，编译器将把它设置为0。 所有的静态持续变量都有下述初始化特征：未被初始化的静态变量的所有位都被设置为0，这种变量被称为零初始化的。 存储描述 持续性 作用域 链接性 如何声明 自动 自动 代码块 无 在代码块中 寄存器 自动 代码块 无 在代码块中，使用关键字register 静态，无连接性 静态 代码块 无 在代码块中，使用关键字static 静态，外部链接性 静态 文件 外部 不在任何函数中 静态，内部链接性 静态 文件 内部 不再任何函数中，使用关键字static 除了默认的零初始化外，还可对静态变量进行常量表达式初始化和动态初始化。零初始化和常量表达式初始化被统称为静态初始化。这意味着在编译器处理文件时初始化变量。动态初始化意味着变量在编译后初始化。 C++11新增了关键字constexpr，这增加了创建常量表达式的方式。 静态持续性、外部链接性链接性为外部的变量通常简称为外部变量，它们的存储持续性为静态，作用域为整个文件。外部变量是在函数外定义的，因此对所有函数而言都是外部的。 单定义规则指出变量只能定义一次，C++提供了两种变量声明。一种是定义声明，简称定义，它给变量分配存储空间，另一种是引用声明，简称声明，它不给变量分配存储空间，它引用已有的变量；引用声明使用关键字extern，且不进行初始化，否则为定义。 单定义规则并不意味这不能定义相同名字的变量。因为定义可以被覆盖。 静态持续性、内部链接性将static限定符用于作用域为整个文件的变量时，该变量的链接性定义为内部的。我们不能在两个文件中分别定义同名的变量，这违反了单定义规则；但是一个内部静态变量能够隐藏在另一个文件中定义的外部静态变量。 静态存储持续性、无链接性静态局部变量的值在程序运行期间一直存在，初始化只初始化一次。 说明符和限定符有些称为存储说明符或cv限定符的关键字提供了其他有关存储的信息。下边是存储说明符： auto，C++11中不再是说明符 register static extern thread_local mutable 关键字mutable的含义将根据const来解释。cv限定符包含const和volatile。const我们已经介绍过了。volatile表明即使一个程序代码没有对内存单元进行修改，其值也可能发生变化，例如访问某些硬件。这样编译器就不会对这个变量进行特殊优化。 mutable指出即使结构或类为const，某个成员也可以被修改。 在C++中，但不是在C语言中，const限定符对默认存储类型稍有影响。在默认情况下，全局变量的链接性为外部的，但const全局变量的链接性为内部的。对于const变量，我们需要使用extern指出其链接性为外部的。 函数和链接性函数的链接性可选的范围比变量小。默认情况下，函数的链接性为外部的，可以在文件间共享。对于函数来说extern关键字是可选的。使用关键字static来指出函数链接性为内部的，只能在当前文件中使用，必须同时在原型和函数定义中使用该关键字。 单定义规则也适用于非内联函数。内联函数不受这个规则的约束，我们允许将内联函数定义在头文件中。要求所有内联函数的定义都必须相同。 语言链接性语言链接性对函数也有影响。链接程序要求每个不同的函数都有不同的符号名。C语言中，一个名称只对应一个函数，因此这很容易实现，编译器可能将func这样的函数翻译为_func。这被称为C语言链接性。但在C++中，函数重载导致一个名称对应多个函数，我们需要为这些函数生成不同的名称，例如加上参数列表的类型信息，这被称为C++语言链接性。这就导致了链接程序寻找函数时的方法不同。如果要在C++中使用C库中预编译的函数，我们可以使用函数原型来指出希望的约定： 123extern \"C\" void func(int); // cextern void func(int); // c++extern \"C++\" func(int); // c++ 存储方案和动态分配对于new或malloc分配的内存，我们有自己控制这些内存生存周期的能力。 new和delete将被转换为对应的函数，我们可以提供自己的函数来替换现有的new函数 new还提供一种变体，被称为定位new运算符。我们能够指定存放的位置。我们必须包含new头文件。 12char buffer[1024];int *p3 = new (buffer)int[10]; 定位new运算符并不跟踪哪些内存已经被使用，两次使用将返回相同的地址，先前的数据将被覆盖。我们不能使用delete来释放这些内存。 对于定位new函数，我们不可以替换，但可以进行重载。 名称空间C++提供的名称空间工具，可以更好的控制名称的作用域。 传统的C++名称空间声明区域是可以进行声明的区域。潜在作用域从声明点开始，到其声明区域的结尾。变量在潜在作用域内并不一定都是可见的。 C++可以通过定义一种新的声明区域来创建命名的名称空间，提供一个声明名称的区域。名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中。在默认情况下，名称空间中声明的名称的链接性是外部的，除非它引用了常量。存在一个全局名称空间，它对应于文件声明区域，全局变量在这个名称空间中。 任何名称空间中的名称不会与其他名称空间中的名称发生冲突。我们使用作用域解析运算符::来使用名称空间中的名称。 同样我们也可以使用using声明或using编译指令来简化对名称空间的使用。前者是特定标识符可用，后者使整个名称空间可用。 using声明将特定的名称添加到它所属的声明区域中。 using声明和using编译指令是不一样的，使用using声明就好像是声明了相应的名称一样，如果一个名称已经在函数中声明了，则不能再使用using声明导入相同的名称。然而使用using编译指令将进行名称解析，局部变量将隐藏名称空间版本的同名变量。 名称空间可以进行嵌套，也可以在名称空间中使用using声明和using编译指令。using编译指令是可传递的。还可以对名称空间创建别名： 1namespace test = other_namespace; 我们可以创建未命名的名称空间，其中的名称的潜在作用域为从声明点到该声明区域末尾。这提供了链接性为内部的静态变量的替代品。 指导原则对于名称空间，下面是指导原则： 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量 如果开发了一个函数库，将其放在一个名称空间中 谨慎使用using编译指令 不要在头文件使用using编译指令 导入名称时，首先使用作用域解析运算符或using声明的方法 对于using声明，首选将其作用域设置为局部而不是全局","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://gwq5210.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"Cpp Primer Plus","slug":"Cpp-Primer-Plus","permalink":"https://gwq5210.com/tags/Cpp-Primer-Plus/"}],"keywords":[]},{"title":"Cpp Primer Plus读书笔记（一）","slug":"Cpp-Primer-Plus读书笔记（一）","date":"2017-07-02T21:25:04.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2017/07/02/Cpp-Primer-Plus读书笔记（一）/","link":"","permalink":"https://gwq5210.com/2017/07/02/Cpp-Primer-Plus读书笔记（一）/","excerpt":"","text":"第一章 预备知识C++简介C++融合了三种不同的编程方式： C语言代表的过程性语言 以类为代表的面向对象于艳 模板支持的泛型编程 面向对象编程面向对象编程(OOP)强调的是数据。理念是设计与问题本质特性相对应的数据格式。 泛型编程泛型编程强调编程要独立于特定数据类型，即创建独立于类型的代码。 C与C++C++是C的超集，尽管有一些细微差别，但这种差别很小。 第二章 开始学习C++进入C++C++提供了不同于C的输入输出工具，内置的cin和cout对象，使用它们需要包含头文件iostream。 main函数通常被启动代码调用，启动代码是编译程序加入到程序当中的。 如果main函数没有指明返回语句，则认为return 0;是返回语句。 C++提供两种注释的方式//(C++)或/**/(C)。C99标准在C语言中加入了//注释。 #include编译指令会让预处理器添加指定文件内容到程序中。 不同的头文件名可被不同的程序使用。 头文件类型 约定 示例 说明 C++旧式风格 以.h结尾 iostream.h C++程序可以使用 C旧式风格 以.h结尾 math.h C,C++程序可以使用 C++新式风格 没有扩展名 iostream C++程序可以使用，使用namespace std 转换后的C 加上前缀c，没有扩展名 cmath C++程序可以使用，可以使用不是C的特性，如namespace std C++中可以使用命名空间来避免名字冲突。可以使用using编译指令来使用命名空间中的函数或类对象。 123using namespace std;using std::cin;std::cout &lt;&lt; \"Hello World!\" &lt;&lt; std::endl; cout中，可以使用endl和”\\n”表示换行符。不同的是endl确保程序继续运行前刷新输出，使用”\\n”不能提供这样的保证。 12cout &lt;&lt; \"Hello World!\\n\";cout &lt;&lt; \"Hello world!\" &lt;&lt; endl; 尽量遵循好的C++代码风格，程序会便于阅读。 C++语句变量在使用前必须进行声明，通常是为了指出要存储的类型和程序对存储在这里的数据使用的名称。 对于声明变量，C++的做法是尽可能在首次使用变量前声明它。 cout可以根据变量的类型相应的调整行为。 12cout &lt;&lt; 12 &lt;&lt; \"12\" &lt;&lt; endl;printf(\"%d %s\\n\", 12, \"12\"); 类描述了一种数据类型的全部属性(包括可使用它执行的操作)，对象是根据这些描述创建的实体。 函数C++程序应当为程序中使用的每个函数提供原型。 不要混淆函数原型和函数定义。 12345int fun();int fun()&#123; return 0;&#125; 函数可以有返回值和无返回值。无返回值的函数用void来标识。 函数的格式为： 1234type functionname(argumentlist)&#123; statements&#125; 第三章 处理数据简单变量在程序中，为了存储信息，必须记录三个基本属性： 信息将存储在哪里 要存储什么值 存储何种类型的信息 声明变量恰好记录了这些信息。 变量名C++变量名必须遵循如下规则，并尽量使用有意义的变量名： 在名称中只能使用字母字符，数字和下划线(_) 名称的第一个字符不能是数字 区分大写字符与小写字符 不能将C++关键字用作名称 一两个下划线或下划线和大写字母打头的名称被保留给实现(编译器及其使用的资源)使用。以一个下划线开头的名称被保留给实现，用作全局标识符。违反这一点并不会导致编译器错误，但可能会导致行为的不确定性。 C++对名称没有长度限制，名称中的所有字符都有意义，但有些平台有长度限制。C99标准只保证名称中的前63个字符有意义 整形语言只能表示所有整数的子集。C++提供多种不同的整型，以便根据程序具体要求选择最合适的整型 C++的基本整型分别是char、short、int、long和C++ 11新增的long long，其中每种类型都有有符号版本和无符号版本 C++对整型提供了灵活的标准，确保整型的最小长度 short至少16位 int至少与short一样长 long至少32位，且至少与int一样长 long long至少64位，且至少与long一样长 实际上，short是short int的简称，long是long int的简称 sizeof运算符返回类型或变量的长度，单位为字节 1234int a = 0;cout &lt;&lt; sizeof a &lt;&lt; endl; // 变量可以这样写，类型必须加括号cout &lt;&lt; sizeof(a) &lt;&lt; endl;cout &lt;&lt; sizeof(int) &lt;&lt; endl; 头文件climits(limits.h)定义了符号常量来表示类型的限制 符号常量 表示 CHAR_BIT char的位数 CHAR_MAX char的最大值 CHAR_MIN char的最小值 SCHAR_MAX signed char的最大值 SCHAR_MIN signed char的最小值 UCHAR_MAX unsigned char的最大值 SHRT_MAX short的最大值 SHRT_MIN short的最小值 USHRT_MAX unsigned short的最大值 INT_MAX int的最大值 INT_MIN int的最小值 UINT_MAX unsigned int的最大值 LONG_MAX long的最大值 LONG_MIN long的最小值 ULONG_MAX unsigned long的最大值 LLONG_MAX long long的最大值 LLONG_MIN long long的最小值 ULLONG_MAX unsigned long long的最大值 C++支持类似C的符号常量，其进行简单的字符串替换。C++还提供了const来定义符号常量 C++提供了不同于C的初始化方式： 123456int a = 0;int b(1);int c&#123;2&#125;; // C++ 11int d = &#123;3&#125;; // C++ 11int e = &#123;&#125;; // set to 0int f&#123;&#125;; // set to 0 无符号类型整数不能存储负数，但可以增大变量能够存储的整数的最大值 C++确保无符号整数溢出时会取范围另一端的值，但并不保证有符号整数超越限制(上溢和下溢出)时不出错，而这正是当前实现中最为常见的行为 通常int被设置为对目标计算机而言最“自然”的长度，自然长度是只计算机处理起来效率最高的长度，如果没有非常有说服力的理由选择其他类型，则应使用int。其他根据具体取值范围来选择整数类型 整型字面值(常量)是显式书写的常量。C++同C一样能以三种不同的方式来书写整数：基数为10，基数为8，基数为16。C++使用前一(两)位来标识数字常量的基数。如果第一位为1-9，则基数为10；如果第一位为0，第二位为1-7，则基数为8；如果前两位为0x或0X，则基数为16 C++通过后缀，长度来确定常量的类型。除非有理由(使用了后缀或值超出int存储范围)存储为其他类型，否则C++就将整数常量存储为int。 后缀是放在数字常量后的字母，用于表示类型。l或L表示long，u或U表示unsigned int，ul(可以采用任何一种顺序，大小写均可)表示unsigned long(由于l看起来像1，推荐使用大写L后缀)。C++提供了用于表示long long的后缀ll或LL，还提供了用于表示unsigned long long的后缀ull，Ull，uLL，ULL 对于长度，C++中，对10进制整数采用的规则与16进制和8进制稍有不同。对于不带后缀的十进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、long或long long。对于不带后缀的16进制或8进制整数，将使用下面几种类型中能够存储的最小类型来表示：int、unsigned int、long、unsigned long、long long或unsigned long long char类型是专为存储字符而设计的，编程语言将字符存储为数值，实际上char类型是一种整型，可以当做比short更小的整型 char字面值有两种表示方式：直接单引号括起来的单个字符，如’a’；使用转义字符表示的特殊字符，如’\\n’ 与int类型不同，char在默认情况下既不是没有符号，也不是有符号。是否有符号由C++的实现来决定，但可以显式的指定char为有符号或无符号，这在把char当做数值类型是就十分重要 bool类型的值可以为true或false，分别表示真假。字面值true和false都可以通过提升转化为int类型。任何数字值或指针值都可以被隐式转换为bool值 C++中可以使用const来修改变量声明和初始化，创建一个符号常量。其被初始化后，编译器就不允许修改该常量的值。如果在定义常量是没有初始化值，则该常量的值是不确定的，且无法修改 1const type name = value; 浮点型浮点数可以用来表示小数，浮点数有两种表示：一是常用的标准小数点表示，如8.2等；二是E表示法，如3.45E6表示3.45与1000000相乘的结果，指数为负表示除以10的乘方。E表示法确保数字以浮点格式存储。 有三种浮点类型：float、double和long double。C和C++对有效位数(数字中有意义的位数)的要求分别是：至少32位，至少48位且不少于float，long double至少和double一样多。可以从cfloat头文件获取这些类型的相关限制。 默认情况下的浮点常量存储为double，如果想使用float存储，请加f或F后缀 浮点数由于精度有限，在计算时可能会出现错误 signed char，short，int和long统称为符号整型；它们的无符号版本统称为无符号整型；C++ 11新增了long long。bool、char、wchar_t、符号整型和无符号整型统称为整型；C++ 11新增了char16_t和char32_t。float，double和long double统称为浮点型。整型和浮点型统称为算术类型 算术运算符C++提供了5中基本算术运算：+、-、*、/、% 对于除法，如果两个操作数都是整数，则结果为商的整数部分 对于取模，两个操作数必须是整数，如果其中一个是负数，结果符合如下规则：(a/b)*b+a%b=a 为了完成复杂的运算，需要规定运算符的优先级和结合性。*和/的优先级高于+和-。+，-，*，/都是从做到右结合的。从左到右的结合性意味着如果优先级相同的操作符被同时作用于同一个操作数，则首先计算左侧的操作符。从右到左亦然。 对于如下表达式，程序必须在做加法前计算乘法，但并没有指出先计算哪个乘法，这取决于实现。结合性在这里不起作用，因为两个乘号没有作用到同一个操作数 120*5+24*6 C++自动执行多种类型转化： 将一种算术类型的值赋给另一种算术类型的变量时，C++将对值进行转换 表达式中包含不同类型的类型时，C++将对值进行转换 将参数传递给函数时，C++将对值进行转换 初始化和赋值进行的转换有可能会丢失数值或损失精度 以{}方式进行的初始化，不允许缩窄 在表达式中，有两种转换：一些类型在出现时就会自动转换，有些类型在与其他类型同时出现在表达式中时将被自动转换 在计算表达式时，C++将bool，char，unsigned char，signed char和short值转换为int如果short比int短，则unsigned short类型被转换成int，如果两种类型长度相同，则unsigned short转换为unsigned int，这确保转换时不会丢失数据，同样wchar_t被提升为下列类型中第一个宽度足够的类型：int，unsigned int，long或unsigned long 不同类型进行计算时也会进行转化： 如果有一个操作数类型为long double，则将另一个操作数转换为long double 否则，如果有一个操作数类型为double，则将另一个操作数转换为double 否则，如果有一个操作数类型为float，则将另一个操作数转换为float 否则，说明操作数都是整型，则执行整型提升 在这种情况下，如果两个操作数都是有符号或无符号的，且其中一个操作数级别比另一个低，则转换为较高的类型 如果一个操作数为有符号的，另一个操作数为无符号的，且无符号数的级别比有符号数的级别高，则将有符号数转换为无符号操作数对应的类型 否则，如果有符号类型可表示无符号类型的所有可能值，则将无符号操作数转换为有符号操作数的类型 否则，将两个操作数都转换为有符号类型的无符号版本 注：传统C总是将float提升为double，即使两个操作数都是float 传递参数时的类型转换通常由C++函数原型控制，然而也可以取消原型对参数传递的控制，尽管这样做并不明智。在这种情况下，C++将对char和short(signed和unsigned)应用整型提升。另外为保持传统C语言中大量代码的兼容性，在将参数传递给取消原型对参数传递控制的函数时，C++将float参数提升为double C++允许强制类型转换： 12(type_name)value // Ctype_name(value) // C++ 在初始化声明中，如果使用关键字auto，而不指定变量的类型，编译器把变量的类型设置成与初始值相同 第四章 复合类型数组数组是一种数据格式，能够存储多个同类型的值 要创建数组，可使用声明语句，数组声明应指出一下三点： 存储在每个元素中的值的类型 数组名 数组中的元素数 array_size指定元素数目，它必须是整型常数或const值，也可以是常量表达式，其中的值在编译时必须已知 1type_name array_name[array_size]; 数据的下标从0开始编号，编译器并不会检查使用下标的有效性 只有在定义数组时才能使用数组初始化，以后就不能使用了，不能将一个数组赋值给另一个数组初始化数组时，提供的值可以少于数组的元素数目，编译器将其他元素设置为0初始化时，方括号内为空，C++编译器将计算元素个数C++ 11提供的列表初始化{}可以省略等号；大括号内不包含任何东西，则将所有元素设置为0；列表初始化进制缩窄 12345int a[4] = &#123;0, 1, 2, 3&#125;;int b[4];int c[4] = &#123;1&#125;; // 1,0,0,0int d[4] = &#123;0&#125;;// 0,0,0,0int e[4] = &#123;&#125;; 字符串C-风格字符串以空字符结尾，空字符写为\\0，ASCII值为0，用来标记字符串的结尾 123char a[4] = &#123;'a', 'b', 'c', 'd'&#125;; // not a stringchar b[4] = &#123;'a', 'b', 'c', '\\0'&#125;; // a stringchar c[4] = \"abc\"; 用引号括起来的字符串隐式的包括结尾的空字符，这种表示方式成为字符串字面值 确定存储字符串需要的最短数组时，不要忘记将结尾的空字符计算在内 字符串常量不能与字符常量互换，即’s’和”s”表示不同的含义。后者表示s和\\0两个字符组成的字符串 任何两个由空白分割的字符串常量都将自动拼接成一个字符串常量，拼接时不会再字符串之间添加空格 cin使用空白来确定字符串的结束位置，并不能读取包含空白的一行字符串 cin提供的成员函数getline(char *arr, int size)提供读取一行的能力，它通过回车来确定输入结尾，但不保存换行符（用空字符来替换换行符）。getline最多读取size-1或遇到换行符结束，会在结尾自动添加空字符。 get()方法提供了另外一种读取行的方式，该方法有几种变体。与getline不同的是get不再读取并丢弃换行符，而是将其保留在输入对列中。使用不带参数的get函数可以读取一个字符 getline使用起来更简单，get使得错误检查更简单。更多介绍请参考C++手册 string类简介string使用来比数组简单，同时提供了将字符串作为一种数据类型的方法，更多介绍可参考C++手册 C++新增了另一种类型的原始字符串，原始字符串使用“(和)”来界定边界，并使用前缀R来标识原始字符串在原始字符串中按回车键不仅会移动到下一行，还将在原始字符串中添加回车符还可以在界定符”(或)”的两个字符之间添加相同的其他字符，来标识结尾，这样可以在原始字符串中添加)”这样的字符 1234cout &lt;&lt; R\"(nihao\\n)\" &lt;&lt; endl;cout &lt;&lt; R\"(nihao\\n)\" &lt;&lt; endl;cout &lt;&lt; R\"a(nihao\\n)a\" &lt;&lt; endl; 结构简介结构是一种更加灵活的数据格式，同一个结构可以存储多种类型的数据。结构是用户自定义的类型，定义了类型后，便可以创建这种类型的变量 C++允许在声明结构变量时省略struct关键字 结构声明的位置很重要，可以将声明放在函数中，这样这个结构只能在本函数中使用。放在函数外的声明称为外部声明，外部声明可以被其后的任何函数使用 C++支持使用列表初始化的方式初始化结构变量，等号是可选的，如果大括号内为空，则各个成员被初始化为0，且不允许缩窄 结构变量可以进行赋值 可以声明结构数组，数组中每个元素都是该结构类型的变量 与C一样，C++允许指定占用特定位数的结构成员，字段的类型应为整型或枚举，接下来是冒号，后跟着一个数字，表示使用的位数。可以使用没有名字的字段来提供间距 12345678struct torgle_register&#123; unsigned int SN: 4; unsigned int : 4; bool flag: 1; bool retry: 1;&#125;;torgle_register tr = &#123;14, true, true&#125;; 共用体共用体是一种数据格式，它能够存储不同的数据类型，但只能同时存储其中的一种类型，共用体的语法与结构类似，但含义不同 匿名共用体没有名称，其成员将成为位于同地址处的变量，每次只有一个成员是当前的成员 123456789101112131415161718struct widget&#123; int type; union &#123; long id_num; char id_char[20]; &#125;;&#125;;widget price;if (price.type)&#123; cin &gt;&gt; price.id_num&#125;else&#123; cin &gt;&gt; price.id_char&#125; 枚举enum工具提供了另一种创建符号常量的方式，这种方式可以代替const。 1enum color &#123;red, green, yellow&#125;; 这样color成为枚举类型，大括号中的名称作为符号常量，它们对应0-2，这些常量叫做枚举量 在不进行强制类型转换的情况下，只能将定义枚举时使用的枚举常量赋值给这中枚举变量 对于枚举只定义了赋值运算符。枚举是整型，可被提升为int类型，但int类型不能自动转换为枚举类型 如果试图将不适当的值强制类型转换赋值给枚举变量，结果将是不确定的 枚举更常被用来定义符号常量，而不是定义新类型，如果不创建枚举类型，则可以省略枚举类型的名称 枚举的值可以显式指定，red默认为0，后边没有初始化的将比前一个大1，orange为7 1enum &#123;red, green = 4, yellow = 6, orange&#125;; 每个枚举都有取值范围，通过强制类型转化，可以将取值范围内的任何整数值赋给枚举变量，即使这个值不是枚举值 取值范围定义如下，首先找出上限，需要知道枚举的最大值，找到大于这个最大值的，最小的2的幂，将它减去1，这个值就是范围的上限。要计算下限，需要知道枚举常量的最小值，如果它不小于0，则取值范围的下限为0；否则，采用寻找上限方式相同的方式，但加上负号。如果最小的枚举值是-6，而比它小的，最大的2的幂是-8(加上负号)，因此下限为-7 指针和自由存储空间指针指针是一个变量，其存储的是值的地址 对于常规变量，在变量名前加地址运算符(&amp;)，就可以获得它的位置 cout在显示地址时，使用16进制表示法 使用常规变量时，值是指定的量，地址是派生量。指针策略刚好相反，将地址视为指定的量，而将值视为派生量。指针用于存储值的地址 *运算符被成为间接值或解除引用运算符，将其应用于指针，可以得到该地址处存储的值 C++中，int *是一种复合类型，是指向int的指针，也可以声明其他类型的指针 指针和指针指向的值是不同的概念，它们的长度可能不同 在指针声明中可以初始化指针，被初始化的是地址，而不是指针指向的值 使用为初始化的指针，可能导致严重的运行时错误。一定要在对指针应用解除引用运算符前，将指针初始化为一个确定的、适当的地址。这是关于使用指针的金科玉律 指针和整型是截然不同的类型，不能将int类型直接赋值给指针类型，而要通过强制类型转换来进行赋值 内存管理指针的真用用武之地是在运行阶段分配未命名的内存以存储值。这种情况只能通过指针来访问内存。 在C语言中可以使用库函数malloc来分配内存，在C++中仍然可以这样做，但C++提供了更好的方法——new运算符 new运算符的使用格式如下： 1type_name *pointer_name = new type_name; 需要再两个地方制定数据类型，用来指定需要什么类型的内存和声明什么类型的指针 new分配的内存块通常与常规变量声明分配的内存块不同，一个在堆中分配，一个在栈中分配 当内存使用完成时，使用delete运算符能够将其归还给内存池，归还后的内存可供程序的其他部分使用，一定要配对的使用new和delete，否则将发生内存泄露 不要尝试释放已经释放的内存块，这种结果是不确定的，不能使用delete来释放声明变量获得的内存，对空指针使用delete是安全的 在编译时给数组分配内存称为静态联编，意味着数组是在编译时加入程序的，这种必须在编译时指定数组的长度。与之对应，数组在程序运行时创建被称为动态联编，这种情况程序在运行时确定数组的长度 使用下边的来创建和释放动态数组： 12int *arr = new int[10];delete [] arr; new运算符返回第一个数组元素的地址，不同于普通变量，应使用delete []来释放整个数组 对于使用new和delete时，应注意： 不要使用delete来释放不是new分配的内存 不要使用delete来释放同一个内存块两次 如果使用new []为数组分配内存，则应使用delete []来释放 如果使用new来为一个实体分配内存，则应使用delete来释放 对空指针使用delete是安全的 使用动态数组只需要把返回的指针当做数组名来使用即可，在C和C++内部使用指针来处理数组 不能修改数组名的值，但动态数组的指针是变量可以修改它的值 指针、数组和指针算术指针和数组基本等价的原因在于指针算术和C++内部处理数组的方式 不同于整数算术，对指针来说，增加1相当于增加它指向类型的字节数，两个指针相减，得到的是他们之间的间隔（同一个数组中才有意义） 对于数组表达式arr[i]，编译器将该表达式看做*(arr + i)，如果使用指针，也进行这样的转换 对数组名使用sizeof得到的是数组的长度，对数组指针应用sizeof得到的是指针的长度 对数组名取地址得到的是数组的地址，数组名实际上代表数组中第一个元素的地址 12int arr[10];int (*p_arr)[10] = &amp;arr; 在cout和多数C++表达式中，char数组名，char指针，以及用引号括起来的字符串常量都被解释为字符串的第一个字符的地址 对于字符串常量，不应尝试修改它 应使用strcpy而不是赋值运算符来将字符串赋给数组 对于结构指针，应使用箭头成员运算符(-&gt;)来访问结构成员。另一种方法是(*p)-&gt;b 可以将new和delete放在不同的函数中，但这容易遗忘使用delete C++有三种管理数据内存的方式：自动存储、静态存储和动态存储。C++ 11新增了线程存储 在函数内部定义的常规变量使用自动存储空间，被称为自动变量。这表明它们在所属的函数被调用时自动产生，在函数结束时消亡。自动变量时一个局部变量，其作用于为包含它的代码块。代码块是被包含在花括号中的一段代码，自动变量通常存储在栈中 静态存储是在整个程序运行期间都存在的存储方式，有两种方式定义静态变量：在函数外定义它和在声明变量时使用个关键字static new和delete提供了比自动存储和静态存储更加灵活的方法。数据的声明周期不完全受程序或函数的生存时间控制，动态分配的变量通常存储在堆中 数组、结构和指针，可以使用各种方式组合它们 模板类vector和array(C++ 11)提供了动态数组和定长数组的替代品 vector可以在运行阶段设置vector对象的长度，它使用new和delete来管理内存 vector的功能比数组强大，但付出的代价是效率稍低。array提供了固定长度的数组，使用栈来存储数据，其更方便和安全 可以像使用普通数组一样使用vector和array，vector和array对象可以使用赋值，但数组不行。 vector和array可以使用at方法来确保不使用非法索引，这将在运行时捕获错误，程序默认将中断","categories":[],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://gwq5210.com/tags/读书笔记/"},{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"Cpp Primer Plus","slug":"Cpp-Primer-Plus","permalink":"https://gwq5210.com/tags/Cpp-Primer-Plus/"}],"keywords":[]},{"title":"cpp必读书籍推荐","slug":"cpp必读书籍推荐","date":"2017-07-02T20:56:49.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2017/07/02/cpp必读书籍推荐/","link":"","permalink":"https://gwq5210.com/2017/07/02/cpp必读书籍推荐/","excerpt":"本文内容来自国外著名编程问答网站Stackoverflow评选的C++推荐书单！推荐大家看原版英文，但这些书大部分也都有中文版！ 手册类 – 所有级别 C++程序设计语言(The C++ Programming Language) 作者：Bjarne Stroustrup(更新到C++11) C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了C++11的内容。电子书：第三版（中文）、第四版（英文） C++标准程序库(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发行的第二版涵盖了C++11。电子书：第一版（中文）、第一版（英文）、第二版（英文） The C++ IO Streams and Locales 作者：Angelika Langer and Klaus Kreft 除了这本书，市面上基本没有讲解streams and locales的书。电子书：96年版（英文） C++ 11手册:The C++ Standard (INCITS/ISO/IEC 14882-2011) 作者：C++标准委员会 这当然是C++最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有人会买现在价值$30US的电子发行版。电子书：N3225（英文） Overview of the New C++ (C++11/14) 作者：Scott Meyers(更新到C++11/C++14) 这是Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。电子书：2011年版（英文）","text":"本文内容来自国外著名编程问答网站Stackoverflow评选的C++推荐书单！推荐大家看原版英文，但这些书大部分也都有中文版！ 手册类 – 所有级别 C++程序设计语言(The C++ Programming Language) 作者：Bjarne Stroustrup(更新到C++11) C++之父写的经典C++书籍。内容覆盖C++的所有东西，从语言内核到标准库、编程范式和语言哲学(这使得最新版突破1千页)。2013年5月出版的第四版涵盖了C++11的内容。电子书：第三版（中文）、第四版（英文） C++标准程序库(C++ Standard Library Tutorial and Reference) 作者：Nicolai Josuttis (更新到C++11) 这本书是C++标准库（STL）的引导和手册。 2012年4月发行的第二版涵盖了C++11。电子书：第一版（中文）、第一版（英文）、第二版（英文） The C++ IO Streams and Locales 作者：Angelika Langer and Klaus Kreft 除了这本书，市面上基本没有讲解streams and locales的书。电子书：96年版（英文） C++ 11手册:The C++ Standard (INCITS/ISO/IEC 14882-2011) 作者：C++标准委员会 这当然是C++最权威的标准。要注意的是，C++标准是提供给有足够精力和时间的专家级用户研究用的。国内估计很少有人看，在国外一般它的第一个发行版也非常贵($300+ US)，国外有人会买现在价值$30US的电子发行版。电子书：N3225（英文） Overview of the New C++ (C++11/14) 作者：Scott Meyers(更新到C++11/C++14) 这是Scott Meyers开设的一个为期3天的C++课程的教材。Scott Meyers是C++社区最受尊敬的作者之一。虽然内容比较简短，但质量极高。电子书：2011年版（英文） 初级入门如果你是一个无编程经验的C++初学者，或者有其它语言经验的C++初学者，那强烈推荐下面的书籍。 C++ Primer 作者：Stanley Lippman, Josée Lajoie, and Barbara E. Moo (更新到C++11) 近1千页，本书透彻的介绍了C++，以浅显和详细的方式讲到C++语言差不多所有内容。2012年8月发行的第五版包含C++11的内容。不要和 C++ Primer Plus (Stephen Prata)搞混了。电子书：第三版（中文）、第四版（中文）、第五版（英文版） Accelerated C++ 作者：Andrew Koenig and Barbara Moo 这本书覆盖了和C++ Primer一样的内容，但厚度只有C++ Primer的四分之一。这主要是因为本书面向的不是编程的初学者，而是有其它语言经验的C++初学者。对于初学者，本书学习曲线稍显陡峭，但对于能克服这一点的学习者而言，它确实非常紧凑的介绍了C++这门语言。电子书：中文版，英文版 C++编程思想（Thinking in C++) 作者：Bruce Eckel 共两卷，第二卷主要将标准库，但还是不错的。电子书：第二版V1（英文版）、第二版V2（英文版）、第二版V1（中文版）、第二版V2（中文版）C++程序设计原理与实践 （Programming: Principles and Practice Using C++ ）作者：Bjarne Stroustrup C++之父写的C++入门书籍。本书面向没有编程经验的初学者，但相信有编程经验的人也能从本书中学到不少东西。电子书：中文版最实用 Effective C++ 作者：Scott Meyers 本书以瞄准成为C++程序员必读的第二本书籍而写，Scott Meyers成功了。早期的版本面向从C语言转过来的程序员。第三版修改为面向从类似Jave等语言转来的程序员。内容覆盖了50多个很容易记住的条款，每个条款深入浅出（并且有趣）讲到了你可能没有考虑过的C++规则。电子书：第二版（英文）、第三版（英文）、第三版（中文) Effective STL 作者：Scott Meyers 讲解方式和Effective类似，但内容主要面向于STL。电子书：中文版，英文版中级 More Effective C++ 作者：Scott Meyers 更多（深入）关于C++的规则。没有前一本Effective C++重要。但同样值得一读。电子书：中文版 Exceptional C++ 作者：Herb Sutter 讲解方式为提出并解决一系列的C++难题。本书极其透彻的讲解了C++资源管理、异常安全和RAII。同时覆盖了一些较为深入的技术，比如：编译防火墙（pimpl idiom)、名字查找规则,、好的类设计和C++内存模型。电子书：中文版，英文版 More Exceptional C++ 作者：Herb Sutter 讲到了Exceptional C++没有涉及到的更高级的异常安全技术, 同时讨论了高效的C++ OOP方式和如何正确的使用STL。电子书：中文版，英文版 Exceptional C++ Style 作者：Herb Sutter 讨论了泛型编程、最优化和资源管理。本书出彩之处在于谈到了如何用非成员函数和单职责原则编写模块化的C++代码。电子书：中文版 C++编程规范(C++ Coding Standards) 作者：Herb Sutter and Andrei Alexandrescu “编程规范”这里并不是”代码缩进要用几个空格”。这本书包含了101个例子、惯用法、缺陷，通过这些可以帮助你编写正确、清晰高效的C++代码。电子书：中文版 C++ 模板完全指南(C++ Templates: The Complete Guide)作者：David Vandevoorde and Nicolai M. Josuttis 本书是关于C++11之前的模板的。它覆盖了从非常基础到最高级的元编程知识，解释了模板工作原理的细节(概念和实现方式）。并且讨论了大量的缺陷。附录中包含关于ODR和重载的精彩总结。电子书：中文版、英文版高级 C++设计新思维-泛型编程与设计模式之应用(Modern C++ Design ) 作者：Andrei Alexandrescu 泛型编程鼻祖级书籍。本书先介绍了基于策略（policy-based)的设计、type lists 和泛型编程基础， 然后讲到了许多有用的设计模式(包括small object allocators, functors, factories, visitors, and multimethods) 如何被高效、模块化、清晰的泛型代码实现。电子书：中文版、英文版 C++模板元编程(C++ Template Metaprogramming)作者：David Abrahams and Aleksey Gurtovoy 更多的是讲解boost::mpl，想要深入理解mpl的可以看一下。电子书：中文版 C++ Concurrency In Action 作者：Anthony Williams 这本书主要内容是C++11的并发支持，包括线程库、原子(atomics)库、内存模型、锁和互斥量。同时也讲解了开发和调试多线程程序的一些难题。电子书：英文版 Advanced C++ Metaprogramming 作者：Davide Di Gennaro 前C++11时代TMP技术的手册级书籍。本书更侧重于工程实践。里面有大量的可能几乎无人知道但很实用的技术写成的代码。本书可能比Alexandrescu的书更值得读。对于资深的开发者来说，这是一个学习C++暗角技术的绝佳机会，通常这些技术要通过资深的编程经历才能获取。电子书：没找到 经典 / 古老注意: 下列书中的部分内容可能有些过时 C++的设计与演化(The Design and Evolution of C++ )作者：Bjarne Stroustrup 如果你想知道为什么C++是今天这个样子，那么这本书将给你答案。本书覆盖C++标准化之前的一切东西。电子书：中文版 C++沉思录(Ruminations on C++) 作者：Andrew Koenig and Barbara Moo 本书不是为了讲解具体的C++技术细节，而是如何通过C++编写出色的OO代码。电子书：中文版 Advanced C++ Programming Styles and Idioms 作者：James Coplien 讲解了一些C++特有的惯用法. 它确实是一本不错的书籍，如果时间闲暇也可一读。不过它确实很老了，可能有些不符合现代的C++。电子书：中文版 大规模C++程序设计（Large Scale C++ Software Design） 作者：John Lakos 本书介绍了如何管理大规模C++软件项目的技术。很值得一读，除了有些过时以外。它是在C++98以前写的，缺少了好多对大规模项目重要的特性（比如名字空间）。假如你工作在一个大规模的C++项目中，你可能想要读它, 不过你需要注意那些不适用甚至错误的技术点。电子书：中文版 深度探索C++对象模型 (Inside the C++ Object Model ) 作者：Stanley Lippman 如果你想知道虚函数是如何实现、多继承时基类是如何在内存中排布的和所有影响性能的东西，那么这本书会给你答案。不过这本书有好多低级的拼写排版错误，英文原版错误更多，侯捷翻译的版本中注明和纠正了很多，但本书绝对值得一读，你将明白编译器如何实现C++的对象模型。电子书：中文版、英文版 原文链接：http://bestcbooks.com/recommended-cpp-books/原文有电子书下载链接","categories":[],"tags":[{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"书籍推荐","slug":"书籍推荐","permalink":"https://gwq5210.com/tags/书籍推荐/"}],"keywords":[]},{"title":"protobuf的编码","slug":"protobuf的编码","date":"2016-07-30T19:35:53.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2016/07/30/protobuf的编码/","link":"","permalink":"https://gwq5210.com/2016/07/30/protobuf的编码/","excerpt":"这篇文章介绍protobuf消息的二进制格式。你在你的应用中使用protobuf不必了解这些，但是它可以更好的让你知道protobuf的编码格式是怎样影响你编码后消息的大小的。 一个简单的消息比方说，你有一个非常简单的消息定义：123message Test1 &#123; required int32 a = 1;&#125; 在一个应用中，如果你创建一个Test1的消息，将a设置成150，然后序列化到流中，如果你能看到序列化的消息，会看到三个字节：108 96 01 这是什么意思呢？继续阅读。。。","text":"这篇文章介绍protobuf消息的二进制格式。你在你的应用中使用protobuf不必了解这些，但是它可以更好的让你知道protobuf的编码格式是怎样影响你编码后消息的大小的。 一个简单的消息比方说，你有一个非常简单的消息定义：123message Test1 &#123; required int32 a = 1;&#125; 在一个应用中，如果你创建一个Test1的消息，将a设置成150，然后序列化到流中，如果你能看到序列化的消息，会看到三个字节：108 96 01 这是什么意思呢？继续阅读。。。 Base 128 Varints为了理解这个简单的protobuf编码，你首先需要了解varints，varints是一个使用一个字节或多个字节编码整数的方法。较小的数字使用较少的字节。 在varint中，除了最后一个字节，都会设置最高位（most significant bit，msb），这个最高位指示后边仍然有字节。低7bits用来存储数字补码表示，低的7bits组会优先存储。 因此，这里是数字1的表示，它是单个字节的因此，msb不会被设置：10000 0001 下边是比较复杂的300：11010 1100 0000 0010 怎样才能得出这个是300呢？首先你丢弃每个字节的msb，它仅仅是用来告诉我们数字字节表示的结尾。121010 1100 0000 0010→ 010 1100 000 0010 然后交换这两个7bits的组，因为varint先存储低7bits组，组合之后就能得到最终的数字：1234000 0010 010 1100→ 000 0010 ++ 010 1100→ 100101100→ 256 + 32 + 8 + 4 = 300 消息结构正如你了解到的，protobuf消息是一系列key-value的组合，二进制格式的消息，仅仅使用字段数字作为key，这个key的名称和声明的类型可以在解码时引用消息类型定义得到，如proto文件。 当编码消息时，键和值会组合成字节流。解析的时候，解析器需要能够跳过不能解析的字段。这样的话，新的字段加入的时候，较老的程序就不必修改，它可以不使用这些字段。这样，每个键值对编码成二进制的时候就会有两个值，一个是proto文件中的字段数字，另一个是能够提供值长度的二进制类型。 可用的二进制类型如下表： 类型 意义 用于 0 Varint int32, int64, uint32, uint64, sint32, sint64, bool, enum 1 64-bit fixed64, sfixed64, double 2 Length-delimited string, bytes, embedded messages, packed repeated fields 3 Start group groups (deprecated) 4 End group groups (deprecated) 5 32-bit fixed32, sfixed32, float 在序列化后的消息中，每一个key是类似这样的varint：(field_number &lt;&lt; 3) | wire_type，换句话说，低3位用来存储二进制类型。 现在让我们来看看开始提到的那个例子，现在知道序列化后的消息中，第一个数字永远是varint，这里是08，丢弃msb之后：1000 1000 取出低3位得到二进制类型0，右移3位后得到字段数字1。因此，我们知道了标签为1的值是varint，也就是说接下来的序列是varint，使用varint编码规则我们可以得到接下来的两个字节96 01存储的是150：123496 01 = 1001 0110 0000 0001 → 000 0001 ++ 001 0110 (drop the msb and reverse the groups of 7 bits) → 10010110 → 2 + 4 + 16 + 128 = 150 更多值得类型有符号整数正如前面提到的，和wire类型0关联的值都被编码成varint。然而，对于有符号整数（sint32和sint64）与一般整数（int32和int64）的一个很重要的不同点是它们对负数编码的处理。如果你使用int32或int64表示负数，那么这个varint总是10个字节长——它被当做一个非常大的无符号数。如果你使用任意一个有符号数，那么varint将会使用ZigZag编码，它对负数编码更有效率。 ZigZag编码将有符号整数映射到无符号整数，这样它的绝对值就很小，相应的varint编码长度也比较小。zig-zags在正数和负数之间来回交叉进行编码，-1编码是当做1,1在编码是当做2，-2编码成3，等等： Signed Original Encoded As 0 0 -1 1 1 2 -2 3 2147483647 4294967294 -2147483648 4294967295 换句话说，n在sint32的时候被编码为(n &lt;&lt; 1) ^ (n &gt;&gt; 31)，在sint64的时候被编码为(n &lt;&lt; 1) ^ (n &gt;&gt; 63)。 运算的第二部分，(n&gt;&gt;31)是算术右移，也就是说，如果n是正数，右移补的位为0，否则是1。 当sint32或sint64解析的时候，会解析成原来得数字。 非varint数字这个数字类型很简单——double和fixed64的wire类型是1，这告诉解析器接下来是固定的64bits数据，相应的float和fixed32的wire类型时5，说明拥有32bits数据。这两种情况下的值都以小端字节序存储。 stringswire类型为2意味着值是一个varint编码的长度，接下来是指定字节长度的数据。123message Test2 &#123; required string b = 2;&#125; 将b设置成testing的编码为：112 07 74 65 73 74 69 6e 67 后七个字节是UTF-8编码的testing，key是0x12，wire类型是2，tag是2，0x07表示值的长度是7，然后是7个字节的字符串。 嵌套消息现在定义一个消息，其字段是Test1类型的消息：123message Test3 &#123; required Test1 c = 3;&#125; 我们将a设置成150，下边是编码后的消息：11a 03 08 96 01 正如你看到的，最后三个字节和第一个例子是一样的，它前边有一个值为3的varint标识长度——嵌套消息被当做和字符串一样处理。 可选和可重复元素在proto2中定义的repeated字段（没有[packed=true]选项），编码后的消息是零个或多个拥有相同标签的键值对。这些重复的值不一定连续出现，可能会和其他字段交错出现。解析的时候，各个元素之间的顺序被保留，尽管其他字段的顺序是不确定的。在proto3中，repeated字段使用packed encoding，下边将会介绍。 在proto3中非repeated字段和proto2中的optional字段，编码后的消息中可能有也可能没有包含标签数字的key-value对。 一般的，编码后的消息不会超过一个非repeated的字段，不过，我们期望解析器能够处理这种情况。对于数值类型和字符串类型，如果相同的数字标签出现了多次，那么解析器会保存最后一个出现的值。对于嵌套消息字段，解析器将多个相同数字标签的值合并，就像调用Message::MergeFrom一样——对于普通字段，用后边实例的值代替前边实例的值，对于嵌套消息字段进行合并，重复字段进行连接。这个规则使得解析连续两个编码后的消息一样和分别解析两个消息然后把它们合并的效果是一样的：12MyMessage message;message.ParseFromString(str1 + str2); 等价于：1234MyMessage message, message2;message.ParseFromString(str1);message2.ParseFromString(str2);message.MergeFrom(message2); 这个属性偶尔会用到，它允许在你不知道他们类型的情况下进行合并消息。 打包重复字段2.1.0版本引入了打包重复字段，在proto2中需要在重复字段中添加[packed=true]选项。在proto3中，重复字段默认就是打包的。它的功能和重复字段类似，但采取了不同的编码。当一个打包的重复字段不包含任何元素时，它不会出现在编码后的消息中。否则，这个字段的全部元素被打包成wrie类型为2的单个键值对。除了没有标签数字前缀外，每个元素被编码成它本来的样子。 假设你又个消息123message Test4 &#123; repeated int32 d = 4 [packed=true];&#125; 现在，你定义一个Test4变量，给重复字段d提供值3，170和86942，那么它的编码为：1234522 // tag (field number 4, wire type 2)06 // payload size (6 bytes)03 // first element (varint 3)8E 02 // second element (varint 270)9E A7 05 // third element (varint 86942) 仅仅原始数字类型（varint，32-bit或64-bit）的重复字段才能够声明为packed。 需要注意的是，虽然有通常没有理由为打包重复字段编码多个键值对，但编码器必须要能够接受多个键值对。在这种情况下，有效数据应该串联起来。每个键值对必须包含全部的元素。 编译器必须能够像它们没有packed一样解析packed的重复字段，反之亦然。为这样的字段添加[packed=true]是一种向前向后兼容的方式。 字段顺序虽然你能够在proto文件中以任何顺序使用字段数字，当消息序列化的时候，它应该按照字段数字的顺序写入，就像C++，Java和Python序列化代码那样。这就允许解析代码依赖字段数字的顺序进行优化。然而，protobuf解析器必须能够以任何顺序解析它们，并不是所有的消息是通过简单序列化得到的——举例来说，一个合并两个消息的简单方法是将它们序列化后的消息串联。 如果一个消息中包含未知的字段，母线的Java和C++实现会将它们以任意的顺序写入已知字段的后边。当前的Python实现并不追踪未知字段。 参考1) Google Protocol Buffer Encoding","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}],"tags":[{"name":"protobuf","slug":"protobuf","permalink":"https://gwq5210.com/tags/protobuf/"},{"name":"编码方式","slug":"编码方式","permalink":"https://gwq5210.com/tags/编码方式/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}]},{"title":"google protobuf简介及使用","slug":"google protobuf简介","date":"2016-07-30T14:17:10.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2016/07/30/google protobuf简介/","link":"","permalink":"https://gwq5210.com/2016/07/30/google protobuf简介/","excerpt":"什么是Google ProtoBuf？ProtoBuf是一种灵活高效的结构化数据存储机制，像XML一样，但是其更加轻巧、快速、简单。使用ProtoBuf十分简单，只需要在.proto文件中定义数据就好了，然后你可以利用ProtoBuf提供的工具生成不同语言的序列化和反序列化的代码，目前提供C++、Java、Python、C#、GO等语言版本。 ProtoBuf的优点同XML数据相比，ProboBuf有这许多优点：1：简单2：小3-10倍3：快20-100倍4：更少的二义性5：生成的数据访问类更加容易编程","text":"什么是Google ProtoBuf？ProtoBuf是一种灵活高效的结构化数据存储机制，像XML一样，但是其更加轻巧、快速、简单。使用ProtoBuf十分简单，只需要在.proto文件中定义数据就好了，然后你可以利用ProtoBuf提供的工具生成不同语言的序列化和反序列化的代码，目前提供C++、Java、Python、C#、GO等语言版本。 ProtoBuf的优点同XML数据相比，ProboBuf有这许多优点：1：简单2：小3-10倍3：快20-100倍4：更少的二义性5：生成的数据访问类更加容易编程 举个例子，为了描述一个人的name和email，在XML中你需要这样做：1234&lt;person&gt; &lt;name&gt;John Doe&lt;/name&gt; &lt;email&gt;jdoe@example.com&lt;/email&gt;&lt;/person&gt; 相应的在ProtoBuf中，类似这样（文本格式，编码后的二进制格式不是这样）：123456# Textual representation of a protocol buffer.# This is *not* the binary format used on the wire.person &#123; name: \"John Doe\" email: \"jdoe@example.com\"&#125; 编码为二进制后，其仅仅占用28个字节，解析也只需要100-200纳秒；但是XML版本就需要至少69个字节来表示（去掉空格以后），解析需要的时间为5000-10000纳秒。 同样在访问上，ProtoBuf也更加简便：12345678910cout &lt;&lt; \"Name: \" &lt;&lt; person.name() &lt;&lt; endl;cout &lt;&lt; \"E-mail: \" &lt;&lt; person.email() &lt;&lt; endl;//Whereas with XML you would have to do something like:cout &lt;&lt; \"Name: \" &lt;&lt; person.getElementsByTagName(\"name\")-&gt;item(0)-&gt;innerText() &lt;&lt; endl;cout &lt;&lt; \"E-mail: \" &lt;&lt; person.getElementsByTagName(\"email\")-&gt;item(0)-&gt;innerText() &lt;&lt; endl; 定义一个简单的MessageProtoBuf文件以proto为后缀，如定义一个person类型的消息person.proto，如下：12345678// person.proromessage person &#123; required string name = 1; required string email = 2; required int32 age = 3; optional string address = 4; optional string phone = 5;&#125; 上述文件可以使用以下命令生成C++的源代码：12// 需要安装protocprotoc person.proto -cpp_out=. 我们注意到，消息中的每一个字段由四个部分构成，如name字段，其结构为：12// 规则 类型 名字 = 唯一标签required string name = 1; 字段的类型在上边的例子中，我们使用了两种类型：string和int32，除此之外你还可以声明其他的一些基本类型，如bool等，同时还可以是一些自定义的类型，如枚举和一个pb消息。 分配标签每一个字段后，都分配了一个独一无二的数字标号，这个标号是用来在二进制格式中区分某一个字段用的。因此，一个标号只能使用一次，也就是说即使你将旧的字段删除，也不能再重用为之分配的标签了，需要重新指定一个没使用过得标签号。 标签号的值在1-15之前的，编码后仅仅使用一个字节（包括标识号和字段类型）。标签号范围在16-2047占用2个字节，因此你应该将1-15分配给频率使用很高的字段，可以给使用频繁的字段预留1-15的标签号。 标签号最小为1，最大为2^29-1（536870911），数字19000到19999 (FieldDescriptor::kFirstReservedNumber到FieldDescriptor::kLastReservedNumber)是预留给ProtoBuf实现的，因此你也不能使用这些标签号。 字段的规则ProtoBuf消息中的字段有如下三种规则：1、required：这个字段是必须的。2、optional：这个字段是可选的，在消息中有或者没有均可。3、repeated：这个字段是可以重复任意次（包括0），可以理解为数组。 出于历史原因，repeated字段对于数字类型来说，不一定以最高效的方式编码，可以使用[packed=true]选项来获得更高的效率。1repeated int32 samples = 4 [packed=true]; 对于required字段，一定要谨慎的使用，required如果更改为optional字段，新生成的消息在老版本的程序中就会拒绝解析，认为这是一个不完整的消息；但是对于optional和repeated字段就没有这个问题。 添加更多的消息可以再一个proto文件中定义多个message。当你需要定义多个有关联的消息时，这就十分有用。例如你想定义一个请求和回复的消息，在一个proto文件中定义就十分方便。123456789message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3;&#125;message SearchResponse &#123; ...&#125; 使用注释在proto文件中你可以使用C/C++风格的注释：//12345message SearchRequest &#123; required string query = 1; optional int32 page_number = 2;// Which page number do we want? optional int32 result_per_page = 3;// Number of results to return per page.&#125; 保留字段在你更新你的消息时，你可能删除掉一些字段，当其他人更新时，可能会重新使用之前用到的标签号，这个使用你可以使用reversed关键字，当其他人使用到reversed中的标号时，ProtoBuf会给出警告。你不能将名字和标号在一个reserved语句中混用。1234message Foo &#123; reserved 2, 15, 9 to 11; reserved \"foo\", \"bar\";&#125; ProtoBuf从proto文件中生成了什么？ProtoBuf编译器会将proto文件编译成你选择语言的相应代码，这些代码中包括了获取和设置字段的方法，序列化到输出流和从输入流解析的方法。对于C++，编译器对每一个proto文件生成相应的h和cc文件，其中包括了每个消息对应的类。对于Java，编译器为每一个消息生成一个对应的java文件。对于生成代码的API的详细介绍，可以在API reference找到。 基本数据类型一个只使用基本类型的消息，可以选择的类型在如下的表格中，包括proto中可以选择的类型和生成类的相应类型： .proto类型 备注 C++类型 Java类型 Python类型 double double double float float float float float int32 使用变长编码，编码负数效率不高，如果字段大部分是负数，应该使用sint32代替 int32 int int int64 使用变长编码，编码负数效率不高，如果字段大部分是负数，应该使用sint64代替 int64 long int/long uint32 使用变长编码 uint32 int int/long uint64 使用变长编码 uint64 long int/long sint32 使用变长编码，编码负数效率比int32高 int32 int int sint64 使用变长编码，编码负数效率比int64高 int64 long int/long fixed32 总是4个字节，当值大于2^28时比uint32效率高 uint32 int int fixed64 总是8个字节，当值大于2^28时比uint32效率高 uint64 long int/long sfixed32 总是4个字节 int32 int int sfixed64 总是8个字节 int64 long int/long bool bool boolean bool string 必须由UTF-8编码的或者7-bit的ASCII组成的文本 string String str/unicode bytes 可以包括任意序列的字节 string ByteString str 可选字段和默认值一个消息中的字段可以定义为optional，即可选的，一个合法的消息可以包括也可以不包括这个可选的字段。当解析消息时，如果不包括可选字段，那么可选字段就会被设置为默认值，这个默认值可以指定。例如：1optional int32 result_per_page = 3 [default = 10]; 如果没有显示指定默认值，ProtoBuf会为每个类型指定默认值：string类型指定为空串，bool指定为false，对于数值类型，指定为0，对于枚举类型，默认为列表中的第一个值。因此如果修改枚举定义，就需要注意兼容性问题了。 枚举protobuf同样提供了枚举类型，这种类型只能使用预定义列表中的值。例如你想为SearchResult添加corpus字段，它可以是：UNIVERSAL, WEB, IMAGES, LOCAL, NEWS, PRODUCTS or VIDEO。这利用枚举就可以很方便的实现。下边是一个例子：123456789101112131415message SearchRequest &#123; required string query = 1; optional int32 page_number = 2; optional int32 result_per_page = 3 [default = 10]; enum Corpus &#123; UNIVERSAL = 0; WEB = 1; IMAGES = 2; LOCAL = 3; NEWS = 4; PRODUCTS = 5; VIDEO = 6; &#125; optional Corpus corpus = 4 [default = UNIVERSAL];&#125; 枚举类型中，可以把两个不同的标识赋为相同的值，进而实现别名的功能。为了能够支持这个特性，你需要设置allow_alias为true，否则，将会编译错误。1234567891011enum EnumAllowingAlias &#123; option allow_alias = true; UNKNOWN = 0; STARTED = 1; RUNNING = 1;&#125;enum EnumNotAllowingAlias &#123; UNKNOWN = 0; STARTED = 1; // RUNNING = 1; // Uncommenting this line will cause a compile error inside Google and a warning message outside.&#125; 枚举常量必须是32-bit的整数。枚举使用varint encoding编码，负数效率不高，因此不推荐使用负数。你可以将枚举定义在一个消息内或者整个proto文件中，此外，还可以通过MessageType.EnumType语法在一个消息中使用另一个消息中定义的枚举类型。 当protobuf编译器生成enum类型时，生成的代码将会包含一个相应的枚举类型（Java和C++）或一个包含符号常量的特定的EnumDescriptor类（python）。可以参考generated code guide获取更多信息。 使用其他类型消息你可以将一个消息中的字段设置为其他消息类型。例如，你想在SearchResponse中包含一个Result类型：123456789message SearchResponse &#123; repeated Result result = 1;&#125;message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3;&#125; 导入定义上边的例子中，Result和SearchResponse定一在一个proto文件中，同样，也可以使用其他proto文件中定义的类型。这就需要在你的proto文件的开头加入类似的语句：1import \"myproject/other_protos.proto\"; 一般来说，你直接使用import就可以满足要求了。但有时，你可能想将一个proto文件移动到新的位置。你可以不直接移动proto文件，在老的位置放一个dummy .proto文件使用import public来将所有的imports跳转到新的位置。import public的依赖可以通过导入任何包含了import public语句的proto文件来传递。1234// new.proto// All definitions are moved here// old.proto// This is the proto that all clients are importing. 12import public \"new.proto\";import \"other.proto\"; 123// client.protoimport \"old.proto\";// You use definitions from old.proto and new.proto, but not other.proto protobuf编译器通过命令行参数-I或–proto_path来指定导入文件的搜索目录，如果没有指定，则使用编译器被调用的目录，一般来说，应该在命令行指定这个参数，确保全部合法的名字是可以被真长导入的。 使用proto3消息类型可以在proto2中导入proto3的消息类型，反之亦然。但是，proto2的枚举不能在proto3语法中使用。 嵌套类型你可以将一个消息定义在另一个消息内。例如：12345678message SearchResponse &#123; message Result &#123; required string url = 1; optional string title = 2; repeated string snippets = 3; &#125; repeated Result result = 1;&#125; 可以在其他消息中用Parent.Type使用嵌套的消息类型：123message SomeOtherMessage &#123; optional SearchResponse.Result result = 1;&#125; 同样的，可以支持多层嵌套：1234567891011121314message Outer &#123; // Level 0 message MiddleAA &#123; // Level 1 message Inner &#123; // Level 2 required int64 ival = 1; optional bool booly = 2; &#125; &#125; message MiddleBB &#123; // Level 1 message Inner &#123; // Level 2 required int32 ival = 1; optional bool booly = 2; &#125; &#125;&#125; 组这个特性已经被弃用，不应该使用其来创建新的类型，可以用嵌套消息类型代替。 更新一个消息类型如果一个已存在的消息类型已经不能满足你的需要——例如，你希望消息包含一些额外的字段，但是你仍然希望使用旧消息格式的代码，不必担心！！！protobuf不需要修改已有代码就可以非常简单的来更新一个消息类型。有如下规则： 不要改变任何已存在字段的数字标签 任何新加的字段都应该是optional或repeated。这意味着任何使用旧代码序列化后的消息可以使用新的代码解析，它不会缺失任何required字段。你应该为这些字段设置默认值，以便新的代码能够和老的代码进行交互。相应的，新的代码创建的消息也能够被老的代码解析：老的二进制简单的在解析的过程中忽略新的字段。但是，解析的过程中新的字段并不会被丢弃，如果重新被序列化，新的字段仍然会被序列化，因此，如果消息重新发送给新的程序，新的字段仍然能够被正确解析。 非必须字段能够被移除——它的数字标签不能在你的新消息类型中重新使用。为了防止出现类似的情况，你可以重新命名这个字段，如添加前缀”OBSOLETE_”或者将这个数字标签保留。 非必须字段可以转换成扩展，反之亦然——要保证类型和数字标签一样。 int32, uint32, int64, uint64和bool是兼容的——这意味着你能够将一个字段从其中一种类型转换到另一种类型，而不会破坏向前或向后兼容。如果一个数字从一个不一致的类型解析出来，将会出现类似C++中的问题（例如，一个64-bit数字按照32-bit数字读，其会截断成32-bit的数字）。 sint32和sint64是兼容的，但是与其他整数类型不兼容。 string和bytes（只要bytes是有效的UTF-8）是兼容的。 嵌入消息和bytes（如果bytes包含一个消息版本的编码）是兼容的。 fixed32和sfixed32是兼容的，fixed64和sfixed64是兼容的。 optional和repeated是兼容的。Given serialized data of a repeated field as input, clients that expect this field to be optional will take the last input value if it’s a primitive type field or merge all input elements if it’s a message type field. 更改默认值一般是可以的，但要记住，默认值不会通过网络发送，因此，如果程序收到一个特定字段没有设置的消息，这个程序会从程序的协议版本中读取默认值。它不会看到发送者代码中的默认值。 enum is compatible with int32, uint32, int64, and uint64 in terms of wire format (note that values will be truncated if they don’t fit), but be aware that client code may treat them differently when the message is deserialized. Notably, unrecognized enum values are discarded when the message is deserialized, which makes the field’s has.. accessor return false and its getter return the first value listed in the enum definition, or the default value if one is specified. In the case of repeated enum fields, any unrecognized values are stripped out of the list. However, an integer field will always preserve its value. Because of this, you need to be very careful when upgrading an integer to an enum in terms of receiving out of bounds enum values on the wire. In the current Java and C++ implementations, when unrecognized enum values are stripped out, they are stored along with other unknown fields. Note that this can result in strange behavior if this data is serialized and then reparsed by a client that recognizes these values. In the case of optional fields, even if a new value was written after the original message was deserialized, the old value will be still read by clients that recognize it. In the case of repeated fields, the old values will appear after any recognized and newly-added values, which means that order will not be preserved. 扩展扩展让你能够在消息中声明一个第三方可用的数字标签范围。其他人可以使用这些数字标签在新的proto文件中为你的消息定义新的字段而不需要修改原始文件，如：1234message Foo &#123; // ... extensions 100 to 199;&#125; 这是说在Foo中数字标签[100-199]是预留给扩展的。其他人现在导入你的proto文件后就能在他们自己的proto文件中使用特定的数字标签范围为Foo添加字段，如：123extend Foo &#123; optional int32 bar = 126;&#125; 现在Foo有了一个名称为bar的optional字段。当Foo编码之后，其二进制表示与用户直接在Foo中定义一个新的字段编码之后的表示是一样的。然而，其访问扩展字段和访问普通字段的方式是不一样的。在C++中：12Foo foo;foo.SetExtension(bar, 15); Foo类定义了一个模板化的访问器HasExtension(), ClearExtension(), GetExtension(), MutableExtension()和AddExtension()，All have semantics matching the corresponding generated accessors for a normal field. For more information about working with extensions, see the generated code reference for your chosen language. 扩展可以是除了oneof或map的任何类型任何类型。 嵌套扩展你可以在其他消息中定义扩展：123456message Baz &#123; extend Foo &#123; optional int32 bar = 126; &#125; ...&#125; 相应的：12Foo foo;foo.SetExtension(Baz::bar, 15); 换句话说，bar定义在Baz的作用域中了。 This is a common source of confusion: Declaring an extend block nested inside a message type does not imply any relationship between the outer type and the extended type. In particular, the above example does not mean that Baz is any sort of subclass of Foo. All it means is that the symbol bar is declared inside the scope of Baz; it’s simply a static member. A common pattern is to define extensions inside the scope of the extension’s field type – for example, here’s an extension to Foo of type Baz, where the extension is defined as part of Baz:123456message Baz &#123; extend Foo &#123; optional Baz foo_ext = 127; &#125; ...&#125; 但是，在其他类型定义中定义扩展是不必要的：12345678message Baz &#123; ...&#125;// This can even be in a different file.extend Foo &#123; optional Baz foo_baz_ext = 127;&#125; 实际上，这种语法可以避免混乱。如果不熟悉扩展，用户很可能会将扩展误会成子类。 选择扩展数字确保两个用户不会使用同一个数字标签为消息添加不同的扩展是很重要的，将扩展意外的解析成错误的类型能够造成数据损坏。你可以在定义消息的时候指定扩展数字标签的范围。如果你想使用很大的数字，可以使用关键字max代替：123message Foo &#123; extensions 1000 to max;&#125; max最大是2^29-1或536870911。 除此之外，你还要避免使用保留数字标签从19000到19999 (FieldDescriptor::kFirstReservedNumber到FieldDescriptor::kLastReservedNumber)，你能够在指定扩展数字范围时指定这些数字，但是编译器会阻止你真正使用这些保留的数字。 Oneof如果你的消息有很多可选的字段，但是同一时间只能表现为一个消息，那么你可以使用oneof特性来实现。 oneof像所有的可选字段使用共享的内存区域，同时只能有一个可选字段被设置。设置任一oneof的消息，会自动的清除其他消息，你可以使用case()或WhichOneof()检查那个消息被设置了。 使用Oneof使用oneof非常简单：123456message SampleMessage &#123; oneof test_oneof &#123; string name = 4; SubMessage sub_message = 9; &#125;&#125; 你可以在oneof定义中添加任何类型的字段而不能使用required、optional或repeated关键字。 在生成的代码中，oneof字段拥有和optional字段一样的getter和setter方法。另外还有检查哪一个字段被设置的api，可以参考这里。 Oneof特性 设置一个oneof字段，会自动将其他字段清空。因此，如果你设置了许多字段，只有最后一个设置的字段是有效的 12345SampleMessage message;message.set_name(\"name\");CHECK(message.has_name());message.mutable_sub_message(); // Will clear name field.CHECK(!message.has_name()); 如果解析器遇到了多个oneof成员，只有最后一个遇到的成员在解析的消息中有效 扩展不支持oneof oneof不能是repeated的 反射API能够在oneof字段上使用 如果你使用C++，确保你的代码不会崩溃。下面简单的代码因为使用了被set_name已经清除的sub_message，会导致崩溃 1234SampleMessage message;SubMessage* sub_message = message.mutable_sub_message();message.set_name(\"name\"); // Will delete sub_messagesub_message-&gt;set_... // Crashes here 在C++中，如果你让oneof消息使用Swap函数，这两个消息会拥有对方的值，如下，msg1会有sub_message的值，msg2会有name的值 1234567SampleMessage msg1;msg1.set_name(\"name\");SampleMessage msg2;msg2.mutable_sub_message();msg1.swap(&amp;msg2);CHECK(msg1.has_sub_message());CHECK(msg2.has_name()); 向后兼容问题在消息中添加或删除oneof字段时，要特别小心。如果检查到字段的结果是None或NOT_SET，可能意味着消息还没有被设置或者在不同版本的oneof消息中被设置了。没法知道一个不知道的字段是不是oneof消息的成员，这种情况就没有办法区分。 标签重用问题 将可选字段移动到或者移出oneof：序列化或反序列化消息的时候可能会丢失一些信息（一些字段会被清空）。 删除一个oneof字段并且将它加回来：序列化或反序列化消息的时候可能会清空你当前设置的字段。 分割或合并oneof消息：这和移动optional字段类似。 Maps如果你想在你数据定义中使用map，protobuf提供了一个简单的语法：1map&lt;key_type, value_type&gt; map_field = N; key_type可以是整数或者string类型（因此除了浮点数的原生类型都可以），value_type可以是任何类型。 例如，你想创建一个和字符串关联的Project变量projects，可以使用如下的语法：1map&lt;string, Project&gt; projects = 3; 更多的api可以参考这里。 Map特性 扩展不支持map map不能是repeated、optional或required 二进制格式的顺序或map迭代的顺序是未定义的，因此你不能依赖map的items以特定的顺序进行遍历 当proto转换成text格式的时候，map会按照key排序，key是数字的时候按照数字大小排序 当从二进制解析或合并的时候，如果map的key重复了，只有最后一个value会被用到。当从text格式解析的时候，遇到重复的键值，会解析失败 向后兼容问题map在二进制格式下与下边的语法一样，因此protobuf实现虽然不支持map，但仍然能后处理你的数据：123456message MapFieldEntry &#123; key_type key = 1; value_type value = 2;&#125;repeated MapFieldEntry map_field = N; 包你可以在proto文件中加入可选的package指定包名称，这样可以避免消息的名称出现冲突。12package foo.bar;message Open &#123; ... &#125; 为消息添加包名之后需要添加包名来取到特定的消息：12345message Foo &#123; ... required foo.bar.Open open = 1; ...&#125; 在不同的语言中使用不同的语法来拿到包中的消息： 在C++中，包使用名称空间实现，例如Open在名称空间foo::bar中 在Java中，可以像Java中的包一样使用，除非你在proto文件中额外指定了option java_package选项 在Python中，包直接被忽略了，因为Python使用源代码在文件系统中的位置来组织模块 包和名称解析在protobuf中的类型名称解析和C++中类似，首先在最内层的作用域搜寻，然后是次内层，等等。每一个包是它父包的内一层。一个前导的点表示从最外边的作用域开始搜寻，如.foo.bar.Baz。 protobuf编译器通过导入proto文件来解析所有的类型名。即使生成代码的语言有着不同的作用域规则，它也能引用到每一种类型。 定义服务如果你想在RPC（Remote Procedure Call）系统中使用你的消息，你可以在proto文件中定义一个RPC服务的接口，protobuf编译器会自动生成这些服务接口的代码。例如，你想定义一个接收SearchRequest和返回SearchResponse方法的RPC服务，你可以在proto文件中类似这样定义：123service SearchService &#123; rpc Search (SearchRequest) returns (SearchResponse);&#125; 默认的，protobuf编译器会生成一个名为SearchService的抽象接口，并且有一个相应的“桩”实现。这个实现将所有的请求转发给一个必须实现抽象接口的RpcChannel。例如，你想实现一个将序列化消息通过HTTP发送给服务器的RpcChannel。换句话说，生成的代码提供了一个使用基于protobuf类型安全的RPC调用，而你不需要关注特定的RPC实现，因此，在C++中，你可以像这样写代码：1234567891011121314151617181920212223242526272829303132using google::protobuf;protobuf::RpcChannel* channel;protobuf::RpcController* controller;SearchService* service;SearchRequest request;SearchResponse response;void DoSearch()&#123; // You provide classes MyRpcChannel and MyRpcController, which implement // the abstract interfaces protobuf::RpcChannel and protobuf::RpcController. channel = new MyRpcChannel(\"somehost.example.com:1234\"); controller = new MyRpcController; // The protocol compiler generates the SearchService class based on the // definition given above. service = new SearchService::Stub(channel); // Set up the request. request.set_query(\"protocol buffers\"); // Execute the RPC. service-&gt;Search(controller, request, response, protobuf::NewCallback(&amp;Done));&#125;void Done()&#123; delete service; delete channel; delete controller;&#125; 所有的服务类会实现一个服务的接口，它提供了一个不需要在编译时知道方法名或它的输入类型和输出类型而调用特定接口的方式。在服务端，这可以用来实现一个可以注册服务的RPC服务器。123456789101112131415161718192021222324252627282930using google::protobuf;class ExampleSearchService : public SearchService&#123;public: void Search(protobuf::RpcController* controller, const SearchRequest* request, SearchResponse* response, protobuf::Closure* done) &#123; if (request-&gt;query() == \"google\") &#123; response-&gt;add_result()-&gt;set_url(\"http://www.google.com\"); &#125; else if (request-&gt;query() == \"protocol buffers\") &#123; response-&gt;add_result()-&gt;set_url(\"http://protobuf.googlecode.com\"); &#125; done-&gt;Run(); &#125;&#125;;int main(int argc, char argv[])&#123; // You provide class MyRpcServer. It does not have to implement any // particular interface; this is just an example. MyRpcServer server; protobuf::Service* service = new ExampleSearchService; server.ExportOnPort(1234, service); server.Run(); delete service; return 0;&#125; 除此之外，你可以使用 gRPC：一个谷歌开发的语言和平台无关的开源RPC系统。gRPC可以很好的和protobuf一起工作，通过一个特殊的protobuf编译器插件从proto文件生成相应的RPC代码。然而，因为客户端和服务器使用的proto2和proto3生成代码之间潜在的兼容性问题，推荐你使用proto3来定义RPC服务。你可以在Proto3 Language Guide这里找到更多关于proto3的语法。如果你想在gRPC中使用proto2，你需要使用version 3.0.0或更高版本的protobuf编译器和库。 除了gRPC，有许多不断基于protobuf的正在开发中的第三方RPC项目。你可以在这里找到这些列表：third-party add-ons wiki page。 选项在一个单独的proto文件中可以声明一些选项。选项不会改变一些整体声明的含义，但是可能会影响一些它在特定上下文的处理。全部的选项在google/protobuf/descriptor.proto中。 一些选项是文件级的选项，意味着你应该将这些选项写在top-level的作用域，而不是在任何消息，枚举或服务的定义中。一些选项是消息级别的定义，意味着应该写在消息定义里。一些选项是字段级别的选项，意味着它们应该写在字段定义中。选项也可以应用在枚举类型，枚举值，服务类型和服务方法，然而这些选项对它们没有用。 这里是很多常用的选项： java_package（文件选项）：你想在生成的java类中使用的包名。如果没有在proto文件中指定java_package选项，那么将会使用默认的proto包（在proto文件中使用package关键字指定）。然而，proto的包通常不用来代替Java包，因为proto的包不期望是一个反向域名。如果不生成Java代码，这个选项不起作用。 1option java_package = \"com.example.foo\"; java_outer_classname（文件选项）：这个类名是你生成的Java外部类的名字（也是文件名字）。如果不指定java_outer_classname，类名由proto文件的名字驼峰方式组成（如foo_bar.proto 的名字FooBar.java）。如果不生成Java代码，这个选项不起作用。 1option java_outer_classname = \"Ponycopter\"; optimize_for (文件选项): 可以设置为SPEED，CODE_SIZE或者LITE_RUNTIME。这个对C++和Java代码生成器（或其他第三方代码生成器）的起作用的方式如下： SPEED（默认）：protobuf编译器为序列化，解析和在消息类型上执行其他通用的操作而生成代码。这个代码性能是很高的。 CODE_SIZE：在这个选项下protobuf编译器会生成较小的类，它们会依赖共享的，基于反射的代码来实现序列化、解析和变量的其他操作。生成的代码比SPEED小，但是操作的速度会变慢。类仍然会实现和SPEED模式下一样的公共API。这个模式比较适合那些包含了很多数量的proto文件，而又对它们的性能没有很高要求的场景。 LITE_RUNTIME：protobuf编译器会生成在运行时依赖”lite”库（用libprotobuf-lite替代libprotobuf）的类。lite运行时库比全量的库小很多（大概小一个数量级），但是它去除了一些类似描述器和反射的特性。这对运行在特定平台如移动电话上的应用格外有用。编译器会生成与SPEED模式速度一样的方法。生成的类在每种语言中仅仅会实现MessageLite接口中的方法，它提供了Message全部方法的子集。1option optimize_for = CODE_SIZE; cc_generic_services, java_generic_services, py_generic_services (文件选项): 它们分别决定编译器在生成C++、Java和Python代码时是否基于服务定义生成抽象服务代码。因为历史原因，它们默认是true。然而，2.3.0版本（2010年1月）认为更好实现RPC系统的方法是提供代码生成插件去为每一个系统去生成代码，而不是依赖抽象服务。 1234// This file relies on plugins to generate service code.option cc_generic_services = false;option java_generic_services = false;option py_generic_services = false; cc_enable_arenas (文件选项)：Enables arena allocation for C++ generated code message_set_wire_format (消息选项)：如果设置成true，这个消息使用一个不同的意图兼容以前在Google内部使用被叫做MessageSet的二进制格式。在Google之外的使用者或许永远也不会用到这个选项。消息必须被定义为如下形式： 1234message Foo &#123; option message_set_wire_format = true; extensions 4 to max;&#125; packed(字段选项)：如果设置为true，在基本数字类型的repeated字段上会使用更加紧凑的编码。使用这个选项没有缺点。2.3.0之前的版本遇到packed数据会忽略它，因此，改变一个存在的字段不可能不打破wire的兼容性。在2.3.0之后的版本，这个改变是安全的，因为解析器总是能接受这两种格式，但是要在使用老版本protobuf的程序中小心的处理这个字段。 1repeated int32 samples = 4 [packed=true]; deprecated (字段选项)：如果设置为true，表示这个字段是废弃的，不应该在新的代码中使用这个字段。在多数语言中这个选项没有实际的用处，在Java中，这会变成一个@Deprecated的注解。在未来，其他特定语言的生成器也许会生成在字段访问器上添加废弃符号，在真正编译代码的时候如果尝试使用这个字段，则发出一个警告。如果这个字段没有被任何人使用，而且希望新用户不会使用这个字段，可以考虑将其放置在保留语句中。 1optional int32 old_field = 6 [deprecated=true]; 自定义选项Protobuf甚至可以允许你定义和使用你自己的选项。注意到这个高级特性大多数人并不需要用到。选项例如FileOptions或FieldOptions在google/protobuf/descriptor.proto文件中定义，因此，定义自己的选项可以简单的扩展这些消息。例如：123456789import \"google/protobuf/descriptor.proto\";extend google.protobuf.MessageOptions &#123; optional string my_option = 51234;&#125;message MyMessage &#123; option (my_option) = \"Hello world!\";&#125; 这里我们通过扩展MessageOptions定义了一个消息选项。当我们使用这个选项时，这个选项的名字必须使用括号括起来，表示这是一个扩展的选项。我们可以在C++中类似这样来读取my_option的值：1string value = MyMessage::descriptor()-&gt;options().GetExtension(my_option); MyMessage::descriptor()-&gt;options()返回MyMessage类型的MessageOptions，读取自定义选项，就像读取其他扩展字段。相应的，在Java中可以写成这样：12String value = MyProtoFile.MyMessage.getDescriptor().getOptions() .getExtension(MyProtoFile.myOption); 在Python类似：12value = my_proto_file_pb2.MyMessage.DESCRIPTOR.GetOptions() .Extensions[my_proto_file_pb2.my_option] 自定义选项可以用在使用protobuf构造的任何结构中，下边是例子：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import \"google/protobuf/descriptor.proto\";extend google.protobuf.FileOptions &#123; optional string my_file_option = 50000;&#125;extend google.protobuf.MessageOptions &#123; optional int32 my_message_option = 50001;&#125;extend google.protobuf.FieldOptions &#123; optional float my_field_option = 50002;&#125;extend google.protobuf.EnumOptions &#123; optional bool my_enum_option = 50003;&#125;extend google.protobuf.EnumValueOptions &#123; optional uint32 my_enum_value_option = 50004;&#125;extend google.protobuf.ServiceOptions &#123; optional MyEnum my_service_option = 50005;&#125;extend google.protobuf.MethodOptions &#123; optional MyMessage my_method_option = 50006;&#125;option (my_file_option) = \"Hello world!\";message MyMessage &#123; option (my_message_option) = 1234; optional int32 foo = 1 [(my_field_option) = 4.5]; optional string bar = 2;&#125;enum MyEnum &#123; option (my_enum_option) = true; FOO = 1 [(my_enum_value_option) = 321]; BAR = 2;&#125;message RequestType &#123;&#125;message ResponseType &#123;&#125;service MyService &#123; option (my_service_option) = FOO; rpc MyMethod(RequestType) returns(ResponseType) &#123; // Note: my_method_option has type MyMessage. We can set each field // within it using a separate \"option\" line. option (my_method_option).foo = 567; option (my_method_option).bar = \"Some string\"; &#125;&#125; 注意如果你希望使用在一个package中定义的选项，你必须在选项名字前加上package名，就像使用类型那样：12345678910111213// foo.protoimport \"google/protobuf/descriptor.proto\";package foo;extend google.protobuf.MessageOptions &#123; optional string my_option = 51234;&#125;// bar.protoimport \"foo.proto\";package bar;message MyMessage &#123; option (foo.my_option) = \"Hello world!\";&#125; 最后一点：因为自定义选项是扩展，他们必须像其他字段或扩展那样指定标签号。在上边的例子中，我们使用了范围为50000-99999的字段号，这个范围时预留给独立组织内部使用的，因此你可以自由的在你自己的应用中使用。如果你想使用自定义选项在公共的应用中，你必须确保你的字段数字是全局唯一的。你可以向protobuf-global-extension-registry@google.com发送申请来获取一个全局唯一的字段数字，只需要提供你的项目名称和网站（如果可用的话）。通常，你只需要一个扩展数字，你可以声明多个选项在一个扩展消息中。123456789101112131415message FooOptions &#123; optional int32 opt1 = 1; optional string opt2 = 2;&#125;extend google.protobuf.FieldOptions &#123; optional FooOptions foo_options = 1234;&#125;// usage:message Bar &#123; optional int32 a = 1 [(foo_options).opt1 = 123, (foo_options).opt2 = \"baz\"]; // alternative aggregate syntax (uses TextFormat): optional int32 b = 2 [(foo_options) = &#123; opt1: 123 opt2: \"baz\" &#125;];&#125; 因为不同的选项级别有着不同的字段数字空间，因此，你可以在不同的选项级别中使用相同的扩展数字。 生成你的消息类为了生成与你定义的proto文件相应的Java，Python或C++代码，你需要运行protobuf编译器来作用在你的proto文件上。如果你还没有protobuf编译器，下载安装包，然后阅读README。可以像这样调用protobuf编译器：1protoc --proto_path=IMPORT_PATH --cpp_out=DST_DIR --java_out=DST_DIR --python_out=DST_DIR path/to/file.proto IMPORT_PATH：指定了当使用import指令时寻找proto文件的路径。如果省略，就会搜寻当前路径。可以通过指定多次–proto_path来指定多个搜寻路径，他们会按照顺序搜寻。-I=IMPORT_PATH是–proto_path的简写。 你可以提供一个活多个输出目录： –cpp_out：生成C++代码的目录。了解更多可以参考这里。 –java_out：生成Java代码的目录。了解更多可以参考这里。 –python_out：生成Python代码的目录。了解更多可以参考这里。 作为便利，如果这个目录是以.zip或.jar结尾的，编译器将会把文件输出到给定名字的zip文件中，对于.jar还会加入Java JAR需要的manifest文件。如果文件已经存在，将会覆盖写入。 你必须提供一个或多个proto文件作为输入。多个proto文件可以在一次提供，尽管名字是以当前目录的相对路径确定的，但是仍然需要的IMPORT_PATHs中包含，以确定它的位置。 参考1) Google Protocol Buffer 的在线帮助2) Google Protocol Buffer 的使用和原理 - IBM","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}],"tags":[{"name":"c++","slug":"c","permalink":"https://gwq5210.com/tags/c/"},{"name":"protobuf","slug":"protobuf","permalink":"https://gwq5210.com/tags/protobuf/"},{"name":"python","slug":"python","permalink":"https://gwq5210.com/tags/python/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}]},{"title":"c语言中使用数据库","slug":"c语言中使用数据库","date":"2016-01-23T20:21:40.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2016/01/23/c语言中使用数据库/","link":"","permalink":"https://gwq5210.com/2016/01/23/c语言中使用数据库/","excerpt":"安装首先，要安装mysql数据库，安装好后，可能还不能使用mysql的c语言库，还要安装mysql的库，命令如下：sudo apt-get install libmysql++-dev。安装好后，就可以包含&lt;mysql/mysql.h&gt;头文件，然后使用mysql的c语言api了。 数据结构1）MYSQL这个结构体代表一个数据库连接的句柄，它被大多数的mysql函数使用。不要尝试拷贝MYSQL结构体，不保证这样的拷贝是可以使用的。MYSQL的定义如下：","text":"安装首先，要安装mysql数据库，安装好后，可能还不能使用mysql的c语言库，还要安装mysql的库，命令如下：sudo apt-get install libmysql++-dev。安装好后，就可以包含&lt;mysql/mysql.h&gt;头文件，然后使用mysql的c语言api了。 数据结构1）MYSQL这个结构体代表一个数据库连接的句柄，它被大多数的mysql函数使用。不要尝试拷贝MYSQL结构体，不保证这样的拷贝是可以使用的。MYSQL的定义如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243typedef struct st_mysql&#123; NET net; /* Communication parameters */ unsigned char *connector_fd; /* ConnectorFd for SSL */ char *host,*user,*passwd,*unix_socket,*server_version,*host_info; char *info, *db; struct charset_info_st *charset; MYSQL_FIELD *fields; MEM_ROOT field_alloc; my_ulonglong affected_rows; my_ulonglong insert_id; /* id if insert on table with NEXTNR */ my_ulonglong extra_info; /* Not used */ unsigned long thread_id; /* Id for connection in server */ unsigned long packet_length; unsigned int port; unsigned long client_flag,server_capabilities; unsigned int protocol_version; unsigned int field_count; unsigned int server_status; unsigned int server_language; unsigned int warning_count; struct st_mysql_options options; enum mysql_status status; my_bool free_me; /* If free in mysql_close */ my_bool reconnect; /* set to 1 if automatic reconnect */ /* session-wide random string */ char scramble[SCRAMBLE_LENGTH+1]; my_bool unused1; void *unused2, *unused3, *unused4, *unused5; LIST *stmts; /* list of all statements */ const struct st_mysql_methods *methods; void *thd; /* Points to boolean flag in MYSQL_RES or MYSQL_STMT. We set this flag from mysql_stmt_close if close had to cancel result set of this object. */ my_bool *unbuffered_fetch_owner; /* needed for embedded server - no net buffer to store the 'info' */ char *info_buffer; void *extension;&#125; MYSQL; 2）MYSQL_RES这个结构体代表查询结果的所有列（SELECT，SHOW，DESCRIBE，EXPLAIN）。查询返回的结果叫做数据集，可以在后边使用。MYSQL_RES的定义如下：1234567891011121314151617typedef struct st_mysql_res &#123; my_ulonglong row_count; MYSQL_FIELD *fields; MYSQL_DATA *data; MYSQL_ROWS *data_cursor; unsigned long *lengths; /* column lengths of current row */ MYSQL *handle; /* for unbuffered reads */ const struct st_mysql_methods *methods; MYSQL_ROW row; /* If unbuffered read */ MYSQL_ROW current_row; /* buffer to current row */ MEM_ROOT field_alloc; unsigned int field_count, current_field; my_bool eof; /* Used by mysql_fetch_row */ /* mysql_stmt_close() had to cancel this result */ my_bool unbuffered_fetch_cancelled; void *extension;&#125; MYSQL_RES; 3，MYSQL_ROW用来表示查询出来的一行，可以通过mysql_fetch_row()函数获得。MYSQL_ROW的定义如下：1typedef char **MYSQL_ROW; /* return data as array of strings */ 4，MYSQL_FIELD用来表示数据库中的字段。包含的信息有字段名，类型，大小等。可以通过mysql_fetch_field()函数获得。MYSQL_FIELD的定义如下：1234567891011121314151617181920212223typedef struct st_mysql_field &#123; char *name; /* Name of column */ char *org_name; /* Original column name, if an alias */ char *table; /* Table of column if column was a field */ char *org_table; /* Org table name, if table was an alias */ char *db; /* Database for table */ char *catalog; /* Catalog for table */ char *def; /* Default value (set by mysql_list_fields) */ unsigned long length; /* Width of column (create length) */ unsigned long max_length; /* Max width for selected set */ unsigned int name_length; unsigned int org_name_length; unsigned int table_length; unsigned int org_table_length; unsigned int db_length; unsigned int catalog_length; unsigned int def_length; unsigned int flags; /* Div flags */ unsigned int decimals; /* Number of decimals in field */ unsigned int charsetnr; /* Character set */ enum enum_field_types type; /* Type of field. See mysql_com.h for types */ void *extension;&#125; MYSQL_FIELD; 常用函数1）mysql_init头文件：1#include &lt;mysql/mysql.h&gt; 函数原型为：1MYSQL *mysql_init(MYSQL *mysql); 在连接数据库之前，必须调用mysql_init函数来初始化一个MYSQL结构体。这个结构体可以使用mysql_real_connect()函数连接数据库。如果mysql是NULL，那么函数初始化一个新的结构体，分配新的内存空间，并返回内存空间的地址，如果不是NULL，则初始化mysql指向的内存，返回传进来的地址。函数执行成功返回MYSQL结构体的指针，否则返回NULL。 2）mysql_real_connect连接数据库需要设置相关的参数，可以使用这个函数来完成，并进行实际的连接。原型如下：1234567MYSQL *mysql_real_connect(MYSQL *mysql, const char *host, const char *user, const char *passwd, const char *db, unsigned int port, const char *unix_socket, unsigned long clientflag); 需要包含头文件：1#include &lt;mysql/mysql.h&gt; 来说明参数的含义: mysql是使用mysql_init()函数初始化的结构体； host是mysql服务器所在的服务器计算机名或者ip地址，如果host是NULL或者是字符串”localhost”，那么就连接到本地计算机； user和passwd是数据库登陆时的用户名和密码，如果user是NULL或者空字符串””，那么假设用户名为当前登陆的用户ID，如果passwd是NULL，则只可以访问这个服务器中不需要口令的数据，口令在传递到网络以前是加密的； db表示数据库的名字，如果db不是NULL，那么连接将这个数据库设置为默认的数据库； 如果port非零，那么这个值用来当做TCP/IP连接的端口，一般来说port取0； 如果unix_socket不是NULL，那么这个字符串指定的socket或者命名管道会使用，这与host参数有关；一般来unix_socket取NULL； clientflag通常为0，在很特殊的情况下可以是一些标志的组合，下面列出一些，详细请见文档。 CLIENT_FOUND_ROWS，返回找到的（匹配的）行数，而不是收到影响的行数。 CLIENT_NO_SCHEMA，不允许db_name.tbl_name.col_name语法，这是为了ODBC，如果使用该语法，将导致语法分析器产生一个错误，它在一些有bugs的ODBC程序中是有用的。 CLIENT_COMPRESS，使用压缩协议。 mysql_real_connect函数成功返回一个只想MYSQL结构体的指针，返回值与第一个参数值相同，如果连接失败返回NULL，可以使用mysql_error()函数来查看错误原因。 3）mysql_close完成连接任务后，可以用mysql_close()来关闭连接，原型如下：123#include &lt;mysql/mysql.h&gt;void mysql_close(MYSQL *sock); 关闭连接后，sock会被清空，指针也变的无效而不能再使用。 4）mysql_options这个函数与连接函数关系紧密，它只能在mysql_init()函数和mysql_real_connect函数之间调用。原型如下：1234#include &lt;mysql/mysql.h&gt;int mysql_options(MYSQL *mysql,enum mysql_option option, const void *arg); 这个函数用来设置额外的连接选项，并影响连接的行为。可以多次调用该函数来设置数个选项。option是打算设置的选项，arg是打算设置的值。如果选项是整数，那么arg应该指向整数的值，下面列出一些选项，详细请见文档。 MYSQL_INIT_COMMAND，参数类型为char *，当连接到mysql服务器时执行的命令，再次执行连接时会自动的调用。 MYSQL_OPT_CONNECT_TIMEOUT，参数类型为unsigned int *，以秒为单位的连接超时。 MYSQL_OPT_PROTOCOL，参数类型为unsigned int *，要使用的协议类型，应该是mysql.h中定义的mysql_protocal_type的枚举类型之一。 MYSQL_OPT_COMPRESS，参数没有使用，在网络连接中使用压缩。 mysql_options()函数成功调用返回0，否则返回非零值。 5）mysql_errno函数原型为：123#include &lt;mysql/mysql.h&gt;unsigned int mysql_errno(MYSQL *mysql); 这个函数用来获取制定的连接最近调用函数的错误代码。这个函数调用可能成功，也可能失败。返回0表示未出现错误。在MYSQL errmsg.h头文件中列出了错误信息的代码。 6）mysql_error函数原型为：123#include &lt;mysql/mysql.h&gt;const char *mysql_error(MYSQL *mysql); 对于mysql指定的连接，mysql_error()函数返回最近调用函数失败原因的字符串表示，字符串以’\\0’作为终结字符，如果没有错误，则返回的可能时上一个错误，或者返回空串。如果返回空串，说明没有产生错误。 7）mysql_query，mysql_real_query函数原型如下：12345#include &lt;mysql/mysql.h&gt;int mysql_query(MYSQL *mysql, const char *q);int mysql_real_query(MYSQL *mysql, const char *q, unsigned long length); 对于制定mysql连接，执行q指向的字符串的SQL语句，与命令行不同，它不需要包含表示终止的分号。如果运行成功，函数返回0，否则返回非零。mysql_query()函数不能用来执行包含二进制数据的语句操作，这时，就必须使用mysql_real_query()函数，length代表字符串的长度，此外，mysql_real_query不需要调用strlen来，所以更快。你可以使用mysql_field_count()函数来检查语句是否返回结果集。错误信息可能是如下情况： CR_COMMANDS_OUT_OF_SYNC，以不恰当的顺序执行了命令。 CR_SERVER_GONE_ERROR，mysql服务器不可用。 CR_SERVER_LOST，查询过程中，与服务器的连接丢失了。 CR_UNKNOWN_ERROR，未知的错误。 8）mysql_affected_rows函数原型为：123#include &lt;mysql/mysql.h&gt;my_ulonglong mysql_affected_rows(MYSQL *mysql); 这个函数用在不返回数据的SQL语句中，也就是UPDATA，DELETE和INSERT语句。这个函数返回上次UPDATE更改的行数，上次DELETE删除的行数或者上次INSERT插入的行数，或SELECT返回的行数。可以在执行过mysql_query()函数或者mysql_real_query()函数后调用。对于SELECT语句这个函数类似mysql_num_rows()。返回值大于零表示影响的行数。零表示对于UPDATE没有数据被更新，在执行中没有行匹配WHERE子句或者没有语句被执行。-1表示出错，或者对于SELECT语句，mysql_affected_rows()函数的调用先于mysql_store_result()。因为这个函数返回无符号的值，所以，可以使用如下的方式检查-1，(my_ulonglong)-1或(my_ulonglong)~0，这两个方式是等价的。 通常，从mysql数据库中检索数据有四个步骤。 发出查询。 检索数据。 处理数据。 整理所需要的数据。 用mysql_query或mysql_real_query发出查询。检索数据可以用mysql_store_result或mysql_use_result，取决于怎样检索数据，接着是调用mysql_fetch_row来处理数据，最后必须调用mysql_free_result来让mysql进行必要的整理工作。 9）mysql_store_result函数原型为：123#include &lt;mysql/mysql.h&gt;MYSQL_RES *mysql_store_result(MYSQL *mysql); 这个函数必须在调用mysql_query或者mysql_real_query函数后才能使用，用来在结果集中存储数据。可以产生数据的语句有SELECT，SHOW，DESCRIBE，EXPLAIN，CHECK TABLE等等。在对结果集操作完成后，你必须调用mysql_free_result。这个函数返回一个结果集的指针，如果失败，则返回NULL。MYSQL_RES结构体定义如下：1234567891011121314151617typedef struct st_mysql_res &#123; my_ulonglong row_count; MYSQL_FIELD *fields; MYSQL_DATA *data; MYSQL_ROWS *data_cursor; unsigned long *lengths; /* column lengths of current row */ MYSQL *handle; /* for unbuffered reads */ const struct st_mysql_methods *methods; MYSQL_ROW row; /* If unbuffered read */ MYSQL_ROW current_row; /* buffer to current row */ MEM_ROOT field_alloc; unsigned int field_count, current_field; my_bool eof; /* Used by mysql_fetch_row */ /* mysql_stmt_close() had to cancel this result */ my_bool unbuffered_fetch_cancelled; void *extension;&#125; MYSQL_RES; 10）mysql_num_rows函数原型为：123#include &lt;mysql/mysql.h&gt;my_ulonglong STDCALL mysql_num_rows(MYSQL_RES *res); 如果调用mysql_store_result成功，则可以使用mysql_num_rows函数来检索实际返回的行数，返回结果当然可能为0。如果mysql_store_result成功，这个函数也会成功。一旦调用mysql_store_result成功，那么所有查询的数据都将存储在客户端，不需要冒着网络出错的危险。如果查询的数据量很大，最好还是按照需要检索数据。检索到数据后，需要对数据进行处理，可以使用这些函数：mysql_fetch_row,mysql_data_seek,mysql_row_tell,mysql_row_seek，将在下面介绍。 11）mysql_fetch_row函数原型为：123#include &lt;mysql/mysql.h&gt;MYSQL_ROW mysql_fetch_row(MYSQL_RES *result); 这个函数返回结果集中的下一行数据。如果没有更多数据或出错，则返回NULL。 12）mysql_data_seek函数原型为：1234#include &lt;mysql/mysql.h&gt;void mysql_data_seek(MYSQL_RES *result, my_ulonglong offset); 13）mysql_row_tell函数原型为：123#include &lt;mysql/mysql.h&gt;MYSQL_ROW_OFFSET mysql_row_tell(MYSQL_RES *res); 这个函数返回一个偏移值，它表示结果集的当前位置，它不是行号，不能用于mysql_data_seek。但是可以将它用于mysql_row_seek。 14）mysql_row_seek函数原型为：1234#include &lt;mysql/mysql.h&gt;MYSQL_ROW_OFFSET mysql_row_seek(MYSQL_RES *result, MYSQL_ROW_OFFSET offset); 这个函数移动结果集的位置，并且返回当前位置。这在已知的点之间跳转是很有用的。 15）mysql_free_result函数原型为：123#include &lt;mysql/mysql.h&gt;void mysql_free_result(MYSQL_RES *result); 当完成对一个结果集的操作后，必须调用这个函数来释放内存空间。不要试图在调用此函数后，再次使用结果集。 16）mysql_use_result函数原型为：123#include &lt;mysql/mysql.h&gt;MYSQL_RES *mysql_use_result(MYSQL *mysql); 这个函数也和mysql_store_result一样，返回一个结果集的指针，不过，实际上它并没有检索到任何数据，仅仅初始化来接收数据，为了获得数据必须反复调用mysql_fetch_row，知道检索完数据。出错返回NULL。这中情况下，将不能使用函数mysql_num_rows，mysql_data_seek，mysql_row_seek，mysql_rows_tell，准确的说，mysql_num_rows可以被调用，不过在mysql_fetch检索完之前是不可能获取到可用的行数的。使用这个降低了网络通信量。仅仅检索数据是没有用的，应该能够做进一步工作，返回的数据一般有两种： 检索到的实际数据 关于数据的数据，即元数据 17）mysql_field_count函数原型为：123#include &lt;mysql/mysql.h&gt;unsigned int mysql_field_count(MYSQL *mysql); 可以使用mysql_field_count函数返回最近一次执行查询中字段的数目。当mysql_store_result返回NULL的时候，可以调用这个函数来确定mysql_store_result为什么调用失败。一般来说，mysql_store_result失败的原因有： malloc调用失败，例如，结果集太大了。 不能读数据，如连接出现了错误。 查询没有返回数据，如查询语句是INSERT，UPDATE和DELETE。 总是可以用这个函数来检查查询是否返回了空结果集。 18）mysql_fetch_field,mysql_fetch_fields函数原型为：1234#include &lt;mysql/mysql.h&gt;MYSQL_FIELD *mysql_fetch_field(MYSQL_RES *result);MYSQL_FIELD *mysql_fetch_fields(MYSQL_RES *res); 这个函数返回一个MYSQL_FIELD结构体或数组，是结果集中的列定义。重复调用这个函数返回所有关于列的信息，当没有更多列时，返回NULL。其中MYSQL_FIELD结构体的定义如下：1234567891011121314151617181920212223typedef struct st_mysql_field &#123; char *name; /* Name of column */ char *org_name; /* Original column name, if an alias */ char *table; /* Table of column if column was a field */ char *org_table; /* Org table name, if table was an alias */ char *db; /* Database for table */ char *catalog; /* Catalog for table */ char *def; /* Default value (set by mysql_list_fields) */ unsigned long length; /* Width of column (create length) */ unsigned long max_length; /* Max width for selected set */ unsigned int name_length; unsigned int org_name_length; unsigned int table_length; unsigned int org_table_length; unsigned int db_length; unsigned int catalog_length; unsigned int def_length; unsigned int flags; /* Div flags */ unsigned int decimals; /* Number of decimals in field */ unsigned int charsetnr; /* Character set */ enum enum_field_types type; /* Type of field. See mysql_com.h for types */ void *extension;&#125; MYSQL_FIELD; 19）IS_NUM这是一个宏定义，用来检测字段是否是数字形式的，如果是，返回真。参数为MYSQL_FIELD结构体中的枚举类型type。 20）mysql_field_seek函数原型为：1234#include &lt;mysql/mysql.h&gt;MYSQL_FIELD_OFFSET mysql_field_seek(MYSQL_RES *result, MYSQL_FIELD_OFFSET offset); 这个函数将字段光标移动到给定的偏移量，下一调用mysql_fetch_field将返回该偏移量指定的列。返回当前的偏移量。 21）mysql_field_tell函数原型为；123#include &lt;mysql/mysql.h&gt;MYSQL_FIELD_OFFSET mysql_field_tell(MYSQL_RES *res); 这个函数用来设置当前连接的字符编码。csname指向一个有效的字符编码名字。函数作用与SET NAMES类似。这个函数会影响mysql_real_escape_string()的行为。执行成功返回0，否则返回非0。一般来说，要显式的指定编码。一个例子：1234567891011121314MYSQL mysql;mysql_init(&amp;mysql);if (!mysql_real_connect(&amp;mysql,\"host\",\"user\",\"passwd\",\"database\",0,NULL,0))&#123; fprintf(stderr, \"Failed to connect to database: Error: %s\\n\", mysql_error(&amp;mysql));&#125;if (!mysql_set_character_set(&amp;mysql, \"utf8\"))&#123; printf(\"New client character set: %s\\n\", mysql_character_set_name(&amp;mysql));&#125; 23）mysql_autocommit函数原型为：123#include &lt;mysql/mysql.h&gt;my_bool mysql_autocommit(MYSQL * mysql, my_bool auto_mode); mysql的默认提交操作是自动提交（autocommit），除非显式的开始一个事务，否则，每个查询被当做一个单独的事务自动执行，可以通过这个函数来开始一个事务。MySQL默认的存储引擎是MyISAM，MyISAM存储引擎不支持事务处理，所以改变autocommit没有什么作用，InnoDB存储引擎支持事务处理。InnoDB表引擎下关闭mysql自动事物提交可以大大提高数据插入的效率，这是因为如果需要插入1000条数据，mysql会自动发起（提交）1000次的数据写入请求，如果把autocommit关闭掉，通过程序来控制，只要一次commit就可以搞定。auto_mode参数为0或1。执行成功返回0，否则返回非0。 24）mysql_commit123#include &lt;mysql/mysql.h&gt;my_bool mysql_commit(MYSQL * mysql); 手动进行一次提交操作。执行成功返回0，否则返回非0。 25）mysql_rollback函数原型为：123#include &lt;mysql/mysql.h&gt;my_bool mysql_rollback(MYSQL * mysql); 手动进行一次回滚操作，执行成功返回0，否则返回非0。 参考1）http://www.cnblogs.com/yeahgis/p/3381485.html","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"mysql","slug":"编程/mysql","permalink":"https://gwq5210.com/categories/编程/mysql/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://gwq5210.com/tags/c语言/"},{"name":"数据库","slug":"数据库","permalink":"https://gwq5210.com/tags/数据库/"},{"name":"mysql","slug":"mysql","permalink":"https://gwq5210.com/tags/mysql/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"},{"name":"mysql","slug":"编程/mysql","permalink":"https://gwq5210.com/categories/编程/mysql/"}]},{"title":"c语言中的可变参数","slug":"c语言中的可变参数","date":"2016-01-22T22:54:30.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2016/01/22/c语言中的可变参数/","link":"","permalink":"https://gwq5210.com/2016/01/22/c语言中的可变参数/","excerpt":"c语言中可变参数列表有关的内容在stdarg.h头文件中。这个头文件中的内容可以让函数实现类似scanf函数的功能，接收不确定个数的参数。使用方法稍微复杂一些，必须按照如下步骤进行：1.在函数原型中使用省略号。2.在函数定义中创建一个va_list类型的变量。3.用宏将该变量初始化为一个参数列表。4.用宏访问这个参数列表。5.用宏完成清理工作。 下面详细介绍这些步骤，函数原型中的参数列表中至少有一个后跟省略号的参数，这个参数成为parmN，如：","text":"c语言中可变参数列表有关的内容在stdarg.h头文件中。这个头文件中的内容可以让函数实现类似scanf函数的功能，接收不确定个数的参数。使用方法稍微复杂一些，必须按照如下步骤进行：1.在函数原型中使用省略号。2.在函数定义中创建一个va_list类型的变量。3.用宏将该变量初始化为一个参数列表。4.用宏访问这个参数列表。5.用宏完成清理工作。 下面详细介绍这些步骤，函数原型中的参数列表中至少有一个后跟省略号的参数，这个参数成为parmN，如： 12345678// 合法void f1(int n, ...);// 合法int f2(int n, const char *s, ...);// 无效，省略号不是最后一个参数char f3(char c1, ..., char c2);// 无效，没有任何参数double f4(); 接下来，在头文件stdarg.h中声明的va_list类型代表一种数据对象，该数据对象用于存放参数列表中省略号部分代表的参数。可变参数函数的定义应该像下边这样： 123doube sum(int lim, ...)&#123; va_list ap; // 声明用于存放参数的变量 然后，函数将使用stdargs.h中定义的宏va_start()把参数列表复制到va_list变量中。宏va_start()有两个参数：va_list类型的变量和变量parmN。如前所述，这里两个参数分别为va和lim，所以，va_start()函数的调用如下所示： 1va_start(vp, lim); // 把vp初始化为参数列表 下一步是访问参数列表中的内容，这涉及宏va_arg()的使用，该宏接受两个参数：一个va_list类型的变量和一个类型名。第一次调用va_arg()时，它返回参数列表的第一项，下次调用返回第二项，一次类推。参数类型制定返回值的类型。例如，如果参数列表中第一个参数为double类型，第二个为int类型，那么可使用下列语句： 12345double tic;int toc;...tic = va_arg(ap, double); // 取得第一个参数toc = va_arg(ap, int); // 取得第二个参数 这里需要注意的是，实际参数的类型必须与说明的类型相匹配，如果第一个参数为10.0，那么前面的tic部分的代码正常工作；但是如果参数为10，代码就可能无法正常工作。这里不会像赋值过程中那样进行double到int的自动转换。最后，应该使用va_end()完成清理工作。该宏接受一个va_list变量作为参数： 1va_end(ap); // 清理工作 此后，只有用va_start()重新对ap初始化后，才能使用变量ap。因为va_arg()不提供后退回先前参数的方法，所以保存va_list变量的副本是有用的，C99为此专门添加了宏va_copy()。该宏的两个参数均为va_list类型变量，它将第二个参数复制到第一个参数中： 123456789va_list ap;va_list apcopy;double tic;int toc;...va_start(ap, lim); // 把ap初始化为参数列表va_copy(apcopy, ap); // apcopy是ap一个副本tic = va_arg(ap, double); // 取得第一个参数toc = va_arg(ap, int); // 取得第二个参数 这时，虽然已从ap中删除了前两项，但是还可以从apcopy中重新获取这两项。下面是一个例子： 1234567891011121314151617181920212223242526272829303132333435363738/************************************************************************* &gt; File Name: varargs.c &gt; Author: gwq &gt; Mail: gwq5210@qq.com &gt; Created Time: 2015年01月07日 星期三 20时13分16秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;double sum(int num, ...)&#123; va_list ap; int i = 0; double res = 0.0; va_start(ap, num); for (i = 0; i &lt; num; ++i) &#123; res += va_arg(ap, double); &#125; va_end(ap); return res;&#125;int main(int argc, char *argv[])&#123; double s = 0.0; s = sum(3, 1.1, 2.5, 13.3); printf(\"sum(3, 1.1, 2.5, 13.3) = %.2f\\n\", s); // 如果不对应，会出现错误，这与放的位置有关 //s = sum(3, 1, 2.5, 13.3); //printf(\"sum(3, 1, 2.5, 13.3) = %.2f\\n\", s); s = sum(6, 1.1, 2.1, 13.1, 4.1, 5.1, 6.1); printf(\"sum(6, 1.1, 2.5, 13.1, 4.1, 5.1, 6.1) = %.2f\\n\", s); return 0;&#125; 上边也测试了，传进来的参数不对应的情况，发生了错误。下面是另一个程序，说明了va_arg传入的类型还可以是自定义的类型： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/************************************************************************* &gt; File Name: testargs.c &gt; Author: gwq &gt; Mail: gwq5210@qq.com &gt; Created Time: 2015年01月07日 星期三 20时21分44秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;struct point_t &#123; int x, y;&#125;;struct point_t add(int num, ...)&#123; va_list ap; va_start(ap, num); int i = 0; struct point_t p; struct point_t res; res.x = 0; res.y = 0; for (i = 0; i &lt; num; ++i) &#123; p = va_arg(ap, struct point_t); res.x += p.x; res.y += p.y; &#125; va_end(ap); return res;&#125;int main(int argc, char *argv[])&#123; struct point_t p; struct point_t sum; p.x = 1; p.y = 2; sum = add(3, p, p, p); printf(\"add(3, p, p, p) = &#123;%d, %d&#125;\\n\", sum.x, sum.y); return 0;&#125; 下面说说stdio.h中与va_list相关的几个函数：这几个函数有vprintf,vfprintf,vsprintf,vsnprintf。函数原型分别为： 1234int vprintf(const char *format, va_list ap);int vfprintf(FILE *stream, const char *format, va_list ap);int vsprintf(char *str, const char *format, va_list ap);int vsnprintf(char *str, size_t size, const char *format, va_list ap); 这几个函数分别与printf,fprintf,sprintf,snprintf类似，不过，他们接受一个va_list类型的变量，而不是参数列表。利用这几个函数可以实现方便的函数如： 123456789101112131415161718192021222324252627282930/************************************************************************* &gt; File Name: execute_cmd.c &gt; Author: gwq &gt; Mail: gwq5210@qq.com &gt; Created Time: 2015年01月07日 星期三 20时44分17秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;stdarg.h&gt;#define BUFSIZE 1024int execute_cmd(const char *fmt, ...)&#123; char cmd[BUFSIZE]; va_list ap; va_start(ap, fmt); vsprintf(cmd, fmt, ap); va_end(ap); return system(cmd);&#125;int main(int argc, char *argv[])&#123; execute_cmd(\"echo %s\", \"dir\"); execute_cmd(\"ls %s\", \"/\"); return 0;&#125; 这里边的大部分内容都是从书上摘下来的，程序部分经过了修改。 参考：1）C Primer Plus（第五版）中文版 16.132）hustoj项目源代码","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://gwq5210.com/tags/c语言/"},{"name":"可变参数","slug":"可变参数","permalink":"https://gwq5210.com/tags/可变参数/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}]},{"title":"url转码解码-c语言实现","slug":"url转码解码-c语言实现","date":"2016-01-22T22:07:10.000Z","updated":"2022-07-17T15:47:36.034Z","comments":true,"path":"2016/01/22/url转码解码-c语言实现/","link":"","permalink":"https://gwq5210.com/2016/01/22/url转码解码-c语言实现/","excerpt":"url提交信息为何要转码呢？因为url本身会有很多特殊字符。而提交的参数中如果再有特殊字符的话，url就不能区分哪些是参数内容，哪些是分隔符。尤其是unicode，gb18030，big5等多字节的编码，不知道里面会隐藏什么字节，因此必须全部转码。 好像C语言里面没有现成的转码函数。参考这里，从php的转码中引出两个函数，进行转码。 字符’a’-‘z’,’A’-‘Z’,’0’-‘9’,’.’,’-‘,’*’和’_’ 都不被编码，维持原值； 空格’ ‘被转换为加号’+’。 其他每个字节都被表示成”%XY”的格式，X和Y分别代表一个十六进制位。编码为UTF-8。","text":"url提交信息为何要转码呢？因为url本身会有很多特殊字符。而提交的参数中如果再有特殊字符的话，url就不能区分哪些是参数内容，哪些是分隔符。尤其是unicode，gb18030，big5等多字节的编码，不知道里面会隐藏什么字节，因此必须全部转码。 好像C语言里面没有现成的转码函数。参考这里，从php的转码中引出两个函数，进行转码。 字符’a’-‘z’,’A’-‘Z’,’0’-‘9’,’.’,’-‘,’*’和’_’ 都不被编码，维持原值； 空格’ ‘被转换为加号’+’。 其他每个字节都被表示成”%XY”的格式，X和Y分别代表一个十六进制位。编码为UTF-8。 下面是代码实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101/************************************************************************* &gt; File Name: url.c &gt; Author: gwq &gt; Mail: gwq5210@qq.com &gt; Created Time: 2014年12月19日 星期五 14时05分41秒 ************************************************************************/#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define BURSIZE 1024int hex2dec(char c)&#123; if ('0' &lt;= c &amp;&amp; c &lt;= '9') &#123; return c - '0'; &#125; else if ('a' &lt;= c &amp;&amp; c &lt;= 'f') &#123; return c - 'a' + 10; &#125; else if ('A' &lt;= c &amp;&amp; c &lt;= 'F') &#123; return c - 'A' + 10; &#125; else &#123; return -1; &#125;&#125;char dec2hex(short int c)&#123; if (0 &lt;= c &amp;&amp; c &lt;= 9) &#123; return c + '0'; &#125; else if (10 &lt;= c &amp;&amp; c &lt;= 15) &#123; return c + 'A' - 10; &#125; else &#123; return -1; &#125;&#125;/* * 编码一个url */void urlencode(char url[])&#123; int i = 0; int len = strlen(url); int res_len = 0; char res[BURSIZE]; for (i = 0; i &lt; len; ++i) &#123; char c = url[i]; if (('0' &lt;= c &amp;&amp; c &lt;= '9') || ('a' &lt;= c &amp;&amp; c &lt;= 'z') || ('A' &lt;= c &amp;&amp; c &lt;= 'Z') || c == '/' || c == '.') &#123; res[res_len++] = c; &#125; else &#123; int j = (short int)c; if (j &lt; 0) j += 256; int i1, i0; i1 = j / 16; i0 = j - i1 * 16; res[res_len++] = '%'; res[res_len++] = dec2hex(i1); res[res_len++] = dec2hex(i0); &#125; &#125; res[res_len] = '\\0'; strcpy(url, res);&#125;/* * 解码url */void urldecode(char url[])&#123; int i = 0; int len = strlen(url); int res_len = 0; char res[BURSIZE]; for (i = 0; i &lt; len; ++i) &#123; char c = url[i]; if (c != '%') &#123; res[res_len++] = c; &#125; else &#123; char c1 = url[++i]; char c0 = url[++i]; int num = 0; num = hex2dec(c1) * 16 + hex2dec(c0); res[res_len++] = num; &#125; &#125; res[res_len] = '\\0'; strcpy(url, res);&#125;int main(int argc, char *argv[])&#123; char url[BURSIZE] = \"http://'www.baidu.com/a b\"; urlencode(url); printf(\"%s\\n\", url); return 0;&#125; 参考1) bnuoj vjudge2) wudishine的专栏","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://gwq5210.com/tags/c语言/"},{"name":"url转码","slug":"url转码","permalink":"https://gwq5210.com/tags/url转码/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}]},{"title":"C语言笔记","slug":"C语言笔记","date":"2015-11-08T21:40:48.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2015/11/08/C语言笔记/","link":"","permalink":"https://gwq5210.com/2015/11/08/C语言笔记/","excerpt":"C语言笔记变量相关： C99以前的C要求在一个代码块的开始处声明变量。 声明语句为变量创建，标定存储空间并为其制定初始值。 C99引入_Bool类型表示布尔值。它还提供stdbool.h头文件，包含这个头文件可以使用bool来代替_Bool，并把true和false定义为1和0的符号常量。 C99提供一个可选的名字集合，用来描述确定的位数。如int16_t表示一个16位有符号整数类型，uint32_t表示一个32位无符号整数类型。使用这些名字，需要包含头文件inttypes.h。另外，这种确切的长度类型在某些系统上可能不支持。不如，不能保证某些系统上存在一种int8_t类型（8位有符号整数）。为了解决这个问题，C99标准定义了第二组名字集合。这些名字保证所表示的类型至少大于指定长度的最小类型，被称为“最小长度类型”。例如，int_least8_t是可以容纳8位有符号数的那些类型中长度最小的一个别名。因为一些程序员更关心速度而非空间。C99为他们定义了一组可使计算达到最快的类型集合。这组集合被称为“最快最小长度类型”。如，int_fast8_t定义为系统中对8位有符号数而言计算最快的整数类型的别名。为了使用printf输出这些类型，C99还提供了一些串宏来帮助打印这些类型。（注：可能一些编译器并不支持这一特性）","text":"C语言笔记变量相关： C99以前的C要求在一个代码块的开始处声明变量。 声明语句为变量创建，标定存储空间并为其制定初始值。 C99引入_Bool类型表示布尔值。它还提供stdbool.h头文件，包含这个头文件可以使用bool来代替_Bool，并把true和false定义为1和0的符号常量。 C99提供一个可选的名字集合，用来描述确定的位数。如int16_t表示一个16位有符号整数类型，uint32_t表示一个32位无符号整数类型。使用这些名字，需要包含头文件inttypes.h。另外，这种确切的长度类型在某些系统上可能不支持。不如，不能保证某些系统上存在一种int8_t类型（8位有符号整数）。为了解决这个问题，C99标准定义了第二组名字集合。这些名字保证所表示的类型至少大于指定长度的最小类型，被称为“最小长度类型”。例如，int_least8_t是可以容纳8位有符号数的那些类型中长度最小的一个别名。因为一些程序员更关心速度而非空间。C99为他们定义了一组可使计算达到最快的类型集合。这组集合被称为“最快最小长度类型”。如，int_fast8_t定义为系统中对8位有符号数而言计算最快的整数类型的别名。为了使用printf输出这些类型，C99还提供了一些串宏来帮助打印这些类型。（注：可能一些编译器并不支持这一特性） 浮点数的上溢和下溢。当一个计算结果是一个大的不能表达的数时，会发生上溢，现在C语言用一个特殊值表示这个太大的数，printf函数显示此值为inf或infinity。如果将浮点数能表示的最小的数除以2，将会得到一个低于正常的值，如果除以一个足够大的数，将使所有位都为0。现在C库提供了用于检查计算是否会产生低于正常的值的函数。有一个特殊的浮点值NaN（Not-a-Number）。例如asin函数返回反正弦值，但是正弦值不能大于1，所以它的输入参数不能大于1，否则函数返回NaN值，printf函数显示此值为nan，NaN或类似形式。 C99还支持复数和虚数类型。 在将浮点数转换为整数时，C简单的丢弃小数部分（截尾），而不进行四舍五入。 sizeof运算符返回一个size_t类型的数，这个类型通常是unsigned或unsigned long。对于某个具体量的大小sizeof的括号是可选的，但对于类型来说，括号是必需的。如sizeof(int)，sizeof(2.0)&lt;=&gt;sizeof 2.0。 C99标准要求编译器识别局部标识符的前63个字符和外部标识符的前31个字符。在这之前分别为31个和6个字符。 参数传递机制对于下面的代码段： 12345float n1 = 3.0;double n2 = 3.0;long n3 = 300000;long n4 = 123456790;printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4); 该调用告诉计算机把变量n1,n2,n3,n4的值传递给计算机，计算机把他们放置到被称为堆栈（stack）的一块内存区域中来实现。计算机根据变量的类型而非转换说明符把这些值放到堆栈中。所以，n1,n2,n3,n4四个变量在堆栈中分别占8,8,4,4个字节，其中n1的float被转换成了double。然后，控制交给了printf函数。该函数中堆栈中把值读出来，但是在读取时，它根据转换说明符去读取。%ld说明符指出，printf应该读取4个字节，所以printf在堆栈中读取前4个字节作为它的一个值。这就是n1的前半部分，它被解释成一个long类型。写一个%ld说明符再读取4个字节；这就是n1的后半部分，它也被解释成一个long类型。同样，第三个和第四个%ld说明符分别读取n2的前半部分和后半部分，并解释成一个long类型。所以虽然n3和n4的说明符都正确，但是printf仍然读取了错误的字节。一般来说，栈从高地址向低地址生长，即高地址是栈的底部。而函数的入栈顺序是从右向左。从右向左入栈的原因是，这样可以使得编译器可以支持可变参数，通过第一个参数可以获得参数的个数和每个参数的大小，这样就能取得每个参数。在C中，会发生许多自动类型转换。当char和short类型出现在表达式里或者作为函数的参数时，它们都被提升为int类型。当float类型作为一个函数参数时被提升为double。在包含两种数据类型的任何运算里，两个值都被转换成两种类型里较高的级别。 优先级和求值顺序 运算符的优先级为决定表达式里求值的顺序提供了重要的规则，但是它并不决定所有的规则。如：1y = 6 * 12 + 5 * 20; 当两个运算符共享一个操作数的时候，优先级规定了求值顺序。例如，12既是运算符的操作数，又是+运算符的操作数，根据优先级的规定乘法运算先进行。与之类似，优先级规定了对5进行乘法操作而不是加法操作。总之，两个乘法操作在加法操作之前进行。但是优先级并没有确定的是这两个乘法运算中到底那个先进行。C将这个选择权留给实现者，这是因为可能一种选择在一种硬件上效率更高，而另一种选择在另一种硬件上效率更高。但是不管先执行那个乘法运算，表达式都会简化成72+100。虽然乘法运算符的结合性是从左到右，但因为两个\\运算符不共享一个操作数，所以从左到右的规则对它并不适用。也就是说结合规则适用于共享同一操作数的运算符。 对于参数传递，参数的求值顺序也是不确定的。所以，下边的语句的结果在不同的系统上可能会产生不同的结果。1234int num = 1;printf(\"%d %d\\n\", num, num * num++);int n = 2;printf(\"%d\\n\", n++ + n++); 但是我们可以通过一下原则来避免这些问题。 如果一个变量出现在同一个函数的多个参数中，不要将增量或减量运算符用于它上边。 当一个变量多次出现在一个表达式里时，不要将增量或减量运算符用于它上边。 顺序点是程序执行中的一点，在该点处，所有的副作用都在进入下一步之前被计算。在C中语句里的分号标志了一个顺序点。任何一个完整的表达式结束也是一个顺序点。一个完整的表达式是这样一个表达式——它不是一个更大的表达式的子表达式。逗号运算符是一个顺序点。 分支和跳转 C99标准要求编译器最少支持127层else-if嵌套。 C99标准为逻辑运算符增加了可供选择的拼写方法。它们在iso646.h头文件中定义，包含这个头文件可以使用and，or，not来代替相应的逻辑运算符。同时，C还提供了3元字符扩展。 switch语句里的case必须是整型（包括char）常量或者整型常量表达式（仅包含整数常量的表达式）。 函数 C99标准不再支持函数的int类型的默认设置。类型声明是函数定义的一部分。 一般来讲，尾递归的空间复杂度是常量。 所有的C函数地位同等，也就是说，main函数也可以被其本身或者被其他函数递归掉调用——尽管很少这么做。 数组 数组制定初始化项目，对数组中指定的项目初始化。如多次对一个元素初始化，则最后一次有效。 12345// 传统语法int arr1[6] = &#123;0, 0, 0, 0, 0, 123&#125;;// C99语法int arr2[6] = &#123;[5] = 123&#125;;int arr3[3] = &#123;[2] = 3, 4&#125;; // 数组内容为0， 3， 4 C99之前声明数组的方括号内只能使用整数常量表达式（表达式的值必须大于0）。注意，与C++不同，const值不是一个整数常量。 C99引入了变长数组，即声明数组的方括号内可以使用变量。变长数组必须是自动存储类型的，这意味着他们必须在函数内部或者作为函数形式参数声明，而且声明时不可以进行初始化。 123int sum2d(int, int, int ar[*][*]); // ar是一个边长数组，必须使用*号代替省略的维数int sum2d(int a, int b, int ar[a][b]); // a和b的声明一定要在ar的前边int sum2d(int ar[a][b], int a, int b); // 错误 C99复合文字。可以使用复合文字创建一个无名数组。 1234// 一个包含两个int值的数组(int [2])&#123;10, 20&#125;// 可以通过指针来使用他们，也可以将他们用做函数参数int *p = (int [3])&#123;1, 2, 3&#125;; 指针 可以使用const来创建指向常量的指针或指针常量，当然也可以创建指向常量的指针常量。如下： 12const int *pi1; // 指向常量的指针，指针指向的值不能改变int * const pi2; // 指针常量，指针指向的地址不能改变，但是指针指向地址的值可以改变 指向多为数组的指针。 12int (*pz)[2]; // pz指向一个包含两个int值的数组int *p[2]; // p是一个数组，这个数组的每一个元素是一个指向一个int值的指针 指针兼容性。多维数组指针要求指针的维数是一致的。 12345678910111213int *pt;int (*pa)[3];int ar1[2][3];int ar2[3][2];int **p2; // 指向指针的指针pt = &amp;ar1[0][0];pt = ar1[0];pt = ar1; // 非法pa = ar1;pa = ar2; // 非法p2 = &amp;pt;*p2 = ar2[0];p2 = ar2; // 非法 const指针与非const指针。可以把一个非const指针赋值给一个const指针，但是不能把一个const指针赋值给一个非const指针。这个结论有一个前提，值进行一层间接运算。在两层间接运算时，这样的赋值就不再安全。 123456const int **pp2;int *p1;const int n = 13;pp2 = &amp;p1; // 不允许，但我们假设允许*pp2 = &amp;n; // 合法，二者都是const，这同时会使p1指向n*p1 = 10; // 合法，但这会改变const n的值 void指针。在C中void指针可以赋给其他类型的指针而不需要强制转换。但在C++中需要。 在C99中同样可以声明一个变长数组指针。 字符串 字符串属于静态存储类。 ANSI C提供了函数：atoi, atof, atol, strtol, strtoul, strtod来将字符串转换成数值。 可以使用sprintf来将数值转换成字符串。 作用域 一个C变量的作用域可以是代码块作用域，函数原型作用域或者文件作用域。 一个C变量有静态存储时期和自动存储时期。除非你显示的初始化自动变量，否则他们不会被自动初始化。 如果一个变量被声明为寄存器变量，你无法获得它的地址。 一个外部变量只能进行一次初始化，而且一定是在变量被定义时进行。 类型限定符 限定词volatile告诉编译器该变量除了可被程序修改外还可以被其他代理改变。因此，这告诉编译器要小心的优化这个变量。 限定词restrict只可以用于指针，表明该指针是访问一个数据对象的唯一且初始的方式。这样编译器就可以进行合适的优化。一个例子是memcpy的参数使用了restrict，要求两个内存区域不能有重叠，而memmove则不做这个假定。 文件I/O stdout和stderr的一个区别是，当出现输出重定向的时候，stderr仍然将输出打印到屏幕上。即stderr不受重定向的影响。 在Unix和Linux这样只有一种文件类型的系统，打开文件时使用带b字母的模式和不带b字母的模式是相同的。 程序中可以同时打开的文件数目是有限制的，这取决于系统和实现，通常为10到20之间。 结构，联合和枚举 指定项目初始化。与数组的类似。 1struct person p = &#123;.name = \"gwq\"&#125;; // 仅仅指定名字 在一些系统上，结构的占用空间大小可能会大于他内部各个成员大小之和，这是因为系统对数据的对齐存储要求所致。 和数组名不同，单独的结构名不是该结构地址的同义词。 可以允许一个结构赋值给另一个结构，但是对数组不能这么做。 C99复合文字和结构。 1234// 无名结构对结构赋值struct person p = （struct person)&#123;\"gwq\", 21&#125;;// 如果需要一个结构的地址，可以使用&amp;获得一个复合结构的地址。struct person *pp = &amp;（struct person)&#123;\"gwq\", 21&#125;; C99的伸缩型数组成员。声明一个伸缩型数组成员的规则是：1）伸缩性数组成员必须是最后一个数组成员。2）结构中必须至少有一个其他成员。3）伸缩型数组就像普通数组一样被声明，除了它的方括号内是空的。该数组成员的特殊属性之一是它不存在，至少不立即存在。C99的意图是使用malloc来分配足够的空间来使用这个数组成员。如： 1234567struct flex &#123; int count; double average; double scores[]; // 伸缩型数组成员&#125;;// 现在这个pf指向的结构，拥有了5个元素的double类型数组。struct flex *pf = malloc(sizeof(struct flex) + 5 * sizeof(double)); 联合是一个能在同一个存储空间里（但不同时）存储不同类型数据的数据类型。 枚举可以声明代表整数常量的符号名称。实际上，枚举常量是int类型的。虽然枚举常量是int类型的，但是枚举变量较为宽松的限定为任一种整数类型，只要该整数类型能保存这些枚举常量。 C的某些枚举属性不能延伸到C++中，如C允许对枚举变量使用++，但C++不允许。 枚举的默认值是从零开始递增。但可以制定特定的值。 12enum color &#123;red, green, blue&#125;;// 分别为0， 1， 2enum levels &#123; low, medium = 500; high&#125;; 分别为0， 500， 501 C使用术语名字空间（namespace）来表示识别一个名字的程序的部分。作用域是这个概念的一部分：名字相同但具有不同作用域的两个变量不会冲突；而名字相同并在相同作用域中的两个变量就会冲突。名字空间是分类别的。在一个特定作用域内的结构标记，联合标记以及枚举标记都共享一个名字空间，并且这个名字空间与普通变量使用的名字空间是不同的。如： 12struct rect &#123;double x; double y&#125;;int rect; // 在C中不会引起冲突 但是这种方式会引起混乱；而且，C++不允许在同一个作用域内对一个变量和一个标记使用同一个名字，因为它把标记和变量名放在同一个名字空间中。 奇特的声明如下：12345678int board[8][8]; // int数组的数组int **ptr; // 指向int指针的指针int *risks[10]; // 具有10个元素的数组，每个元素是一个指向int的指针int (*rusks)[10]; // 一个指针，指向具有10个元素的int数组int *oof[3][4]; // 一个3*4的数组，每个元素是一个指向int的指针int (*uuf)[3][4]; // 一个指针，指向3*4的int数组int (*uof[3])[4]; // 一个具有3个元素的数组，每一个元素是指向具 // 有四个元素的int数组的指针 弄清楚这些声明的诀窍便是理解使用修饰符的顺序。 表示一个数组的[]和表示一个函数的()具有相同的优先级，这个优先级高于间接运算符的优先级。如：int arr[10]声明一个指针数组，而不是一个指向数组的指针。 []和()都是从左到右结合的。声明int goods[10][50]使得goods是一个由12个具有50个int值的数组构成的数组，而不是一个由50个具有12个int值的数组构成的数组。 []和()具有相同的优先级，但是由于他们是从左到右结合的，所以声明int (*rusks)[10]在应用方括号之前先将*和rusks组合在一起。这意味着rusks是一个指向具有10个int值的数组的指针。 函数和指针 声明一个指向特定函数类型的指针，首先声明一个该类型的函数，然后用(*pf)形式的表达式代替函数名称；pf就成为了指向那种类型函数的指针了。 使用指针调用函数有两种看起来都合理的方式。如：12345678void ToUpper(char *);void ToLower(char *);void (*pf)(char *);char mis[] = \"Nina Metier\";pf = ToUpper;(*pf)(mis); // 把ToUpper作用于mispf = ToLower;pf(mis); // 把ToLower作用于mis K&amp;R C不允许第二种形式，但是有的实现却采用第二种形式，为了保持与现有代码的兼容性，ANSI C把这二者作用等价形式全部接受。 不能拥有一个函数的数组，但是可以拥有一个函数指针的数组。如char (*pf[3])(void); 位操作 掩码。使用位与（&amp;）可以获得特定某个位或某些位的值。 打开位。使用位或（|）可以将某一位置为1而不管这个位原来是多少。 关闭位。使用位与（&amp;）与求反（～）可以将某个位置为0，不管这个位原来是多少。如： 123int mask = 1;int n = 3;int m = n &amp; ~mask; // 将最低位关闭 转置位，因为1与0异或为1，1与1异或为0。而0与0异或为0,0与1异或为1。所以可以使用异或操作（^）来转置某些位。只需要将需要转置的位的掩码置为1，其余置为0就行了。 左移位运算符（&lt;&lt;）将其左侧操作数的值的每位向左移动，移动的位数由其右侧操作数指定。空出的位用0填充，并且丢弃移出左侧操作数末端的位。 右移位运算符（&gt;&gt;）将其左侧操作数的值的每位向右移动，移动的位数由其右侧操作数指定。丢弃移出左侧操作数右端的位。对于unsigned类型，使用0填充左端空出的位。对于有符号数，结果依赖机器。空出的位可能用0填充，或者使用符号（最左端的）位的副本填充。 移位运算符能够提供快捷，高效的（依赖于硬件）的对2的幂的乘法和除法。 可以在结构中使用位字段，即对其的操作仅仅是对这个或这几个位的操作。使用一个宽度为0的未命名字段迫使下一个字段与下一个整数对齐。不允许一个字段跨越两个unsigned int之间的边界，编译器自动的移位这样一个字段定义，使得字段按unsigned int边界对齐。发生这种情况时，会在第一个unsigned int中留下一个未命名的洞。如：1234567struct &#123; unsigned int field1: 1; unsigned int : 2; unsigned int field2: 1; unsigned int : 0; unsigned int field3: 1;&#125;stuff; 以上例子中，stuff.field1与stuff.field2之间有一个2位的间隙，stuff.field3存储在下一个int中。 一个重要的机器依赖性是将字段放置到一个int中的顺序。在有些机器上，这个顺序是从左向右；在另一些机器上顺序是从右向左。另外，不同机器在两个字段间边界的位置上也有区别。由于这些原因，位字段往往难以移植。 同样也可使用位运算来模仿位字段的功能，但这要稍微复杂一些。 C预处理器和库 C的预处理只进行字符替换，不会进行算数运算。如： 12#define TWO 2int x = TWO * TWO; // 进过预处理后是2 * 2，实际想乘发生在编译阶段 预处理器不会替换在字符串中的宏。如： 123#define TWO 2#define OW \"nihao\"printf(\"TWO:OW\");// 打印出来TWO:OW而不是2:nihao 对于重定义宏，ANSI C只允许新定义与旧定义完全相同。相同定义意味着主体具有相同顺序的语言符号。 在宏定义中可以使用参数。但这使用不当可能会带来难以理解的结果。因为宏只进行简单的文本替换，可能一个参数在宏中会出现好多次，这对有副作用的表达式，会产生多次副作用，典型的就是自增和自减运算符。 可以使用#号将一个宏的参数字符串化。如： 123#define PR(x) printf(#x \" = %d.\\n\", x);int x = 56;PR(x); // 替换为:printf(\"x\" \" = %d.\\n\", x); 可以使用##符号来将一个语言符号组合成一个语言符号，可以理解为生成一个变量的名称。如： 12XNAME(n) x ## nint XNAME(1) = 4; // 替换为int x1 = 4; 可以使用…和__VA_ARGS__来定义一个可变参数的宏。方法是将宏定义中参数列表的最后一个参数写为省略号，然后在被替换部分就可以使用__VA_ARGS__来代替省略的部分。如： 123#define PR(...) printf(__VA_ARGS__)PR(\"nihao\"); // printf(\"nihao\");PR(\"%d\", x); // printf(\"%d\", x); 函数调用需要一定的开销，这意味着执行调用时花费了时间用于建立调用，传递参数，跳转到函数代码段并返回。使用类函数宏的一个原因就是可以减少执行时间。此外C99还提供了另外一种方法：内敛函数。C99标准这样叙述：“把函数变为内联函数将建议编译器尽可能快速地调用该函数。上述建议的效果由实现来定义”。因此，使函数变为内联函数可能会简化函数的调用机制，但也可能不起作用。 因为内联函数没有预留给它单独代码块，所以无法获得内敛函数的地址（实际上，可以获得地址，但这样会使编译器产生非内联代码）。另外，内联函数不会在调试器中显示。 内联函数应该比较短小。对于很长的函数，调用函数的时间少于执行函数主体的时间；此时，使用内敛函数不会节省很多时间。 编译器在优化内联函数时，必须知道函数定义的内容，这意味着内联函数的定义和对该函数的调用必须在同一文件中，正因为这样，内联函数通常具有内部连接。在多文件的程序中，每个调用内联函数的文件，都要对该函数进行定义。 main函数在结束时会隐式的调用exit()；可以使用atexit函数注册在程序（隐式或显示）调用exit函数前，调用的函数。可以注册多个函数，最后注册的函数最先被调用。ANSI保证这个列表中至少可以放置32个函数。 注：以上这些文字，大部分抄录自C Primer Plus（第五版）中文版。","categories":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}],"tags":[{"name":"c语言","slug":"c语言","permalink":"https://gwq5210.com/tags/c语言/"},{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/tags/编程/"}],"keywords":[{"name":"编程","slug":"编程","permalink":"https://gwq5210.com/categories/编程/"}]},{"title":"2015年腾讯阿里实习生招聘面试经历","slug":"2015年腾讯阿里实习生招聘面试经历","date":"2015-11-08T21:35:07.000Z","updated":"2022-07-17T15:47:36.030Z","comments":true,"path":"2015/11/08/2015年腾讯阿里实习生招聘面试经历/","link":"","permalink":"https://gwq5210.com/2015/11/08/2015年腾讯阿里实习生招聘面试经历/","excerpt":"每年毕业生找工作都是一个问题，对于个人来说，无非就是笔试和面试的问题。对于应届生来说，最头疼的或许不是笔试而是面试。对于笔试，只要自身实力过硬，一般都没有问题（退一步讲，万一笔试没过，还可以在面试的时候霸面）；对于面试，就不一样了，应届生没有接触过面试，所以对于面试可能有些害怕，面试之前会在网上搜一些面试注意事项之类的，而这些都是对所有面试的一般概括，没有什么针对性，无非就是提醒面试者注意着装、礼貌、准备一些各种版本的自我介绍之类的，不得不说这些还是有很大帮助的。但在我看来，这些都没有自己实打实的来一次真正的面试有帮助。所以，我鼓励那些想要找工作的同学，可以尝试着真的去准备一场面试，运气好的话，说不定就被录取了呢。下面，我分享一下我的今年（2015年）的面试经历和感想，希望对一些同学有所帮助。","text":"每年毕业生找工作都是一个问题，对于个人来说，无非就是笔试和面试的问题。对于应届生来说，最头疼的或许不是笔试而是面试。对于笔试，只要自身实力过硬，一般都没有问题（退一步讲，万一笔试没过，还可以在面试的时候霸面）；对于面试，就不一样了，应届生没有接触过面试，所以对于面试可能有些害怕，面试之前会在网上搜一些面试注意事项之类的，而这些都是对所有面试的一般概括，没有什么针对性，无非就是提醒面试者注意着装、礼貌、准备一些各种版本的自我介绍之类的，不得不说这些还是有很大帮助的。但在我看来，这些都没有自己实打实的来一次真正的面试有帮助。所以，我鼓励那些想要找工作的同学，可以尝试着真的去准备一场面试，运气好的话，说不定就被录取了呢。下面，我分享一下我的今年（2015年）的面试经历和感想，希望对一些同学有所帮助。 对于面试的着装，技术类的面试，穿平常的便装就行，不用穿的特别正式，穿的正式反而显得不自然，而且在面试官看来也多少会有几分怪异。非技术类的，具体应该也没有什么特别的标准，如果自己之前有正式的西装之类的衣服，可以穿上去面试，如果没有，感觉也没有必要去准备一下，穿自己平常的衣服应该也不会有多大的问题。这纯属个人见解，可以根据实际的情况，询问学长之类的，应该都会得到满意的解答。 一般来说，公司会通知你在特定的时间地点面试，我们最好提前15到30分钟到达指定的地点（有的会明确要求你提前15分钟到达）。之前在网上看到有说让提前5到10分钟左右，如果提前半个小时去，可能会被公司视为没有时间观念，根据我个人的面试经历，这完全就是扯淡，去公司面试的人那么多，根本不会有人注意到你的，更别说什么看出来一个人的时间观念了；况且，面试官面试时间会在某个范围内波动，遇到你前面的人没来面试，你提前被面试的可能性不是没有；另外，如果太赶的话，很容易造成紧张情绪，面试的时候发挥不好，提前去的话，还可以和其他人交流一下，缓解一下紧张情绪，如果是多个人一块儿去，边等边聊天，基本上也不会有什么紧张的情绪。 另外需要注意的就是个人礼仪等方面的问题，不过，对于一个有基本素质的人，这应该都不是问题，只要稍微注意下就ok了。 最后，面试的时候一定要带上自己的简历，一般来说面试都是三面（不排除更多次面试的可能，貌似这些都是大牛，是要给他们加工资的），带上三份或者更多的简历保证万无一失，如果不带，可以想象面试官要求你给他一份简历你却没有的尴尬情景；最好还有带上纸和笔，技术面试，少不了要在纸上写程序之类的，如果面试官没提供纸，或者提供的纸用完了，那么我们自己带的就派上用场了。 以上这些，个人感觉只要面试的时候稍稍注意一些，都不是问题，毕竟一个公司招聘人才，主要考察的是个人的专业能力，其他方面，只要不是做的太差，都不会有什么问题。 下面，我先来说一下腾讯的面试经历。腾讯我总共面试了三次，一面和二面是技术面，三面是HR面。可能是我个人简历和自我介绍的问题，一面和二面都是面试官在一张纸上指出一些题让写代码或者说思路，没有问我项目或者其他具体的技术问题；HR面基本就是聊天，了解一下你的个人情况之类的，一般来说，技术类的HR是不会刷人的，但也不排除后边的人比你优秀之类的，然后，你就被悲催的刷掉了。 先说一面，一面大学持续了40分钟，刚开始先是自我介绍，我大概说了有三分钟，主要说了ACM的经历，学过linux，写过后台小程序，重点介绍的是ACM的经历，可能是这个原因，面试官上来就让我写程序，问了两个题目。 第一道题目是将字符串”I am student”变成”student am I”，要求尽量节省内存。当时我看道题目后，大致看了一下，就开始写了，也没仔细看题，就写了一个字符串翻转的函数，给面试官看了，面试官明确说错了，我当时就懵了，心想这下完了，但是，我还是静下心来看哪里错了，我看了一遍程序，感觉是没错的，就又再看了一遍题目，立刻就明白了，md，原来题目看错了，当时就给我自己跪了。然后，我就又开始写，写的时候，询问了下面试官，分割单词的空格是不是只有一个，他和我说你可以只考虑一个的情况，然后问我，如果有多个空格怎么处理，我就说可以先做一次预处理，将多个空格变成一个空格。然后，我就开始写了，这次的思路是从字符串的后边往前找空格，找到空格后，将空格替换成’\\0’，用printf函数打印空格后紧邻的那个字符串，一直处理到字符串开头；面试官看的过程中，我开始说思路，说好后，面试官说，不是让打印出来，是让在原来字符串的基础上将字符串改变成这个样子；说完之后，我就开始不淡定了，但是还得想呀，想了一会儿，我感觉写程序时间可能不够用，我就和面试官说，可不可以说思路，他说可以，我就说可以使用循环移位，我想的时候，想的是循环左移，说的时候突然想到循环右移的效率更高一点，这时面试官可能不太理解，就让我画了一个示意图，标明循环右移后额结果，面试官大概明白后，就和我说，你这个想法的时间复杂度有点高呀，我说是的，复杂度是O(n^2)，然后，他让我想想有没有时间复杂度低而且还节省内存的方法，我想的过程中，面试官上了个厕所，回来就问我想出来了没，我说没有，然后，就又指了一道题目让我想；其实，当时我差点就问他，有没有既快又省内存的方法，不过，我是忍着没问，后来，面试完后，我查了一下，还真有，方法真是巧妙，先将字符串中的单词（以空格为分隔符）翻转一次，然后，再以整个字符串为单位翻转一次，就得到了结果；当时就被这种方法惊呆了，太特么妙了。这里附带说下，前几天做360的笔试题目，最后写代码的题目就是这个题，不过是以’.’为分隔符。代码贴到下面：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;string.h&gt;#include &lt;stdio.h&gt;// 实现字符串相应范围翻转void reverse(char *begin, char *end)&#123; while (begin &lt; end) &#123; char c = *begin; *begin = *end; *end = c; ++begin; --end; &#125;&#125;// 翻转两次，第一次以整个字符串为单位翻转，第二次以点分割的单词为单位翻转char *str_rev(char *str)&#123; char *begin = str; int len = strlen(str); char *p; reverse(begin, begin + len - 1); while (*p != '\\0') &#123; while (*p != '\\0' &amp;&amp; *p != '.') &#123; ++p; &#125; if (*p == '\\0') &#123; break; &#125; else &#123; reverse(begin, p - 1); begin = p + 1; &#125; &#125; return str;&#125;int main(void)&#123; char str[] = \"www.soso.com\"; printf(\"%s\\n\", str_rev(str)); return 0;&#125; 面试官让我看第二道题目的时候说，你说下思路，时间不多了，只能给你5分钟的时间考虑；看过题目后，还算好，是一道字典树的题目，说的是有好多电话区号，每一个数字代表一级的地址，比如8213代表A市B区C街道D号等；要求给一个区号，在给定的列表中尽可能快的找到这个区号对应的地址，当时看到后就想到是字典树，面试官让写个数据结构，写好后，让面试官看了下，面试官问的过程中意识到结构体中还得有一个记录地址的字符数组，然后就问我这个数组存什么东西，我说存这个数字对应的地址，没有想到找的过程中将字符串连接起来也得浪费时间，面试官就指出了这一点；另外，还问了一个其他的问题，我也支支吾吾没说清楚。说完之后，面试官就表示面试就到这里，让我问问题，我就问了一些面试结果什么时候出来之类的问题。当时出来后，心里感觉，这下肯定特么要挂了，表现这么不好，当时心里感觉就挺蛋疼的，但也没办法，回到住的地方后，就进入了焦急的等待过程，到了晚上七点左右吧（我是下午两点的一面），在微信里查询状态变成了复试环节，当时就很高兴，没想到竟然过了一面；晚上就点左右，给我发了短信，让第二天早上十点去二面。后边，我就开始大概准备了下，早早的睡下了。 接下来是二面。二面面试官也是开始先让自我介绍，我的介绍和一面大概一样，然后面试官就拿出一张纸，让我做题，中间也没问我其他的问题。这次总做了六道题目。 第一道是类数学题。说是一瓶汽水1元，每两个空瓶可以换一瓶汽水，你现在有20元，问最多可以喝多少瓶汽水？当时，我在纸上大概写了下，算了个39。大概是这样：20+10+5+2+1+1=39，最后一个1是5个空瓶中4瓶换了2瓶汽水，剩了一个空瓶加上最后的一个空瓶。这样最后还剩下一个空瓶，当时没想那么多，就说了个39，然后面试官问我的思路，我大概说了下，然后就让我做下一道题了。面试完后，在网上查了下，还真查到了，发现大部分说的是39，还有一些说的是40，因为可以先和老板借一瓶汽水，喝完后，就有两个瓶子了，把瓶子给老板就ok了。感觉还是40个是最好的答案。其实网上还可以找到其他类似的题目，也十分有趣，就是稍微坑一点儿，看完绝对感觉智商被碾压。 第二道也是道有趣的题目。有10个箱子，每个箱子里有10个苹果，其中，9个箱子里的苹果1斤1个，另外的1个箱子中的苹果9两1个，现在有一个电子秤，要求只称一次（只能得到一个读数，苹果可以拿出来称），区分出来装9两1个苹果的那个箱子。大家可以想一下这道题目怎么做。 当时，看完题目后，也是看错题了，以为是天平，说了一下思路，然后，面试官就说不是天平，是电子秤，可以得到斤两数的。然后，我就开始想，想了好久好久，中间也提出了些疑问，面试官说，只称一次就是只能得到一个读数。想了好久之后，面试官说，从每个箱子里边拿出苹果来称试试，当时，我就傻了，之前我一直在想苹果是以箱子为单位的，只能以一个箱子为单位来称，我就将我之前的误区说了出来，然后，就在纸上开始画，我先写下了1到10十个数字，作为箱子的标号，然后突然想到，可以从1号箱子里边拿出1个苹果，一次类推，然后将拿出来的苹果称一次，得到一个斤两数，根据斤两数是可以区分出来那个箱子装了9两1个的苹果的。当时，只是有这个想法，没有具体的做法，然后面试官问我，怎么区分，我说的比较模糊，他就问我少1两是那个箱子，我就说是1号箱子，一次类推，然后这道题目就算过了，让我做下一道题（这里，我想说的是在面试过程中，有什么疑问，一定要询问面试官，要不然坑的就是自己）。剩下的题目忘记顺序了，就按照我的记忆来标记题号吧。 第三道是说，有5个人ABCDE，写程序输出5个人的排队的所有可能顺序。面试官拿出纸和笔让写，因为这比较基础，就开始写了。写了一会儿，可能嫌我写的慢了或者是时间快到了，就让我说思路，我就说用dfs枚举，大概说了下，就开始下一道题了。 第四道是一个栈的题目，让判定一个给定的括号序列是否匹配，这个序列由{,},(,)四中符号组成。当时看了下，就说出思路了。 第五道是让实现一个atoi函数，就是把一个字符串转换成一个整数，我问了下用不用考虑非法情况，面试官说不用，然后，我就开始写了，很快就写完了。 第六道题目是：有100个乒乓球，两个人轮流拿乒乓球，每个人最多拿5个球，最少拿1个球，拿到最后一个球的人获胜，你先拿，拿几个球才能保证获胜，策略是什么？了解博弈论的人都知道这是nim博弈的一种特殊情况，100%（5+1）为0时，先手输，否则，先手一定有赢的策略，先手先拿4个，假如后手拿x个，那么先手就拿6-x个，这样就能保证先手获胜。不懂博弈论的人可以采用另一种思路，想拿到第100个球，就必须拿到第94个球才能保证获胜；想拿到第94个球，就必须拿到第88个球才能保证获胜；。。。;依次类推，就得到先手必须拿走4个球。 问完后，看我是本科生就问了我考不考研，我说不考，问我什么原因，我说了下。然后，我问了下结果什么时候出来之类的就出来了。这次感觉比一面好多了，除了第一道题目，其他的都答的不错。果然，在中午12点左右，我查微信状态的时候，状态已将变成了HR面试环节了。然后就是漫长的等待了，也一直没有发通知，到了官网上说的面试的最后一天，我坐不住了，去现场问了下情况，说是第二天还有面试，我就又回来继续等待了，等了一天左右吧，面试的前一天晚上给我发了短信，让我去面试，到了才发现，我应该是这个HR的倒数第三个面试者，我之前有一个人正在面试，我就站在门口听（感觉好无耻），听的过程中，也想了下自己的回答。 HR面试，其实就是了解下你自己的性格，价值观之类的，不会问你技术的问题的。面我的HR刚开始也是让自我介绍，这次，我想了另外一个版本的。自我介绍完后，就开始问我家庭情况，父母对自己的态度，自己最成功和最失败的事是什么，感觉大学和高中的区别是什么，上大学后收获最大的是什么，自己对自己的评价，工作城市，录取后要去的部门，为什么想进这个部门，还有没有其他的实习机会，如果都得到了offer，怎么选择，最后，让我问问题，我问了些转正，面试结果等方面的问题，然后就结束了，总共聊了大概45分钟左右，感觉还不错。 面完HR后，虽然说不怎么刷人，但是也是很担心，在T派上找到了一个西安等offer的群，加了进去，也关注着其他人的情况，发现基本都是这个状况，我也就不那么担心了，后来，还有个人把西安HR领队的拉进群里了，解答了好多问题。等了3天吧，收到了签约的短信，过了几个小时，收到了深圳打来的电话，就是确认下信息啥的。到这里总算结束了。 等腾讯offer的过程中，还去阿里面了一下，刚好腾讯和阿里面试的地点只隔了一条马路，很近。可能是腾讯的面试太过顺利，把rp都用完了，阿里的面试就有点坑了。阿里一面就跪了。下面大致介绍一下阿里的面试经历。 面试的基本流程也差不多，不过，阿里的组织感觉没有腾讯做的好，有人说，阿里面试的地方就像一个菜市场，阿里面试的地方是一个大厅，里边摆了好多桌子，距离差不多刚刚好，而且，说话基本上是可以听见的；而腾讯是在面试官住的房间里边面试的，感觉要好一点吧。 面试的时候，也是先让做自我介绍（和之前面腾讯的版本差不多），然后，就开始问我问题，看我简历上说了用过linux，就开始问我关于linux的问题，问我linux程序加载进内存后，有哪些区域，我大概说了下有代码区，静态存储区，栈区，为进程私有，地址向下生长，大小一般为1M左右，堆区，为进程共享，地址向上生长，可分配的内存理论上要无限大，取决于物理内存的大小（这里我说错了，当时面试官指出，每个进程要有一个虚拟的地址空间，这个地址空间要和字长对应，堆的大小要取决于字长），还说了局部变量在进入作用域自动在栈区分配，超出作用域自动回收，而堆区需要使用malloc等函数手动申请，使用free函数手动释放。然后，问我了一下关于计算机存储结构的问题，说CPU速度很快，而硬盘读写很慢，问我在存储方面，CPU读取数据的访问顺序是什么，我表示顺序为：寄存器-&gt;缓存-&gt;内存-&gt;硬盘；关于缓存，没有说明缓存的分级，经过提醒才想到有一级缓存，二级缓存，三级缓存，还问我这些存储器的访问时间的差距大概有多大，我就大概说了下，他问我是了解过具体的数字，还是只有这个概念，不能定量确定，我说是只有概念，不能确定准确的差距；最后问我知道哪些外存的形式，我说普通硬盘7200转，5400转的，还有SSD，光盘，U盘等；然后，问我有没有了解过多核系统的问题，我说没有了解过，这个阶段基本就结束了。 接下来问我做过什么项目没有，我说在linux下用c语言写过用curl抓取网页的东西，解析html，存到数据库里；还写过用curl库模拟http登陆，提交表单之类的程序。我说其中用到了一些linux系统调用。问了项目中一些具体的细节，我说是用linux系统调用实现的。 下面就问我用什么编程工具，我说在linux用vim，gcc，gdb，makefile等，就问我关于gdb的命令，我大概说了下，说完后，就问我有没有想过gdb是怎么实现的，我当时说了半天也没说清楚，然后他给提示说操作系统有什么东西可以使程序停下来，暗示了好久，我才意识到时中断。接下来问我有没有看过linux内核源代码，我说没有。然后，他就问我有没有学过目前比较流行的技术之类的，也没明确说什么技术，自己也确实没学过，就说没有，然后说感觉要先打好基础，然后再去接触一些比较高级的技术。前面关于技术的差不多就问到这里了，下来想想感觉真是被虐成狗，不过当时面试官也挺和气的，感觉也没怎么糟。 问完技术就让我写代码了。第一题是写一个宏，求一个结构体类型中指定的成员在这个结构体中的偏移量。当时想了一会，没有思路，面试官说，这是linux内核中的一个宏，给定一个结构体类型，和一个这个结构体中的成员名，返回偏移量，还解释说，linux内核中的结构体是很大的，有时候只知道结构体中成员的地址，想要知道整个结构体的地址，就要使用这个宏。下面是我根据面试官的说法写的，还真是这样。具体思路是，将0强制转换成这个结构体的指针，来访问这个结构体中的成员，然后，取这个成员的地址，得到的就是成员相对结构体起始的偏移量，不过，按照这个宏，貌似是访问了地址为0的空间，但起始编译器是聪明的，不会真的去访问，而是根据结构体在内存中的内存布局直接得到偏移量就ok了，OFFSET宏定义如下，注意运算符的优先级：12345678910111213141516171819#include &lt;stdio.h&gt;#define OFFSET(type, field) (&amp;((type *)0)-&gt;field)struct Node &#123; int a; char b; short c; char *d;&#125;; int main(int argc, char *argv[])&#123; printf(\"%p\\n\", OFFSET(struct Node, a)); printf(\"%p\\n\", OFFSET(struct Node, b)); printf(\"%p\\n\", OFFSET(struct Node, c)); printf(\"%p\\n\", OFFSET(struct Node, d)); return 0;&#125; 第二个题目是给定一个二叉树，判断给定的二叉树是不是一个二叉搜索树（BST），当时脑抽了，认为BST就是一个节点的左子节点小于这个节点，右子节点大于这个节点就行了，然而，其实是一个节点的左子树的所有节点都小于这个节点，右子树的所有结点都大于这个节点。我是按照第一种方法写的，当然是错的，后来经过提示，意识到错了，纠正了之后，问我有一个BST要得到一个升序序列，是什么遍历，我说了好几次，才说是中序遍历，其实一个判定一个二叉树是不是BST，就只需要中序遍历，记录前一个节点的值就行了，和现在访问的比较，只要全部小于就是一个BST。真是对二叉树的理解还是不够深入。不过感觉leetcode里应该会用很多这样的题目。 第三个题是一个函数指针的题。相对来说比较简单，让写一个函数指针，这个函数指针指向一个有两个int参数，返回一个char指针的函数。写函数指针有一种技巧，就是先写这样一个函数f，最后将函数名替换为(*pf)就行了，这个方法是在C primer中提到的。这个答案如下：1char *(*pf)(int a, int b); 做完题目，就结束了，让我问问题，我就问面试结果什么时候出来，他说在外边等着。然后我就在外边等通知，等了差不多30分钟，还没见消息，这时看到了面试指引，上边说如果面试完10分钟没有消息，就到签到处询问，我去问了，然后就说，今天的面试已经结束，你可以走了，当时就知道是被刷掉了，走后，过了2个小时左右，收到了短信，说面试已经结束，在网站上查的状态是待回绝，就知道是挂了。不过阿里比腾讯好的一点是当时就可以知道结果，不用等那么长时间，反正感觉等消息最蛋疼了。 经过这两次面试，大致也知道了自己在哪些方面的不足，从总也学习到了不少的面试经验，感觉也是不错的。 最后，就是说，去面试一定要有自信，要抱着挑战自我，挑战offer的心态去面试。","categories":[{"name":"面试","slug":"面试","permalink":"https://gwq5210.com/categories/面试/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://gwq5210.com/tags/面试/"},{"name":"腾讯","slug":"腾讯","permalink":"https://gwq5210.com/tags/腾讯/"},{"name":"阿里","slug":"阿里","permalink":"https://gwq5210.com/tags/阿里/"}],"keywords":[{"name":"面试","slug":"面试","permalink":"https://gwq5210.com/categories/面试/"}]}]}