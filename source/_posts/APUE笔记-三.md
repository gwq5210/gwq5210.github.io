title: APUE笔记-三
date: 2022-07-19 17:03:04
tags: [unix, linux, 读书笔记, APUE]
---

# 第八章 进程控制

## 进程标识

每个进程都有一个非负整型表示的唯一进程ID。虽然是唯一的，但是进程ID是可复用的，当一个进程终止后，其进程ID就成为复用的候选者，大多数UNIX系统实现延迟算法，使得赋予新建进程的ID不同于最近终止进程所使用的ID

系统中有一些专用进程，但是具体细节随实现而不同。ID为0的进程通常是调度进程，常常被称为交换进程（swapper），该进程是内核的一部分，它并不执行任何磁盘上的程序，因此也被称为系统进程。进程ID 1通常是init进程，init进程绝不会终止，它是一个普通的用户进程，但是他以超级用户特权运行。init会成为孤儿进程的父进程

下列函数返回进程的标识符

```cpp
#include <unistd.h>

pid_t getpid(void);  // 返回调用进程的进程ID
pid_t getppid(void);  // 返回调用进程的父进程ID
uid_t getuid(void);  // 返回调用进程的实际用户ID
uid_t geteuid(void);  // 返回调用进程的有效用户ID
gid_t getgid(void);  // 返回调用进程的实际组ID
gid_t getegid(void);  // 返回调用进程的有效组ID
```

以上函数都没有出错返回

## 函数fork

一个现有的进程可以调用fork函数创建一个新进程

```cpp
#include <unistd.h>

pid_t fork(void);

子进程返回0，父进程返回子进程Id；若出错，返回-1
```

由fork创建的新进程被称为子进程（child process），fork函数被调用一次，但返回两次。两次返回的区别是子进程的返回值是0，而父进程的返回值则是新建子进程的进程ID。一个进程的子进程可以有多个，但并没有一个函数使一个进程可以获得其所有子进程的进程ID。子进程ID不可能为0，因为进程ID 0总是由内核交换进程使用

子进程和父进程继续执行fork调用之后的指令。子进程是父进程的副本。例如，子进程获得父进程数据空间、堆和栈的副本。注意，这是子进程所拥有的副本，父进程和子进程并不共享这些存储空间部分。父进程和子进程共享正文段

由于在fork之后经常跟着exec，所以现在的很多实现并不执行一个父进程数据段、栈和堆的完全副本。作为代替，使用了写时复制（Copy-On-Write，COW）技术。这些区域由父进程和子进程共享，而且内核将它们的访问权限改变为只读。如果父进程和子进程中的任一个试图修改这些区域，则内核只为修改区域的那块内存制作一个副本，通常是虚拟存储系统中的一页

Linux 3.2.0提供clone系统调用，是fork的推广形式，允许调用者控制哪些部分由父进程和子进程共享

一般来说，在fork之后是父进程先执行还是子进程先执行是不确定的，这取决于内核所使用的调度算法。如果要求父进程和子进程之间相互同步，则要求某种形式的进程间通信

fork之后标准IO库的缓存区也被复制，如果缓冲区中存在数据，则在子进程中也存在相应的数据，可能会输出两次

### 文件共享

重定向父进程的标准输出时，子进程的标准输出也被重定向。实际上fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中，就好像对每个文件描述符来说，执行了dup函数，父进程和子进程每个相同的打开描述符共享一个文件表项。

重要的一点是父进程和子进程共享同一个文件偏移量。如果不共享，则要实现父子进程都写到同一个文件则要困难的多。但如果父进程和子进程写同一描述符指向的文件，但又没有任何形式的同步，那么它们的输出就会相互混合（假定所用的描述符是在fork之前打开的），但这并不是常用的操作模式

![fork之后父进程和子进程之间对打开文件的共享](https://gwq5210.com/images/fork之后父进程和子进程之间对打开文件的共享.png)

在fork之后，处理文件描述符有以下两种常见的情况

- 父进程等待子进程完成。这种情况下，父进程无需对其描述符做任何处理。当子进程终止后，它曾进行过读、写操作的任一共享描述符的文件偏移量已做了相应更新
- 父进程和子进程各自执行不同的程序段。这种情况下，在fork之后，父进程和子进程各自关闭它们不需使用的文件描述符，这样就不会干扰对方使用的文件描述符。这种方法是网络服务进程经常使用的

除了打开文件之外，父进程的很多其他属性也由子进程继承

- 实际用户ID、实际组ID、有效用户ID、有效组ID
- 附属组ID
- 进程组ID
- 会话ID
- 控制终端
- 设置用户ID标志和设置组ID标志
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 对任一打开文件描述符的执行时关闭（close-on-exec）标志
- 环境
- 连接的共享存储段
- 存储映像
- 资源限制

父进程和子进程之间的区别如下

- fork的返回值不同
- 进程ID不同
- 这两个进程的父进程ID不同：子进程的父进程ID是创建它的进程ID，而父进程的父进程ID则不变
- 子进程的tms_utime、tms_stime、tms_cutime和tms_ustime的值设置为0
- 子进程不继承父进程设置的文件锁
- 子进程的未处理闹钟被清除
- 子进程的未处理信号集设置为空

fork失败的两个主要原因是

- 系统中已经有了太多的进程（通常意味着某个方面除了问题）
- 该实际用户ID的进程总数超过了系统限制

fork有以下两种用法

- 一个父进程希望复制自己，使父进程和子进程同时执行不同的代码段。这在网络服务进程中是常见的——父进程等待客户端的服务请求。当这种请求到达时，父进程调用fork，使子进程处理此请求。父进程则继续等待下一个服务请求
- 一个进程要执行一个不同的程序。这对shell是常见的。在这种情况下，子进程从fork返回后立即调用exec

某些操作系统将第二种用法中的两个操作组合成一个操作，称为spawn，UNIX将这两个操作分开，使得子进程在fork和exec之间可以更改自己的树形，如IO重定向、用户ID、信号安排等

## 函数vfork

vfork函数的调用序列和返回值与fork相同，但两者的语义不同

vfork函数用于创建一个新进程，而该新进程的目的是exec一个新程序。vfork和fork一样都创建一个子进程，但是它并不将父进程的地址空间完全复制到子进程中，因为子进程会立即调用exec或exit，于是也就不会引用该地址空间。

不过在子进程调用exec或exit之前，它在父进程的空间运行，这种优化工作方式在某些UNIX系统的实现中提高了效率，但如果子进程修改数据（除了用于存放vfork返回值的变量）、进行函数调用、或者没有调用exec或exit就返回都可能带来未知的结果。

vfork和fork之间的另一个区别是：vfork保证子进程先运行，在它调用exec或exit之后父进程才可能被调度运行，当子进程调用这两个函数的任意一个时，父进程会恢复运行。如果在调用这两个函数之前，子进程依赖于父进程的进一步动作，则会导致死锁

## 函数exit

进程5种正常终止方式如下

- 在main函数内执行return语句，这等效于调用exit
- 调用exit函数。此函数由ISO C定义，其操作包括调用各终止处理程序（调用atexit登记），然后关闭所有标准IO流等。因为ISO C并不处理文件描述符、多进程（父进程和子进程）以及作业控制，所以这一定义对UNIX系统而言是不完整的
- 调用_exit和_Exit函数。ISO C定义_Exit函数其目的是为进程提供一种无需运行终止处理程序或信号处理程序而终止的方法。对于标准IO流是否进行冲洗，这取决于实现。在UNIX系统中_Exit和_exit是同义的，并不冲洗标准IO流。_exit函数由exit调用，它处理UNIX系统特定的细节。大多数UNIX系统实现中，exit是C库的一个函数，_exit是一个系统调用
- 进程的最后一个线程在其启动例程中执行return语句。但是，该线程的返回值不用做进程的返回值。当最后一个线程从其启动例程返回时，该进程以终止状态0返回
- 进程的最后一个线程调用pthread_exit函数。如同前面一样，在这种情况中，进程终止状态总是0，这与传送给pthread_exit的参数无关

3种异常终止具体如下

- 调用abort。它产生SIGABRT信号，这是下一种异常终止的一种特例
- 当进程接收到某些信号时。信号可由进程自身（如调用abort函数）、其他进程或内核产生
- 最后一个线程对“取消”（cancellation）请求做出相应。默认情况下，“取消”以延迟方式发生：一个线程要求取消另一个线程，若干时间之后，目标线程终止

不管进程如何终止，最后都会执行内核中的同一段代码。这段代码为相应进程关闭所有打开描述符，释放它所使用的存储器

上述任意一种终止情形，我们都希望终止进程能够通知其父进程它是如何终止的。对于3个终止函数（exit、_exit和_Exit），实现这一点的方法是，将其退出状态（exit status）作为参数传递给函数。在异常终止情况，内核（不是进程本身）产生一个指示其异常终止原因的终止状态（termination status）。在任意一种情况下，该终止进程的父进程都能用wait和waitpid函数取得其终止状态

子进程是父进程调用欧冠fork之后生成的。上面又说明了子进程将其终止状态返回给父进程。但是如果父进程在子进程之前终止，又将如何呢？其回答是：对于父进程已经终止的所有进程，它们父进程都改变为init进程。我们称这些进程由init进程收养。其操作过程大致是：在一个进程终止时，内核逐个检查所有活动进程，以判断它是否是正要终止进程的子进程，如果是，则该进程的父进程ID就更改为1（init的进程ID），这种处理方法保证了每个进程有一个父进程

另一个我们关心的情况是，如果子进程在父进程之前终止，那么父进程又如何能在做相应检查时得到子进程的终止状态呢？如果子进程完全消失了，父进程在最终准备好检查子进程是否终止时是无法获取它的终止状态的。内核为每个终止子进程保存了一定量的信息，所以当终止进程的父进程调用wait或waitpid时可以得到这些信息。这些信号至少包括进程ID、该进程的终止状态以及该进程使用的CPU时间总量。内核可以释放终止进程所使用的所有存储区，关闭其所有打开文件。在UNIX系统术语中，一个已经终止、但是其父进程尚未对其进行善后处理（获取终止子进程的有关信息、释放它仍占用的资源）的进程被称为僵死进程（zombie）。ps命令将僵死进程的状态打印为Z。如果一个长期运行的程序，它fork了很多子进程，那么除非父进程等待取得子进程的终止状态，不然这些子进程终止后就会变成僵死进程

被init收养的进程不会变成僵死进程。因为init进程在子进程终止时会调用wait函数取得其终止状态

## 函数wait和waitpid

当一个进程正常或异常终止时，内核就向其父进程发送SIGCHLD信号。因为子进程终止是一个异步事件（这可以在父进程运行的任何时候发生），所以这种信号也是内核向父进程发的异步通知。父进程可以选择忽略该信号，或者提供一个该信号发生时即被调用执行的函数（信号处理程序）。对于这种信号的系统默认动作是忽略它。

调用wait或waitpid的进程可能发生如下情况

- 如果其所有子进程都还在运行，则阻塞
- 如果一个子进程已终止，正等待父进程获取其状态，则取得该子进程的终止状态立即返回
- 如果它没有任何子进程，则立即出错返回

如果进程由于接收到SIGCHLD信号而调用wait，我们期望wait会立即返回。但是如果在随机时间点调用wait，则进程可能会阻塞

```cpp
#include <sys/wait.h>

pid_t wait(int* statloc);
pid_t waitpid(pid_t pid, int* statloc, int options);

若成功，返回进程ID；若出错，返回0或-1
```

这两个函数的区别如下

- 在一个子进程终止前，wait使其调用者阻塞，而waitpid有一个选项，可使调用者不阻塞
- waitpid并不等待在其调用之后的第一个终止子进程，它有若干个选项，它可以控制它所等待的进程

如果子进程已经终止，并且是一个僵死进程，则wait立即返回并取得该子进程的状态；否则wait使其调用者阻塞，直到一个子进程终止。如果调用者阻塞而且它有多个子进程，则在其某一子进程终止时，wait就立即返回。因为wait返回终止子进程的进程ID，所以它总能了解是哪个子进程终止了

statloc是一个整型指针。如果statloc不是一个空指针，则终止进程的终止状态就存放在statloc中，如果不关心终止状态，则可以将该参数设置为空指针

依据传统，这两个函数返回的整型状态字是由实现定义的，终止状态使用如下宏来查看

![终止状态的宏](https://gwq5210.com/images/终止状态的宏.png)

如果需要等待一个指定进程终止，在早期的UNIX系统中，必须调用wait，然后将其返回的进程ID和所期望的进程ID相比较。如果终止进程不是所期望的，则该进程ID和终止状态保存起来，然后再次调用wait，反复调用直到指定进程终止，下一次又想等待一个特定进程时，先查看已终止的进程列表或继续调用wait。

waitpid可以实现这一功能及其他功能，根据pid参数，作用如下

- pid等于-1：等待任一子进程。此种情况下，waitpid和wait等效
- pid大于0：等待进程ID与pid相等的子进程
- pid等于0：等待组ID等于调用进程组ID的任一子进程
- pid小于-1：等待组ID等于pid绝对值的任一子进程

对于wait其唯一的出错是调用进程没有子进程（函数调用被一个信号中断时，也可能返回另一种出错）。但是对于waitpid，如果指定的进程或进程组不存在，或者参数pid指定的进程不是调用进程的子进程，都可能出错

参数options可以进一步控制waitpid的操作，此参数或者是0或者是如下常量按位或运算的结果

![waitpid的options参数](https://gwq5210.com/images/waitpid的options参数.png)

waitpid提供了wait函数没有的3个功能

- waitpid可等待一个特定的进程，而wait则返回任一终止子进程的状态
- waitpid提供了一个wait的非阻塞版本
- wait通过WUNTRACED和WCONTINUED选项支持作业控制

如果一个进程fork一个子进程，但不要它等待子进程终止，也不希望子进程处于僵死状态知道父进程终止，实现这一要求的诀窍是调用fork两次，子进程的子进程会被init收养

## 函数waitid

Single UNIX Specification包括了另一个取得进程终止状态的函数waitid，此函数类似于waitpid，但提供了更多的灵活性

```cpp
#include <sys/wait.h>

int waitid(idtype_t idtype, id_t id, siginfo_t* infop, int options);

若成功，返回0；若出错，返回-1
```

与waitpid类似，waitid允许一个进程指定要等待的子进程。但它使用两个单独的参数表示要等待的子进程所属的类型，而不是将此与进程ID或进程组ID组合成一个参数

idtype类型如下

![waitid的idtype常量](https://gwq5210.com/images/waitid的idtype常量.png)

options是以下各标志的按位或运算，这些标志指示调用者关注哪些状态变化

![waitid的options常量](https://gwq5210.com/images/waitid的options常量.png)

WCONTINUED、WEXITED或WSTOPPED这三个常量之一必须在options参数中指定

infop是指向siginfo结构的指针，该结构包含了造成子进程进程状态改变有关信号的详细信息

## 函数wait3和wait4

大多数UNIX系统实现提供了另外两个函数wait3和wait4。该函数允许内核返回由终止进程机器所有子进程使用的资源概况

```cpp
#include <sys/types.h>
#include <sys/wait.h>
#include <sys/time.h>
#include <sys/resource.h>

pid_t wait3(int* statloc, int options, struct rusage* rusage);
pid_t wait4(pid_t pid, int* statloc, int options, struct rusage* rusage);

若成功，返回进程ID；若出错，返回-1
```

资源统计信息包括用户CPU时间总量、系统CPU时间总量、缺页次数、接收到信号的次数等。可以参考getrusage(2)手册页

## 竞争条件

当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，我们认为发生了竞争条件（race condition）。fork之后无法确定哪个进程先运行，因此需要某种形式的同步

如果一个进程需要等待其父进程终止，则可使用下列形式的循环

```cpp
while (getppid() != 1) {
  sleep(1);
}
```

这种形式的循环称为轮询（polling），它的问题是浪费了CPU的时间

为了避免竞争条件和轮询，在多个进程间需要某种形式的信号发送和接收的方法，比如使用信号和各种形式的进程间通信

## 函数exec

fork函数创建新的子进程后，子进程往往要调用一种exec函数以执行另一个程序。当进程调用一种exec函数时，该进程执行的程序完全替换为新程序，而新程序则从其main函数开始执行。

调用exec并不创建新进程，其进程ID并不会改变。exec只是用磁盘上的一个新程序替换了当前进程的正文段、数据段、堆段和栈段

有7中不同的exec函数，常常被统称为exec函数。

fork可以创建新进程，用exec可以初始执行新的程序。exit函数和wait函数处理终止和等待终止，这是我们需要的基本进程控制原语。我们可以用这些原语构造另外一些如popen和system之类的函数

```cpp
#include <unistd.h>

int execl(const char* pathname, const char* arg0, ... /* (char*)0 */);
int execv(const char* pathname, char* const argv[]);
int execle(const char* pathname, const char* arg0, ..., /* (char*)0, */ char* const envp[]);
int execve(const char* pathname, char* const argv[], char* const envp[]);
int execlp(const char* filename, const char* arg0, ... /* (char*)0 */);
int execvp(const char* filename, char* const argv[]);
int fexecve(int fd, char* const argv[], char* const envp[]);
```

这些函数之间的第一个区别是前4个函数取路径名作为参数，后两个函数则取文件名作为参数，最后一个取文件描述符作为参数。当指定filename作为参数时：

- 如果filename包含/，则就将其视为路径名
- 否则就按PATH环境变量，在它所指定的各目录中搜寻可执行文件

如果execlp或execvp使用路径前缀中的一个找到了一个可执行文件，但是该文件不是由连接编辑器产生的可执行文件，则就认为该文件是一个shell脚本，于是试着调用/bin/sh，并以该filename作为shell输入

fexecve函数避免了寻找正确的可执行文件，而是依赖调用进程来完成这项工作。调用进程可以使用文件描述符验证所需文件并且无竞争的执行该文件

第二个区别与参数表的传递相关（l表示list，v表示矢量vector）。函数execl、execlp和execle要求将新程序的每个命令行参数都说明为一个单独的参数。这种参数表以空指针结尾。对于另外四个函数，则应先构造一个指向各参数的指针数组，然后将该数组地址作为这4个函数的参数

最后一个区别与向新程序传递环境表相关。以e结尾的3个函数可以传递一个指向环境字符串指针数组的指针。其他4个函数则使用调用进程中的environ变量为新程序复制现有的环境。通常一个进程允许将其环境传播给其子进程，但有时也有这种情况，进程想要为子进程指定某一个确定的环境

函数名中的字符会给我们一些记忆的帮助。字母p表示该函数取filename作为参数，并且用PATH环境变量寻找可执行文件。字母l表示该函数取一个参数表，它与字母v互斥。v表示该函数取一个`argv[]`矢量。最后字母e表示该函数取`envp[]`数组，而不使用当前环境变量

![7个exec函数之间的区别](https://gwq5210.com/images/7个exec函数之间的区别.png)

每个系统对参数表和环境表的总长度都有一个限制。这种限制是由ARG_MAX给出的，此值至少是4096字节

执行exec后，进程ID没有改变，但新程序从调用进程继承了下列属性

- 进程ID和父进程ID
- 实际用户ID和实际组ID
- 附属组ID
- 进程组ID
- 会话ID
- 控制终端
- 闹钟尚余留的时间
- 当前工作目录
- 根目录
- 文件模式创建屏蔽字
- 文件锁
- 进程信号屏蔽
- 资源限制
- nice值
- tms_utime、tms_stime、tms_cutime以及tms_cstime值

对打开文件的处理与每个描述符的执行时关闭（close-on-exec）标志值有关。若设置了该标志，则在执行exec时关闭该描述符；否则该描述符仍打开。除非特地的用fcntl设置了该执行时关闭标志，否则系统的默认操作是在exec后仍保持这种描述符打开
