title: APUE笔记-五
date: 2022-07-29 15:08:47
tags: [unix, linux, 读书笔记, APUE]
---

# 第十四章 高级IO

## 非阻塞IO

系统调用可分成两类：“低速”系统调用和其他。低速系统调用是可能会使进程永远阻塞的一类系统调用，包括

- 如果某些文件类型（如读管道、终端设备和网络设备）的数据并不存在，读操作可能会使调用者永远阻塞
- 如果数据不能被相同的文件类型立即接受（如管道中无空间，网络流控制），写操作可能会使调用者永远阻塞
- 在某种条件发生之前打开某些文件类型可能会发生阻塞（如要打开一个终端设备，需要先等待与之连接的调制解调器应答，又如若以只读模式打开FIFO，那么在没有其他进程已用读模式打开该FIFO时也要等待）
- 对已经加上强制性记录锁的文件进行读写
- 某些ioctl操作
- 某些进程间通信函数

虽然读写磁盘文件会暂时阻塞调用者，但并不能将与磁盘IO有关的系统调用视为“低速”

非阻塞IO使我们可以发出open、read和write这样的IO操作，并使这些操作不会永远阻塞。如果这种操作不能完成，则调用立即出错返回，表示该操作如继续执行将阻塞。设置阻塞方法如下

- 如果调用open获得描述符，则可指定O_NONBLOCK标志
- 对于已经打开的一个描述符，则可调用fcntl，由该函数打开O_NONBLOCK文件状态标志。

## 记录锁

记录锁（record locking）的功能是：当一个进程正在读或修改文件的某个部分时，使用记录锁可以阻止其他进程修改同一文件区。对于UNIX系统而言，“记录”这个词是一个误用，因为UNIX系统内核根本没有使用文件记录这个概念。一个更适合的术语可能是字节范围锁（byte-range locking），因为它锁定的只是文件中的一个区域（也可能是整个文件）

POSIX.1使用fcntl来创建记录锁

```cpp
#include <fcntl.h>

int fcntl(int fd, int cmd, .../* struct flock* flockptr */);

若成功，返回值依赖于cmd；若出错，返回-1
```

对于记录锁，cmd是F_GETLK、F_SETLK或F_SETLKW。第三个参数（我们将调用flockptr）是一个指向flock结构的指针

```cpp
struct flock {
  short l_type;  // F_RDLCK, F_WRLCK or F_UNLCK
  short l_whence;  // SEEK_SET, SEEK_CUR or SEEK_END
  off_t l_start;  // offset in bytes, relative to l_whence
  off_t l_len;  // length, in bytes; 0 means lock to EOF
  pid_t l_pid;  // returned with F_GETLK
};
```

- 进程的ID（l_pid）持有的锁能阻塞当前进程（仅有F_GETLK返回）
- 锁可以在当前文件尾端处开始或者越过尾端处开始，但是不能在文件起始位置之前开始
- 如若l_len为0，则表示锁的范围可以扩展到最大可能偏移量。这意味着不管向该文件中追加写了多少数据，它们都可以处于锁的范围内（不必猜测会有多少字节被追加写到了文件之后），而且起始位置可以是文件中的任意一个位置
- 为了对整个文件加锁，我们设置l_start和l_whence指向文件的起始位置，并且指定长度（l_len）为0

![不同类型锁彼此之间的兼容性](https://gwq5210.com/images/不同类型锁彼此之间的兼容性.png)

上述兼容性规则适用于不同进程提出的锁请求，并不适用于单个进程提出的多个锁请求。如果一个进程对一个文件区间已经有了一把锁，后来该进程又企图在同一文件区间再加一把锁，那么新锁将替换已有锁。加读锁时，该描述符必须是读打开的。加写锁时，该描述符必须是写打开的

fcntl的三个命令如下

- F_GETLK：判断由flockptr所描述的锁是否会被另外一把锁所排斥（阻塞）。如果存在一把锁，它阻止创建由flockptr所描述的锁，则该现有锁的信息将重写flockptr指向的信息。如果不存在这种情况，则除了将l_type设置为F_UNLCK之外，flockptr所指向结构中的其他信息保持不变
- F_SETLK：设置由flockptr所描述的锁。如果我们试图获得一把读锁（l_type为F_RDLCK）或写锁（l_type为F_WRLCK），而兼容性规则阻止系统给我们这把锁，那么fcntl会立即出错返回，此时errno设置为EACCES或EAGAIN。此命令也用来清除由flockptr指定的锁（l_type为F_UNLCK）
- F_SETLKW：这个命令是F_SETLK的阻塞版本，W表示wait。如果锁请求的读锁或写锁因另一个进程当前已经对所请求区域的某部分进行了加锁而不能被授予，那么调用进程会被设置为休眠。如果请求创建的锁已经可用，或者休眠由信号中断，则该进程被唤醒

应当了解，用F_GETLK测试能否建立一把锁，然后用F_SETLK或F_SETLKW企图建立那把锁，这两者不是一个原子操作。因此不能保证在这两次fcntl调用之间会不会有另一个进程插入并建立一把相同的锁。如果不希望在等待锁变为可用时产生阻塞，就必须处理由F_SETLK返回的可能的出错

在设置或释放文件上的一把锁时，系统按要求组合或分裂相邻区。

![文件字节范围锁](https://gwq5210.com/images/文件字节范围锁.png)

由于F_GETLK命令返回是否有现有的锁阻止调用进程设置它自己的锁。因为F_SETLK和F_SETLKW命令总是替换调用进程现有的锁（若已存在），所以调用进程决不会阻塞在自己持有的锁上，于是，F_GETLK命令决不会报告调用进程自己持有的锁

如果两个进程互相等待对方持有并且不释放（锁定）的资源时，则这两个进程就处于死锁状态。检测到死锁时，内核必须选择一个进程接收出错返回。

### 锁的隐含继承和释放

- 锁与进程和文件两者相关联。第一，当一个进程终止时，它所建立的锁全部释放；第二，无论一个描述符何时关闭，该进程通过这一描述符所引用的文件上的任何一把锁都会释放（这些锁都是该进程设置的）

```cpp
// close(fd2)之后，在fd1上设置的锁被释放
fd1 = open(pathname, ...);
read_lock(fd1, ...);
fd2 = dup(fd1);
close(fd2);

fd1 = open(pathname, ...)
read_lock(fd1, ...);
fd2 = open(pathname, ...)
close(fd2)
```

- 由fork产生的子进程不继承父进程锁设置的锁。这意味着，若一个进程得到一把锁，然后调用fork，那么对于父进程获得的锁而言，子进程被视为另一个进程。对于通过fork从父进程处继承过来的描述符，子进程需要调用fcntl才能获取它自己的锁。这个约束是有道理的，因为锁的作用是阻止多个进程同时写同一个文件。如果子进程通过fork继承父进程的锁，则父进程和子进程就可以同时写同一个文件
- 在执行exec后，新程序可以继承原执行程序的锁。但是注意，如果对一个文件描述符设置执行时关闭标志，那么当作为exec的一部分关闭该文件描述符时，将释放相应文件的所有锁

### 记录锁的实现

```cpp
fd1 = open(pathname, ...);
write_lock(fd1, 0, SEEK_SET, 1);  // parent write locks byte 0
if ((pid = fork()) > 0) {  // parent
  fd2 = dup(fd1);
  fd3 = open(pathname, ...);
} else if (pid == 0) {
  read_lock(fd1, 1, SEEK_SET, 1);  // child read locks byte 1
}
pause();
```

![记录锁的数据结构](https://gwq5210.com/images/记录锁的数据结构.png)

在v节点上有lockf结构，lockf结构描述了一个给定进程的一个加锁区域。关闭描述符时，内核会从该描述符所关联的i节点开始，逐个检查lockf链表中的各项，并释放由调用进程持有的各把锁。内核并不清楚（也不关心）是又哪一个描述符来设置的这把锁

### 在文件尾端加锁

在对相对于文件尾端的字节范围加锁或解锁时需要特别小心。因为内核必须独立于当前文件偏移量或文件尾端而记住锁。

### 建议性锁和强制性锁

强制性锁会让内核检查每一个open、read和write，验证调用进程是否违背了正在访问的文件上的某一把锁。对一个特定文件打开其设置组ID位，关闭其组执行位便开启了对该文件的强制性锁机制。因为当组执行位关闭时，设置组ID位不再有意义。

强制性锁对unlink函数没有影响。因此可以删除原文件（已加强制性记录锁），然后将临时文件名改为原文件名。

## IO多路复用

IO多路复用，一般是需要构造一张我们感兴趣的描述符（通常都不止一个）的列表，然后调用一个函数，直到这些描述符中的一个已准备好几下IO时，该函数才返回。poll、pselect和select来完成这个工作，从这些函数返回时，进程会被告知哪些描述符已经准备好可以进行IO

### 函数select和pselect

传给select的参数告诉内核

- 我们所关心的描述符
- 对于每个描述符我们所关心的条件（读、写和异常条件）
- 愿意等待多长时间（可以永远等待、等待一个固定的时间或根本不等待）

从select返回时，内核告诉我们

- 已准备好描述符的数量
- 对于读、写或异常这3个条件中的每一个，哪些描述符已准备好

使用这种返回信息，就可以调用相应的IO函数（read或write），并且确知该函数不会阻塞

```cpp
#include <sys/select.h>

int select(int maxfdp1, fd_set* restrict readfds, fd_set* restrict writefds, fd_set* restrict exceptfds, struct timeval* restrict tvptr);

返回准备就绪的描述符数目；若超时，返回0；若出错，返回-1
```

tvptr指定愿意等待的时间长度，单位是秒和微秒。可以指定永远等待、不等待或等待指定的时间

中间3个参数是指向描述符集的指针。分别指明读、写或异常条件的描述符集合。如果不关心相应条件，可以将参数设置为NULL，如果3个指针都为NULL，则select提供了精度更高的定时器

fd_set可以认为是一个bitmap。需要通过以下函数来进行操作

```cpp
#include <sys/select.h>

int FD_ISSET(int fd, fd_set* fdset);

若fd在描述符集中，返回非0值；否则，返回0

void FD_CLR(int fd, fd_set* fdset);
void FD_SET(int fd, fd_set* fdset);
void FD_ZERO(fd_set* fdset);
```

这些接口可以实现为宏或函数

maxfdp1的意思是最大文件描述符编号值加1。考虑所有3个描述符集，在3个描述符集中找出最大描述符编号值，然后加1，这就是第一个参数值。也可以将其设置为FD_SETSIZE，这是一个常量，指定最大描述符数，通常是1024。

返回值

- 返回-1表示出错
- 返回0表示没有描述符准备好。此时，所有的描述符集都会置0
- 一个正返回值说明了已经准备好的描述符数。该值是3个描述符中已准备好的描述符数之和，所以如果同一描述符已准备好读和写，那么在返回值中会对其计数两次。在这种情况下，3个描述符集中仍旧打开的位对应于已准备好的描述符

准备好含义如下

- 对于读，是进行read操作不会阻塞
- 对于写，是进行write操作不会阻塞
- 对于异常条件，是描述符有一个未决异常条件。包括：在网络连接上到达带外数据，或者在处于数据包模式的伪终端上发生了某些条件
- 对于读、写和异常条件，普通文件的文件描述符总是返回准备好

一个描述符阻塞与否并不影响select是否阻塞。如果在一个描述符上碰到了文件尾端，则select会认为该描述符是可读的。然后调用read，它返回0，这是UNIX系统指示到达文件尾端的方法（很多人错误的认为，到达文件尾端时，select会指示一个异常条件）

除以下几点外，pselect与select相同

- select的超时值用timeval结构指定，但pselect使用timespec结构
- pselect的超时值被声明为const，这就保证调用pselect不会改变此值，而select可能改变此值（取决于实现，如Linux 3.2.0将用剩余时间值更新该结构）
- pselect可使用可选的信号屏蔽字。若sigmask为NULL，则在信号有关的方面，pselect与select相同。否则sigmask指定信号屏蔽字，在调用pselect时，以原子操作的方式安装该信号屏蔽字。在返回时，恢复以前的信号屏蔽字

## 函数poll

poll函数类似select，但是程序员接口有所不同。poll函数可用于任何类型的文件描述符

```cpp
#include <poll.h>

int poll(struct pollfd fdarray[], nfds_t nfds, int timeout);

返回准备就绪的描述符数目；若超时，返回0；若出错，返回-1
```

与select不同，poll不是为每个条件构造一个描述符集，而是构造一个pollfd结构的数组，每个数组元素指定一个描述符编号以及我们对该描述符感兴趣的条件

```cpp
struct pollfd {
  int fd;  // file descriptor to check, or < 0 to ignore
  short events;  // events of interest on fd
  short revents;  // events that occurred on fd
};
```

应将每个数组元素的events成员设置为以下值的一个或几个，通过这些值告诉内核我们关心的是每个描述符的哪些事件。返回值revents成员由内核设置，用于说明每个描述符发生了哪些事件。poll不更改events成员

![poll的标志](https://gwq5210.com/images/poll的标志.png)

当一个描述符被挂断（POLLHUP）后，就不能再写该描述符，但是有可能仍然可以从该描述符读取到数据

timeout参数指定我们愿意等待多长时间。

理解文件尾端与挂断之间的区别是很重要的。如果我们正从终端输入数据，并键入文件结束符，那么就会打开POLLIN，于是我们就可以读文件结束指示（read返回0）。revents中的POLLHUP没有打开。如果正在调制解调器，并且电话线已挂断，我们将街道POLLHUP通知

与select一样，一个描述符是否阻塞不会影响poll是否阻塞

## 函数readv和writev

readv和writev函数用于在一次函数调用中读、写多个非连续缓冲区。有时也将这两个函数称为散布读（scatter read）和聚集写（gather write）

```cpp
#include <sys/uio.h>

ssize_t readv(int fd, const struct iovec* iov, int iovcnt);
ssize_t writev(int fd, const struct iovec* iov, int iovcnt);

返回已读或已写的字节数；若出错，返回-1
```

iovec结构如下

```cpp
struct iovec {
  void* iov_base;  // starting address of buffer
  size_t iov_len;  // size of buffer
};
```

iov数组中的元素数由iovcnt指定，其最大值受限于IOV_MAX。writev函数从缓冲区中聚集输出数据的顺序是：iov[0]、iov[1]直至iov[iovcnt-1]。writev返回输出的总字节数，通常应等于所有缓冲区长度之和

![iovec的结构](https://gwq5210.com/images/iovec的结构.png)


readv函数则将读入的数据按上述同样顺序散布到缓冲区中。readv总是先填满一个缓冲区，然后再填写下一个。readv返回读到的字节总数。如果遇到文件尾端，已无数据可读，则返回0

应当用尽量少的系统调用次数来完成任务。如果我们只写少量的数据，将会发现自己复制数据然后使用一次write会比用writev更合算。但也可能发现，我们管理自己的分段缓冲区会增加程序额外的复杂性成本，所以从性能成本的角度来看不合算

## 存储映射IO

存储映射IO（memory-mapped IO）能将一个磁盘文件映射到存储空间中的一个缓冲区上，于是，当从缓冲区中取数据时，就相当于读文件中的相应字节。与此类似，将数据存入缓冲区时，相应字节就自动写入文件。这样就可以在不使用read和write的情况下执行IO

为了使用这一功能，应首先告诉内核将一个给定的文件映射到一个存储区域中。这是由mmap函数实现的

```cpp
#include <sys/mmap.h>

void* mmap(void* addr, size_t len, int prot, int flag, int fd, off_t off);

若成功，返回映射区的起始地址；若出错，返回MAP_FAILED
```

addr参数用于指定映射存储区的起始位置。通常将其设置为0，这表示由系统选择该映射区的起始地址。此函数的返回值是该映射区的起始地址

fd参数是指定要被映射文件的描述符。在文件映射到地址空间之前，必须先打开该文件。len参数是映射的字节数，off是要映射字节在文件中的起始偏移量

prot参数指定了映射存储区的保护要求

- PROT_READ：映射区可读
- PROT_WRITE：映射区可写
- PROT_EXEC：映射区可执行
- PROT_NONE：映射区不可访问

可将参数prot指定为PROT_NONE，也可以指定为PROT_READ、PROT_WRITE和PROT_EXEC的任意组合的按位或。对指定映射存储区的保护要求不能超过文件open模式访问权限。例如，若该文件是只读打开的，那么对映射存储区就不能指定PROT_WRITE

映射存储区一般位于堆和栈之间：这属于实现细节，各种实现之间可能不同

flag参数如下

- MAP_FIXED：返回值必须等于addr。因为这不利于可移植性，所以不鼓励使用此标志。如果未指定此标志，而且addr非0，则内核只把addr视为在何处设置映射区的一种建议，但是不保证会使用所要求的地址。将addr指定为0可获得最大可移植性
- MAP_SHARED：这一标志描述了本进程对映射区所进行的存储操作的配置。此标志指定存储操作修改映射文件，也就是，存储操作相当于对该文件的write。必须指定本标志或下一个标志（MAP_PRIVATE），但不能同时指定两者
- MAP_PRIVATE：本标志说明，对映射区的存储操作导致创建该映射文件的一个私有副本。所有后来对该映射区的引用都是引用该副本。（此标志的一种用途是用于调试程序，它将程序文件的正文部分映射至存储区，但允许用户修改其中的指令。任何修改值影响程序文件的副本，而不影响原文件）

![存储映射文件的例子](https://gwq5210.com/images/存储映射文件的例子.png)


每种实现都可能还有另外一些MAP_XXX标志值，它们是那种实现所特有的。详细情况清参考手册

off的值和addr的值（如果指定了MAP_FIXED）通常被要求是系统虚拟存储页长度的倍数。虚拟存储页长可用带参数_SC_PAGESIZE或_SC_PAGE_SIZE的sysconf函数得到。因为off和addr常常指定为0，所以这种要求一般并不重要

既然映射文件的起始偏移量受系统虚拟存储页长度的限制，那么如果映射区的长度不是页长度的整数倍时，会怎么样呢？假定文件长度为12字节，系统页长为512字节，则系统通常提供512字节的映射区，其中后500字节被设置为0。可以修改后面的这500字节，但任何改动都不会在文件中反映出来。于是不能用mmap将数据添加到文件中。我们必须先加长该文件

与映射区相关的信号有SIGSEGV和SIGBUS。信号SIGSEGV通常用于指示进程试图访问对它不可用的存储区。如果映射存储区被mmap指定成了只读的，那么进程试图将数据存入这个映射存储区的时候，也会产生此信号。如果映射区的某个部分在访问时已不存在，则产生SIGBUS信号。例如，假设用文件长度映射了一个文件，但在引用该映射区之前，另一个进程已将该文件截断。此时，如果进程试图访问对应于该文件已截去部分的映射区，将会接收到SIGBUS信号

子进程能通过fork继承存储映射区（因为子进程复制父进程地址空间，而存储映射区是该地址空间中的一部分），但是由于同样的原因，新程序则不能通过exec继承存储映射区

调用mprotect可以更改一个现有映射的权限

```cpp
#include <sys/mman.h>

int mprotect(void* addr, size_t len, int prot);

若成功，返回0；若出错，返回-1
```

prot的合法值与mmap中的prot参数一样。请注意，地址参数addr的值必须是系统页长的整数倍

如果修改的页是通过MAP_SHARED标志映射到地址空间的，那么修改不会立即写回到文件中。相反，何时写回脏页由内核的守护进程决定，决定的依据是系统负载和用来限制在系统失败事件中的数据损失的配置参数。因此，如果只修改了一页中的一个字节，当修改被写回到文件中时，整个页都会被写回

如果共享映射中的页已修改，那么可以调用msync将该页冲洗到被映射的文件中。msync函数类似于fsync，但作用于存储映射区

```cpp
#include <sys/mman.h>

int msync(void* addr, size_t len, int flags);

若成功，返回0；若出错，返回-1
```

如果映射是私有的，那么不修改被映射的文件。与其他存储映射函数一样，地址必须与页边界对齐

flags参数使我们对如何冲洗存储区有某种程度的控制。可以指定MS_ASYNC标志来简单的调试要写的页。如果希望在返回之前等待写操作完成，则可指定MS_SYNC标志。一定要指定两个标志中的一个

MS_INVALIDATE是一个可选标志，允许我们通知操作系统丢弃那些与底层存储器没有同步的页。若使用了此标志，某些实现将丢弃指定范围中的所有页，但这种行为并不是必需的

当进程终止时，会自动解除存储映射区的映射，或者直接调用munmap函数也可以解除映射区。关闭映射存储区时使用的文件描述符并不解除映射区

```cpp
#include <sys/mman.h>

int munmap(void* addr, size_t len);

若成功，返回0；若出错，返回-1
```

munmap并不影响被映射的对象，也就是说，调用munmap并不会使映射区的内容写到磁盘文件上。对于MAP_SHARED区磁盘文件的更新，会在我们将数据写到存储映射区后的某个时刻，按内核虚拟存储算法自动进行。在存储区解除映射后对MAP_PRIVATE存储区的修改会被丢弃

可以使用mmap和memcpy来读取或写入文件，与mmap和memcpy相比，read和write执行了更多的系统调用，并做了更多的复制。read和write函数将数据从内核缓存区中复制到应用缓冲区（read），然后再把数据从应用缓冲区复制到内核缓冲区（write）。而mmap和memcpy则直接把数据从映射到地址空间的一个内核缓冲区复制到另一个内核缓冲区。当引用尚不存在的内存页时，这样的复制过程就会作为处理页错误的结果而出现（每次错页读发生一次错误，每次错页写发生一次错误）。如果系统调用和额外的复制操作的开销和页错误的开销不同，那么这两种方法中就会有一种比另一种表现更好
